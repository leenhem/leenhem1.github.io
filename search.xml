<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一个TCP连接可以发送多少个HTTP请求？</title>
    <url>/2021/08/28/1127/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-25.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>一个TCP连接可以发送多少个HTTP请求？就这这个问题，我们聊聊TCP、HTTP以及浏览器之间的关系和对请求处理的优化。</p>
<h3 id="TCP与HTTP的渊源"><a href="#TCP与HTTP的渊源" class="headerlink" title="TCP与HTTP的渊源"></a>TCP与HTTP的渊源</h3><hr>
<p>我们知道TCP协议对应于传输层，HTTP协议对应于应用层。WEB项目中，HTTP协议是建立在TCP的基础上的。</p>
<p>最初浏览器从服务器加载一个网页，会发起一个HTTP请求，这时需要先建立一个TCP连接。当本次数据请求完毕之后，会立刻断开TCP连接。</p>
<p>但随着时间的推理，HTML网页内容越来越复杂，不仅有内容，还有JS、CSS和图片资源，每个资源的请求都建立一次TCP连接，效率就会很低。</p>
<p>这时，Keep-Alive就被提出用来了，专门用于解决效率低的问题。</p>
<p>本文关于TCP连接能够发送多少个HTTP请求，本质上就是围绕着解决通信的低效问题的。</p>
<p>下面我们通过几个常见的面试问题，来逐步揭开这其中包含的知识点。</p>
<h3 id="问题一：浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？"><a href="#问题一：浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？" class="headerlink" title="问题一：浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？"></a>问题一：浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？</h3><hr>
<p>HTTP协议Header中的Connection属性决定了连接是否持久，不同HTTP协议版本有所不同。</p>
<p>HTTP&#x2F;1.0中Connection默认为close，即每次请求都会重新建立和断开TCP连接。缺点：建立和断开TCP连接，代价过大。</p>
<p>HTTP&#x2F;1.1中Connection默认为keep-alive，即连接可以复用，不用每次都重新建立和断开TCP连接。超时之后没有连接则主动断开。可以通过声明Connection为close进行关闭。</p>
<p><strong>优点</strong>：TCP连接可被重复利用，减少建立连接的损耗，SSL的开销也可以避免。刷新页面时也可以复用，从而不再建立SSL连接等。</p>
<p><strong>结论</strong>：默认情况下（HTTP&#x2F;1.1）建立TCP连接不会断开，只有在请求报头中声明Connection: close才会请求完成之后关闭连接。不断开的最终目的是减少建立连接所导致的性能损耗。</p>
<h3 id="问题二：一个TCP连接可以对应几个HTTP请求？"><a href="#问题二：一个TCP连接可以对应几个HTTP请求？" class="headerlink" title="问题二：一个TCP连接可以对应几个HTTP请求？"></a>问题二：一个TCP连接可以对应几个HTTP请求？</h3><hr>
<p>如果Connection为close，则一个TCP连接只对应一个HTTP请求。</p>
<p>如果Connection为Keep-alive，则一个TCP连接可对应一个到多个HTTP请求。</p>
<h3 id="问题三：一个TCP连接中，可以同时发送多个HTTP请求吗？"><a href="#问题三：一个TCP连接中，可以同时发送多个HTTP请求吗？" class="headerlink" title="问题三：一个TCP连接中，可以同时发送多个HTTP请求吗？"></a>问题三：一个TCP连接中，可以同时发送多个HTTP请求吗？</h3><hr>
<p>HTTP&#x2F;1.1中单个TCP连接在同一时刻只能处理一个请求。HTTP&#x2F;1.1在RFC 2616中规定了Pipelining来解决这个问题，但浏览器默认是关闭的。</p>
<p>RFC 2616中规定：一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。</p>
<p>Pipelining本身存在一些问题，比如代理服务器不能正确处理HTTP Pipelining、Head-of-line Blocking连接头阻塞（首个请求耗时过长，阻塞其他请求）。所以，浏览器默认关闭该功能。</p>
<p>HTTP&#x2F;2.0提供了多路复用技术Multiplexing，一个TCP可以并发多个HTTP请求（理论无上限，但是一般浏览器会有TCP并发数的限制）。</p>
<p>HTTP&#x2F;1.1中为了提升性能，通常会采用连接复用和同时建立多个TCP连接的方式提升性能。</p>
<p><strong>结论</strong>：HTTP&#x2F;1.1中存在Pipelining技术支持一个连接发送多个请求，但存在弊端，浏览器默认关闭。HTTP&#x2F;2.0中通过多路复用技术支持一个TCP连接中并发请求HTTP。</p>
<h3 id="问题四：浏览器对同一Host建立TCP连接的数量有没限制？"><a href="#问题四：浏览器对同一Host建立TCP连接的数量有没限制？" class="headerlink" title="问题四：浏览器对同一Host建立TCP连接的数量有没限制？"></a>问题四：浏览器对同一Host建立TCP连接的数量有没限制？</h3><hr>
<p>不同浏览器限制不同，比如Chrome最多允许同一个Host可建立6个TCP连接。</p>
<p>如果服务器只支持HTTP&#x2F;1.1，浏览器会采用在同一个Host下建立多个TCP连接来进行效率提升。如果是基于HTTPS传输，在SSL握手之后，还会尝试协商是否可以采用HTTP&#x2F;2.0的Multiplexing功能。</p>
<h3 id="问题五：keep-alive使用场景及优缺点"><a href="#问题五：keep-alive使用场景及优缺点" class="headerlink" title="问题五：keep-alive使用场景及优缺点"></a>问题五：keep-alive使用场景及优缺点</h3><hr>
<p>开启keep-alive对内存要求高，关闭keep-alive对CPU要求高；如果内存和CPU都足够，开启和关闭keep-alive对性能影响不大；如果考虑服务器压力，如果是静态页面，大量的调用js或者图片的话，建议开启keep-alive；如果是动态网页，建议关闭keep-alive。</p>
<p><strong>注意事项</strong>：如果需要使用keep-alive功能，服务器端如果使用nginx中keepalive_timeout值要大于0。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>通过上面的整体分析，我们不仅了解了TCP与HTTP之间的关系，还明确了现代浏览器基于不同的HTTP协议所作出的网络层面优化。而HTTP2&#x2F;0的多路复用机制还是一些高性能框架的基础，比如gRPC的实现。</p>
]]></content>
      <categories>
        <category>HTTP</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>org.apache.tomcat.util.net.NioEndpoint$Acceptor.run Socket accept failed java.io.IOException: 打开的文件过多</title>
    <url>/2021/09/20/1212/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-16-1024x512.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>项目进行压力测试时报错org.apache.tomcat.util.net.NioEndpoint$Acceptor.run Socket accept failed<br>java.io.IOException: 打开的文件过多</p>
<h3 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h3><hr>
<p>16-Sep-2021 20:54:23.275 严重 [http-nio-8064-Acceptor-0] org.apache.tomcat.util.net.NioEndpoint$Acceptor.run Socket accept failed<br> java.io.IOException: 打开的文件过多<br>        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)<br>        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)<br>        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)<br>        at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:455)<br>        at java.lang.Thread.run(Thread.java:748)</p>
<p>16-Sep-2021 20:56:22.156 严重 [http-nio-8064-exec-32] org.apache.coyote.http11.Http11Processor.service Error processing request<br> java.lang.IllegalStateException: java.io.FileNotFoundException: &#x2F;data&#x2F;tomcat-option&#x2F;webapps&#x2F;carsoa-opinion&#x2F;WEB-INF&#x2F;lib&#x2F;swagger-bootstrap-ui-1.9.5.jar (打开的文件过多)<br>        at org.apache.catalina.webresources.AbstractSingleArchiveResourceSet.getArchiveEntry(AbstractSingleArchiveResourceSet.java:100)<br>        at org.apache.catalina.webresources.AbstractArchiveResourceSet.getResource(AbstractArchiveResourceSet.java:262)<br>        at org.apache.catalina.webresources.StandardRoot.getResourceInternal(StandardRoot.java:281)<br>        at org.apache.catalina.webresources.CachedResource.validateResource(CachedResource.java:110)<br>        at org.apache.catalina.webresources.Cache.getResource(Cache.java:69)<br>        at org.apache.catalina.webresources.StandardRoot.getResource(StandardRoot.java:216)<br>        at org.apache.catalina.webresources.StandardRoot.getResource(StandardRoot.java:206)<br>        at org.apache.catalina.mapper.Mapper.internalMapWrapper(Mapper.java:1027)<br>        at org.apache.catalina.mapper.Mapper.internalMap(Mapper.java:842)<br>        at org.apache.catalina.mapper.Mapper.map(Mapper.java:698)<br>        at org.apache.catalina.connector.CoyoteAdapter.postParseRequest(CoyoteAdapter.java:679)<br>        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:336)<br>        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800)<br>        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)<br>        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:800)<br>        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1471)<br>        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)<br>        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)<br>        at java.lang.Thread.run(Thread.java:748)<br>Caused by: java.io.FileNotFoundException: &#x2F;data&#x2F;tomcat-option&#x2F;webapps&#x2F;carsoa-opinion&#x2F;WEB-INF&#x2F;lib&#x2F;swagger-bootstrap-ui-1.9.5.jar (打开的文件过多)<br>        at java.util.zip.ZipFile.open(Native Method)<br>        at java.util.zip.ZipFile.<init>(ZipFile.java:225)<br>        at java.util.zip.ZipFile.<init>(ZipFile.java:155)<br>        at java.util.jar.JarFile.<init>(JarFile.java:166)<br>        at java.util.jar.JarFile.<init>(JarFile.java:130)<br>        at org.apache.tomcat.util.compat.JreCompat.jarFileNewInstance(JreCompat.java:188)<br>        at org.apache.tomcat.util.compat.JreCompat.jarFileNewInstance(JreCompat.java:173)<br>        at org.apache.catalina.webresources.AbstractArchiveResourceSet.openJarFile(AbstractArchiveResourceSet.java:313)<br>        at org.apache.catalina.webresources.AbstractSingleArchiveResourceSet.getArchiveEntry(AbstractSingleArchiveResourceSet.java:96)<br>        … 20 more</p>
<h3 id="分析1-调整linux系统打开文件数"><a href="#分析1-调整linux系统打开文件数" class="headerlink" title="分析1 调整linux系统打开文件数"></a>分析1 调整linux系统打开文件数</h3><hr>
<p>根据org.apache.tomcat.util.net.NioEndpoint$Acceptor.run Socket accept failed<br>java.io.IOException: 打开的文件过多<br>我们初步判断为系统没有优化<br>下面我们优化一下系统参数</p>
<p>ulimit -a 查看系统文件打开数为1024，这个明显太小了</p>
<p>ulimit -a<br>core file size          (blocks, -c) 0<br>data seg size           (kbytes, -d) unlimited<br>scheduling priority             (-e) 0<br>file size               (blocks, -f) unlimited<br>pending signals                 (-i) 128531<br>max locked memory       (kbytes, -l) 64<br>max memory size         (kbytes, -m) unlimited<br>open files                      (-n) 1024<br>pipe size            (512 bytes, -p) 8<br>POSIX message queues     (bytes, -q) 819200<br>real-time priority              (-r) 0<br>stack size              (kbytes, -s) 8192<br>cpu time               (seconds, -t) unlimited<br>max user processes              (-u) 128531<br>virtual memory          (kbytes, -v) unlimited<br>file locks                      (-x) unlimited</p>
<p>查看报错程序所占用的文件数</p>
<p>lsof -p 17405wc -l<br>1005</p>
<p>调整系统文件打开数</p>
<p>vim &#x2F;etc&#x2F;security&#x2F;limits.conf<br>* soft nofile 65535<br>* hard nofile 65535</p>
<p>重新登录用户生效<br>再次压测，发现还是有问题</p>
<h3 id="分析2-调整tomcat配置"><a href="#分析2-调整tomcat配置" class="headerlink" title="分析2 调整tomcat配置"></a>分析2 调整tomcat配置</h3><hr>
<p>根据 org.apache.coyote.http11.Http11Processor.service Error processing request<br>java.lang.IllegalStateException: java.io.FileNotFoundException: &#x2F;data&#x2F;tomcat-option&#x2F;webapps&#x2F;carsoa-opinion&#x2F;WEB-INF&#x2F;lib&#x2F;swagger-bootstrap-ui-1.9.5.jar (打开的文件过多)<br>报错，我们发现有可能是tomcat线程配置应该有问题，文件过多<br>调整tomcat，在server.xml中修改如下一段</p>
<pre><code>&lt;Connector port=&quot;8064&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           acceptCount=&quot;100&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>改成</p>
<pre><code>&lt;Connector port=&quot;8064&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           acceptCount=&quot;1000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>调整完成<br>acceptCount&#x3D;“100” 改为 acceptCount&#x3D;“1000”<br>压测，项目正常响应</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>tomcat</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>acceptCount</tag>
        <tag>IOException</tag>
        <tag>linux</tag>
        <tag>sysctl.conf</tag>
        <tag>Tomcat</tag>
        <tag>Too many open files</tag>
        <tag>ulimit</tag>
        <tag>文件数</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 遇到 Too many open files 时，哪项配置在生效？</title>
    <url>/2021/09/21/1220/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-18-1024x512.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<ul>
<li>MySQL 配置文件和 mysqld.service 中都声明了可打开的最大文件数时，哪个在生效？</li>
<li>MySQL 配置文件中对可打开的最大文件数配置，怎么才能生效？</li>
<li>如果把 mysqld 的 service 中对最大文件数做的限制删除，那谁在控制？</li>
</ul>
<p>测试环境信息：</p>
<p>docker容器, 宿主机内核：4.15.0-36-generic<br>systemd版本：systemd-219-42.el7_4.4.x86_64<br>mysql-5.7.25</p>
<p>MySQL 配置文件的配置中文件描述符的限制为：</p>
<p>[root@udp2 3306]# grep -i open_files_limit &#x2F;opt&#x2F;mysql&#x2F;etc&#x2F;3306&#x2F;my.cnf<br>open_files_limit &#x3D; 65535</p>
<p>注册的 mysqld service 中配置的文件描述符的限制为：</p>
<p>[root@udp2 3306]# grep -i limitnofile &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;mysqld_3306.service<br>LimitNOFILE &#x3D; 65535</p>
<p>通过 &#x2F;proc&#x2F;{replace-with-pid-of-mysql}&#x2F;limits 查看 mysqld 的资源限制：</p>
<p>当前 mysqld 程的资源限制值为65535，但不知是哪个限制在起作用。</p>
<h3 id="MySQL-配置文件和-mysqld-service-中都声明了可打开的最大文件数时，哪个在生效？"><a href="#MySQL-配置文件和-mysqld-service-中都声明了可打开的最大文件数时，哪个在生效？" class="headerlink" title="MySQL 配置文件和 mysqld.service 中都声明了可打开的最大文件数时，哪个在生效？"></a>MySQL 配置文件和 mysqld.service 中都声明了可打开的最大文件数时，哪个在生效？</h3><hr>
<h4 id="修改限制的配置并重启-mysqld"><a href="#修改限制的配置并重启-mysqld" class="headerlink" title="修改限制的配置并重启 mysqld"></a>修改限制的配置并重启 mysqld</h4><p>修改配置 mysql 配置：在 my.cnf 的[mysqld]下配置：open_files_limit &#x3D; 65536<br>在 mysqld 的 service 文件中[Service]下配置：LimitNOFILE &#x3D; 65534</p>
<h4 id="重启-mysqld-服务："><a href="#重启-mysqld-服务：" class="headerlink" title="重启 mysqld 服务："></a>重启 mysqld 服务：</h4><p>重启服务 systemctl daemon-reload<br>systemctl restart mysqld_3306.service</p>
<h4 id="通过-x2F-proc-x2F-replace-with-pid-of-mysql-x2F-limits-再次查看资源限制的值："><a href="#通过-x2F-proc-x2F-replace-with-pid-of-mysql-x2F-limits-再次查看资源限制的值：" class="headerlink" title="通过&#x2F;proc&#x2F;{replace-with-pid-of-mysql}&#x2F;limits 再次查看资源限制的值："></a>通过&#x2F;proc&#x2F;{replace-with-pid-of-mysql}&#x2F;limits 再次查看资源限制的值：</h4><p>[root@udp2 system]# pgrep mysql<br>16054<br>[root@udp2 system]# cat &#x2F;proc&#x2F;16054&#x2F;limits  grep -i “max open files”<br>Max open files            65534                65534                files</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>mysqld my.cnf 和 mysqld service 都配置了最大可打开文件数时，是 mysqld.service 的配置在生效。</p>
<h3 id="MySQL-配置文件中对可打开的最大文件数配置，怎么才能生效？"><a href="#MySQL-配置文件中对可打开的最大文件数配置，怎么才能生效？" class="headerlink" title="MySQL 配置文件中对可打开的最大文件数配置，怎么才能生效？"></a>MySQL 配置文件中对可打开的最大文件数配置，怎么才能生效？</h3><hr>
<h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>有同学对上面配置的结论有疑惑，因为 MySQL 官网查到：</p>
<p>MySQL 配置文件中的 open_files_limit 不起作用，上面的结论跟官网的描述似乎不太能对上。下面我们来确认一下</p>
<h4 id="首先我们再仔细读一下这个描述："><a href="#首先我们再仔细读一下这个描述：" class="headerlink" title="首先我们再仔细读一下这个描述："></a>首先我们再仔细读一下这个描述：</h4><p>using the value requested at by setting this variable directly or by using the –open-files-limit option to mysqld_safe，</p>
<p>这个参数是要传给谁的？mysqld_safe。</p>
<h4 id="我们看一看通过-DMP-平台启动的-mysqld-服务的-mysqld-safe"><a href="#我们看一看通过-DMP-平台启动的-mysqld-服务的-mysqld-safe" class="headerlink" title="我们看一看通过 DMP 平台启动的 mysqld 服务的 mysqld_safe"></a>我们看一看通过 DMP 平台启动的 mysqld 服务的 mysqld_safe</h4><p>[root@udp2 system]# ps -ef  grep mysql<br>root       922 14557  0 16:01 pts&#x2F;1    00:00:00 grep –color&#x3D;auto mysql<br>actiont+ 12178     1  4 15:59 ?        00:00:05 &#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25&#x2F;bin&#x2F;mysqld –defaults-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;etc&#x2F;3306&#x2F;my.cnf –daemonize –pid-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysqld.pid –user&#x3D;actiontech-mysql –socket&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysqld.sock –port&#x3D;3306</p>
<p>可以看到没有 mysqld_safe进 程。mysqld_safe 主要是对 mysqld 进程做了一些守护性的工作，DMP 平台提供了更强大的高可用能力，就没有使用 mysqld_safe 来启动 mysqld 。</p>
<h4 id="我们再测试一下用-mysqld-safe-来启动-mysqld"><a href="#我们再测试一下用-mysqld-safe-来启动-mysqld" class="headerlink" title="我们再测试一下用 mysqld_safe 来启动 mysqld :"></a>我们再测试一下用 mysqld_safe 来启动 mysqld :</h4><p>启动命令：nohup &#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25&#x2F;bin&#x2F;mysqld_safe –defaults-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;etc&#x2F;3306&#x2F;my.cnf –user&#x3D;actiontech-mysql &amp;</p>
<h4 id="启动完成后，再来看看资源限制情况："><a href="#启动完成后，再来看看资源限制情况：" class="headerlink" title="启动完成后，再来看看资源限制情况："></a>启动完成后，再来看看资源限制情况：</h4><p>[root@udp2 system]# ps -ef  grep mysql<br>root      9267 14557  2 16:01 pts&#x2F;1    00:00:00 &#x2F;bin&#x2F;sh &#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25&#x2F;bin&#x2F;mysqld_safe –defaults-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;etc&#x2F;3306&#x2F;my.cnf –user&#x3D;actiontech-mysql<br>actiont+ 11437  9267 17 16:01 pts&#x2F;1    00:00:01 &#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25&#x2F;bin&#x2F;mysqld –defaults-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;etc&#x2F;3306&#x2F;my.cnf –basedir&#x3D;&#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25 –datadir&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306 –plugin-dir&#x3D;&#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25&#x2F;lib&#x2F;plugin –user&#x3D;actiontech-mysql –log-error&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysql-error.log –open-files-limit&#x3D;65536 –pid-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysqld.pid –socket&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysqld.sock –port&#x3D;3306<br>root     13082 14557  0 16:02 pts&#x2F;1    00:00:00 grep –color&#x3D;auto mysql<br>[root@udp2 system]#<br>[root@udp2 system]# cat &#x2F;proc&#x2F;11437&#x2F;limits  grep -i “max open files”<br>Max open files            65536                65536                files<br>[root@udp2 system]# cat &#x2F;proc&#x2F;9267&#x2F;limits  grep -i “max open files”<br>Max open files            65536                65536                files</p>
<p>可以看到在使用 mysqld_safe 启动 mysqld 时，my.cnf 中的配置起了作用，跟官档描述是相吻合的。</p>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>不是使用 mysqld_safe 启动的 mysql 实例的资源限制如果不手工介入，配置中的限制值是未生效的。</p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>通过该测试有2个点值得注意：</p>
<ol>
<li>systemd 的 service 是针对一个服务级别的资源限制，一个服务可有一个进程，也可有多个进程，mysqld 的服务只有 mysqld 进程，所以这里在设计上可改进的点是：在 mysqld 的 service 中，将 my.cnf 中设置的值配置给 LimitNOFILE 。这个时候能体现运维平台的优势，通过运维平台改MySQL 配置，平台可以将配置改动联动的带入到 mysqld 的 service 。如果是自己手动改的话就得牢记两者之间的关联，一个不小心可能就漏改了。</li>
<li>在生产上，经常有服务需要重启的场景，通过启动命令重启和通过注册到 systemd的服务重启，是有一些差异的。比如这里对 mysqld 的资源限制生效的配置，不同的启动方式直接影响了实际生效的资源限制。</li>
</ol>
<h3 id="如果把-mysqld-的-service-中对最大文件数做的限制删除，那谁在控制？"><a href="#如果把-mysqld-的-service-中对最大文件数做的限制删除，那谁在控制？" class="headerlink" title="如果把 mysqld 的 service 中对最大文件数做的限制删除，那谁在控制？"></a>如果把 mysqld 的 service 中对最大文件数做的限制删除，那谁在控制？</h3><hr>
<h4 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h4><p>现在我们知道了如果是 mysqld_safe 启动的 mysqld，open_files_limit 受 mysql 配置的限制，如果是注册到 systemd 的 mysqld service 启动 mysqld, service 中的配置起作用。</p>
<p>将服务注册到systemd是现在服务管理的主流方式。那如果mysqld的service中没有设置LimitNOFILE，哪个配置会控制资源限制呢？</p>
<h4 id="把-mysqld-的-service-中-LimitNOFILE-x3D-65534-通过行首加-注释掉，然后重启-mysqld-服务："><a href="#把-mysqld-的-service-中-LimitNOFILE-x3D-65534-通过行首加-注释掉，然后重启-mysqld-服务：" class="headerlink" title="把 mysqld 的 service 中 LimitNOFILE &#x3D; 65534 通过行首加#注释掉，然后重启 mysqld 服务："></a>把 mysqld 的 service 中 LimitNOFILE &#x3D; 65534 通过行首加#注释掉，然后重启 mysqld 服务：</h4><p>systemctl daemon-reload</p>
<p>systemctl restart mysqld_3306.service</p>
<h4 id="等启动完成，再来看打开文件数的限制："><a href="#等启动完成，再来看打开文件数的限制：" class="headerlink" title="等启动完成，再来看打开文件数的限制："></a>等启动完成，再来看打开文件数的限制：</h4><p>[root@udp2 system]# pgrep mysql<br>6700<br>[root@udp2 system]# cat &#x2F;proc&#x2F;6700&#x2F;limits   grep -i “max open files”<br>Max open files            1048576              1048576              files</p>
<p>现在 mysqld 的 open-files-limit 生效的值: 1048576，这个值是哪里来的呢？</p>
<h4 id="systemd-对资源限制是通过-cgroup-实现的。资源限制的等级结构可以通过命令systemd-cgls来查看，我们来看看现在的资源限制结构（仅显示-mysqld-相关的等级结构，其它手工删除了）："><a href="#systemd-对资源限制是通过-cgroup-实现的。资源限制的等级结构可以通过命令systemd-cgls来查看，我们来看看现在的资源限制结构（仅显示-mysqld-相关的等级结构，其它手工删除了）：" class="headerlink" title="systemd 对资源限制是通过 cgroup 实现的。资源限制的等级结构可以通过命令systemd-cgls来查看，我们来看看现在的资源限制结构（仅显示 mysqld 相关的等级结构，其它手工删除了）："></a>systemd 对资源限制是通过 cgroup 实现的。资源限制的等级结构可以通过命令systemd-cgls来查看，我们来看看现在的资源限制结构（仅显示 mysqld 相关的等级结构，其它手工删除了）：</h4><p>[root@udp2 system]# systemd-cgls<br>├─    1 &#x2F;usr&#x2F;sbin&#x2F;init<br>├─ 7000 systemd-cgls<br>├─ 7002 less<br>├─14557 bash<br>└─system.slice<br>  ├─mysqld_3306.service<br>  │ └─6700 &#x2F;opt&#x2F;mysql&#x2F;base&#x2F;5.7.25&#x2F;bin&#x2F;mysqld –defaults-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;etc&#x2F;3306&#x2F;my.cnf –daemonize –pid-file&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysqld.pid –user&#x3D;actiontech-mysql –socket&#x3D;&#x2F;opt&#x2F;mysql&#x2F;data&#x2F;3306&#x2F;mysqld.sock –port&#x3D;3306</p>
<p>可以看到 mysqld 直接受 system.slice 限制</p>
<h4 id="刚开始我们已经介绍了，我们是在-docker-环境下测试的。退出容器，在宿主机查看测试用的-docker-容器资源限制的等级结构："><a href="#刚开始我们已经介绍了，我们是在-docker-环境下测试的。退出容器，在宿主机查看测试用的-docker-容器资源限制的等级结构：" class="headerlink" title="刚开始我们已经介绍了，我们是在 docker 环境下测试的。退出容器，在宿主机查看测试用的 docker 容器资源限制的等级结构："></a>刚开始我们已经介绍了，我们是在 docker 环境下测试的。退出容器，在宿主机查看测试用的 docker 容器资源限制的等级结构：</h4><p><img src="https://img-blog.csdnimg.cn/97f1ceb4eaa5405d88b9ccaa4a1e3d34.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="MySQL-遇到-Too-many-open-files-时，哪项配置在生效？"><a href="#MySQL-遇到-Too-many-open-files-时，哪项配置在生效？" class="headerlink" title="MySQL 遇到 Too many open files 时，哪项配置在生效？"></a>MySQL 遇到 Too many open files 时，哪项配置在生效？</h3><hr>
<p>mysqld_3306.service 父一级是 system.slice ，再上一级是容器 id ，这2个都是 docker 生成的，不受我们控制，应该不会无缘无故改写资源限制，所以我们再往上级看：再上级是 docker ,这个是有注册服务的，是用户可参与设置的，我们来看看这个配置里对 open-flies-limit 的限制值：</p>
<p>root@ubuntu:~# grep -i “limitnofile” &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service LimitNOFILE&#x3D;1048576</p>
<p>到此，可以初步猜测是 docker 服务的资源限制在起作用</p>
<h4 id="修改-docker-service-中的最大打开文件数的限制："><a href="#修改-docker-service-中的最大打开文件数的限制：" class="headerlink" title="修改 docker service 中的最大打开文件数的限制："></a>修改 docker service 中的最大打开文件数的限制：</h4><p>设置 LimitNOFILE&#x3D;1048577，</p>
<h4 id="重新加载配置及重启服务"><a href="#重新加载配置及重启服务" class="headerlink" title="重新加载配置及重启服务"></a>重新加载配置及重启服务</h4><p>systemctl daemon-reload<br>systemctl restart docker.service</p>
<h4 id="然后重启mysqld所在的容器和mysqld服务后，查看资源限制"><a href="#然后重启mysqld所在的容器和mysqld服务后，查看资源限制" class="headerlink" title="然后重启mysqld所在的容器和mysqld服务后，查看资源限制"></a>然后重启mysqld所在的容器和mysqld服务后，查看资源限制</h4><p>[root@udp2 opt]# pgrep mysql<br>22339<br>[root@udp2 opt]# cat &#x2F;proc&#x2F;22339&#x2F;limits  grep -i “max open files”<br>Max open files 1048577 1048577 files<br>到此我们找到并确认了 mysqld 服务中未配置最大打开文件数时，查看到的这个 magic 1048576 的来源正是上一步猜测的 docker.service 。</p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>如果 service 中不设置的话，要看资源限制的等级结构的父级或更上层的父级的设置来确定是谁在控制最大可打开文件数。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>cgroup 是红帽6开始提供的功能，本文结论可能跟特定系统有关</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Mysql</category>
        <category>运维</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Too many open files</tag>
        <tag>ulimit</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>python 开发Celery异步任务调度与RabbitMQ环境搭建</title>
    <url>/2021/10/21/1329/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-17-1024x461.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Celery是一个Python任务队列系统，用于处理跨线程或网络节点的工作任务分配。它使异步任务管理变得容易。<br>您的应用程序只需要将消息推送到像RabbitMQ这样的代理，Celery worker会弹出它们并安排任务执行。</p>
<h3 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h3><hr>
<p>celery 的5个角色</p>
<ul>
<li>Task 就是任务，有异步任务(Async Task)和定时任务(Celery Beat)</li>
<li>Broker 中间人，接收生产者发来的消息即Task，将任务存入队列。<br>任务的消费者是Worker。<br>Celery 本身不提供队列服务，推荐用Redis或RabbitMQ实现队列服务。</li>
<li>Worker 执行任务的单元，它实时监控消息队列，如果有任务就获取任务并执行它。</li>
<li>Beat 定时任务调度器，根据配置定时将任务发送给Broker。</li>
</ul>
<p>Backend 用于存储任务的执行结果。</p>
<p><img src="https://img-blog.csdnimg.cn/1f2f1a0dabde4630b5f8bf473e833b83.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><hr>
<ol>
<li>django环境v2.1.2</li>
<li>安装celery版本</li>
</ol>
<p>pip install celery&#x3D;&#x3D;3.1.26.post2</p>
<ol start="4">
<li>安装django-celery包</li>
</ol>
<p>pip install django-celery&#x3D;&#x3D;3.3.1</p>
<h3 id="RabbitMQ-环境"><a href="#RabbitMQ-环境" class="headerlink" title="RabbitMQ 环境"></a>RabbitMQ 环境</h3><hr>
<p>Broker(RabbitMQ) 负责创建任务队列，根据一些路由规则将任务分派到任务队列，然后将任务从任务队列交付给 worker<br>先使用docker 搭建RabbitMQ 环境,rabbitMQ 镜像仓库地址 <a href="https://hub.docker.com//_/rabbitmq%E6%89%BE%E5%B8%A6%E6%9C%89">https://hub.docker.com/\_/rabbitmq找带有</a> mangement的版本，会带web后台管理界面</p>
<p>下载 3.8.0-management 镜像</p>
<p>docker pull rabbitmq:3.8.0-management</p>
<p>启动容器,设置账号 admin 和密码 123456</p>
<p>docker run -d –name rabbitmq3.8 -p 5672:5672 -p 15672:15672 –hostname myRabbit -e RABBITMQ_DEFAULT_USER&#x3D;admin -e RABBITMQ_DEFAULT_PASS&#x3D;123456 rabbitmq:3.8.0-management</p>
<p>宿主机需开放 5672 和 15672 这 2 个端口，5672 是后端接口访问的端口，15672 是前端 web 管理后台页面地址，输入<a href="http://ip:15672可以访问">http://ip:15672可以访问</a> web 网站</p>
<p><img src="https://img-blog.csdnimg.cn/d2c14dc841b7466d84921a7cc3896816.png" alt="在这里插入图片描述"></p>
<p>输入前面设置的账号 admin 和密码 123456 可以直接登录</p>
<p><img src="https://img-blog.csdnimg.cn/cfab555b1cf140caad646c9f200767ea.png" alt="在这里插入图片描述"></p>
<h3 id="Django-中使用-Celery"><a href="#Django-中使用-Celery" class="headerlink" title="Django 中使用 Celery"></a>Django 中使用 Celery</h3><hr>
<p>要在 Django 项目中使用 Celery，您必须首先定义 Celery 库的一个实例（称为“应用程序”）</p>
<p>如果你有一个现代的 Django 项目布局，比如：</p>
<p>- proj&#x2F;</p>
<ul>
<li>manage.py</li>
<li>proj&#x2F;<ul>
<li>__init__.py</li>
<li>settings.py</li>
<li>urls.py</li>
</ul>
</li>
</ul>
<p>那么推荐的方法是创建一个新的proj&#x2F;proj&#x2F;celery.py模块来定义 Celery 实例：</p>
<p>import os</p>
<p>from celery import Celery</p>
<h1 id="Set-the-default-Django-settings-module-for-the-‘celery’-program"><a href="#Set-the-default-Django-settings-module-for-the-‘celery’-program" class="headerlink" title="Set the default Django settings module for the ‘celery’ program."></a>Set the default Django settings module for the ‘celery’ program.</h1><p>os.environ.setdefault(‘DJANGO_SETTINGS_MODULE’, ‘proj.settings’)</p>
<p>app &#x3D; Celery(‘proj’)</p>
<h1 id="Using-a-string-here-means-the-worker-doesn’t-have-to-serialize"><a href="#Using-a-string-here-means-the-worker-doesn’t-have-to-serialize" class="headerlink" title="Using a string here means the worker doesn’t have to serialize"></a>Using a string here means the worker doesn’t have to serialize</h1><h1 id="the-configuration-object-to-child-processes"><a href="#the-configuration-object-to-child-processes" class="headerlink" title="the configuration object to child processes."></a>the configuration object to child processes.</h1><h1 id="namespace-x3D-’CELERY’-means-all-celery-related-configuration-keys"><a href="#namespace-x3D-’CELERY’-means-all-celery-related-configuration-keys" class="headerlink" title="- namespace&#x3D;’CELERY’ means all celery-related configuration keys"></a>- namespace&#x3D;’CELERY’ means all celery-related configuration keys</h1><h1 id="should-have-a-CELERY-prefix"><a href="#should-have-a-CELERY-prefix" class="headerlink" title="should have a `CELERY_` prefix."></a>should have a `CELERY_` prefix.</h1><p>app.config_from_object(‘django.conf:settings’, namespace&#x3D;’CELERY’)</p>
<h1 id="Load-task-modules-from-all-registered-Django-apps"><a href="#Load-task-modules-from-all-registered-Django-apps" class="headerlink" title="Load task modules from all registered Django apps."></a>Load task modules from all registered Django apps.</h1><p>app.autodiscover_tasks()</p>
<p>@app.task(bind&#x3D;True)<br>def debug_task(self):<br>    print(f’Request: {self.request!r}’)</p>
<p>其中debug_task是测试的任务，可以注掉</p>
<p># @app.task(bind&#x3D;True)</p>
<h1 id="def-debug-task-self"><a href="#def-debug-task-self" class="headerlink" title="def debug_task(self):"></a>def debug_task(self):</h1><h1 id="print-‘Request-0-r-’-format-self-request"><a href="#print-‘Request-0-r-’-format-self-request" class="headerlink" title="print(‘Request: {0!r}’.format(self.request))"></a>print(‘Request: {0!r}’.format(self.request))</h1><p>上面一段只需改这句，’proj’是自己django项目的app名称</p>
<p>app &#x3D; Celery(‘proj’)</p>
<p>然后你需要在你的proj&#x2F;proj&#x2F;<strong>init</strong>.py 模块中导入这个应用程序。这确保在 Django 启动时加载应用程序，以便@shared_task装饰器（稍后提到）将使用它：</p>
<p># This will make sure the app is always imported when</p>
<h1 id="Django-starts-so-that-shared-task-will-use-this-app"><a href="#Django-starts-so-that-shared-task-will-use-this-app" class="headerlink" title="Django starts so that shared_task will use this app."></a>Django starts so that shared_task will use this app.</h1><p>from .celery import app as celery_app</p>
<p>__all__ &#x3D; (‘celery_app’,)</p>
<p>上面这段固定的，不用改</p>
<h3 id="tasks任务"><a href="#tasks任务" class="headerlink" title="tasks任务"></a>tasks任务</h3><hr>
<p>在app下新建tasks.py,必须要是tasks.py文件名称，django会自动查找到app下的该文件</p>
<p>@shared_task<br>def add(x, y):<br>    print(“task———-1111111111111111111111”)<br>    return x + y</p>
<p>@shared_task<br>def mul(x, y):<br>    return x * y</p>
<p>tasks.py可以写任务函数add、mul，让它生效的最直接的方法就是添加app.task 或shared_task 这个装饰器</p>
<h3 id="添加setting配置"><a href="#添加setting配置" class="headerlink" title="添加setting配置"></a>添加setting配置</h3><hr>
<p>setting.py添加配置</p>
<ul>
<li>broker参数表示用来连接broker的URL，rabbitmq采用的是一种称为’amqp’的协议，如果rabbitmq运行在默认设置下，celery不需要其他信息，只要amqp:&#x2F;&#x2F;即可。</li>
<li>backend参数是可选的，如果想要查询任务状态或者任务执行结果时必填, Celery中的后端用于存储任务结果。<br>rpc意味着将结果作为AMQP消息发送回去。</li>
</ul>
<p>#   RabbitMQ配置BROKER_URL 和backend<br>BROKER_URL &#x3D; ‘amqp:&#x2F;&#x2F;admin:<a href="mailto:&#49;&#x32;&#x33;&#x34;&#53;&#x36;&#64;&#x31;&#57;&#50;&#46;&#49;&#54;&#56;&#x2e;&#x31;&#x2e;&#49;&#49;">&#49;&#x32;&#x33;&#x34;&#53;&#x36;&#64;&#x31;&#57;&#50;&#46;&#49;&#54;&#56;&#x2e;&#x31;&#x2e;&#49;&#49;</a>:5672&#x2F;&#x2F;‘<br>CELERY_RESULT_BACKEND &#x3D; ‘rpc:&#x2F;&#x2F;‘</p>
<p>CELERY_TASK_SERIALIZER &#x3D; ‘json’<br>CELERY_RESULT_SERIALIZER &#x3D; ‘json’<br>CELERY_ACCEPT_CONTENT&#x3D;[‘json’]<br>CELERY_TIMEZONE &#x3D; ‘Asia&#x2F;Shanghai’<br>CELERY_ENABLE_UTC &#x3D; True</p>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><hr>
<p>views.py创建视图</p>
<p>from .tasks import add, mul</p>
<p>def task_demo(request):<br>    res &#x3D; add.delay(10, 20)<br>    print(res.task_id)  # 返回task_id<br>    return JsonResponse({“code”: 0, “res”: res.task_id})</p>
<h3 id="启动worker"><a href="#启动worker" class="headerlink" title="启动worker"></a>启动worker</h3><hr>
<p>前面pip已经安装过celery应用了，celery是一个独立的应用，可以启动worker</p>
<p>celery -A MyDjango worker -l info</p>
<p>其中MyDjango是你自己的django项目名称</p>
<p>运行日志</p>
<p> ————– celery@DESKTOP-HJ487C8 v3.1.26.post2 (Cipater)<br>—- **** —–<br>— * ***  * – Windows-10-10.0.17134-SP0<br>– * - **** —</p>
<ul>
<li>** ———- [config]</li>
<li>** ———- .&gt; app:         yoyo:0x1ea1a96e9b0</li>
<li>** ———- .&gt; transport:   amqp:&#x2F;&#x2F;admin:**@192.168.1.11:5672&#x2F;&#x2F;</li>
<li>** ———- .&gt; results:     rpc:&#x2F;&#x2F;</li>
<li>*** — * — .&gt; concurrency: 4 (prefork)</li>
</ul>
<p>– ******* —-<br>— ***** —– [queues]<br> ————– .&gt; celery           exchange&#x3D;celery(direct) key&#x3D;celery</p>
<p>[tasks]<br>  . yoyo.tasks.add<br>  . yoyo.tasks.mul</p>
<p>[2021-10-18 22:45:03,155: INFO&#x2F;MainProcess] Connected to amqp:&#x2F;&#x2F;admin:**@192.168.1.11:5672&#x2F;&#x2F;<br>[2021-10-18 22:45:03,347: INFO&#x2F;MainProcess] mingle: searching for neighbors<br>[2021-10-18 22:45:04,897: INFO&#x2F;MainProcess] mingle: all alone<br>[2021-10-18 22:45:05,406: WARNING&#x2F;MainProcess] e:\python36\lib\site-packages\celery\fixups\django.py:265:<br>UserWarning: Using settings.DEBUG leads to a memory leak, never use this setting in production environments!<br>  warnings.warn(‘Using settings.DEBUG leads to a memory leak, never ‘<br>[2021-10-18 22:45:05,407: WARNING&#x2F;MainProcess] celery@DESKTOP-HJ487C8 ready.</p>
<p>运行的时候，当我们看到” Connected to amqp”说明已经连接成功了！</p>
<h3 id="shell交互环境"><a href="#shell交互环境" class="headerlink" title="shell交互环境"></a>shell交互环境</h3><hr>
<p>在django shell交互环境调试运行任务</p>
<p>D:\202107django\MyDjango&gt;python manage.py shell<br>Python 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.<br>(InteractiveConsole)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from yoyo.tasks import add,mul<br>from celery.result import AsyncResult</p>
<p>res &#x3D; add.delay(11, 12)<br>res<br>&lt;AsyncResult: c5ff83a4-4840-4b36-8869-5ce6081904f1&gt;<br>res.status<br>‘SUCCESS’</p>
<p>res.backend<br>&lt;celery.backends.redis.RedisBackend object at 0x0000015E011C3128&gt;</p>
<p>res.task_id<br>‘c5ff83a4-4840-4b36-8869-5ce6081904f1’</p>
<p>get_task &#x3D; AsyncResult(id&#x3D;res.task_id)<br>get_task<br>&lt;AsyncResult: c5ff83a4-4840-4b36-8869-5ce6081904f1&gt;<br>get_task.result<br>23</p>
</blockquote>
</blockquote>
</blockquote>
<p>res.status是查看任务状态<br>res.task_id 是获取任务的id<br>res.result 获取任务结果<br>根据任务的id查询任务的执行结果AsyncResult(id&#x3D;res.task_id).result获取</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Celery</tag>
        <tag>Django</tag>
        <tag>python</tag>
        <tag>任务调度</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇 jenkins怎么样部署k8s项目之Jenkins插件配置</title>
    <url>/2022/04/08/485/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-49-1024x462.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>想要在Jenkins上实现k8s自动化部署，首先在Jenkins上安装一个插件Kubernetes Plugin</p>
<p>Kubernetes插件是一个很棒的工具，可以将Jenkins从属设备动态配置为Kubernetes集群上的pod。您需要做的就是添加和配置Kubernetes Cloud作为Jenkins配置的一部分。</p>
<h2 id="插件如图"><a href="#插件如图" class="headerlink" title="插件如图"></a>插件如图</h2><hr>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-43-1024x337.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-44-1024x408.png"></p>
<p>安装插件的过程就不讲述了，安装完成后Kubernetes插件怎么配置呢？<br>配置Jenkins Kubernetes插件需要的哪些东西</p>
<ol>
<li>首先要有一个k8s集群，查看<br>&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf  </li>
<li>kubernetes url 一般还说地址就是：<a href="https://kubernetes:6443/">https://kubernetes:6443</a>  </li>
<li>连接Kubernetes证书， 哪里生成证书的证书，下面我会详细说</li>
</ol>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><hr>
<p>在<strong>系统管理</strong> — <strong>系统设置</strong> — <strong>最下面</strong> 新增一个云</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-45-1024x425.png"></p>
<p>在Kubernetes Cloud details…里面 配置K8s集群信息  </p>
<h3 id="需要填写的内容"><a href="#需要填写的内容" class="headerlink" title="需要填写的内容"></a>需要填写的内容</h3><ul>
<li>名称</li>
<li>Kubernetes 地址</li>
<li>Kubernetes 服务证书 key</li>
<li>Kubernetes 命名空间</li>
<li>凭据</li>
<li>Jenkins 地址</li>
</ul>
<p>OK，这些都是必要参数，其它参数可选，根据自己的需求来配置</p>
<p>名称，自己定、后面流水线pipeline中会用的到<br>Kubernetes 地址，就是&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf里面的server: <a href="https://172.25.42.235:6443/">https://172.25.42.235:6443</a> 选项<br>命名空间，自己创建一个就可以<br>Jenkins 地址，就是当前Jenkins的访问地址</p>
<h3 id="服务证书-key-和-凭据"><a href="#服务证书-key-和-凭据" class="headerlink" title="服务证书 key 和 凭据"></a>服务证书 key 和 凭据</h3><p>下面重点说Kubernetes 服务证书 key 和 凭据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/kubernetes/admin.conf  </span><br><span class="line"><span class="comment">#文件中有三个值 </span></span><br><span class="line">certificate-authority-data</span><br><span class="line">client-certificate-data</span><br><span class="line">client-key-data</span><br></pre></td></tr></table></figure>
<p>把这三个值搞出来，解密</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;certificate-authority-data&gt;的值  <span class="built_in">base64</span> -d &gt; ca.crt</span><br><span class="line"><span class="built_in">echo</span> &lt;client-certificate-data&gt;的值  <span class="built_in">base64</span> -d &gt; client.crt</span><br><span class="line"><span class="built_in">echo</span> &lt;client-key-data&gt;的值  <span class="built_in">base64</span> -d &gt; client.key</span><br></pre></td></tr></table></figure>
<p>好，我生成了三个文件，其中ca.crt就是<strong>Kubernetes 服务证书 key</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 .kube]<span class="comment"># ll</span></span><br><span class="line">总用量 24</span><br><span class="line">drwxr-x---. 4 root root   35 4月  14 09:29 cache</span><br><span class="line">-rw-r--r--  1 root root 1066 4月  28 08:53 ca.crt</span><br><span class="line">-rw-r--r--  1 root root 1147 4月  28 08:54 client.crt</span><br><span class="line">-rw-r--r--  1 root root 1675 4月  28 08:54 client.key</span><br><span class="line">-rw-------. 1 root root 5593 4月  14 15:02 config</span><br><span class="line">drwxr-x---. 3 root root 4096 4月  14 20:16 http-cache</span><br><span class="line">[root@k8s-master01 .kube]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>那么凭据怎么搞呢，请看下面操作，还用到刚生产的文件<br>根据这三个文件生成一个PKCS12格式的客户端证书文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 .kube]<span class="comment"># openssl pkcs12 -export -out cert.pfx -inkey client.key -in client.crt -certfile ca.crt</span></span><br><span class="line">Enter Export Password:</span><br><span class="line">Verifying - Enter Export Password:</span><br><span class="line">[root@k8s-master01 .kube]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>记好自己设置的密码，下面要用到<br>再看凭据文件cert.pfx生成了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 .kube]<span class="comment"># ll</span></span><br><span class="line">总用量 28</span><br><span class="line">drwxr-x---. 4 root root   35 4月  14 09:29 cache</span><br><span class="line">-rw-r--r--  1 root root 1066 4月  28 08:53 ca.crt</span><br><span class="line">-rw-------  1 root root 3197 4月  29 11:06 cert.pfx</span><br><span class="line">-rw-r--r--  1 root root 1147 4月  28 08:54 client.crt</span><br><span class="line">-rw-r--r--  1 root root 1675 4月  28 08:54 client.key</span><br><span class="line">-rw-------. 1 root root 5593 4月  14 15:02 config</span><br><span class="line">drwxr-x---. 3 root root 4096 4月  14 20:16 http-cache</span><br><span class="line">[root@k8s-master01 .kube]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>好了，我们现在在Jenkins里面添加凭据<br>系统管理—凭据配置</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-46-1024x398.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-47-1024x482.png"></p>
<p>选择类型Certificate，范围全局 (Jenkins, nodes, items, all child items, etc)，上传证书cert.pfx，设置密码，保存完成</p>
<p>配置Jenkins Kubernetes插件 凭据选刚刚添加的就可以了</p>
<h2 id="搞了半天，测试一下吧"><a href="#搞了半天，测试一下吧" class="headerlink" title="搞了半天，测试一下吧"></a>搞了半天，测试一下吧</h2><hr>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-48-1024x437.png"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Jenkins插件</tag>
        <tag>Kubernetes Cloud</tag>
        <tag>pipeline</tag>
        <tag>部署k8s</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐 k8s原生镜像仓库registry好用的UI</title>
    <url>/2021/05/03/512/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-52.png"></p>
<p>Docker 官方提供的 registry 没有web管理页面<br>无意间发现了一个docker registry 的前端页面服务 docker-registry-frontend 还不错，推荐给大家使用</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><hr>
<p>docker pull konradkleine&#x2F;docker-registry-frontend:v2</p>
<p>[root@k8s-master01 registry]# docker pull konradkleine&#x2F;docker-registry-frontend:v2<br>v2: Pulling from konradkleine&#x2F;docker-registry-frontend<br>Digest: sha256:181aad54ee64312a57f8ccba5247c67358de18886d5e2f383b8c4b80a7a5edf6<br>Status: Image is up to date for konradkleine&#x2F;docker-registry-frontend:v2<br>docker.io&#x2F;konradkleine&#x2F;docker-registry-frontend:v2<br>[root@k8s-master01 registry]#</p>
<p>下载下来后，我放到k8s里面部署了</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><hr>
<p>我的deployment.yaml文件</p>
<p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: registry-frontend<br>  namespace: docker-registry<br>spec:<br>  selector:<br>    matchLabels:<br>      app: registry-frontend<br>  replicas: 1<br>  template:<br>    metadata:<br>      labels:<br>        app: registry-frontend<br>    spec:<br>      nodeSelector:<br>        name: “node-235”<br>      containers:<br>      - name: registry-frontend<br>        image: konradkleine&#x2F;docker-registry-frontend:v2<br>        ports:<br>        - containerPort: 8080<br>        env:<br>          - name: ENV_DOCKER_REGISTRY_HOST<br>            value: “172.25.42.235”<br>          - name: ENV_DOCKER_REGISTRY_PORT<br>            value: “5000”</p>
<p>我把它部署到了和registry同一个命名空间了<br>参数说明：</p>
<pre><code>  - name: ENV\_DOCKER\_REGISTRY\_HOST # 仓库地址
    value: &quot;172.25.42.235&quot;
  - name: ENV\_DOCKER\_REGISTRY\_PORT # 仓库端口
    value: &quot;5000&quot;
</code></pre>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><hr>
<p>[root@k8s-master01 registry]# kubectl apply -f deployment-frontend.yaml<br>deployment.apps&#x2F;registry-frontend created<br>[root@k8s-master01 registry]# kubectl get pod -n docker-registry<br>NAME                                READY   STATUS    RESTARTS   AGE<br>registry-6c58cb656-7lxgz            1&#x2F;1     Running   1          4h21m<br>registry-frontend-7f46c6c9c-2fq87   1&#x2F;1     Running   0          31s</p>
<h2 id="配置上端口，可以在外面访问"><a href="#配置上端口，可以在外面访问" class="headerlink" title="配置上端口，可以在外面访问"></a>配置上端口，可以在外面访问</h2><hr>
<p>我的service.yaml配置内容</p>
<p>apiVersion: v1<br>kind: Service<br>metadata:<br>  namespace: docker-registry<br>  labels:<br>    app: registry-frontend<br>  name: registry-frontend-nodeport<br>spec:<br>  externalTrafficPolicy: Cluster<br>  type: NodePort<br>  ports:<br>    - name: manager<br>      protocol: TCP<br>      port: 80<br>      targetPort: 80<br>      nodePort: 5001<br>  selector:<br>    app: registry-frontend</p>
<p>映射宿主机端口5001</p>
<h2 id="应用service配置"><a href="#应用service配置" class="headerlink" title="应用service配置"></a>应用service配置</h2><hr>
<p>[root@k8s-master01 registry]# kubectl apply -f service-frontend.yaml<br>service&#x2F;registry-frontend-nodeport created<br>[root@k8s-master01 registry]# kubectl get service -n docker-registry<br>NAME                         TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE<br>registry-frontend-nodeport   NodePort   10.110.57.28     <none>        80:5001&#x2F;TCP     10s<br>registry-nodeport            NodePort   10.103.250.191   <none>        5000:5000&#x2F;TCP   4h8m<br>[root@k8s-master01 registry]# </p>
<h2 id="访问一下"><a href="#访问一下" class="headerlink" title="访问一下"></a>访问一下</h2><p><img src="https://code404.icu/img/moveypu/2021/04/image-51-1024x483.png"></p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>镜像仓库</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>k8s</tag>
        <tag>registry</tag>
        <tag>UI</tag>
        <tag>web</tag>
        <tag>原生</tag>
        <tag>镜像仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>ES ElasticSearch 7.5 集群模式 安装手册？</title>
    <url>/2022/05/06/ES%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C7.5/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/9f813eea5e754f2993e2423cf8a189b3.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 Elastic）是目前全文搜索引擎的首选。</p>
<p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>
<p>Elastic 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。</p>
<p>Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><hr>
<table>
<thead>
<tr>
<th>序号</th>
<th>IP地址</th>
<th>系统</th>
<th>角色</th>
<th>节点名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>192.168.10.101</td>
<td>CentOS7</td>
<td>master&#x2F;node</td>
<td>es01</td>
</tr>
<tr>
<td>2</td>
<td>192.168.10.102</td>
<td>CentOS7</td>
<td>master&#x2F;node</td>
<td>es02</td>
</tr>
<tr>
<td>3</td>
<td>192.168.10.103</td>
<td>CentOS7</td>
<td>master&#x2F;node</td>
<td>es03</td>
</tr>
</tbody></table>
<h3 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h3><hr>
<h4 id="优化系统参数"><a href="#优化系统参数" class="headerlink" title="优化系统参数"></a>优化系统参数</h4><h5 id="修改limits-conf"><a href="#修改limits-conf" class="headerlink" title="修改limits.conf"></a>修改limits.conf</h5><p>编辑 &#x2F;etc&#x2F;security&#x2F;limits.conf，追加以下内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure>
<p>此文件修改后需要重新登录用户，才会生效</p>
<h5 id="修改sysctl-conf"><a href="#修改sysctl-conf" class="headerlink" title="修改sysctl.conf"></a>修改sysctl.conf</h5><p>在&#x2F;etc&#x2F;sysctl.conf文件最后添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p  <span class="comment"># 使配置生效</span></span><br></pre></td></tr></table></figure>


<h4 id="安装包下载地址"><a href="#安装包下载地址" class="headerlink" title="安装包下载地址"></a>安装包下载地址</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="添加系统用户"><a href="#添加系统用户" class="headerlink" title="添加系统用户"></a>添加系统用户</h4><p>添加用户，以普通用户启动ElasticSearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd es</span><br></pre></td></tr></table></figure>

<h4 id="解压ES安装包"><a href="#解压ES安装包" class="headerlink" title="解压ES安装包"></a>解压ES安装包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/</span><br><span class="line">tar -zxvf elasticsearch-7.5.1-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">ls</span> </span><br><span class="line">elasticsearch-7.5.1-linux-x86_64.tar.gz</span><br><span class="line">elasticsearch-7.5.1</span><br><span class="line"><span class="built_in">mkdir</span> /data/elasticsearch-7.5.1/data</span><br><span class="line"><span class="built_in">mkdir</span> /data/elasticsearch-7.5.1/logs</span><br></pre></td></tr></table></figure>

<h4 id="修改ES集群配置"><a href="#修改ES集群配置" class="headerlink" title="修改ES集群配置"></a>修改ES集群配置</h4><p>配置文件在 &#x2F;data&#x2F;elasticsearch-7.5.1&#x2F;config&#x2F;elasticsearch.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster.name: es-cluster-log <span class="comment"># ES集群名称，每个节点必须相同</span></span><br><span class="line">node.name: es01  <span class="comment"># ES集群内节点名，每个节点名称必须不同</span></span><br><span class="line">path.data: /data/elasticsearch-7.5.1/data  <span class="comment"># 索引数据目录</span></span><br><span class="line">path.logs: /data/elasticsearch-7.5.1/logs  <span class="comment"># 日志目录</span></span><br><span class="line">network.host: 0.0.0.0  <span class="comment"># 监听地址</span></span><br><span class="line">http.port: 9200  <span class="comment"># 监听服务端口</span></span><br><span class="line">transport.tcp.port: 9300   <span class="comment"># 服务发现的数据端口</span></span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;192.168.10.101&quot;</span>,<span class="string">&quot;192.168.10.102&quot;</span>,<span class="string">&quot;192.168.10.103&quot;</span>] <span class="comment"># 集群各个节点的ip</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;es01&quot;</span>, <span class="string">&quot;es02&quot;</span>,<span class="string">&quot;es03&quot;</span>] <span class="comment"># 集群各个节点名称对应node.name，集群选举设置</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span> <span class="comment"># 开启跨域</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br><span class="line">xpack.security.enabled: <span class="literal">true</span> <span class="comment"># 开启xpack</span></span><br><span class="line">xpack.license.self_generated.type: basic <span class="comment"># xpack 许可证类型</span></span><br><span class="line">xpack.security.transport.ssl.enabled: <span class="literal">true</span>  <span class="comment"># 启用 SSL 证书</span></span><br><span class="line">xpack.security.transport.ssl.verification_mode: certificate  <span class="comment"># 配置证书</span></span><br><span class="line">xpack.security.transport.ssl.keystore.path: elastic-certificates.p12</span><br><span class="line">xpack.security.transport.ssl.truststore.path: elastic-certificates.p12</span><br></pre></td></tr></table></figure>

<p>上面这个配置要 复制到 192.168.102&#x2F;103上面 ，只需要把 node.name 改成对应的名称就可以</p>
<h3 id="生成证书文件"><a href="#生成证书文件" class="headerlink" title="生成证书文件"></a>生成证书文件</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先生成包含证书颁发机构证书信息和用于签名的私钥信息CA证书文件</span></span><br><span class="line">bin/elasticsearch-certutil  ca</span><br><span class="line">...</span><br><span class="line">Please enter the desired output file [elastic-stack-ca.p12]: </span><br><span class="line">Enter password <span class="keyword">for</span> elastic-stack-ca.p12 : </span><br><span class="line"></span><br><span class="line"><span class="comment">#根据CA证书文件，生成ES秘钥</span></span><br><span class="line">bin/elasticsearch-certutil  cert --ca elastic-stack-ca.p12</span><br><span class="line">...</span><br><span class="line">ll *.p12</span><br><span class="line">-rw-------  1 es es   3443 5月   6 14:11 elastic-certificates.p12</span><br><span class="line">-rw-------  1 es es   2527 5月   6 14:06 elastic-stack-ca.p12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把证书.p12 复制到config下面</span></span><br></pre></td></tr></table></figure>

<h3 id="把证书密码添加到-keystore-秘钥中"><a href="#把证书密码添加到-keystore-秘钥中" class="headerlink" title="把证书密码添加到 keystore 秘钥中"></a>把证书密码添加到 keystore 秘钥中</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/elasticsearch-keystore add xpack.security.transport.ssl.keystore.secure_password</span><br><span class="line">bin/elasticsearch-keystore add xpack.security.transport.ssl.truststore.secure_password</span><br><span class="line"><span class="comment">## 密码为创建证书时设置的密码</span></span><br></pre></td></tr></table></figure>

<h3 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/elasticsearch -d</span><br></pre></td></tr></table></figure>



<h3 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a>配置密码</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure>



<h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://elastic:123456@192.168.10.101:9200/_cluster/health?pretty&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cluster_name&quot;</span>: <span class="string">&quot;es-cluster-log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;number_of_nodes&quot;</span>: 3,</span><br><span class="line">    <span class="string">&quot;number_of_data_nodes&quot;</span>: 3,</span><br><span class="line">    <span class="string">&quot;active_primary_shards&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;active_shards&quot;</span>: 2,</span><br><span class="line">    <span class="string">&quot;relocating_shards&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;initializing_shards&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;unassigned_shards&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;delayed_unassigned_shards&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;number_of_pending_tasks&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;number_of_in_flight_fetch&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;task_max_waiting_in_queue_millis&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;active_shards_percent_as_number&quot;</span>: 100.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>ES</category>
        <category>运维</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>API 方式 Push 数据到 PushGateway</title>
    <url>/2021/05/08/api-%E6%96%B9%E5%BC%8F-push-%E6%95%B0%E6%8D%AE%E5%88%B0-pushgateway/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-5.png"></p>
<h2 id="Pushgateway-简介"><a href="#Pushgateway-简介" class="headerlink" title="Pushgateway 简介"></a>Pushgateway 简介</h2><hr>
<p>Pushgateway 是 Prometheus 生态中一个重要工具，使用它的原因主要是：</p>
<p>Prometheus 采用 pull 模式，可能由于不在一个子网或者防火墙原因，导致 Prometheus 无法直接拉取各个 target 数据。<br>在监控业务数据的时候，需要将不同数据汇总, 由 Prometheus 统一收集。<br>由于以上原因，不得不使用 pushgateway，但在使用之前，有必要了解一下它的一些弊端：</p>
<p>将多个节点数据汇总到 pushgateway, 如果 pushgateway 挂了，受影响比多个 target 大。<br>Prometheus 拉取状态 up 只针对 pushgateway, 无法做到对每个节点有效。<br>Pushgateway 可以持久化推送给它的所有监控数据。<br>因此，即使你的监控已经下线，prometheus 还会拉取到旧的监控数据，需要手动清理 pushgateway 不要的数据。</p>
<h2 id="通过-API-来管理-prometheus数据"><a href="#通过-API-来管理-prometheus数据" class="headerlink" title="通过 API 来管理 prometheus数据"></a>通过 API 来管理 prometheus数据</h2><hr>
<h3 id="push单条数据"><a href="#push单条数据" class="headerlink" title="push单条数据"></a>push单条数据</h3><p>Push 数据到 PushGateway 向 {job&#x3D;“test_job”} 添加单条数据：</p>
<p>echo “test_metric 12345”curl –data-binary @- <a href="http://192.168.80.144:9091/metrics/job/test/_job">http://192.168.80.144:9091/metrics/job/test\_job</a><br> –data-binary  #表示发送二进制数据，注意：它是使用POST方式发送的！</p>
<p>执行完毕，刷新一下 PushGateway UI 页面，此时就能看到刚添加的 test_metric 指标数据了。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-6-1024x373.png"></p>
<p>不过我们会发现，除了 test_metric 外，同时还新增了 push_time_seconds 和 push_failure_time_seconds 两个指标，这两个是 PushGateway 系统自动生成的相关指标。此时，我们在 Prometheus UI 页面上 Graph 页面可以查询的到该指标了。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-7-1024x413.png"></p>
<p>这里要着重提一下的是，上图中 test_metric 我们查询出来的结果为 test_metric{exported_job&#x3D;“test_job”,instance&#x3D;“pushgateway”,job&#x3D;“pushgateway”} ，眼尖的会发现这里头好像不太对劲，刚刚提交的指标所属 job 名称为 test_job ，为啥显示的为 exported_job&#x3D;“test_job” ，而 job 显示为 job&#x3D;“pushgateway” ，这显然不太正确，那这是因为啥？其实是因为 Prometheus 配置中的一个参数 honor_labels （默认为 false）决定的，我们不妨再 Push 一个数据，来演示下添加 honor_labels: true 参数前后的变化。</p>
<h3 id="Push-一个复杂指标"><a href="#Push-一个复杂指标" class="headerlink" title="Push 一个复杂指标"></a>Push 一个复杂指标</h3><p>下面，我们 Push 一个复杂一些的，一次写入多个指标，而且每个指标添加 TYPE 及 HELP 说明。</p>
<p>[root@NEWCWS-AS03 data]# cat &lt;&lt;EOF  curl –data-binary @- <a href="http://192.168.80.144:9091/metrics/job/test/_job/instance/test/_instance">http://192.168.80.144:9091/metrics/job/test\_job/instance/test\_instance</a></p>
<blockquote>
<h1 id="TYPE-test-metrics-counter"><a href="#TYPE-test-metrics-counter" class="headerlink" title="TYPE test_metrics counter"></a>TYPE test_metrics counter</h1><p>test_metrics{label&#x3D;”app1”,name&#x3D;”demo”} 100.00</p>
<h1 id="TYPE-another-test-metrics-gauge"><a href="#TYPE-another-test-metrics-gauge" class="headerlink" title="TYPE another_test_metrics gauge"></a>TYPE another_test_metrics gauge</h1><h1 id="HELP-another-test-metrics-Just-an-example"><a href="#HELP-another-test-metrics-Just-an-example" class="headerlink" title="HELP another_test_metrics Just an example."></a>HELP another_test_metrics Just an example.</h1><p>another_test_metrics 123.45<br>EOF</p>
</blockquote>
<p>添加完毕，再刷新一下 PushGateway UI 页面，可以看到添加的数据了。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-8-1024x460.png"></p>
<p>从上图可以看出，&#x2F;metrics&#x2F;job&#x2F;test_job 和 metrics&#x2F;job&#x2F;test_job&#x2F;instance&#x2F;test_instance 虽然它们都属于 test_job，但是它们属于两个指标值，因为 instance 对二者做了区分。此时我们访问 Prometheus UI 页面上 Graph 页面查询该指标。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-9-1024x402.png"></p>
<h3 id="honor-labels配置的意义"><a href="#honor-labels配置的意义" class="headerlink" title="honor_labels配置的意义"></a>honor_labels配置的意义</h3><p>依旧有问题，那么修改一下 prometheus.yaml，增加 honor_labels: true 参数配置如下：</p>
<ul>
<li>job_name: ‘pushgateway’<br>honor_labels: true<br>static_configs:<ul>
<li>targets: [‘192.168.80.144:9091’]<br>labels:<br>  instance: pushgateway</li>
</ul>
</li>
</ul>
<p>重启 Prometheus，稍等一会，等到 Prometheus 采集到数据后，我们再访问 Prometheus UI 页面上 Graph 页面查询该指标。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-10-1024x421.png"></p>
<p>此时，可以看到能够正确匹配到 Push 的指标值对应到 job 和 instance 上了。这里说明一下 honor_labels 的作用：因为 Prometheus 配置 PushGateway 的时候，也会指定 job 和 instance，但是它只表示 PushGateway 实例本身，不能真正表达收集数据的含义。所以配置 PushGateway 需要添加 honor_labels:true 参数，避免收集数据本身的 job 和 instance 被覆盖。</p>
<h2 id="删除某一个指标"><a href="#删除某一个指标" class="headerlink" title="删除某一个指标"></a>删除某一个指标</h2><hr>
<p>如果要删除某一个指标，同样可以通过 API 方式触发删除。例如删除 job&#x3D;“test_job” 组下的所有指标值，可以执行如下命令：</p>
<p>curl -X DELETE <a href="http://192.168.80.144:9091/metrics/job/test/_job">http://192.168.80.144:9091/metrics/job/test\_job</a></p>
<p>注意：删除 job&#x3D;“test_job” 组下的所有指标值，不包括 {job&#x3D;“test_job”, instance&#x3D;“test_instance”} 中的指标值，虽然它们的 job 名称都为 test_job。如果想删除该指标值，那么需要执行如下命令：</p>
<p>curl -X DELETE <a href="http://192.168.80.144:9091/metrics/job/test/_job/instance/test/_instance">http://192.168.80.144:9091/metrics/job/test\_job/instance/test\_instance</a></p>
<p>同样，我们也可以在 PushGateway UI 页面指定指标记录后边，点击 Delete Group 按钮来删除，这里就不在演示了。</p>
]]></content>
      <categories>
        <category>运维监控</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Prometheus</tag>
        <tag>push</tag>
        <tag>PushGateway</tag>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>AttributeError:使用flask-sqlalchemy连接到sqlite数据库时无法设置属性</title>
    <url>/2021/05/26/attributeerror%E4%BD%BF%E7%94%A8flask-sqlalchemy%E8%BF%9E%E6%8E%A5%E5%88%B0sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>安装supervisor-cesi的时候，使用sqlite数据库 登录报错</p>
<p>sa_url.database &#x3D; os.path.join(app.root_path, sa_url.database)</p>
<p>Traceback (most recent call last):<br>  File “<console>“, line 1, in <module><br>  File “c:\coding-projects\task-master-tdd\env\lib\site-packages\flask_sqlalchemy\__init__.py”, line 1060, in __repr__<br>    self.engine.url if self.app or current_app else None<br>  File “c:\coding-projects\task-master-tdd\env\lib\site-packages\flask_sqlalchemy\__init__.py”, line 943, in engine<br>    return self.get_engine()<br>  File “c:\coding-projects\task-master-tdd\env\lib\site-packages\flask_sqlalchemy\__init__.py”, line 962, in get_engine<br>    return connector.get_engine()<br>  File “c:\coding-projects\task-master-tdd\env\lib\site-packages\flask_sqlalchemy\__init__.py”, line 555, in get_engine<br>    options &#x3D; self.get_options(sa_url, echo)<br>  File “c:\coding-projects\task-master-tdd\env\lib\site-packages\flask_sqlalchemy\__init__.py”, line 570, in get_options<br>    self._sa.apply_driver_hacks(self._app, sa_url, options)<br>  File “c:\coding-projects\task-master-tdd\env\lib\site-packages\flask_sqlalchemy\__init__.py”, line 914, in apply_driver_hacks<br>    sa_url.database &#x3D; os.path.join(app.root_path, sa_url.database)<br>AttributeError: can’t set attribute</p>
<p>解决方法:</p>
<p>SQLAlchemy自动作为Flask-SQLAlchemy的依赖项安装，其最新版本(1.4.0）引入了以下突破性的更改：</p>
<p>URL对象现在是一个名为tuple的不可变对象。要修改URL对象，请使用URL.set(）方法生成新的URL对象。</p>
<p>我只需安装以前版本的SQLAlchemy（1.3.23）就可以解决这个问题。</p>
<p>pip install  –upgrade sqlalchemy&#x3D;&#x3D;1.3.23</p>
<p>ok</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>AttributeError</tag>
        <tag>flask</tag>
        <tag>sqlalchemy</tag>
        <tag>sqlite</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>awk 如何删除重复行_不排序删除重复行</title>
    <url>/2021/08/11/awk-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C-%E4%B8%8D%E6%8E%92%E5%BA%8F%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-9.png"></p>
<p>前几天看完了awk Oneliner系列的文章，本来想有机会把他的第五部他的总结和另外一个十例篇也做个翻译拿来学习备忘下。不过因为俗务缠身，一时无暇去看，不过今天在测试tcpdump和wireshark抓取用户名和密码的的文档进行处理时，刚好又用到了awk的强大的删除重行，这里也拿来分享下。</p>
<p>1 2 3<br>1 2 3<br>1 2 4<br>1 2 3<br>1 2 5</p>
<p>这里假设我要处理的文件如上面的例子。不难看出里面有三行123，而我想所有的排列顺序不变，遇到重复的就自动删除。想实现的最终效果为：</p>
<p>1 2 3<br>1 2 4<br>1 2 5  </p>
<p>而如果使用sort加uniq进行排序的话，这个文档是看不出有什么不妥，不过我要处理的是用户名与密码一行行对应好的，如果使用sort + uniq处理的话，用户名都排到一块了，密码也又都跑到一块了。<br>这样就分不出来那个是那个了。 而使用的脚本很简单：</p>
<p>awk ‘!x[$0]++’ filename </p>
<blockquote>
<p>注：此处的x只是一个数据参数的名字而已，随你用a、b、c、d都行。</p>
</blockquote>
<p>简要解释一下，awk 的基本执行流程是，对文件的每一行，做一个指定的逻辑判断，如果逻辑判断成立，则执行指定的命令；如果逻辑判断不成立，则直接跳过这一行。</p>
<p>我们这里写的 awk 命令是!x[$0]++，意思是，首先创建一个 map 叫x，然后用当前行的全文$0作为 map 的 key，到 map 中查找相应的 value，如果没找到，则整个表达式的值为真，可以执行之后的语句；如果找到了，则表达式的值为假，跳过这一行。由于表达式之后有++，因此如果某个 key 找不到对应的 value，该++操作会先把对应的 value 设成 0，然后再自增成 1，这样下次再遇到重复的行的时候，对应的 key 就能找到一个非 0 的 value 了。</p>
<blockquote>
<p>注：该处的map类似于array数组，只不过在awk中叫array不恰当。</p>
</blockquote>
<p>awk Oneline中我们也学到过，awk 的流程是先判断表达式，表达式为真的时候就执行语句，可是我们前面写的这个 awk 命令里只有表达式，没有语句，那我们执行什么呢？原来，当语句被省略的时候，awk 就执行默认的语句，即打印整个完整的当前行。就这样，我们通过这个非常简短的 awk 命令实现了去除重复行并保留原有文件顺序的功能。</p>
<p>当然，我们也可以对该例进行下改变，通过判断某列的值相同，就只保留首行。</p>
<p>awk ‘!a[$3]++’ filename</p>
<p>删除第三列重复的行</p>
<p>awk ‘!a[$NF]++’ filename</p>
<p>删除最后一列重复的行</p>
<p>今天看到有人在关于我页面上评论说如何在去除重复行时对空白行不做处理，我这里总结了三种实现方法（都是仅使用awk工具），具体如下（为了便于区分，这里我使用nl命令加了行号）：</p>
<p>[root@code404 ~]# cat a.txt nl -ba   #原文件<br>     1  1 2 3<br>     2  1 2 3<br>     3<br>     4<br>     5  1 2 4<br>     6  1 2 3<br>     7<br>     8<br>     9  1 2 5<br>[root@code404 ~]# awk ‘!NF  !a[$0]++’  a.txt nl -ba   #方法一<br>     1  1 2 3<br>     2<br>     3<br>     4  1 2 4<br>     5<br>     6<br>     7  1 2 5<br>[root@code404 ~]# awk ‘!NF {print;next} !($0 in a) {a[$0];print}’  a.txt nl -ba   #方法二<br>     1  1 2 3<br>     2<br>     3<br>     4  1 2 4<br>     5<br>     6<br>     7  1 2 5<br>[root@code404 ~]# awk ‘!&#x2F;.&#x2F;  !a[$0]++’ a.txt nl -ba  #方法三<br>     1  1 2 3<br>     2<br>     3<br>     4  1 2 4<br>     5<br>     6<br>     7  1 2 5<br>[root@code404 ~]#</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>awk</tag>
        <tag>删除空行</tag>
        <tag>删除行</tag>
      </tags>
  </entry>
  <entry>
    <title>binlog解析出来的日志为何无法恢复</title>
    <url>/2021/08/05/binlog%E8%A7%A3%E6%9E%90%E5%87%BA%E6%9D%A5%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%BA%E4%BD%95%E6%97%A0%E6%B3%95%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-4.png"></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><hr>
<p>问题来自一位群友，简单说就是用 mysqlbinlog 工具读取 binlog 欲进行恢复，却发现数据并没被恢复。</p>
<p>先一起来看下他是怎么做恢复的。</p>
<p>表中原来有几条数据，但不小心被清空了：</p>
<p>[yejr]&gt; select * from t1;<br>+—-+<br> c1<br>+—-+<br>  1<br>  2<br>  3<br>  4<br>+—-+</p>
<p>查看binlog event，有几条插入数据，最后还有一条 truncate table 的”误操作”，现在想要把表数据恢复到误删数据前的状态。</p>
<p>[yejr]&gt; show binlog events in ‘binlog.000003’;<br>+—————+——+—————-+———–+————-+——————————————————————–+<br> Log_name       Pos   Event_type      Server_id  End_log_pos  Info<br>+—————+——+—————-+———–+————-+——————————————————————–+<br> binlog.000003     4  Format_desc          3306          125  Server ver: 8.0.25-15, Binlog ver: 4<br> binlog.000003   125  Previous_gtids       3306          196  aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:1-5<br> binlog.000003   196  Gtid                 3306          282  SET @@SESSION.GTID_NEXT&#x3D; ‘aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:6’<br> binlog.000003   282  Query                3306          358  BEGIN<br> binlog.000003   358  Rows_query           3306          405  # insert into t1 select 1<br> binlog.000003   405  Table_map            3306          454  table_id: 91 (yejr.t1)<br> binlog.000003   454  Write_rows           3306          494  table_id: 91 flags: STMT_END_F<br> binlog.000003   494  Xid                  3306          525  COMMIT &#x2F;* xid&#x3D;75 *&#x2F;<br> binlog.000003   525  Gtid                 3306          611  SET @@SESSION.GTID_NEXT&#x3D; ‘aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:7’<br> binlog.000003   611  Query                3306          687  BEGIN<br> binlog.000003   687  Rows_query           3306          734  # insert into t1 select 2<br> binlog.000003   734  Table_map            3306          783  table_id: 91 (yejr.t1)<br> binlog.000003   783  Write_rows           3306          823  table_id: 91 flags: STMT_END_F<br> binlog.000003   823  Xid                  3306          854  COMMIT &#x2F;* xid&#x3D;76 *&#x2F;<br> binlog.000003   854  Gtid                 3306          940  SET @@SESSION.GTID_NEXT&#x3D; ‘aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:8’<br> binlog.000003   940  Query                3306         1016  BEGIN<br> binlog.000003  1016  Rows_query           3306         1063  # insert into t1 select 3<br> binlog.000003  1063  Table_map            3306         1112  table_id: 91 (yejr.t1)<br> binlog.000003  1112  Write_rows           3306         1152  table_id: 91 flags: STMT_END_F<br> binlog.000003  1152  Xid                  3306         1183  COMMIT &#x2F;* xid&#x3D;77 *&#x2F;<br> binlog.000003  1183  Gtid                 3306         1269  SET @@SESSION.GTID_NEXT&#x3D; ‘aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:9’<br> binlog.000003  1269  Query                3306         1345  BEGIN<br> binlog.000003  1345  Rows_query           3306         1392  # insert into t1 select 4<br> binlog.000003  1392  Table_map            3306         1441  table_id: 91 (yejr.t1)<br> binlog.000003  1441  Write_rows           3306         1481  table_id: 91 flags: STMT_END_F<br> binlog.000003  1481  Xid                  3306         1512  COMMIT &#x2F;* xid&#x3D;78 *&#x2F;<br> binlog.000003  1512  Gtid                 3306         1596  SET @@SESSION.GTID_NEXT&#x3D; ‘aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:10’<br> binlog.000003  1596  Query                3306         1693  use `yejr`; truncate table t1 &#x2F;* xid&#x3D;87 *&#x2F;<br>+—————+——+—————-+———–+————-+——————————————————————–+</p>
<p>运行下面的命令想要进行恢复数据，但发现不能正确恢复：</p>
<p>$ mysqlbinlog –start-position&#x3D;4 –stop-position&#x3D;1512 binlog.000003  mysql -f yejr </p>
<p>已经指定了读取binlog的位置是从4开始，到1512截止，因为再下一个event就是”误操作”了。之后查询 yejr.t1 表数据还是空的，没有被正确恢复。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><hr>
<p>首先再次强调线上操作要非常谨慎，如果只是普通的DML操作，建议事先打开事务模式，这样万一误操作了还能执行 rollback 回滚。</p>
<p>但如果是DDL操作，则基本上只能依赖备份或者延迟从库，所以务必再三确认是在测试环境还是线上环境，以及即将执行的命令影响如何。</p>
<p>再回到问题本身。</p>
<p>在执行 mysqlbinlog 解析binlog并尝试恢复时，观察新的binlog，确认没有写入新数据，说明确实没执行恢复操作。</p>
<p>解析binlog查看，并没有类似 SET SQL_LOG_BIN&#x3D;0 等忽略binlog的设置，而如果复制SQL指令执行出来手动执行，却是可以成功的。说明binlog本身没问题，是其他原因导致的。</p>
<p>再查看 binlog event 时注意到启用了 GTID 模式，在 GTID 模式下有个特点是要求 全局唯一。</p>
<p>除了GTID值持续递增之外，有个不容易注意的特点是，当事务GTID在已执行过的GTID集合（Executed_Gtid_Set）中的话，就不会再次被执行。假设以下几种场景：</p>
<ul>
<li>假设当前Executed_Gtid_Set集合是 1-10，如果下一个GTID是5，它在这个范围内，则无法被执行。</li>
<li>假设当前Executed_Gtid_Set集合是 1-10, 20-30，如果下一个GTID是13，不在这个范围内，则可以被执行。</li>
</ul>
<p>分别做个测试：</p>
<p># 查看当前gtid<br>[yejr]&gt; show master status;<br>+—————+———-+————–+——————+———————————————-+<br> File           Position  Binlog_Do_DB  Binlog_Ignore_DB  Executed_Gtid_Set<br>+—————+———-+————–+——————+———————————————-+<br> binlog.000004       762                                  aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:1-15:20<br>+—————+———-+————–+——————+———————————————-+</p>
<h1 id="下一个GTID在范围内，不会被执行"><a href="#下一个GTID在范围内，不会被执行" class="headerlink" title="下一个GTID在范围内，不会被执行"></a>下一个GTID在范围内，不会被执行</h1><p>[yejr]&gt; set session gtid_next&#x3D;’aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:13’;<br>[yejr]&gt; insert into t1 select 6;<br>Query OK, 0 rows affected (0.00 sec)   #&lt;– 0 rows</p>
<h1 id="下一个GTID不在范围内，会被执行"><a href="#下一个GTID不在范围内，会被执行" class="headerlink" title="下一个GTID不在范围内，会被执行"></a>下一个GTID不在范围内，会被执行</h1><p>[yejr]&gt; set session gtid_next&#x3D;’aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:17’;<br>[yejr]&gt; insert into t1 select 6;<br>Query OK, 1 row affected (0.01 sec)   #&lt;– 1 row affected<br>Records: 1  Duplicates: 0  Warnings: 0</p>
<h1 id="再次查看gtid"><a href="#再次查看gtid" class="headerlink" title="再次查看gtid"></a>再次查看gtid</h1><p>[yejr]&gt; show master status;<br>+—————+———-+————–+——————+————————————————-+<br> File           Position  Binlog_Do_DB  Binlog_Ignore_DB  Executed_Gtid_Set<br>+—————+———-+————–+——————+————————————————-+<br> binlog.000004      1091                                  aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1:1-15:17:20<br>+—————+———-+————–+——————+————————————————-+</p>
<p>验证结果确实如上所说。</p>
<p>知道原因就好办了，查看 mysqlbinlog 的帮助文档，查看选项 –skip-gtids 的解释：</p>
<p>  –skip-gtids        Do not preserve Global Transaction Identifiers; instead<br>                      make the server execute the transactions as if they were<br>                      new.</p>
<p>它可以使得解析出来的binlog event不再保留原来的 GTID 信息，这就可以当成新的 event 被执行了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>如果想要从binlog恢复数据，执行mysqlbinlog时，记得加上 –skip-gtids 选项。</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>binlo日志</tag>
        <tag>为何</tag>
        <tag>无法恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>BIO/NIO/AIO的区别</title>
    <url>/2021/06/13/bio-nio-aio%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-33.png"></p>
<h2 id="BIO-x2F-NIO-x2F-AIO的区别"><a href="#BIO-x2F-NIO-x2F-AIO的区别" class="headerlink" title="BIO&#x2F;NIO&#x2F;AIO的区别"></a>BIO&#x2F;NIO&#x2F;AIO的区别</h2><p><strong>BIO</strong>：同步阻塞IO，每一个客户端连接，服务端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是<code>一个连接一个线程</code>。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-31.png"></p>
<p><strong>NIO</strong>：同步非阻塞IO，基于Reactor模型，客户端和channel进行通信，channel可以进行读写操作，通过多路复用器selector来轮询注册在其上的channel，而后再进行IO操作。这样的话，在进行IO操作的时候再用一个线程去处理就可以了，也就是<code>一个请求一个线程</code>。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-32.png"></p>
<p><strong>AIO</strong>：异步非阻塞IO，相比NIO更进一步，完全由操作系统来完成请求的处理，然后通知服务端开启线程去进行处理，因此是<code>一个有效请求一个线程</code>。</p>
<h2 id="那么你怎么理解同步和阻塞？"><a href="#那么你怎么理解同步和阻塞？" class="headerlink" title="那么你怎么理解同步和阻塞？"></a>那么你怎么理解同步和阻塞？</h2><p>首先，可以认为一个IO操作包含两个部分：</p>
<ol>
<li>发起IO请求</li>
<li>实际的IO读写操作</li>
</ol>
<p>同步和异步在于第二个，实际的IO读写操作，如果操作系统帮你完成了再通知你，那就是异步，否则都叫做同步。</p>
<p>阻塞和非阻塞在于第一个，发起IO请求，对于NIO来说通过channel发起IO操作请求后，其实就返回了，所以是非阻塞。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>AIO</tag>
        <tag>BIO</tag>
        <tag>NIO</tag>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 163 yum源配置</title>
    <url>/2021/04/14/centos-163-yum%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>使用说明</p>
<h5 id="首先备份-x2F-etc-x2F-yum-repos-d-x2F-CentOS-Base-repo"><a href="#首先备份-x2F-etc-x2F-yum-repos-d-x2F-CentOS-Base-repo" class="headerlink" title="首先备份&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo"></a>首先备份&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</h5><hr>
<p>mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</p>
<p><code>对应版本repo文件, 放入/etc/yum.repos.d/(操作前请做好相应备份)</code></p>
<h5 id="配置Yum源"><a href="#配置Yum源" class="headerlink" title="配置Yum源"></a>配置Yum源</h5><hr>
<ul>
<li><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">CentOS7</a> yum源配置</li>
</ul>
<p># CentOS-Base.repo<br>#</p>
<h1 id="The-mirror-system-uses-the-connecting-IP-address-of-the-client-and-the"><a href="#The-mirror-system-uses-the-connecting-IP-address-of-the-client-and-the" class="headerlink" title="The mirror system uses the connecting IP address of the client and the"></a>The mirror system uses the connecting IP address of the client and the</h1><h1 id="update-status-of-each-mirror-to-pick-mirrors-that-are-updated-to-and"><a href="#update-status-of-each-mirror-to-pick-mirrors-that-are-updated-to-and" class="headerlink" title="update status of each mirror to pick mirrors that are updated to and"></a>update status of each mirror to pick mirrors that are updated to and</h1><h1 id="geographically-close-to-the-client-You-should-use-this-for-CentOS-updates"><a href="#geographically-close-to-the-client-You-should-use-this-for-CentOS-updates" class="headerlink" title="geographically close to the client.  You should use this for CentOS updates"></a>geographically close to the client.  You should use this for CentOS updates</h1><h1 id="unless-you-are-manually-picking-other-mirrors"><a href="#unless-you-are-manually-picking-other-mirrors" class="headerlink" title="unless you are manually picking other mirrors."></a>unless you are manually picking other mirrors.</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="If-the-mirrorlist-x3D-does-not-work-for-you-as-a-fall-back-you-can-try-the"><a href="#If-the-mirrorlist-x3D-does-not-work-for-you-as-a-fall-back-you-can-try-the" class="headerlink" title="If the mirrorlist&#x3D; does not work for you, as a fall back you can try the"></a>If the mirrorlist&#x3D; does not work for you, as a fall back you can try the</h1><h1 id="remarked-out-baseurl-x3D-line-instead"><a href="#remarked-out-baseurl-x3D-line-instead" class="headerlink" title="remarked out baseurl&#x3D; line instead."></a>remarked out baseurl&#x3D; line instead.</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><p>[base]<br>name&#x3D;CentOS-$releasever - Base - 163.com<br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</a><br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/os/$basearch/">http://mirrors.163.com/centos/$releasever/os/$basearch/</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7">http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</a></p>
<p>#released updates<br>[updates]<br>name&#x3D;CentOS-$releasever - Updates - 163.com<br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</a><br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/updates/$basearch/">http://mirrors.163.com/centos/$releasever/updates/$basearch/</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7">http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</a></p>
<p>#additional packages that may be useful<br>[extras]<br>name&#x3D;CentOS-$releasever - Extras - 163.com<br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</a><br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/extras/$basearch/">http://mirrors.163.com/centos/$releasever/extras/$basearch/</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7">http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</a></p>
<p>#additional packages that extend functionality of existing packages<br>[centosplus]<br>name&#x3D;CentOS-$releasever - Plus - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/centosplus/$basearch/">http://mirrors.163.com/centos/$releasever/centosplus/$basearch/</a><br>gpgcheck&#x3D;1<br>enabled&#x3D;0<br>gpgkey&#x3D;<a href="http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7">http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</a></p>
<ul>
<li><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">CentOS6</a> yum源配置</li>
</ul>
<p># CentOS-Base.repo<br>#</p>
<h1 id="The-mirror-system-uses-the-connecting-IP-address-of-the-client-and-the-1"><a href="#The-mirror-system-uses-the-connecting-IP-address-of-the-client-and-the-1" class="headerlink" title="The mirror system uses the connecting IP address of the client and the"></a>The mirror system uses the connecting IP address of the client and the</h1><h1 id="update-status-of-each-mirror-to-pick-mirrors-that-are-updated-to-and-1"><a href="#update-status-of-each-mirror-to-pick-mirrors-that-are-updated-to-and-1" class="headerlink" title="update status of each mirror to pick mirrors that are updated to and"></a>update status of each mirror to pick mirrors that are updated to and</h1><h1 id="geographically-close-to-the-client-You-should-use-this-for-CentOS-updates-1"><a href="#geographically-close-to-the-client-You-should-use-this-for-CentOS-updates-1" class="headerlink" title="geographically close to the client.  You should use this for CentOS updates"></a>geographically close to the client.  You should use this for CentOS updates</h1><h1 id="unless-you-are-manually-picking-other-mirrors-1"><a href="#unless-you-are-manually-picking-other-mirrors-1" class="headerlink" title="unless you are manually picking other mirrors."></a>unless you are manually picking other mirrors.</h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="If-the-mirrorlist-x3D-does-not-work-for-you-as-a-fall-back-you-can-try-the-1"><a href="#If-the-mirrorlist-x3D-does-not-work-for-you-as-a-fall-back-you-can-try-the-1" class="headerlink" title="If the mirrorlist&#x3D; does not work for you, as a fall back you can try the"></a>If the mirrorlist&#x3D; does not work for you, as a fall back you can try the</h1><h1 id="remarked-out-baseurl-x3D-line-instead-1"><a href="#remarked-out-baseurl-x3D-line-instead-1" class="headerlink" title="remarked out baseurl&#x3D; line instead."></a>remarked out baseurl&#x3D; line instead.</h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><p>[base]<br>name&#x3D;CentOS-$releasever - Base - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/os/$basearch/">http://mirrors.163.com/centos/$releasever/os/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6</a></p>
<p>#released updates<br>[updates]<br>name&#x3D;CentOS-$releasever - Updates - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/updates/$basearch/">http://mirrors.163.com/centos/$releasever/updates/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6</a></p>
<p>#additional packages that may be useful<br>[extras]<br>name&#x3D;CentOS-$releasever - Extras - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/extras/$basearch/">http://mirrors.163.com/centos/$releasever/extras/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6</a></p>
<p>#additional packages that extend functionality of existing packages<br>[centosplus]<br>name&#x3D;CentOS-$releasever - Plus - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/centosplus/$basearch/">http://mirrors.163.com/centos/$releasever/centosplus/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus</a><br>gpgcheck&#x3D;1<br>enabled&#x3D;0<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6</a></p>
<p>#contrib - packages by Centos Users<br>[contrib]<br>name&#x3D;CentOS-$releasever - Contrib - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/contrib/$basearch/">http://mirrors.163.com/centos/$releasever/contrib/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contrib">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contrib</a><br>gpgcheck&#x3D;1<br>enabled&#x3D;0<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6</a></p>
<ul>
<li><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">CentOS5</a> yum源配置</li>
</ul>
<p># CentOS-Base.repo<br>#</p>
<h1 id="The-mirror-system-uses-the-connecting-IP-address-of-the-client-and-the-2"><a href="#The-mirror-system-uses-the-connecting-IP-address-of-the-client-and-the-2" class="headerlink" title="The mirror system uses the connecting IP address of the client and the"></a>The mirror system uses the connecting IP address of the client and the</h1><h1 id="update-status-of-each-mirror-to-pick-mirrors-that-are-updated-to-and-2"><a href="#update-status-of-each-mirror-to-pick-mirrors-that-are-updated-to-and-2" class="headerlink" title="update status of each mirror to pick mirrors that are updated to and"></a>update status of each mirror to pick mirrors that are updated to and</h1><h1 id="geographically-close-to-the-client-You-should-use-this-for-CentOS-updates-2"><a href="#geographically-close-to-the-client-You-should-use-this-for-CentOS-updates-2" class="headerlink" title="geographically close to the client.  You should use this for CentOS updates"></a>geographically close to the client.  You should use this for CentOS updates</h1><h1 id="unless-you-are-manually-picking-other-mirrors-2"><a href="#unless-you-are-manually-picking-other-mirrors-2" class="headerlink" title="unless you are manually picking other mirrors."></a>unless you are manually picking other mirrors.</h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="If-the-mirrorlist-x3D-does-not-work-for-you-as-a-fall-back-you-can-try-the-2"><a href="#If-the-mirrorlist-x3D-does-not-work-for-you-as-a-fall-back-you-can-try-the-2" class="headerlink" title="If the mirrorlist&#x3D; does not work for you, as a fall back you can try the"></a>If the mirrorlist&#x3D; does not work for you, as a fall back you can try the</h1><h1 id="remarked-out-baseurl-x3D-line-instead-2"><a href="#remarked-out-baseurl-x3D-line-instead-2" class="headerlink" title="remarked out baseurl&#x3D; line instead."></a>remarked out baseurl&#x3D; line instead.</h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><p>[base]<br>name&#x3D;CentOS-$releasever - Base - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/os/$basearch/">http://mirrors.163.com/centos/$releasever/os/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5</a></p>
<p>#released updates<br>[updates]<br>name&#x3D;CentOS-$releasever - Updates - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/updates/$basearch/">http://mirrors.163.com/centos/$releasever/updates/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5</a></p>
<p>#packages used&#x2F;produced in the build but not released<br>[addons]<br>name&#x3D;CentOS-$releasever - Addons - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/addons/$basearch/">http://mirrors.163.com/centos/$releasever/addons/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=addons">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=addons</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5</a></p>
<p>#additional packages that may be useful<br>[extras]<br>name&#x3D;CentOS-$releasever - Extras - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/extras/$basearch/">http://mirrors.163.com/centos/$releasever/extras/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5</a></p>
<p>#additional packages that extend functionality of existing packages<br>[centosplus]<br>name&#x3D;CentOS-$releasever - Plus - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/centosplus/$basearch/">http://mirrors.163.com/centos/$releasever/centosplus/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus</a><br>gpgcheck&#x3D;1<br>enabled&#x3D;0<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5</a></p>
<p>#contrib - packages by Centos Users<br>[contrib]<br>name&#x3D;CentOS-$releasever - Contrib - 163.com<br>baseurl&#x3D;<a href="http://mirrors.163.com/centos/$releasever/contrib/$basearch/">http://mirrors.163.com/centos/$releasever/contrib/$basearch/</a><br>#mirrorlist&#x3D;<a href="http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contrib">http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contrib</a><br>gpgcheck&#x3D;1<br>enabled&#x3D;0<br>gpgkey&#x3D;<a href="http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5">http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5</a></p>
<h5 id="运行以下命令生成缓存"><a href="#运行以下命令生成缓存" class="headerlink" title="运行以下命令生成缓存"></a>运行以下命令生成缓存</h5><hr>
<p>清理缓存</p>
<p>yum clean all</p>
<p>重建元数据缓存</p>
<p>yum makecache</p>
<p>已上就是centos 163 yum源配置过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>163yum源</tag>
        <tag>centos</tag>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 开机流程详解</title>
    <url>/2021/11/17/centos-%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<ul>
<li><strong>BIOS</strong>:(Basic Input Output System)基本输入输出系统,它是一组固化到计算机内主板上一个ROM芯片 上的程序，保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，可从CMOS中读写系统设置的具体信息。</li>
<li><strong>MBR</strong>: Master Boot Record，主要引导记录区。</li>
<li><strong>Boot Loader</strong>：启动引导程序。<br><img src="https://img-blog.csdnimg.cn/1906a2035a2b4ab0816625bfb288a44f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ul>
<h3 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h3><hr>
<h4 id="第一步：加载BIOS"><a href="#第一步：加载BIOS" class="headerlink" title="第一步：加载BIOS"></a>第一步：加载BIOS</h4><hr>
<p>打开计算机电源，计算机硬件会自动加载BIOS，读取BIOS内相关硬件信息及进行硬件系统的自检，随后根据BIOS配置找到第一个有引导程序的的设备。</p>
<h4 id="第二步：读取MBR"><a href="#第二步：读取MBR" class="headerlink" title="第二步：读取MBR"></a>第二步：读取MBR</h4><hr>
<p>硬盘上第0磁道第一个扇区被称为MBR，即主引导记录，大小是512字节，存放了预启动信息、分区表信息。系统找到BIOS所指定的硬盘的MBR后，就会将其复制到物理内存中，被复制到物理内存的内容就是Boot Loader（lilo或者grub）。</p>
<h4 id="第三步：启动Boot-Loader"><a href="#第三步：启动Boot-Loader" class="headerlink" title="第三步：启动Boot Loader"></a>第三步：启动Boot Loader</h4><hr>
<p>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。<br>Boot Loader有若干种，其中Grub、Lilo是常见的Loader。<br>本文以Grub为例讲解，grub功能：提供一个菜单，允许用户选择要启动的系统或不同的内核版本；把用户选定的内核装载到RAM中的特定空间中，解压、展开。</p>
<p>系统读取内存中的grub配置信息（一般为menu.lst或grub.conf），并依照此配置信息来加载指定内核。<br><img src="https://img-blog.csdnimg.cn/c5e51733d6d347959bf42a4f9dc119f0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="第四步：加载内核"><a href="#第四步：加载内核" class="headerlink" title="第四步：加载内核"></a>第四步：加载内核</h4><hr>
<p>grub把系统控制权移交给内核，内核开始探测可识别到的所有硬件设备及尝试挂载根目录以获取其驱动程序。此时就需要首先加载磁盘驱动程序以便读取磁盘，而磁盘驱动程序又保存在磁盘内，这样就会导致linux无法启动。此时需要通过伪文件系统来解决这一问题。</p>
<p>虚拟文件系统 (Initial RAM Disk) 即&#x2F;boot&#x2F;initramfs-release.img ，这个文件的特色是，能够通过boot loader 来加载到内存中， 然后这个文件会被解压缩并且在内存当中模拟成一个根目录，且此模拟在内存当中的文件系统能够提供一支可运行的程序，透过该程序来加载启动过程中所最需要的核心模块，通常这些模块就是 U盘, RAID, LVM, SCSI 等文件系统与磁盘的驱动程序。等加载完成后， 会帮助核心重新呼叫 &#x2F;sbin&#x2F;init 来开始后续的正常启动流程。</p>
<p>注：RamDisk是辅助性文件，并非必须，取决于内核是否能直接驱动根文件系统所在的设备。</p>
<p><img src="https://img-blog.csdnimg.cn/e74f677eb2b4436192d611c326b7f00b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="第五步：运行-x2F-sbin-x2F-init程序，设定linux的运行等级"><a href="#第五步：运行-x2F-sbin-x2F-init程序，设定linux的运行等级" class="headerlink" title="第五步：运行&#x2F;sbin&#x2F;init程序，设定linux的运行等级"></a>第五步：运行&#x2F;sbin&#x2F;init程序，设定linux的运行等级</h4><hr>
<p>内核加载完毕后，运行用户空间内第一个应用程序就是&#x2F;sbin&#x2F;init，然后读取&#x2F;etc&#x2F;inttab文件，依据文件配置设定系统运行等级；</p>
<p><img src="https://img-blog.csdnimg.cn/082393dc0c394987b8a7b5c2265d7631.png" alt="在这里插入图片描述"></p>
<h4 id="第六步：init进程执行rc-sysinit"><a href="#第六步：init进程执行rc-sysinit" class="headerlink" title="第六步：init进程执行rc.sysinit"></a>第六步：init进程执行rc.sysinit</h4><hr>
<p>设定了运行等级后，Linux系统执行&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit系统初始化脚本程序。初始化包括：设置主机名、设置欢迎信息、激活Udex和seliux、挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统、检测根文件系统、设置系统时钟、根据&#x2F;etc&#x2F;sysctl.conf文件来设置内核参数、激活LVM及软RAID设备、激活swap设备、加载额外设备的驱动程序、执行清理操作。</p>
<h4 id="第七步：启动内核模块"><a href="#第七步：启动内核模块" class="headerlink" title="第七步：启动内核模块"></a>第七步：启动内核模块</h4><hr>
<p>具体是依据&#x2F;etc&#x2F;sysconfig&#x2F;modules文件目录下的文件来装载内核模块。</p>
<h4 id="第八步：执行-run-level-的各个服务启动-script-方式"><a href="#第八步：执行-run-level-的各个服务启动-script-方式" class="headerlink" title="第八步：执行 run-level 的各个服务启动 (script 方式)"></a>第八步：执行 run-level 的各个服务启动 (script 方式)</h4><hr>
<p>根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。</p>
<p><img src="https://img-blog.csdnimg.cn/afef5d43fd54406885191f1ade3467d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="第九步：执行-x2F-etc-x2F-rc-d-x2F-rc-local"><a href="#第九步：执行-x2F-etc-x2F-rc-d-x2F-rc-local" class="headerlink" title="第九步：执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local"></a>第九步：执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local</h4><hr>
<p>rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。</p>
<p><img src="https://img-blog.csdnimg.cn/5f232536ecb9499eb8568aa5badabc26.png" alt="在这里插入图片描述"></p>
<h4 id="第十步：执行-x2F-bin-x2F-login程序，进入登录状态"><a href="#第十步：执行-x2F-bin-x2F-login程序，进入登录状态" class="headerlink" title="第十步：执行&#x2F;bin&#x2F;login程序，进入登录状态"></a>第十步：执行&#x2F;bin&#x2F;login程序，进入登录状态</h4><hr>
<p>Linux 就会启动终端机或者是 X Window 来等待使用者登陆。<br><img src="https://img-blog.csdnimg.cn/af61f73d5e5f43b6b48654129db4de75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>CentOS7</category>
        <category>Centos8</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>启动</tag>
        <tag>启动流程</tag>
        <tag>系统启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 Firewalld防火墙增加删除规则方法</title>
    <url>/2021/04/08/centos7-firewalld%E9%98%B2%E7%81%AB%E5%A2%99%E5%A2%9E%E5%8A%A0%E5%88%A0%E9%99%A4%E8%A7%84%E5%88%99%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="firewalld基本操作"><a href="#firewalld基本操作" class="headerlink" title="firewalld基本操作"></a>firewalld基本操作</h3><hr>
<ol>
<li>启动防火墙firewalld</li>
</ol>
<p>[root@localhost ~]# systemctl start firewalld</p>
<ol start="2">
<li>防火墙加入开机自启</li>
</ol>
<p>[root@localhost ~]# systemctl enable firewalld<br>Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service.<br>Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service.<br>[root@localhost ~]# </p>
<ol start="3">
<li>查看是否加入开机自启</li>
</ol>
<p>[root@localhost ~]# systemctl is-enabled firewalld<br>enabled</p>
<ol start="4">
<li>查看防火墙firewalld状态</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –state<br>running<br>#或者:<br>[root@localhost ~]# systemctl status firewalld<br>● firewalld.service - firewalld - dynamic firewall daemon<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; disabled; vendor preset: enabled)<br>   Active: active (running) since 三 2021-04-07 13:32:06 CST; 59s ago<br>     Docs: man:firewalld(1)<br> Main PID: 1731 (firewalld)<br>   CGroup: &#x2F;system.slice&#x2F;firewalld.service<br>           └─1731 &#x2F;usr&#x2F;bin&#x2F;python2 -Es &#x2F;usr&#x2F;sbin&#x2F;firewalld –nofork –nopid</p>
<p>4月 07 13:32:06 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon…<br>4月 07 13:32:06 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon.<br>4月 07 13:32:06 localhost.localdomain firewalld[1731]: WARNING: AllowZoneDrifting is enabled. This is considered an insecure configuration option. It will be removed in a futur…ing it now.<br>Hint: Some lines were ellipsized, use -l to show in full.<br>[root@localhost ~]# </p>
<ol start="5">
<li>关闭firewall防火墙</li>
</ol>
<p>[root@localhost ~]# systemctl stop firewalld</p>
<h3 id="firewall常用参数"><a href="#firewall常用参数" class="headerlink" title="firewall常用参数"></a>firewall常用参数</h3><hr>
<ol>
<li>firewalld中常用的区域名称及策略规则</li>
</ol>
<p>区域（zone）</p>
<p>默认策略规则</p>
<p>trusted</p>
<p>允许所有的数据包进出</p>
<p>home</p>
<p>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许进入</p>
<p>Internal</p>
<p>等同于home区域</p>
<p>work</p>
<p>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许进入</p>
<p>public</p>
<p>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许进入</p>
<p>external</p>
<p>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh服务相关，则允许进入</p>
<p>dmz</p>
<p>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh服务相关，则允许进入</p>
<p>block</p>
<p>拒绝进入的流量，除非与出去的流量相关</p>
<p>drop</p>
<p>拒绝进入的流量，除非与出去的流量相关</p>
<ol start="2">
<li>firewall-cmd命令中的参数以及作用</li>
</ol>
<p>参数</p>
<p>作用</p>
<p>--get-default-zone</p>
<p>查访默认的区域名称</p>
<p>--set-default-zone&#x3D;&lt;区域名称&gt;</p>
<p>设置默认的区域，使其永久生效</p>
<p>--get-zones</p>
<p>显示可用的区域</p>
<p>--get-services</p>
<p>显示预定义的服务</p>
<p>--get-active-zones</p>
<p>显示当前正在使用的区域、来源地址和网卡名称</p>
<p>--add-source&#x3D;</p>
<p>将源自此IP或子网的流量导向指定的区域</p>
<p>--remove-source&#x3D;</p>
<p>不再将源自此IP或子网的流量导向这个区域</p>
<p>--add-interface&#x3D;&lt;网卡名称&gt;</p>
<p>将源自该网卡的所有流量都导向某个指定区域</p>
<p>--change-interface&#x3D;&lt;网卡名称&gt;</p>
<p>将某个网卡与区域进行关联</p>
<p>--list-all</p>
<p>显示当前区域的网卡配置参数、资源、端口以及服务等信息</p>
<p>--list-all-zones</p>
<p>显示所有区域的网卡配置参数、资源、端口以及服务等信息</p>
<p>--add-service&#x3D;&lt;服务名&gt;</p>
<p>设置默认区域允许该服务的流量</p>
<p>--add-port&#x3D;&lt;端口号&#x2F;协议&gt;</p>
<p>设置默认区域允许该端口的流量</p>
<p>--remove-service&#x3D;&lt;服务名&gt;</p>
<p>设置默认区域不再允许该服务的流量</p>
<p>--remove-port&#x3D;&lt;端口号&#x2F;协议&gt;</p>
<p>设置默认区域不再允许该端口的流量</p>
<p>--reload</p>
<p>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</p>
<p>--permanent</p>
<p>添加这个配置的防火墙策略就可以永久生效</p>
<p>--panic-on</p>
<p>开启应急状况模式</p>
<p>--panic-off</p>
<p>关闭应急状况模式</p>
<h3 id="firewall防火墙配置手册"><a href="#firewall防火墙配置手册" class="headerlink" title="firewall防火墙配置手册"></a>firewall防火墙配置手册</h3><hr>
<ol>
<li>查看所有的可用区域(zone)</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –get-zones<br>block dmz drop external home internal public trusted work<br>[root@localhost ~]# firewall-cmd –get-default-zone<br>public #默认可用区域为 public</p>
<ol start="2">
<li>查看指定区域配置</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –zone&#x3D;public –list-all<br>public (active)<br>  target: default<br>  icmp-block-inversion: no<br>  interfaces: ens33<br>  sources:<br>  services: dhcpv6-client ssh<br>  ports:<br>  protocols:<br>  masquerade: no<br>  forward-ports:<br>  source-ports:<br>  icmp-blocks:<br>  rich rules:<br>rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.80.208&#x2F;22” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.65.94&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept</p>
<p><strong>参数说明：</strong></p>
<p>Target：目标<br>icmp-block-inversion：ICMP协议类型黑白名单开关（yes&#x2F;no）<br>Interfaces：关联的网卡接口<br>sources：来源，可以是IP地址，也可以是mac地址<br>services：允许的服务<br>ports：允许的目标端口，即本地开放的端口<br>protocols：允许通过的协议<br>masquerade：是否允许伪装（yes&#x2F;no），可改写来源IP地址及mac地址<br>forward-ports：允许转发的端口<br>source-ports：允许的来源端口<br>icmp-blocks：可添加ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许。<br>rich rules：富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。</p>
<ol start="3">
<li>防火墙添加规则(在默认区域public内)</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –zone&#x3D;public –add-port&#x3D;1521&#x2F;tcp –permanent<br>success<br>[root@localhost ~]# firewall-cmd –reload  #使配置生效<br>success</p>
<ol start="4">
<li>查看public区域策略(端口1521已加入)</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –zone&#x3D;public –list-all<br>public (active)<br>  target: default<br>  icmp-block-inversion: no<br>  interfaces: ens33<br>  sources:<br>  services: dhcpv6-client ssh<br>  ports: 1521&#x2F;tcp<br>  protocols:<br>  masquerade: no<br>  forward-ports:<br>  source-ports:<br>  icmp-blocks:<br>  rich rules:<br>rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.80.208&#x2F;22” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.65.94&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept</p>
<ol start="5">
<li>删除防火墙端口(1521端口)</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –zone&#x3D;public –remove-port&#x3D;1521&#x2F;tcp –permanent #删除端口<br>success<br>[root@localhost ~]# firewall-cmd –reload #使配置生效<br>success<br>[root@localhost ~]# firewall-cmd –zone&#x3D;public –list-all #查看配置<br>public (active)<br>  target: default<br>  icmp-block-inversion: no<br>  interfaces: ens33<br>  sources:<br>  services: dhcpv6-client ssh<br>  ports:<br>  protocols:<br>  masquerade: no<br>  forward-ports:<br>  source-ports:<br>  icmp-blocks:<br>  rich rules:<br>rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.80.208&#x2F;22” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.65.94&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept</p>
<ol start="6">
<li>添加详细防火墙规则(rich rule)</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –permanent –add-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;32” port protocol&#x3D;”tcp” port&#x3D;”3306” accept”<br>success<br>[root@localhost ~]# firewall-cmd –reload<br>success<br>[root@localhost ~]# firewall-cmd –zone&#x3D;public –list-all<br>public (active)<br>  target: default<br>  icmp-block-inversion: no<br>  interfaces: ens33<br>  sources:<br>  services: dhcpv6-client ssh<br>  ports:<br>  protocols:<br>  masquerade: no<br>  forward-ports:<br>  source-ports:<br>  icmp-blocks:<br>  rich rules:<br>rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.80.208&#x2F;22” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”192.168.65.94&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept<br>rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;32” port port&#x3D;”3306” protocol&#x3D;”tcp” accept</p>
<ol start="7">
<li>删除详细防火墙规则(rich rule)</li>
</ol>
<p>[root@localhost ~]# firewall-cmd –permanent –remove-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept”<br>success<br>[root@localhost ~]# firewall-cmd –permanent –remove-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”172.25.42.35&#x2F;32” port port&#x3D;”3306” protocol&#x3D;”tcp” accept”<br>success<br>[root@localhost ~]# firewall-cmd –permanent –remove-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”192.168.80.208&#x2F;22” port port&#x3D;”3306” protocol&#x3D;”tcp” accept”<br>success<br>[root@localhost ~]# firewall-cmd –permanent –remove-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”192.168.65.94&#x2F;24” port port&#x3D;”3306” protocol&#x3D;”tcp” accept”<br>success<br>[root@localhost ~]# firewall-cmd –reload<br>success<br>[root@localhost ~]# firewall-cmd –zone&#x3D;public –list-all<br>public (active)<br>  target: default<br>  icmp-block-inversion: no<br>  interfaces: ens33<br>  sources:<br>  services: dhcpv6-client ssh<br>  ports:<br>  protocols:<br>  masquerade: no<br>  forward-ports:<br>  source-ports:<br>  icmp-blocks:<br>  rich rules:</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>firewall</tag>
        <tag>策略</tag>
        <tag>规则</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下普通账号通过systemctl管理服务需要输入root密码问题</title>
    <url>/2021/06/16/centos7%E4%B8%8B%E6%99%AE%E9%80%9A%E8%B4%A6%E5%8F%B7%E9%80%9A%E8%BF%87systemctl%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5root%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-39-1024x574.png"></p>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>使用普通账号test通过systemctl启动系统服务提示需要输入root密码：</p>
<p>[test@host-192-168-65-94 data]$ systemctl restart nginx<br>&#x3D;&#x3D;&#x3D;&#x3D; AUTHENTICATING FOR org.freedesktop.systemd1.manage-units &#x3D;&#x3D;&#x3D;<br>Authentication is required to manage system services or units.<br>Authenticating as: root<br>Password: </p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>根据上面提示得知权限由<code>polkit</code>进行管理，对应的是<code>org.freedesktop.systemd1.policy</code>这个配置文件下的<code>manae-units</code>动作</p>
<p>进入<code>/usr/share/polkit-1/actions/org.freedesktop.systemd1.policy</code>，将对应<code>manae-units</code>的<code>defaults</code>中的授权全部改为<code>yes</code>，然后执行<code>systemctl restart polkit</code>重启<code>polkit</code></p>
<pre><code>    &lt;action id=&quot;org.freedesktop.systemd1.manage-units&quot;&gt;
</code></pre>
<hr>
<defaults>
<!--
        <allow\_any>auth\_admin</allow\_any>
                    <allow\_inactive>auth\_admin</allow\_inactive>
                    <allow\_active>auth\_admin\_keep</allow\_active>
-->
<allow\_any>yes</allow\_any>
        <allow\_inactive>yes</allow\_inactive>
        <allow\_active>yes</allow\_active>
 </defaults>
        </action>

<h2 id="权限可选的配置参数："><a href="#权限可选的配置参数：" class="headerlink" title="权限可选的配置参数："></a>权限可选的配置参数：</h2><p><strong>defaults</strong> 选项</p>
<p>This element is used to specify implicit authorizations for clients. Elements that can be used inside defaults include:</p>
<ul>
<li><strong><code>allow_any</code></strong>: Implicit authorizations that apply to any client. Optional.</li>
<li><strong><code>allow_inactive</code></strong>: Implicit authorizations that apply to clients in inactive sessions on local consoles. Optional.</li>
<li><strong><code>allow_active</code></strong>: Implicit authorizations that apply to clients in active sessions on local consoles. Optional.</li>
</ul>
<p>Each of the <strong><code>allow_any</code></strong>, <strong><code>allow_inactive</code></strong> and <strong><code>allow_active</code></strong> elements can contain the following values:</p>
<ul>
<li><strong><code>no</code></strong>: Not authorized.</li>
<li><strong><code>yes</code></strong>: Authorized.</li>
<li><strong><code>auth_self</code></strong>: Authentication by the owner of the session that the client originates from is required. Note that this is not restrictive enough for most uses on multi-user systems; auth_admin* is generally recommended.</li>
<li><strong><code>auth_admin</code></strong>: Authentication by an administrative user is required.</li>
<li><strong><code>auth_self_keep</code></strong>: Like auth_self but the authorization is kept for a brief period (e.g. five minutes). The warning about auth_self above applies likewise.</li>
<li><strong><code>auth_admin_keep</code></strong>: Like auth_admin but the authorization is kept for a brief period (e.g. five minutes).</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>Polkit</tag>
        <tag>systemctl</tag>
        <tag>管理服务</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7升级OpenSSH8.5p1附带安装包</title>
    <url>/2021/06/03/centos7%E5%8D%87%E7%BA%A7openssh8-5p1%E9%99%84%E5%B8%A6%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-8.png"></p>
<p>当我们的服务器openssh现在漏洞时，让修补漏洞，修补漏洞是个非常麻烦的事情，我们也可以给openssh做一下升级，升级成新版本，就可以解决漏洞等问题</p>
<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p><a href="https://download.csdn.net/download/leenhem/19342812%E5%AE%89%E8%A3%85%E5%8C%85%E5%86%85%E9%99%84%E5%B8%A6%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3">https://download.csdn.net/download/leenhem/19342812</a></p>
<p><a href="https://download.csdn.net/download/leenhem/19342812%E5%AE%89%E8%A3%85%E5%8C%85%E5%86%85%E9%99%84%E5%B8%A6%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3">安装包内附带安装文档</a></p>
<p>具体操作过程如下：</p>
<h3 id="1-将升级包放在服务器-x2F-data-x2F-openssh目录下。"><a href="#1-将升级包放在服务器-x2F-data-x2F-openssh目录下。" class="headerlink" title="1.将升级包放在服务器&#x2F;data&#x2F;openssh目录下。"></a>1.将升级包放在服务器&#x2F;data&#x2F;openssh目录下。</h3><p>[root@host-192-168-65-94 openssh]# ll<br>total 6608<br>drwxr-xr-x. 4 root root      81 Jun  2 17:06 centos7 ssh8.5<br>-rw-r–r–. 1 root root 6764646 Jun  2  2021 centos7_ssh8.5.zip<br>[root@host-192-168-65-94 openssh]# pwd<br>&#x2F;data&#x2F;openssh<br>[root@host-192-168-65-94 openssh]# </p>
<h3 id="2-查看现有openssh版本"><a href="#2-查看现有openssh版本" class="headerlink" title="2. 查看现有openssh版本"></a>2. 查看现有openssh版本</h3><p>[root@host-192-168-65-94 data]# sshd -v<br>unknown option – v<br>OpenSSH_7.4p1, OpenSSL 1.0.1e-fips 11 Feb 2013<br>usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]<br>            [-E log_file] [-f config_file] [-g login_grace_time]<br>            [-h host_key_file] [-o option] [-p port] [-u len]</p>
<h3 id="3-升级openssh"><a href="#3-升级openssh" class="headerlink" title="3.升级openssh"></a>3.升级openssh</h3><p>[root@host-192-168-65-94 centos7 ssh8.5]# sh update_ssh.sh<br>Preparing…                          ################################# [100%]<br>Updating &#x2F; installing…<br>   1:libICE-1.0.9-9.el7               ################################# [ 20%]<br>   2:libSM-1.2.2-2.el7                ################################# [ 40%]<br>   3:openssl-libs-1:1.0.2k-19.el7     ################################# [ 60%]<br>   4:openssl-1:1.0.2k-19.el7          ################################# [ 80%]<br>   5:libXt-1.1.5-3.el7                ################################# [100%]<br>Preparing…                          ################################# [100%]<br>Updating &#x2F; installing…<br>   1:openssh-8.5p1-1.el7.centos       ################################# [ 11%]<br>   2:openssh-askpass-8.5p1-1.el7.cento################################# [ 22%]<br>   3:openssh-askpass-gnome-8.5p1-1.el7################################# [ 33%]<br>   4:openssh-clients-8.5p1-1.el7.cento################################# [ 44%]<br>   5:openssh-server-8.5p1-1.el7.centoswarning: &#x2F;etc&#x2F;ssh&#x2F;sshd_config created as &#x2F;etc&#x2F;ssh&#x2F;sshd_config.rpmnew<br>################################# [ 56%]<br>   6:openssh-debuginfo-8.5p1-1.el7.cen################################# [ 67%]<br>Cleaning up &#x2F; removing…<br>   7:openssh-server-7.4p1-11.el7      ################################# [ 78%]<br>   8:openssh-clients-7.4p1-11.el7     ################################# [ 89%]<br>   9:openssh-7.4p1-11.el7             ################################# [100%]<br>—— upgradeSSH finished ——<br>OpenSSH_8.5p1, OpenSSL 1.0.2k-fips  26 Jan 2017<br>[root@host-192-168-65-94 centos7 ssh8.5]# </p>
<h3 id="4-查看升级后openssh版本"><a href="#4-查看升级后openssh版本" class="headerlink" title="4. 查看升级后openssh版本"></a>4. 查看升级后openssh版本</h3><p>[root@host-192-168-65-94 centos7 ssh8.5]# ssh -v<br>usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]<br>           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]<br>           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]<br>           [-i identity_file] [-J [user@]host[:port]] [-L address]<br>           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]<br>           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]<br>           [-w local_tun[:remote_tun]] destination [command]<br>[root@host-192-168-65-94 centos7 ssh8.5]# </p>
<h3 id="5-安装包地址"><a href="#5-安装包地址" class="headerlink" title="5.安装包地址"></a>5.安装包地址</h3><p><a href="https://download.csdn.net/download/leenhem/19342812">https://download.csdn.net/download/leenhem/19342812</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos7</tag>
        <tag>openssh升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos8 如何在_Rescue_救援_模式下配置网络 联网 和 SSH 登录</title>
    <url>/2021/07/08/centos8-%E5%A6%82%E4%BD%95%E5%9C%A8-rescue-%E6%95%91%E6%8F%B4-%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C-%E8%81%94%E7%BD%91-%E5%92%8C-ssh-%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-58.png"></p>
<p>Centos 系统救援</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>在本教程中，将展示如何使用Centos8的DVD镜像引导Rescue救援模式，并在救援模式中启用网络、配置SSH服务，供用户远程登录该服务器</p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><hr>
<p>Centos8</p>
<h3 id="加载ISO镜像，进入救援模式"><a href="#加载ISO镜像，进入救援模式" class="headerlink" title="加载ISO镜像，进入救援模式"></a>加载ISO镜像，进入救援模式</h3><hr>
<p>在VMware Workstation中，加载光盘，并开机器用。开机按F2，进入BIOS，切换到Boot选项卡。将CD-ROM Drive移动到Hard Drive上面。按F10保存并重启。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-28.png"></p>
<p>选择Troubleshooting，然后选择进入救援模式。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-30.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-29.png"></p>
<p>当进入下面界面时，选择3，直接进入shell界面。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-31.png"></p>
<h3 id="在救援模式配置网卡"><a href="#在救援模式配置网卡" class="headerlink" title="在救援模式配置网卡"></a>在救援模式配置网卡</h3><hr>
<p>首先使用ip addr和nmcli d查看以下网卡信息，并获取到网卡名称，为下一步启动网卡使用：</p>
<p>ip addr<br>nmcli d</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-32.png"></p>
<p>下面激活ens160设备，并查看是否通过DHCP获取到ip地址：</p>
<p>nmcli d connect ens160<br>ip addr</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-33.png"></p>
<p>可以看到ens160的状态已经是connected了。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-34.png"></p>
<p>如果需要设置静态ip地址，可以修改下面的配置文件，并重新加载网卡信息：</p>
<p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens160<br>TYPE&#x3D;Ethernet<br>PROXY_METHOD&#x3D;none<br>BROWSER_ONLY&#x3D;no<br>BOOTPROTO&#x3D;static<br>DEFROUTE&#x3D;yes<br>IPV4_FAILURE_FATAL&#x3D;no<br>IPV6INIT&#x3D;yes<br>IPV6_AUTOCONF&#x3D;yes<br>IPV6_DEFROUTE&#x3D;yes<br>IPV6_FAILURE_FATAL&#x3D;no<br>IPV6_ADDR_GEN_MODE&#x3D;stable-privacy<br>NAME&#x3D;ens160<br>UUID&#x3D;ade25366-fb36-4f7d-b47c-407005b7fc66<br>DEVICE&#x3D;ens160<br>ONBOOT&#x3D;no<br>IPADDR&#x3D;192.168.43.132<br>PREFIX&#x3D;24<br>GATEWAY&#x3D;192.168.43.2</p>
<p>上面配置文件中将BOOTPROTO&#x3D;改为static。添加了IPADDR&#x3D; , PREFIX&#x3D; , GATEWAY&#x3D; 几个信息。</p>
<p>下面使用nmcli命令停用、并启用网卡设备：</p>
<p>nmcli c down ens160<br>nmcli c up ens160</p>
<h3 id="在救援模式启用SSH服务"><a href="#在救援模式启用SSH服务" class="headerlink" title="在救援模式启用SSH服务"></a>在救援模式启用SSH服务</h3><hr>
<p>下面在救援模式启用SSH服务。首先进入&#x2F;etc&#x2F;ssh配置文件目录中。复制sshd_config.anaconda文件，并更改名称为sshd_config</p>
<p>cd &#x2F;etc&#x2F;ssh<br>cp -p sshd_config.anaconda sshd_config</p>
<p>下面启动sshd服务：</p>
<p>systemctl start sshd</p>
<p>通过客户端远程连接测试一下，默认没有root密码。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-35.png"></p>
]]></content>
      <categories>
        <category>Centos8</category>
      </categories>
      <tags>
        <tag>Rescue</tag>
        <tag>救援模式</tag>
        <tag>联网</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS8系统安装手册</title>
    <url>/2021/04/13/centos8%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><hr>
<h4 id="系统镜像最好用迅雷下载，可以断点续传"><a href="#系统镜像最好用迅雷下载，可以断点续传" class="headerlink" title="系统镜像最好用迅雷下载，可以断点续传"></a>系统镜像<code>最好用迅雷下载，可以断点续传</code></h4><ul>
<li>镜像1 <code>CentOS-8.3.2011-x86_64-minimal.iso</code><br>下载地址：<em><a href="http://mirrors.163.com/centos/8.3.2011/isos/x86/_64/CentOS-8.3.2011-x86/_64-dvd1.iso">http://mirrors.163.com/centos/8.3.2011/isos/x86\_64/CentOS-8.3.2011-x86\_64-dvd1.iso</a></em></li>
<li>镜像2 <code>CentOS-8.3.2011-x86_64-dvd1.iso</code><br>下载地址：<a href="http://mirrors.163.com/centos/8.3.2011/isos/x86/_64/CentOS-8.3.2011-x86/_64-minimal.iso">http://mirrors.163.com/centos/8.3.2011/isos/x86\_64/CentOS-8.3.2011-x86\_64-minimal.iso</a></li>
<li>U盘16G</li>
<li>工具UltralISO<br>破解版下载地址：<a href="https://pan.baidu.com/s/1P5f__-V-gdP656zrXYMF-A">百度云</a><br>提取码：code</li>
</ul>
<h2 id="制作U盘启动"><a href="#制作U盘启动" class="headerlink" title="制作U盘启动"></a>制作U盘启动</h2><hr>
<h4 id="1、打开UltraISO软件，选”文件”-“打开”，选择需要制作的镜像后选择”打开”；"><a href="#1、打开UltraISO软件，选”文件”-“打开”，选择需要制作的镜像后选择”打开”；" class="headerlink" title="1、打开UltraISO软件，选”文件” - “打开”，选择需要制作的镜像后选择”打开”；"></a>1、打开UltraISO软件，选”文件” - “打开”，选择需要制作的镜像后选择”打开”；</h4><p><img src="https://code404.icu/img/moveypu/2021/04/20210412173256798-1024x494.png"></p>
<h4 id="2、选”启动”，选择”写入硬盘镜像”；"><a href="#2、选”启动”，选择”写入硬盘镜像”；" class="headerlink" title="2、选”启动”，选择”写入硬盘镜像”；"></a>2、选”启动”，选择”写入硬盘镜像”；</h4><p><img src="https://code404.icu/img/moveypu/2021/04/20210412173511562.png"></p>
<h4 id="3、在硬盘驱动器中选择您需要制作的U盘，之后选”格式化”按钮。点”开始”对U盘进行格式化（提前备份好U盘数据此操作会清空U盘数据）；"><a href="#3、在硬盘驱动器中选择您需要制作的U盘，之后选”格式化”按钮。点”开始”对U盘进行格式化（提前备份好U盘数据此操作会清空U盘数据）；" class="headerlink" title="3、在硬盘驱动器中选择您需要制作的U盘，之后选”格式化”按钮。点”开始”对U盘进行格式化（提前备份好U盘数据此操作会清空U盘数据）；"></a>3、在硬盘驱动器中选择您需要制作的U盘，之后选”格式化”按钮。点”开始”对U盘进行格式化（提前备份好U盘数据此操作会清空U盘数据）；</h4><p><img src="https://code404.icu/img/moveypu/2021/04/20210412173804274.png"></p>
<h4 id="4、格式化完成后，点击”写入”，选择继续操作”是”"><a href="#4、格式化完成后，点击”写入”，选择继续操作”是”" class="headerlink" title="4、格式化完成后，点击”写入”，选择继续操作”是”"></a>4、格式化完成后，点击”写入”，选择继续操作”是”</h4><p><img src="https://code404.icu/img/moveypu/2021/04/20210412173937262.png"></p>
<h4 id="5、刻录成功关闭"><a href="#5、刻录成功关闭" class="headerlink" title="5、刻录成功关闭"></a>5、刻录成功关闭</h4><p><img src="https://code404.icu/img/moveypu/2021/04/2021041218021840.png"></p>
<h5 id="6、将下载好的CentOS-8-3-2011-x86-64-minimal-iso复制到U盘中"><a href="#6、将下载好的CentOS-8-3-2011-x86-64-minimal-iso复制到U盘中" class="headerlink" title="6、将下载好的CentOS-8.3.2011-x86_64-minimal.iso复制到U盘中"></a>6、将下载好的<code>CentOS-8.3.2011-x86_64-minimal.iso</code>复制到U盘中</h5><p><img src="https://img-blog.csdnimg.cn/20210412180449232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><h4 id="1、把U盘插入服务器usb口，选择U盘启动，我的是按F12选择，设备型号不同快捷键可能不一样，请自行查询"><a href="#1、把U盘插入服务器usb口，选择U盘启动，我的是按F12选择，设备型号不同快捷键可能不一样，请自行查询" class="headerlink" title="1、把U盘插入服务器usb口，选择U盘启动，我的是按F12选择，设备型号不同快捷键可能不一样，请自行查询"></a>1、把U盘插入服务器usb口，选择U盘启动，我的是按F12选择，设备型号不同快捷键可能不一样，请自行查询</h4><p><img src="https://img-blog.csdnimg.cn/2021041218080914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2、选择install-centos-linux-8"><a href="#2、选择install-centos-linux-8" class="headerlink" title="2、选择install centos linux 8"></a>2、选择install centos linux 8</h4><p><img src="https://img-blog.csdnimg.cn/20210412180954683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3、安装直接报错"><a href="#3、安装直接报错" class="headerlink" title="3、安装直接报错"></a>3、安装直接报错</h4><p>dracut-initqueue[1076]: Warning: dracut-initqueue timeout - starting timeout scripts<br>dracut-initqueue[1076]: Warning: dracut-initqueue timeout - starting timeout scripts<br>Warngin: &#x2F;dev&#x2F;root does not exist<br>Generating “&#x2F;run&#x2F;initramfs&#x2F;rdsosreport.txt”<br>Entering emergency mode. Exit the shell to continue.<br>Type “Journalctl” to view system logs.<br>You might want to save “&#x2F;run&#x2F;initramfs&#x2F;rdsosreport.txt” to a USB stick or &#x2F;boot<br>after mounting them and attach it to a bug report<br>dracut: &#x2F;<br><img src="https://img-blog.csdnimg.cn/20210412181102117.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210412181322404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4、部署的时候有些问题出现了dracut-initqueue-timeout"><a href="#4、部署的时候有些问题出现了dracut-initqueue-timeout" class="headerlink" title="4、部署的时候有些问题出现了dracut-initqueue timeout"></a>4、部署的时候有些问题出现了<code>dracut-initqueue timeout</code></h4><p>dracut-initqueue timeout的问题，我在网上发现是因为centos7 找不到u盘启动的盘需要我们来设置一下，下面是过程：</p>
<p>dracut:&#x2F;# cd &#x2F;dev<br>dracut:&#x2F;# ls</p>
<p>这样子你就会看到所有的设备信息，找到sdbn，n为一个数字,是你u盘所在，比如我用的是sdb4</p>
<p>dracut:&#x2F;# reboot 重启之后</p>
<p>在install页面按e键 &gt; 修改内容</p>
<p>vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd:LABEL&#x3D;CentOS\x207\x20x86_64.check quiet<br>vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd:&#x2F;dev&#x2F;sdb4 quiet</p>
<p>然后按Ctrl+x就好了。</p>
<h4 id="5、启动完进入图形安装界面"><a href="#5、启动完进入图形安装界面" class="headerlink" title="5、启动完进入图形安装界面"></a>5、启动完进入图形安装界面</h4><p><strong>选择语言</strong><br><img src="https://img-blog.csdnimg.cn/20210412211037813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>下一步进入系统配置<code>一个坑，没有网就无法设置安装源，原dvd1的镜像8G多，无法拷贝到FAT32的U盘内</code></strong></p>
<ul>
<li>没网的情况下，可以将mini版镜像，做为安装源<br><img src="https://img-blog.csdnimg.cn/20210413081822581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>有网就可以直接设置 阿里的源 mirrors.aliyun.com&#x2F;centos&#x2F;8&#x2F;BaseOS&#x2F;x86_64&#x2F;os<img src="https://img-blog.csdnimg.cn/2021041308232174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>配置完成后进行安装</strong><br><img src="https://img-blog.csdnimg.cn/20210413082445389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>等待安装完成 重启</strong></li>
</ul>
<p>已上就是CentOS8系统安装过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>centos8</tag>
        <tag>U盘启动Centos</tag>
        <tag>U盘安装</tag>
        <tag>系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS升级内核版本_linux升级内核版本_Redhat升级内核版本</title>
    <url>/2021/04/10/centos%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC-linux%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC-redhat%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>CentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定<br>我们使用ELRepo做内核升级，这是用于Enterprise Linux软件包的RPM存储库。ELRepo支持Red Hat Enterprise Linux（RHEL）及其衍生版本（Scientific Linux，CentOS等）。<br>ELRepo项目专注于与硬件相关的软件包，以增强您使用Enterprise Linux的体验。这包括文件系统驱动程序，图形驱动程序，网络驱动程序，声音驱动程序，网络摄像头和视频驱动程序。</p>
<h3 id="安装yum源"><a href="#安装yum源" class="headerlink" title="安装yum源"></a>安装yum源</h3><hr>
<h6 id="导入公钥："><a href="#导入公钥：" class="headerlink" title="导入公钥："></a>导入公钥：</h6><p>[root@localhost yum.repos.d]# rpm –import <a href="https://www.elrepo.org/RPM-GPG-KEY-elrepo.org">https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a></p>
<p><strong>服务器没有联网的情况下，可以把公钥文件下载下来，传到服务器上执行</strong></p>
<p>[root@localhost yum.repos.d]# rpm –import RPM-GPG-KEY-elrepo.org<br>[root@localhost yum.repos.d]# cat &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-elrepo.org<br>—–BEGIN PGP PUBLIC KEY BLOCK—–<br>Version: GnuPG v1.4.5 (GNU&#x2F;Linux)</p>
<p>mQGiBEm+&#x2F;6QRBAC5mbtqOFSQ0FkTLIMdIoqxtraIeUqwbPp3IBYQ&#x2F;u&#x2F;EREjyEf1D<br>qFyBEXII0dD8JDT85vRZ81jhB7nFWa0VbUfY0xfghkbnokiNBVNpiQcvszw3UYDF<br>aLAaOC8Z98vmlsQaBBTQG6704ZXLr7FJyG3GP5WE6egXIQQbrMcdmCoRBwCg&#x2F;dwC<br>HLWjuemoDc5SX7hKHbB4zZ8D&#x2F;jP+oMbqz+bDn8OZ2UuaGdxr+mHW8tzTdPjnEU8e<br>hUt1ws8eBqn&#x2F;gMfKvUBa8xFSILe8Ty99u+VjFbcRsdf0H6dRre9AdDVUz5oxzoPw<br>gamA8mhPQvFh3wt9smtRUh5IoM2LiM1s5pGMLuYuvSnVUPArEnSfW6K5I6v7OarU<br>3WfrBACDEGGcaWKjfdkRtmKIQrzu6AnldVC1ISLVAoqxHnKNFTk1BgO0PSZDpfJI<br>x8fMCnGlusoL6F5+LYEk4K4B0zvlj1ur3JocjxpuBLccl94JTo&#x2F;+I9ZbS8ptUqLw<br>LBUkgIQJzzIH4G5NZsQ3FpzSWGRFVa7etqTv9BfUMUmJxhEoobQ&#x2F;ZWxyZXBvLm9y<br>ZyAoUlBNIFNpZ25pbmcgS2V5IGZvciBlbHJlcG8ub3JnKSA8c2VjdXJlQGVscmVw<br>by5vcmc+iGAEExECACAFAkm+&#x2F;6QCGwMGCwkIBwMCBBUCCAMEFgIDAQIeAQIXgAAK<br>CRAwm8MFuq2uUlgWAKCGWOpyodbzxS7Xy&#x2F;0X9m9qVnHq+ACfUHrQzYAtFRpT07Sg<br>giosE+mvAKu5Ag0ESb7&#x2F;pxAIALgT0q0HhwugE717a7N+gAtCbFu8pCXOZcrAnJpG<br>cMA9VWmsODZStPTxXYM2ggCMSzUnNis8pPZOPIP5C+t2IYtVjLshM4C9UiY7u5ET<br>jErWCxWmF+2QLO50K56E4qxj0wufZt9P+Ih0USUM5L2oyrQG51uj&#x2F;2v3Qq3igc8Z<br>NTtmEOfis3losusQbAfZtTBmNQ0570kkhMxiyavgAUxLenXHYrkDJFuL7XdBCmna<br>kykTn2dzU81rIDZ+QPxII4V&#x2F;eZ5xGiRY&#x2F;EDUIAysEV2m0NNZgWi&#x2F;twUnZICm7zYp<br>VRviJrBnFTvNEPMhiGRnJgQp&#x2F;Krv4WIHQ67N8lQg3q5RJX8AAwUH&#x2F;0UBjBgbsuWR<br>dB+ZYWjKPBy+bJY&#x2F;6HefPUuLrt3QDNINMW8kY7VzWRMWyGc4IlPJDW0nwOn&#x2F;vT5H<br>Dgc3YmA3tm7cKj5wpFijzff61Db8eq+CUKGscKxDBGzHq6oirM5U7DQLmipCs5Eb<br>efwHIjE3aOUSnoQmniEnBWI2hm&#x2F;rftmY9oJSi8xgns4wAokDPiMcucADtbV3fznx<br>ppuowtBi8bcGB1vJZjTySQcSKWv+IVp5ej06uZ9501BEm6HxUZkuAGPecP65kcQu<br>5bg7B7LQeI5AWyujqvfuWgAF34xhl9QU&#x2F;sDWxM3wUog+bw7y8pyWCqnJhp70yx8o<br>SqzhFygT62eISQQYEQIACQUCSb7&#x2F;pwIbDAAKCRAwm8MFuq2uUq8PAKC1+E2pSwiS<br>oHXkKYPYDwApsP1mVACfRe1YnggLYQtG9LMeweVQQC77rK8&#x3D;<br>&#x3D;qyRr<br>—–END PGP PUBLIC KEY BLOCK—–</p>
<h6 id="安装ELRepo-Yum源"><a href="#安装ELRepo-Yum源" class="headerlink" title="安装ELRepo Yum源"></a>安装ELRepo Yum源</h6><ul>
<li>系统版本 RHEL-8 or CentOS-8 请安装</li>
</ul>
<p>yum install <a href="https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm">https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm</a></p>
<ul>
<li>系统版本 RHEL-7, SL-7 or CentOS-7 请安装</li>
</ul>
<p>yum install <a href="https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm">https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</a></p>
<h2 id="安装Linux内核"><a href="#安装Linux内核" class="headerlink" title="安装Linux内核"></a>安装Linux内核</h2><hr>
<h6 id="查找可供安装的内核版本"><a href="#查找可供安装的内核版本" class="headerlink" title="查找可供安装的内核版本"></a>查找可供安装的内核版本</h6><p>[root@localhost yum.repos.d]# yum –disablerepo&#x3D;\* –enablerepo&#x3D;elrepo-kernel list kernel*<br>已加载插件：fastestmirror<br>Loading mirror speeds from cached hostfile<br> * elrepo-kernel: mirrors.tuna.tsinghua.edu.cn<br>已安装的软件包<br>kernel.x86_64                                                                                  3.10.0-1160.el7                                                                   @anaconda<br>kernel-headers.x86_64                                                                          3.10.0-1160.15.2.el7                                                              @updates<br>kernel-lt.x86_64                                                                               5.4.109-1.el7.elrepo                                                              @elrepo-kernel<br>kernel-tools.x86_64                                                                            3.10.0-1160.el7                                                                   @anaconda<br>kernel-tools-libs.x86_64                                                                       3.10.0-1160.el7                                                                   @anaconda<br>可安装的软件包<br>kernel-lt.x86_64                                                                               5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-lt-devel.x86_64                                                                         5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-lt-doc.noarch                                                                           5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-lt-headers.x86_64                                                                       5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-lt-tools.x86_64                                                                         5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-lt-tools-libs.x86_64                                                                    5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-lt-tools-libs-devel.x86_64                                                              5.4.110-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml.x86_64                                                                               5.11.12-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml-devel.x86_64                                                                         5.11.12-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml-doc.noarch                                                                           5.11.12-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml-headers.x86_64                                                                       5.11.12-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml-tools.x86_64                                                                         5.11.12-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml-tools-libs.x86_64                                                                    5.11.12-1.el7.elrepo                                                              elrepo-kernel<br>kernel-ml-tools-libs-devel.x86_64                                                              5.11.12-1.el7.elrepo                                                              elrepo-kernel </p>
<p><strong>这里的kernel-lt,kernel-ml解释一下</strong></p>
<ul>
<li>kernel-ml 中的ml是英文【mainline stable】的缩写，elrepo-kernel中罗列出来的是最新的稳定主线版本。</li>
<li>kernel-lt 中的lt是英文【long term support】的缩写，elrepo-kernel中罗列出来的长期支持版本。</li>
</ul>
<p><strong>不联网离线的情况下，找一台能上网上服务器，或者本地安装虚拟机下载离线安装包</strong></p>
<p>下载地址：<a href="https://elrepo.org/linux/kernel/">https://elrepo.org/linux/kernel/</a></p>
<p>[root@localhost ~]# wget <a href="https://elrepo.org/linux/kernel/el7/x86/_64/RPMS/kernel-lt-5.4.110-1.el7.elrepo.x86/_64.rpm">https://elrepo.org/linux/kernel/el7/x86\_64/RPMS/kernel-lt-5.4.110-1.el7.elrepo.x86\_64.rpm</a><br>–2021-04-09 18:56:54–  <a href="https://elrepo.org/linux/kernel/el7/x86/_64/RPMS/kernel-lt-5.4.110-1.el7.elrepo.x86/_64.rpm">https://elrepo.org/linux/kernel/el7/x86\_64/RPMS/kernel-lt-5.4.110-1.el7.elrepo.x86\_64.rpm</a><br>正在解析主机 elrepo.org (elrepo.org)… 69.195.83.87<br>正在连接 elrepo.org (elrepo.org)69.195.83.87:443… 已连接。<br>已发出 HTTP 请求，正在等待回应… 200 OK<br>长度：52405420 (50M)<br>正在保存至: “kernel-lt-5.4.110-1.el7.elrepo.x86_64.rpm”</p>
<p>100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 52,405,420  4.87MB&#x2F;s 用时 31s    </p>
<p>2021-04-09 18:57:25 (1.63 MB&#x2F;s) - 已保存 “kernel-lt-5.4.110-1.el7.elrepo.x86_64.rpm” [52405420&#x2F;52405420])</p>
<p>[root@localhost ~]# </p>
<h6 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h6><p>[root@localhost yum.repos.d]# yum –enablerepo&#x3D;elrepo-kernel install -y kernel-lt<br>已加载插件：fastestmirror<br>Loading mirror speeds from cached hostfile<br> * elrepo: mirrors.neusoft.edu.cn<br> * elrepo-kernel: mirrors.neusoft.edu.cn<br>file:&#x2F;&#x2F;&#x2F;yumrepo&#x2F;repodata&#x2F;repomd.xml: [Errno 14] curl#37 - “Couldn’t open file &#x2F;yumrepo&#x2F;repodata&#x2F;repomd.xml”<br>正在尝试其它镜像。<br>正在解决依赖关系<br>–&gt; 正在检查事务<br>—&gt; 软件包 kernel-lt.x86_64.0.5.4.110-1.el7.elrepo 将被 安装<br>–&gt; 解决依赖关系完成</p>
<p>依赖关系解决</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> Package                                    架构                                    版本                                                  源                                              大小<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>正在安装:<br> kernel-lt                                  x86_64                                  5.4.110-1.el7.elrepo                                  elrepo-kernel                                   50 M</p>
<h1 id="事务概要"><a href="#事务概要" class="headerlink" title="事务概要"></a>事务概要</h1><p>安装  1 软件包</p>
<p>总下载量：50 M<br>安装大小：227 M<br>Downloading packages:<br>kernel-lt-5.4.110-1.el7.elrepo.x86_64.rpm                                                                                                                                 50 MB  00:00:44<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>警告：RPM 数据库已被非 yum 程序修改。<br>  正在安装    : kernel-lt-5.4.110-1.el7.elrepo.x86_64                                                                                                                                      1&#x2F;1<br>  验证中      : kernel-lt-5.4.110-1.el7.elrepo.x86_64                                                                                                                                      1&#x2F;1 </p>
<p>已安装:<br>  kernel-lt.x86_64 0:5.4.110-1.el7.elrepo                                                                                                                                                      </p>
<p>完毕！<br>[root@localhost yum.repos.d]# </p>
<p><strong>上面下载好了安装包，也可以离线安装</strong></p>
<p>[root@localhost ~]# yum localinstall kernel-lt-5.4.110-1.el7.elrepo.x86_64.rpm<br>已加载插件：fastestmirror, product-id, search-disabled-repos<br>正在检查 kernel-lt-5.4.110-1.el7.elrepo.x86_64.rpm: kernel-lt-5.4.110-1.el7.elrepo.x86_64<br>kernel-lt-5.4.110-1.el7.elrepo.x86_64.rpm 将被安装<br>正在解决依赖关系<br>–&gt; 正在检查事务<br>—&gt; 软件包 kernel-lt.x86_64.0.5.4.110-1.el7.elrepo 将被 安装<br>–&gt; 解决依赖关系完成</p>
<p>依赖关系解决</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> Package                             架构                             版本                                              源                                                                大小<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>正在安装:<br> kernel-lt                           x86_64                           5.4.110-1.el7.elrepo                              &#x2F;kernel-lt-5.4.110-1.el7.elrepo.x86_64                           227 M</p>
<h1 id="事务概要-1"><a href="#事务概要-1" class="headerlink" title="事务概要"></a>事务概要</h1><p>安装  1 软件包</p>
<p>总计：227 M<br>安装大小：227 M<br>Is this ok [y&#x2F;d&#x2F;N]: y<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在安装    : kernel-lt-5.4.110-1.el7.elrepo.x86_64                                                                                                                                      1&#x2F;1<br>  验证中      : kernel-lt-5.4.110-1.el7.elrepo.x86_64                                                                                                                                      1&#x2F;1 </p>
<p>已安装:<br>  kernel-lt.x86_64 0:5.4.110-1.el7.elrepo                                                                                                                                                      </p>
<p>完毕！</p>
<h2 id="检查内核是否已安装"><a href="#检查内核是否已安装" class="headerlink" title="检查内核是否已安装"></a>检查内核是否已安装</h2><hr>
<p>[root@localhost ~]#  grep ^menuentry &#x2F;boot&#x2F;grub2&#x2F;grub.cfg  cut -d “‘“ -f2<br>CentOS Linux (5.4.110-1.el7.elrepo.x86_64) 7 (Core)<br>CentOS Linux (5.4.109-1.el7.elrepo.x86_64) 7 (Core)<br>CentOS Linux (3.10.0-1160.el7.x86_64) 7 (Core)<br>CentOS Linux (0-rescue-002e2c6979394d74a83b99811a2280c1) 7 (Core)</p>
<p><em>参考上面配置 <strong>kernel-lt-5.4.110-1</strong> 已经成功安装</em></p>
<h2 id="设置系统内核默认启动项"><a href="#设置系统内核默认启动项" class="headerlink" title="设置系统内核默认启动项"></a>设置系统内核默认启动项</h2><hr>
<h6 id="查看系统内核默认启动项"><a href="#查看系统内核默认启动项" class="headerlink" title="查看系统内核默认启动项"></a>查看系统内核默认启动项</h6><p>[root@localhost ~]# grub2-editenv list<br>saved_entry&#x3D;CentOS Linux (5.4.109-1.el7.elrepo.x86_64) 7 (Core)</p>
<h6 id="修改系统内核启动项"><a href="#修改系统内核启动项" class="headerlink" title="修改系统内核启动项"></a>修改系统内核启动项</h6><p>[root@localhost ~]# grub2-set-default ‘CentOS Linux (5.4.110-1.el7.elrepo.x86_64) 7 (Core)’<br>[root@localhost ~]# grub2-editenv list<br>saved_entry&#x3D;CentOS Linux (5.4.110-1.el7.elrepo.x86_64) 7 (Core)</p>
<p><em>参考上面输出内容 此时，操作系统使用的内核已升级为<strong>5.4.110-1.el7.elrepo.x86_64</strong></em></p>
<h2 id="最后一步，需要将内核工具包一并升级"><a href="#最后一步，需要将内核工具包一并升级" class="headerlink" title="最后一步，需要将内核工具包一并升级"></a>最后一步，需要将内核工具包一并升级</h2><hr>
<h6 id="删除旧版本工具包"><a href="#删除旧版本工具包" class="headerlink" title="删除旧版本工具包"></a>删除旧版本工具包</h6><p>[root@localhost ~]# yum remove kernel-tools-libs<br>已加载插件：fastestmirror<br>正在解决依赖关系<br>–&gt; 正在检查事务<br>—&gt; 软件包 kernel-tools-libs.x86_64.0.3.10.0-1160.el7 将被 删除<br>–&gt; 正在处理依赖关系 kernel-tools-libs &#x3D; 3.10.0-1160.el7，它被软件包 kernel-tools-3.10.0-1160.el7.x86_64 需要<br>–&gt; 正在处理依赖关系 libcpupower.so.0()(64bit)，它被软件包 kernel-tools-3.10.0-1160.el7.x86_64 需要<br>–&gt; 正在检查事务<br>—&gt; 软件包 kernel-tools.x86_64.0.3.10.0-1160.el7 将被 删除<br>–&gt; 解决依赖关系完成</p>
<p>依赖关系解决</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> Package                                            架构                                    版本                                              源                                          大小<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>正在删除:<br> kernel-tools-libs                                  x86_64                                  3.10.0-1160.el7                                   @anaconda                                   18 k<br>为依赖而移除:<br> kernel-tools                                       x86_64                                  3.10.0-1160.el7                                   @anaconda                                  337 k</p>
<h1 id="事务概要-2"><a href="#事务概要-2" class="headerlink" title="事务概要"></a>事务概要</h1><p>移除  1 软件包 (+1 依赖软件包)</p>
<p>安装大小：355 k<br>是否继续？[y&#x2F;N]：y<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在删除    : kernel-tools-3.10.0-1160.el7.x86_64                                                                                                                                        1&#x2F;2<br>  正在删除    : kernel-tools-libs-3.10.0-1160.el7.x86_64                                                                                                                                   2&#x2F;2<br>  验证中      : kernel-tools-3.10.0-1160.el7.x86_64                                                                                                                                        1&#x2F;2<br>  验证中      : kernel-tools-libs-3.10.0-1160.el7.x86_64                                                                                                                                   2&#x2F;2 </p>
<p>删除:<br>  kernel-tools-libs.x86_64 0:3.10.0-1160.el7                                                                                                                                                   </p>
<p>作为依赖被删除:<br>  kernel-tools.x86_64 0:3.10.0-1160.el7                                                                                                                                                        </p>
<p>完毕！<br>[root@localhost ~]# </p>
<h6 id="安装新版本工具包"><a href="#安装新版本工具包" class="headerlink" title="安装新版本工具包"></a>安装新版本工具包</h6><p>[root@localhost ~]# yum –disablerepo&#x3D;\* –enablerepo&#x3D;elrepo-kernel install -y kernel-lt-tools<br>已加载插件：fastestmirror<br>Loading mirror speeds from cached hostfile<br> * elrepo-kernel: mirror-hk.koddos.net<br>正在解决依赖关系<br>–&gt; 正在检查事务<br>—&gt; 软件包 kernel-lt-tools.x86_64.0.5.4.110-1.el7.elrepo 将被 安装<br>–&gt; 正在处理依赖关系 kernel-lt-tools-libs &#x3D; 5.4.110-1.el7.elrepo，它被软件包 kernel-lt-tools-5.4.110-1.el7.elrepo.x86_64 需要<br>–&gt; 正在处理依赖关系 libcpupower.so.0()(64bit)，它被软件包 kernel-lt-tools-5.4.110-1.el7.elrepo.x86_64 需要<br>–&gt; 正在检查事务<br>—&gt; 软件包 kernel-lt-tools-libs.x86_64.0.5.4.110-1.el7.elrepo 将被 安装<br>–&gt; 解决依赖关系完成</p>
<p>依赖关系解决</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> Package                                            架构                                 版本                                                源                                           大小<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>正在安装:<br> kernel-lt-tools                                    x86_64                               5.4.110-1.el7.elrepo                                elrepo-kernel                               202 k<br>为依赖而安装:<br> kernel-lt-tools-libs                               x86_64                               5.4.110-1.el7.elrepo                                elrepo-kernel                                91 k</p>
<h1 id="事务概要-3"><a href="#事务概要-3" class="headerlink" title="事务概要"></a>事务概要</h1><p>安装  1 软件包 (+1 依赖软件包)</p>
<p>总下载量：293 k<br>安装大小：486 k<br>Downloading packages:<br>(1&#x2F;2): kernel-lt-tools-5.4.110-1.el7.elrepo.x86_64.rpm                                                                                                                   202 kB  00:00:00<br>(2&#x2F;2): kernel-lt-tools-libs-5.4.110-1.el7.elrepo.x86_64.rpm                                                                                                               91 kB  00:00:00     </p>
<hr>
<p>总计                                                                                                                                                           312 kB&#x2F;s  293 kB  00:00:00<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在安装    : kernel-lt-tools-libs-5.4.110-1.el7.elrepo.x86_64                                                                                                                           1&#x2F;2<br>  正在安装    : kernel-lt-tools-5.4.110-1.el7.elrepo.x86_64                                                                                                                                2&#x2F;2<br>  验证中      : kernel-lt-tools-5.4.110-1.el7.elrepo.x86_64                                                                                                                                1&#x2F;2<br>  验证中      : kernel-lt-tools-libs-5.4.110-1.el7.elrepo.x86_64                                                                                                                           2&#x2F;2 </p>
<p>已安装:<br>  kernel-lt-tools.x86_64 0:5.4.110-1.el7.elrepo                                                                                                                                                </p>
<p>作为依赖被安装:<br>  kernel-lt-tools-libs.x86_64 0:5.4.110-1.el7.elrepo                                                                                                                                           </p>
<p>完毕！</p>
<h2 id="重启，选择新版本内核进入系统"><a href="#重启，选择新版本内核进入系统" class="headerlink" title="重启，选择新版本内核进入系统"></a>重启，选择新版本内核进入系统</h2><p><img src="https://code404.icu/img/moveypu/2021/04/2021040911291197.png"></p>
<h6 id="启动成功查看内核版本"><a href="#启动成功查看内核版本" class="headerlink" title="启动成功查看内核版本"></a>启动成功查看内核版本</h6><p>[root@localhost ~]# grub2-editenv list<br>saved_entry&#x3D;CentOS Linux (5.4.110-1.el7.elrepo.x86_64) 7 (Core)</p>
<p>已上就是升级内核版本过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos7</tag>
        <tag>内核升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos系统上搭建_unbound_dns_服务器搭建_DNS服务器搭建</title>
    <url>/2021/07/12/centos%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%90%AD%E5%BB%BA-unbound-dns-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-dns%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-39.png"></p>
<h3 id="unbound介绍"><a href="#unbound介绍" class="headerlink" title="unbound介绍"></a>unbound介绍</h3><hr>
<p>实现DNS的软件 unbound (貌似bind更强大)<br>unbound是红帽公司推荐的DNS软件<br>Unbound已经取代Berkeley internetnamedomain（BIND）成为几个开源项目中的默认基本系统名称服务器，在这些项目中，它被认为是更小、更现代、更安全的应用程序。</p>
<h3 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h3><hr>
<p>centos7.6,rsync.x86_64 0:3.1.2-6.el7_6.1<br>Red Hat Enterprise Linux Server release 7.4 (Maipo)</p>
<h3 id="解析说明"><a href="#解析说明" class="headerlink" title="解析说明"></a>解析说明</h3><hr>
<p>DNS服务器有多种软件可以实现，这次用的是unbound简单的使用介绍<br>unbound配置文件：&#x2F;etc&#x2F;unbound&#x2F;unbound.conf<br>DNS解析文件为：&#x2F;etc&#x2F;unbound&#x2F;local.d&#x2F;*.conf<br>本机DNS解析地址：&#x2F;etc&#x2F;resolv.conf</p>
<h3 id="服务端的安装设置"><a href="#服务端的安装设置" class="headerlink" title="服务端的安装设置"></a>服务端的安装设置</h3><hr>
<ol>
<li>安装unbound服务软件<br>yum install unbound</li>
</ol>
<p>[root@unbound ~]# yum install unbound<br>Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager<br>This system is not registered with an entitlement server. You can use subscription-manager to register.<br>Resolving Dependencies<br>–&gt; Running transaction check<br>—&gt; Package unbound.x86_64 0:1.6.6-5.el7_8 will be installed<br>–&gt; Processing Dependency: unbound-libs(x86-64) &#x3D; 1.6.6-5.el7_8 for package: unbound-1.6.6-5.el7_8.x86_64<br>–&gt; Running transaction check<br>—&gt; Package unbound-libs.x86_64 0:1.4.20-34.el7 will be updated<br>—&gt; Package unbound-libs.x86_64 0:1.6.6-5.el7_8 will be an update<br>–&gt; Finished Dependency Resolution<br>y<br>Dependencies Resolved<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> Package                                                     Arch                                                  Version                                                        Repository                                           Size<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>Installing:<br> unbound                                                     x86_64                                                1.6.6-5.el7_8                                                  base                                                674 k<br>Updating for dependencies:<br> unbound-libs                                                x86_64                                                1.6.6-5.el7_8                                                  base                                                406 k</p>
<h1 id="Transaction-Summary"><a href="#Transaction-Summary" class="headerlink" title="Transaction Summary"></a>Transaction Summary</h1><p>Install  1 Package<br>Upgrade             ( 1 Dependent package)</p>
<p>Total size: 1.1 M<br>Total download size: 674 k<br>Is this ok [y&#x2F;d&#x2F;N]:<br>Downloading packages:<br>unbound-1.6.6-5.el7_8.x86_64.rpm                                                                                                                                                                                      674 kB  00:00:00<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  Updating   : unbound-libs-1.6.6-5.el7_8.x86_64                                                                                                                                                                                        1&#x2F;3<br>  Installing : unbound-1.6.6-5.el7_8.x86_64 [                                                                                                                                                                                         ] 2&#x2F;3<br>  Installing : unbound-1.6.6-5.el7_8.x86_64                                                                                                                                                                                             2&#x2F;3<br>  Cleanup    : unbound-libs-1.4.20-34.el7.x86_64                                                                                                                                                                                        3&#x2F;3<br>  Verifying  : unbound-libs-1.6.6-5.el7_8.x86_64                                                                                                                                                                                        1&#x2F;3<br>  Verifying  : unbound-1.6.6-5.el7_8.x86_64                                                                                                                                                                                             2&#x2F;3<br>  Verifying  : unbound-libs-1.4.20-34.el7.x86_64                                                                                                                                                                                        3&#x2F;3<br>Installed:<br>  unbound.x86_64 0:1.6.6-5.el7_8<br>Dependency Updated:<br>  unbound-libs.x86_64 0:1.6.6-5.el7_8<br>Complete!</p>
<ol start="2">
<li>启动unbound服务，并设置开机自启</li>
</ol>
<p>[root@unbound ~]# systemctl start unbound<br>[root@unbound ~]#<br>[root@unbound ~]# systemctl enable unbound<br>Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;unbound.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;unbound.service.</p>
<ol start="3">
<li>查看unbound状态<br>systemctl status unbound</li>
</ol>
<p>[root@unbound ~]# systemctl status unbound<br>● unbound.service - Unbound recursive Domain Name Server<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;unbound.service; disabled; vendor preset: disabled)<br>   Active: active (running) since Fri 2021-07-09 15:55:58 CST; 21s ago<br>  Process: 21173 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;unbound-anchor -a &#x2F;var&#x2F;lib&#x2F;unbound&#x2F;root.key -c &#x2F;etc&#x2F;unbound&#x2F;icannbundle.pem (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br>  Process: 21171 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;unbound-checkconf (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br> Main PID: 21188 (unbound)<br>   CGroup: &#x2F;system.slice&#x2F;unbound.service<br>           └─21188 &#x2F;usr&#x2F;sbin&#x2F;unbound -d</p>
<p>Jul 09 15:55:08 host-192-168-65-94 systemd[1]: Starting Unbound recursive Domain Name Server…<br>Jul 09 15:55:08 host-192-168-65-94 unbound-checkconf[21171]: unbound-checkconf: no errors in &#x2F;etc&#x2F;unbound&#x2F;unbound.conf<br>Jul 09 15:55:58 host-192-168-65-94 systemd[1]: Started Unbound recursive Domain Name Server.<br>Jul 09 15:55:58 host-192-168-65-94 unbound[21188]: [21188:0] notice: init module 0: ipsecmod<br>Jul 09 15:55:58 host-192-168-65-94 unbound[21188]: [21188:0] notice: init module 1: validator<br>Jul 09 15:55:58 host-192-168-65-94 unbound[21188]: [21188:0] notice: init module 2: iterator<br>Jul 09 15:55:58 host-192-168-65-94 unbound[21188]: [21188:0] info: start of service (unbound 1.6.6).</p>
<p>查看dns侦听端口<br>netstat -tunlp grep unbound</p>
<p>[root@host-192-168-65-94 ~]# netstat -tunlp  grep unbound<br>tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      21188&#x2F;unbound<br>tcp        0      0 127.0.0.1:8953          0.0.0.0:*               LISTEN      21188&#x2F;unbound<br>tcp6       0      0 ::1:53                  :::*                    LISTEN      21188&#x2F;unbound<br>tcp6       0      0 ::1:8953                :::*                    LISTEN      21188&#x2F;unbound<br>udp        0      0 127.0.0.1:53            0.0.0.0:*                           21188&#x2F;unbound<br>udp        0      0 127.0.0.1:53            0.0.0.0:*                           21188&#x2F;unbound<br>udp        0      0 127.0.0.1:53            0.0.0.0:*                           21188&#x2F;unbound<br>udp        0      0 127.0.0.1:53            0.0.0.0:*                           21188&#x2F;unbound<br>udp6       0      0 ::1:53                  :::*                                21188&#x2F;unbound<br>udp6       0      0 ::1:53                  :::*                                21188&#x2F;unbound<br>udp6       0      0 ::1:53                  :::*                                21188&#x2F;unbound<br>udp6       0      0 ::1:53                  :::*                                21188&#x2F;unbound       </p>
<ol start="4">
<li>修改配置文件 &#x2F;etc&#x2F;unbound&#x2F;unbound.conf</li>
</ol>
<p>vim &#x2F;etc&#x2F;unbound&#x2F;unbound.conf<br>#将# interface: 0.0.0.0 的注释去掉<br>interface: 0.0.0.0<br>#将# access-control: 0.0.0.0&#x2F;0 refuse 的注释去掉，并将refuse改成allow。<br>access-control: 0.0.0.0&#x2F;0 allow。<br>#保存退出</p>
<ol start="5">
<li>自己编写一个dns解析文件，注意必须是这种格式 &#x2F;etc&#x2F;unbound&#x2F;local.d&#x2F;*.conf</li>
</ol>
<p>[root@unbound~]# cat &#x2F;etc&#x2F;unbound&#x2F;local.d&#x2F;xdns.conf<br>local-zone: “code404.icu.” static<br>local-data: “code404.icu. 3600 IN SOA <a href="http://www.code404.icu/">www.code404.icu</a>. root 1 1D 1H 1W 1H”<br>local-data: “<a href="http://www.code404.icu.in/">www.code404.icu.IN</a> A 192.168.65.94”<br>local-data-ptr: “192.168.65.94 <a href="http://www.code404.icu.&quot;/">www.code404.icu.&quot;</a><br>local-data-ptr: “192.168.65.94 <a href="http://www.code404.icu.&quot;/">www.code404.icu.&quot;</a></p>
<ol start="6">
<li>重启dns服务</li>
</ol>
<p>[root@unbound ~]# systemctl restart unbound</p>
<h3 id="验证ping-刚定义好的域名www-code404-icu"><a href="#验证ping-刚定义好的域名www-code404-icu" class="headerlink" title="验证ping 刚定义好的域名www.code404.icu"></a>验证ping 刚定义好的域名<a href="http://www.code404.icu/">www.code404.icu</a></h3><hr>
<p>[root@unbound ~]# ping <a href="http://www.code404.icu/">www.code404.icu</a><br>ping: <a href="http://www.code404.icu/">www.code404.icu</a>: Name or service not known</p>
<p>哎哟我去，几个意思，报错了？<br>赶紧看看dns状态<br>systemctl status unbound</p>
<p>[root@unbound ~]# systemctl status unbound<br>● unbound.service - Unbound recursive Domain Name Server<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;unbound.service; enabled; vendor preset: disabled)<br>   Active: failed (Result: exit-code) since Wed 2019-09-04 07:29:56 PDT; 2min 3s ago<br>  Process: 17994 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;unbound -d $UNBOUND_OPTIONS (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)<br>  Process: 17983 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;unbound-anchor -a &#x2F;var&#x2F;lib&#x2F;unbound&#x2F;root.key -c &#x2F;etc&#x2F;unbound&#x2F;icannbundle.pem (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br>  Process: 17980 ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;unbound-checkconf (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br> Main PID: 17994 (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)</p>
<p>Sep 04 07:29:55 unbound systemd[1]: Starting Unbound recursive Domain Name Server…<br>Sep 04 07:29:55 unbound unbound-checkconf[17980]: unbound-checkconf: no errors in &#x2F;etc&#x2F;unbound&#x2F;unbound.conf<br>Sep 04 07:29:56 unbound systemd[1]: Started Unbound recursive Domain Name Server.<br>Sep 04 07:29:56 unbound unbound[17994]: Sep 04 07:29:56 unbound[17994:0] error: can’t bind socket: Address already in use for 0.0.0.0<br>Sep 04 07:29:56 unbound unbound[17994]: Sep 04 07:29:56 unbound[17994:0] fatal error: could not open ports<br>Sep 04 07:29:56 unbound systemd[1]: unbound.service: main process exited, code&#x3D;exited, status&#x3D;1&#x2F;FAILURE<br>Sep 04 07:29:56 unbound systemd[1]: Unit unbound.service entered failed state.<br>Sep 04 07:29:56 unbound systemd[1]: unbound.service failed.</p>
<p>哎哟我去，unbound服务竟然没启动？<br>再看看dns的53端口是啥情况</p>
<p>[root@unbound ~]# netstat -ntulp  grep 53</p>
<p>此时就感觉好奇怪，unbound服务命名是失败的，为啥还有53端口开启呢？这非常不科学。<br>百度了一把找到答案了，把dns进程先干掉，再开启unbound服务即可。</p>
<p>[root@unbound ~]# kill -9 8589</p>
<p>再启动unbound服务，发现unbound状态就变成了active(running)了，</p>
<p>[root@unbound ~]# systemctl start unbound<br>[root@unbound ~]# systemctl status unbound</p>
<p>再去ping <a href="http://www.code404.icu还不行,我去这更诡异了.这玩意跟windows/">www.code404.icu还不行，我去这更诡异了。这玩意跟windows</a> dns一个尿性，本机的dns都还没改，怎么能ping通呢，于是乎赶紧去改一下解析文件,把dns地址改成本机ip。</p>
<p>[root@unbound ~]# vim &#x2F;etc&#x2F;resolv.conf<br>nameserver 192.168.65.94</p>
<p>第三次ping <a href="http://www.code404.icu/">www.code404.icu</a> 终于ok了。至于添加其他主机的dns，就可以照葫芦画瓢往配置文件里加就行了。有一点要注意啊，其他主机的dns指向必须指向这次配置的unbound主机才行。</p>
<p>至此简单的unbound服务器（dns）就搭建完成了</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>unbound</tag>
      </tags>
  </entry>
  <entry>
    <title>CNCF × Alibaba 云原生技术公开课</title>
    <url>/2021/03/25/cncf-x-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/</url>
    <content><![CDATA[<p><strong>云原生最初来描述云上应用的典型架构与特性，近几年，容器、kubernetes、Serverless、FaaS这些为云设计的基础软件与资源模型重新定义着云上的最佳实践，云原生的概念也不断演进，CNCF（云原生计算基金会）在这个背景下创立，它把云原生的概念更广泛地定义为“让应用更有弹性、容错性、观测性的基础技术，让应用更容易部署、管理的基础软件、让应用更容易编写、编排的运行框架等”，希望能够让用户最好的利用云的资源、产品和交付能力。</strong></p>
<p>本课程由阿里云和CNCF联合开发，课程全程免费。</p>
<h1 id="我们将为您带来"><a href="#我们将为您带来" class="headerlink" title="我们将为您带来"></a>我们将为您带来</h1><ul>
<li>完善的知识体系，打造属于自己的云原生技术树</li>
<li>理解云原生技术背后的思想与本质</li>
<li>与知识体系相辅相成的动手实践</li>
<li>一线技术团队云原生技术最佳实践</li>
</ul>
<h1 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h1><ul>
<li>计算机科学、软件工程等领域的软件工程师和大学生</li>
<li>使用&#x2F;尝试使用容器和Kubernetes技术的应用程序开发者</li>
<li>具有基本服务器端知识、正在探索容器技术的软件开发者和技术管理者</li>
<li>希望理解云原生技术栈基本原理的技术管理者和开发者</li>
</ul>
<h1 id="课时列表"><a href="#课时列表" class="headerlink" title="课时列表"></a>课时列表</h1><h2 id="阶段1：云原生技术基础"><a href="#阶段1：云原生技术基础" class="headerlink" title="阶段1：云原生技术基础"></a>阶段1：云原生技术基础</h2><p><strong>课程列表</strong></p>
<p><strong>学习收益</strong></p>
<p>第1讲：第一堂“云原生”课</p>
<p>了解云原生的概念、本质、主流技术等</p>
<p>第2讲：容器基本概念</p>
<p>掌握容器、容器镜像、容器数据卷等基本概念</p>
<p>第3讲：Kubernetes 核心概念</p>
<p>理解Kubernetes的架构、Kubernetes API原语、集群与部署、Service等概念与基本操作。</p>
<p>第4讲：理解 Pod 和容器设计模式</p>
<p>理解Pod和容器设计模式，如Ambassador、adapter、sidecar等</p>
<p>第5讲：应用编排与管理：核心原理</p>
<p>理解Labels、Selectors、Annotations，以及Kubernetes的核心——控制器模式</p>
<p>第6讲：应用编排与管理： Deployment</p>
<p>掌握Deployment的基础使用，了解应用的水平扩展、滚动更新和回滚</p>
<p>第7讲：应用编排与管理：Job 和 DaemonSet</p>
<p>掌握Job、CronJob和DaemonSet的使用</p>
<p>第8讲：应用配置管理</p>
<p>理解ConfigMaps、SecurityContexts、ServiceAccounts，以及掌握如何定义应用的资源需求、创建和使用Secret等</p>
<p>第9讲：应用存储和持久化数据卷 - 核心知识</p>
<p>理解PersistentVolume、PersistentVolumeClaim、StorageClass的基本概念、操作使用，以及内部工作机制</p>
<h2 id="阶段2：云原生技术进阶"><a href="#阶段2：云原生技术进阶" class="headerlink" title="阶段2：云原生技术进阶"></a>阶段2：云原生技术进阶</h2><p><strong>课程列表</strong></p>
<p><strong>学习收益</strong></p>
<p>第15讲：深入剖析 Linux 容器</p>
<p>理解隔离、资源边界的概念，以及容器镜像的本质、容器数据卷的实现方式等</p>
<p>第16讲：深入理解 etcd - 基本原理解析</p>
<p>理解etcd的核心设计思想</p>
<p>第17讲：深入理解 etcd - etcd性能优化实践</p>
<p>理解etcd性能，以及server端和client端性能优化方法。</p>
<p>第18讲：Kubernetes 调度和资源管理</p>
<p>理解Kubernetes资源模型requests和limits，以及调度工作原理、配置和扩展调度器</p>
<p>第19讲：调度器的调度流程和算法介绍</p>
<p>理解调度流程和调度算法，掌握配置调度器和扩展调度器的方法</p>
<p>第20讲：GPU管理和Device Plugin工作机制</p>
<p>理解GPU管理机制和Device Plugin的工作机制</p>
<p>第21讲：Kubernetes存储架构及插件使用</p>
<p>理解持久化存储体系，掌握Flexvolume和CSI的使用</p>
<p>第22讲：有状态应用编排：StatefulSet</p>
<p>掌握StatefulSet的使用，理解HeadlessService和PVC保持应用状态的原理</p>
<p>第23讲：Kubernetes API编程范式</p>
<p>掌握自定义API资源CRD和自定义控制器CustomController的使用</p>
<h1 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接:"></a>课程链接:</h1><p>[reply] 课程链接：<a href="https://edu.aliyun.com/roadmap/cloudnative">https://edu.aliyun.com/roadmap/cloudnative</a> [&#x2F;reply]</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>FaaS</tag>
        <tag>Kubernetes</tag>
        <tag>云原生</tag>
        <tag>容器</tag>
        <tag>资源编排</tag>
      </tags>
  </entry>
  <entry>
    <title>confluence-wiki-jire安装破解</title>
    <url>/2021/07/25/confluence-wiki-jire%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-65.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>Confluence 作为一款文档协作工具除了具备信息共享和文档协作的基本功能外还依据企业级的应用场景做了很多相应的设置，这些设置从描述看似平常，但是涉及到我们日常工作中就会十分实用，无论是个性化模板还是对团队人员权限的设置都是非常贴合企业工作场景的功能。所以不同于市面上普通的文档协作工具Confluence是针对企业工作场景的一款工具，这个对我们工作专业化会更有帮助，而且从数据安全的角度去考虑，Confluence也是优于其他ToC开源型的工具的。</p>
<h3 id="下载Confluence"><a href="#下载Confluence" class="headerlink" title="下载Confluence"></a>下载Confluence</h3><hr>
<p>atlassian-confluence-7.3.0<br>下载地址：<a href="https://downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-7.3.0-x64.bin">https://downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-7.3.0-x64.bin</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-7.3.0-x64.bin</span><br></pre></td></tr></table></figure>

<p>StatementCallback; </p>
<p>uncategorized SQLException for SQL [CREATE TRIGGER denormalised_space_trigger_on_update AFTER UPDATE ON SPACES FOR EACH ROW sp: BEGIN DECLARE isServiceDisabled BOOL DEFAULT TRUE; </p>
<p>CALL space_procedure_for_denormalised_permissions(isServiceDisabled); IF (isServiceDisabled) THEN LEAVE sp; END IF; IF (NEW.LOWERSPACEKEY &#x3D; OLD.LOWERSPACEKEY) THEN LEAVE sp; END IF; INSERT INTO DENORMALISED_SPACE_CHANGE_LOG(SPACE_ID) VALUES (NEW.SPACEID); END;]; SQL state [HY000]; error code [1419]; </p>
<p>You do not have the SUPER privilege and binary logging is enabled (you <em>might</em> want to use the less safe log_bin_trust_function_creators variable); nested exception is java.sql.SQLException: You do not have the SUPER privilege and binary logging is enabled (you <em>might</em> want to use the less safe log_bin_trust_function_creators variable)</p>
<h3 id="Confluence安装"><a href="#Confluence安装" class="headerlink" title="Confluence安装"></a>Confluence安装</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">[root@code404.icu confluence]<span class="comment"># chmod +x chmod +x atlassian-confluence-7.3.0-x64.bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行安装程序，进行安装</span></span><br><span class="line">[root@code404.icu confluence]<span class="comment"># ./atlassian-confluence-7.3.0-x64.bin </span></span><br><span class="line">Unpacking JRE ...</span><br><span class="line">Starting Installer ...</span><br><span class="line"><span class="comment"># o确定安装，c取消安装</span></span><br><span class="line">This will install Confluence 7.3.0 on your computer.</span><br><span class="line">OK [o, Enter], Cancel [c]</span><br><span class="line">o</span><br><span class="line">Click Next to <span class="built_in">continue</span>, or Cancel to <span class="built_in">exit</span> Setup.</span><br><span class="line"></span><br><span class="line"><span class="comment">#快速安装（使用默认设置）[1]，</span></span><br><span class="line"><span class="comment">#自定义安装（建议高级用户使用）[2，输入]，</span></span><br><span class="line"><span class="comment">#升级现有汇流装置[3]</span></span><br><span class="line">Choose the appropriate installation or upgrade option.</span><br><span class="line">Please choose one of the following:</span><br><span class="line">Express Install (uses default settings) [1], </span><br><span class="line">Custom Install (recommended <span class="keyword">for</span> advanced <span class="built_in">users</span>) [2, Enter], </span><br><span class="line">Upgrade an existing Confluence installation [3]</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定安装的目录，会自动创建，不输入直接回车就是使用默认路径</span></span><br><span class="line">Select the folder <span class="built_in">where</span> you would like Confluence 7.3.0 to be installed,</span><br><span class="line"><span class="keyword">then</span> click Next.</span><br><span class="line">Where should Confluence 7.3.0 be installed?</span><br><span class="line">[/opt/atlassian/confluence]</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定路径存储数据</span></span><br><span class="line">Default location <span class="keyword">for</span> Confluence data</span><br><span class="line">[/var/atlassian/application-data/confluence]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用默认的端口，8090和8000</span></span><br><span class="line">Configure <span class="built_in">which</span> ports Confluence will use.</span><br><span class="line">Confluence requires two TCP ports that are not being used by any other</span><br><span class="line">applications on this machine. The HTTP port is <span class="built_in">where</span> you will access</span><br><span class="line">Confluence through your browser. The Control port is used to Startup and</span><br><span class="line">Shutdown Confluence.</span><br><span class="line">Use default ports (HTTP: 8090, Control: 8000) - Recommended [1, Enter], Set custom value <span class="keyword">for</span> HTTP and Control ports [2]</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装为后台进程，可后台运行</span></span><br><span class="line">Confluence can be run <span class="keyword">in</span> the background.</span><br><span class="line">You may choose to run Confluence as a service, <span class="built_in">which</span> means it will start</span><br><span class="line">automatically whenever the computer restarts.</span><br><span class="line">Install Confluence as Service?</span><br><span class="line">Yes [y, Enter], No [n]</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">Extracting files ...</span><br><span class="line">                                                                           </span><br><span class="line"></span><br><span class="line">Please <span class="built_in">wait</span> a few moments <span class="keyword">while</span> we configure Confluence.</span><br><span class="line"></span><br><span class="line"><span class="comment">#确定开始安装</span></span><br><span class="line">Installation of Confluence 7.3.0 is complete</span><br><span class="line">Start Confluence now?</span><br><span class="line">Yes [y, Enter], No [n]</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">Please <span class="built_in">wait</span> a few moments <span class="keyword">while</span> Confluence starts up.</span><br><span class="line">Launching Confluence ...</span><br><span class="line"></span><br><span class="line">Installation of Confluence 7.3.0 is complete</span><br><span class="line">Your installation of Confluence 7.3.0 is now ready and can be accessed via</span><br><span class="line">your browser.</span><br><span class="line">Confluence 7.3.0 can be accessed at http://localhost:8090</span><br><span class="line">Finishing installation ...</span><br></pre></td></tr></table></figure>



<h3 id="配置confluence"><a href="#配置confluence" class="headerlink" title="配置confluence"></a>配置confluence</h3><hr>
<p>打开Confluence服务地址：<a href="http://www.code404.icu:8090/">http://www.code404.icu:8090</a><br>自动跳转到配置页面</p>
<ul>
<li>语言：选择中文</li>
<li>产品安装</li>
<li>下一步<br><img src="https://img-blog.csdnimg.cn/img_convert/caef798199a180102bfbb32c91ea374c.png" alt="在这里插入图片描述"></li>
<li>获取应用，一个都不选</li>
<li>下一步<br><img src="https://img-blog.csdnimg.cn/img_convert/e93e0428658dd7d4f0a7abd9ad686018.png" alt="在这里插入图片描述"></li>
<li>授权码</li>
<li>记一下 <strong>服务器ID</strong></li>
<li>授权码 需要下面步骤生成<br><img src="https://img-blog.csdnimg.cn/img_convert/9ded2cb19e1b232b63ed0bab971aee8d.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="关闭服务器Confluence服务"><a href="#关闭服务器Confluence服务" class="headerlink" title="关闭服务器Confluence服务"></a>关闭服务器Confluence服务</h3><hr>
<p>&#x2F;etc&#x2F;init.d&#x2F;confluence stop<br>#如果多次安装，confluence后面会有自增数字，查看&#x2F;etc&#x2F;init.d具体数字在命令加上 lsof -i:8090  可以看进程是否关掉</p>
<h3 id="破解Confluence"><a href="#破解Confluence" class="headerlink" title="破解Confluence"></a>破解Confluence</h3><hr>
<ul>
<li>进入&#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;confluence&#x2F;WEB-INF&#x2F;lib ,把这个目录下的atlassian-extras-decoder-v2-3.4.1.jar拷贝一份自己系统(不同版本这个是不一样的）</li>
<li>下载到本地并改名为atlassian-extras-2.4.jar</li>
<li>在Windows上打开confluence_keygen.jar</li>
<li>Name：<a href="http://www.code404.icu/">www.code404.icu</a></li>
<li>Server ID：刚才配置上的 <strong>服务器ID BHAH-S6SE-5IMZ-3X31</strong></li>
<li>.patch!：选择刚下载的 并改名的 atlassian-extras-2.4.jar</li>
<li>.gen!：进行破解生成key，点击gen生成key，记录下key，就是等下要填的激活码</li>
<li>选择第2步中重命名的atlassian-extras-2.4.jar，会生成新的atlassian-extras-2.4.jar，旧的jar包会被改为.bak。<br><img src="https://img-blog.csdnimg.cn/img_convert/40489cdec569fd38948f38d54daaa446.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="把新生产的atlassian-extras-2-4-jar上传到服务器"><a href="#把新生产的atlassian-extras-2-4-jar上传到服务器" class="headerlink" title="把新生产的atlassian-extras-2.4.jar上传到服务器"></a>把新生产的atlassian-extras-2.4.jar上传到服务器</h3><hr>
<p>将新的atlassian-extras-2.4.jar和mysql-connector-java-5.1.39-bin.jar（版本自由选择）到&#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;confluence&#x2F;WEB-INF&#x2F;lib，并且删除旧的（即是服务器上原有的）atlassian-extras-decoder-v2-3.4.1.jar<br>mysql-connector-java 下载地址</p>
<p><a href="https://download.csdn.net/download/leenhem/20401823">https://download.csdn.net/download/leenhem/20401823</a></p>
<h3 id="启动服务器Confluence服务"><a href="#启动服务器Confluence服务" class="headerlink" title="启动服务器Confluence服务"></a>启动服务器Confluence服务</h3><hr>
<p>&#x2F;etc&#x2F;init.d&#x2F;confluence start</p>
<h3 id="接着配置Confluence"><a href="#接着配置Confluence" class="headerlink" title="接着配置Confluence"></a>接着配置Confluence</h3><hr>
<ul>
<li>接下来回到浏览器，刷新一下</li>
<li>把刚生成的key复制进去</li>
<li>下一步<br><img src="https://img-blog.csdnimg.cn/img_convert/1fdb7bef18cda83223c801cb6c72ca92.png" alt="在这里插入图片描述"><br>选择数据库类型，如下所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/bc824f3d636f1e3630219685ffe12106.png" alt="在这里插入图片描述">  </li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>jdbc:mysql:&#x2F;&#x2F;192.168.65.119:3306&#x2F;confluence131?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false&amp;sessionVariables&#x3D;tx_isolation&#x3D;’READ-COMMITTED’</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>下一步 注意：这部耗时很久，是正常现象</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/86012d8703bb32bf282c417d7568b6ae.png" alt="在这里插入图片描述"></p>
<p>新建一个空白站点，完成安装。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>团队协作</category>
      </categories>
      <tags>
        <tag>Confluence</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Confluence导出PDF中文字符缺失</title>
    <url>/2021/07/31/confluence%E5%AF%BC%E5%87%BApdf%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%BC%BA%E5%A4%B1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-65.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>在Confluence上编辑的文档，归档或发给别人时，往往需要导出文档，当导出文档时发现文档内容中文全部缺失</p>
<h3 id="解决Confluence导出PDF中文丢失"><a href="#解决Confluence导出PDF中文丢失" class="headerlink" title="解决Confluence导出PDF中文丢失"></a>解决Confluence导出PDF中文丢失</h3><hr>
<p>使用管理员账号 登录Confluence，在右上角找到配置项<br><img src="https://img-blog.csdnimg.cn/63a5b9c568264446bc507b80a39a4d2f.png" alt="在这里插入图片描述">  </p>
<p>在配置中找到 “PDF导出语言支持”<br><img src="https://img-blog.csdnimg.cn/f87f295afdb54a908bbae33a07f1f1fd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p>
<p>在右侧选择字体文件 simhei.ttf 上传<br>上传完成后单击 install 安装<br>安装完成后再导出PDF，此时PDF内容中文正常显示</p>
]]></content>
      <categories>
        <category>Confluence</category>
      </categories>
      <tags>
        <tag>Confluence</tag>
        <tag>PDF</tag>
        <tag>中文</tag>
        <tag>字符</tag>
        <tag>导出</tag>
      </tags>
  </entry>
  <entry>
    <title>curl报错 curl: option --form: is badly used here</title>
    <url>/2021/06/26/curl%E6%8A%A5%E9%94%99-curl-option-form-is-badly-used-here/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-61.png"></p>
<h3 id="执行curl上传文件"><a href="#执行curl上传文件" class="headerlink" title="执行curl上传文件"></a>执行curl上传文件</h3><p>curl –location –request POST ‘<a href="http://192.168.65.220:19999/upfile/&#39;">http://192.168.65.220:19999/upfile/&#39;</a> \<br>–form ‘&#x3D;@”&#x2F;C:&#x2F;Users&#x2F;Administrator&#x2F;Downloads&#x2F;hemleen-lua-resty-shell-master.zip”‘</p>
<h3 id="报错option-–form-is-badly-used-here"><a href="#报错option-–form-is-badly-used-here" class="headerlink" title="报错option –form: is badly used here"></a>报错option –form: is badly used here</h3><p>Warning: Illegally formatted input field!<br>curl: option –form: is badly used here<br>curl: try ‘curl –help’ or ‘curl –manual’ for more information</p>
<h3 id="原因-curl-版本太低不支持-–form参数"><a href="#原因-curl-版本太低不支持-–form参数" class="headerlink" title="原因 curl 版本太低不支持 –form参数"></a>原因 curl 版本太低不支持 –form参数</h3><p>把 - -form 参数改为 -F 就可以 了</p>
<h3 id="修改后执行"><a href="#修改后执行" class="headerlink" title="修改后执行"></a>修改后执行</h3><p>curl –location –request POST <a href="http://192.168.65.220:19999/upfile/">http://192.168.65.220:19999/upfile/</a> -F file&#x3D;@dist.zip<br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed</p>
<p>  0     0    0     0    0     0      0      0 –:–:– –:–:– –:–:–     0<br> 68 8602k    0     0   68 5904k      0  11.6M –:–:– –:–:– –:–:– 11.6M<br>100 8602k    0    13  100 8602k     16  10.9M –:–:– –:–:– –:–:– 10.9M<br>save file ok</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>上传文件</tag>
      </tags>
  </entry>
  <entry>
    <title>default-sort [Vue warn]: Error in nextTick: &quot;TypeError: array is null&quot;</title>
    <url>/2021/12/20/default-sort-vue-warn-error-in-nexttick-typeerror-array-is-null/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-12.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在vue项目中使用element-ui时报错：[Vue warn]: Error in nextTick: “TypeError: array is null”<br>配置了:default-sort&#x3D;”{prop: ‘internal_ip’, order: ‘ascending’}” 后就报错<br>报错信息如下：</p>
<p>[Vue warn]: Error in nextTick: “TypeError: array is null”</p>
<p>found in</p>
<p>—&gt; <ElTableHeader><br>       <ElTable> at packages&#x2F;table&#x2F;src&#x2F;table.vue<br>         <ComplexTable> at src&#x2F;views&#x2F;kubernetes&#x2F;clusters.vue<br>           <AppMain> at src&#x2F;layout&#x2F;components&#x2F;AppMain.vue<br>             <Layout> at src&#x2F;layout&#x2F;index.vue<br>               <App> at src&#x2F;App.vue<br>                 <Root> vue.runtime.esm.js:619<br>TypeError: array is null</p>
<h3 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h3><hr>
<p>原因就是给el-table的数据源初始时设置为了null，而在使用了default-sort属性时，table在默认排序时对数据源进行map当然报错。</p>
<h3 id="问题解决-default-sort-Vue-warn-Error-in-nextTick-“TypeError-array-is-null”"><a href="#问题解决-default-sort-Vue-warn-Error-in-nextTick-“TypeError-array-is-null”" class="headerlink" title="问题解决 default-sort [Vue warn]: Error in nextTick: “TypeError: array is null”"></a>问题解决 default-sort [Vue warn]: Error in nextTick: “TypeError: array is null”</h3><hr>
<p>将list: null改为list: []就解决了，将数据源数组初始值改为[] 空数组即可。</p>
<p><img src="https://img-blog.csdnimg.cn/9f0e6e94e5c94a48b3223a5d45cfcbbc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>再次访问，就不会报错了</p>
<h3 id="类似的错误"><a href="#类似的错误" class="headerlink" title="类似的错误"></a>类似的错误</h3><hr>
<p>[Vue warn]: Error in nextTick: “TypeError: Cannot read property ‘map‘ of null“<br>也是这样解决，一般原因就是我们在绑定数据时，绑定了null值</p>
]]></content>
      <categories>
        <category>VUE</category>
        <category>网页开发</category>
      </categories>
      <tags>
        <tag>Cannot read property</tag>
        <tag>nextTick</tag>
        <tag>TypeError</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 搭建 Jenkins 实现自动部署</title>
    <url>/2021/04/26/docker-%E6%90%AD%E5%BB%BA-jenkins-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-28.png"></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>操作系统：CentOS Linux release 7.6.1810<br>Docker 版本：19.03.5<br>Jenkins 版本：2.204.1</p>
<h2 id="Docker安装Jenkins"><a href="#Docker安装Jenkins" class="headerlink" title="Docker安装Jenkins"></a>Docker安装Jenkins</h2><h3 id="Docker下载Jenkins"><a href="#Docker下载Jenkins" class="headerlink" title="Docker下载Jenkins"></a>Docker下载Jenkins</h3><p>docker pull jenkins&#x2F;jenkins:lts &#x2F;&#x2F;最新版</p>
<h3 id="查看Jenkins镜像"><a href="#查看Jenkins镜像" class="headerlink" title="查看Jenkins镜像"></a>查看Jenkins镜像</h3><p>docker images<br>docker inspect jenkins镜像ID</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-9.png"></p>
<h3 id="创建一个Jenkins目录"><a href="#创建一个Jenkins目录" class="headerlink" title="创建一个Jenkins目录"></a>创建一个Jenkins目录</h3><p>mkdir &#x2F;data&#x2F;jenkins_home;</p>
<h3 id="安装启动Jenkins容器"><a href="#安装启动Jenkins容器" class="headerlink" title="安装启动Jenkins容器"></a>安装启动Jenkins容器</h3><p>docker run -d –name jenkins -p 8081:8080 -v &#x2F;data&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home jenkins&#x2F;jenkins:lts;<br>备注：<br>-d &#x2F;&#x2F;启动在后台<br>–name &#x2F;&#x2F;容器名字<br>-p &#x2F;&#x2F;端口映射（8081：宿主主机端口，8080：容器内部端口）<br>-v &#x2F;&#x2F;数据卷挂载映射（&#x2F;data&#x2F;jenkins_home：宿主主机目录，另外一个即是容器目录）</p>
<p>jenkins&#x2F;jenkins:lts &#x2F;&#x2F;Jenkins镜像（最新版）</p>
<h3 id="查看Jenkins启动情况"><a href="#查看Jenkins启动情况" class="headerlink" title="查看Jenkins启动情况"></a>查看Jenkins启动情况</h3><p>docker ps  grep jenkins;</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-18-1024x52.png"></p>
<h2 id="安装过程遇到的小问题"><a href="#安装过程遇到的小问题" class="headerlink" title="安装过程遇到的小问题"></a>安装过程遇到的小问题</h2><p>Jenkins容器docker run之后状态总是Exited</p>
<p>查看docker日志 ：<br>docker logs jenkins<br>发现是目前权限问题<br>因为&#x2F;data&#x2F;jenkins_home 目录是root权限</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-19-1024x469.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-20.png"></p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>chown -R 1000:1000 &#x2F;data&#x2F;jenkins_home &#x2F;&#x2F;用户组改变</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-21.png"></p>
<h3 id="宿主主机端口要开启"><a href="#宿主主机端口要开启" class="headerlink" title="宿主主机端口要开启"></a>宿主主机端口要开启</h3><p>需要服务器开放8081端口。</p>
<h2 id="访问Jenkins"><a href="#访问Jenkins" class="headerlink" title="访问Jenkins"></a>访问Jenkins</h2><p><a href="http://192.168.1.100:8081/">http://192.168.1.100:8081</a> &#x2F;&#x2F;ip:端口号</p>
<h2 id="管理配置Jenkins"><a href="#管理配置Jenkins" class="headerlink" title="管理配置Jenkins"></a>管理配置Jenkins</h2><p>解锁</p>
<p>在安装完成后，默认生成了一个登录密码，首次登录需要这个密码。<br>密码路径：var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword &#x2F;&#x2F;容器内部<br>查找密码：<br>docker exec -it jenkins_01 bash &#x2F;&#x2F;进入jenkins容器<br>cat &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword &#x2F;&#x2F;查看密码</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-22-1024x469.png"></p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>新手安装建议选择：Install suggested plugins，安装过程大概半个多小时。</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-23.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-24-1024x593.png"></p>
<h2 id="管理用户创建"><a href="#管理用户创建" class="headerlink" title="管理用户创建"></a>管理用户创建</h2><p>这个用户就是最大管理者权限，相当于admin</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-25.png"></p>
<h2 id="Jenkins配置完成"><a href="#Jenkins配置完成" class="headerlink" title="Jenkins配置完成"></a>Jenkins配置完成</h2><p>到此步，安装就大功告成！<br><a href="http://192.168.1.100:8081/">http://192.168.1.100:8081</a>  &#x2F;&#x2F;ip:端口号</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-26.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-27-1024x595.png"></p>
<h2 id="实现自动化部署"><a href="#实现自动化部署" class="headerlink" title="实现自动化部署"></a>实现自动化部署</h2><p>有了Jenkins，接下来就是代码的自动部署过程了。</p>
<p>已上就是Docker 搭建 Jenkins 实现自动部署过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>docker</tag>
        <tag>实现</tag>
        <tag>搭建</tag>
        <tag>自动</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署oracle-xe-11g数据持久化的问题解决</title>
    <url>/2021/04/29/docker%E9%83%A8%E7%BD%B2oracle-xe-11g%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-29.png"></p>
<h3 id="Docker部署Oracle数据持久化问题"><a href="#Docker部署Oracle数据持久化问题" class="headerlink" title="Docker部署Oracle数据持久化问题"></a>Docker部署Oracle数据持久化问题</h3><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><hr>
<p>kubernets集群部署 oracle<br>镜像所采用的是：wnameless&#x2F;oracle-xe-11g<br>镜像地址是：<a href="https://hub.docker.com/r/oracleinanutshell/oracle-xe-11g">https://hub.docker.com/r/oracleinanutshell/oracle-xe-11g</a><br>我是先下载到本地了</p>
<p># 查看本地镜像<br>[root@k8s-master01 oracle11g]# docker imagesgrep oracleinanutshell<br>oracleinanutshell&#x2F;oracle-xe-11g                                               latest        ad13c30ec346   2 years ago     2.13GB<br>[root@k8s-master01 oracle11g]# </p>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p>现在想要实现数据持久化<br>这个镜像的oradata目录在这里&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;XE<br>我是这样操作的：<br>先把容器中的这个路径下的所有文件都拷贝到宿主机<br>然后再把拷贝出的文件挂载到原先的目录下<br>操作如下：</p>
<h2 id="先启动服务，生成数据文件"><a href="#先启动服务，生成数据文件" class="headerlink" title="先启动服务，生成数据文件"></a>先启动服务，生成数据文件</h2><p>[root@k8s-master01 oracle11g]# docker run -d –name oracle11g -p 1521:1521 -e ORACLE_ALLOW_REMOTE&#x3D;true oracleinanutshell&#x2F;oracle-xe-11g<br>bb62b7f9eb09b976557afed98c7915b53f09d0161d4a9b38337262d9fb036767<br>[root@k8s-master01 oracle11g]# docker logs -f oracle11g<br>Starting Oracle Net Listener.<br>Starting Oracle Database 11g Express Edition instance.</p>
<p>System altered.</p>
<p>^C<br>[root@k8s-master01 oracle11g]# </p>
<p>看到 <code>System altered</code> 代表服务启动成功</p>
<h2 id="把数据文件copy到宿主机"><a href="#把数据文件copy到宿主机" class="headerlink" title="把数据文件copy到宿主机"></a>把数据文件copy到宿主机</h2><p>[root@k8s-master01 oracle11g]# docker cp oracle11g:&#x2F;u01&#x2F;app&#x2F;oracle&#x2F; &#x2F;data&#x2F;oracle11g-data&#x2F;<br>[root@k8s-master01 oracle11g]#<br>[root@k8s-master01 oracle11g]# ls &#x2F;data&#x2F;oracle11g-data&#x2F;oracle&#x2F;<br>admin  diag  fast_recovery_area  oradata  oradiag_oracle  product<br>[root@k8s-master01 oracle11g]# </p>
<p>那么，oracle的数据文件已经copy到宿主机</p>
<h2 id="清除刚启动的容器-oracle11g"><a href="#清除刚启动的容器-oracle11g" class="headerlink" title="清除刚启动的容器 oracle11g"></a>清除刚启动的容器 oracle11g</h2><p>[root@k8s-master01 oracle11g]# docker stop oracle11g<br>oracle11g<br>[root@k8s-master01 oracle11g]# docker rm oracle11g<br>oracle11g<br>[root@k8s-master01 oracle11g]# </p>
<h1 id="在k8s集群下部署oracle-xe-11g"><a href="#在k8s集群下部署oracle-xe-11g" class="headerlink" title="在k8s集群下部署oracle-xe-11g"></a>在k8s集群下部署oracle-xe-11g</h1><p>我的deployment配置</p>
<p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: oracle11g<br>  namespace: database<br>spec:<br>  selector:<br>    matchLabels:<br>      app: oracle11g<br>  replicas: 1 # tells deployment to run 2 pods matching the template<br>  template:<br>    metadata:<br>      labels:<br>        app: oracle11g<br>    spec:<br>      containers:<br>      - name: oracle11g<br>        image: oracleinanutshell&#x2F;oracle-xe-11g:1.0.0<br>        imagePullPolicy: IfNotPresent<br>        volumeMounts:<br>        - mountPath: &#x2F;u01&#x2F;app&#x2F;oracle<br>          name: data-app-11g<br>        ports:<br>        - containerPort: 8080<br>        - containerPort: 1521<br>        env:<br>        - name: ORACLE_ALLOW_REMOTE<br>          value: “true”<br>        - name: ORACLE_DISABLE_ASYNCH_IO<br>          value: “true”<br>        - name: ORACLE_ENABLE_XDB<br>          value: “true”<br>      volumes:<br>      - name: data-app-11g<br>        hostPath:<br>          path: &#x2F;data&#x2F;oracle11g-data&#x2F;oracle  #指定本地存储目录<br>          type: Directory</p>
<p>配置文件中指定了本地存储路径</p>
<h2 id="启动oracle-xe-11g加载本地数据"><a href="#启动oracle-xe-11g加载本地数据" class="headerlink" title="启动oracle-xe-11g加载本地数据"></a>启动oracle-xe-11g加载本地数据</h2><p>[root@k8s-master01 oracle11g]# kubectl apply -f deployment.yaml<br>deployment.apps&#x2F;oracle11g created<br>[root@k8s-master01 oracle11g]# kubectl get pod -n database<br>NAME                         READY   STATUS    RESTARTS   AGE<br>oracle11g-6fb478dbc7-n6874   1&#x2F;1     Running   0          21s<br>oracle12c-ddd5f54b6-852tb    1&#x2F;1     Running   1          6d2h<br>[root@k8s-master01 oracle11g]# </p>
<p>Oracle11g启动成功</p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>[root@k8s-master01 oracle11g]# kubectl logs -f oracle11g-6fb478dbc7-n6874 -n database<br>Starting Oracle Net Listener.<br>Starting Oracle Database 11g Express Edition instance.</p>
<p>User altered.</p>
<p>User altered.</p>
<p>System altered.</p>
<p>System altered.</p>
<p>Shutting down Oracle Database 11g Express Edition instance.<br>Stopping Oracle Net Listener.</p>
<p>Starting Oracle Net Listener.<br>Starting Oracle Database 11g Express Edition instance.</p>
<p>oracle11g 启动成功</p>
<h1 id="k8s开放nodeport端口-访问oracal数据库"><a href="#k8s开放nodeport端口-访问oracal数据库" class="headerlink" title="k8s开放nodeport端口 访问oracal数据库"></a>k8s开放nodeport端口 访问oracal数据库</h1><p>我的service配置如下</p>
<p>apiVersion: v1<br>kind: Service<br>metadata:<br>  namespace: database<br>  labels:<br>    app: oracle11g<br>  name: oracle11g-nodeport<br>spec:<br>        #clusterIP: “172.25.42.235”<br>  externalTrafficPolicy: Cluster<br>  type: NodePort<br>  ports:<br>    - name: manager<br>      protocol: TCP<br>      port: 8080<br>      targetPort: 8080<br>      nodePort: 28080<br>    - name: connect<br>      protocol: TCP<br>      port: 1521<br>      targetPort: 1521<br>      nodePort: 21521<br>  selector:<br>    app: oracle11g</p>
<h2 id="应用service配置"><a href="#应用service配置" class="headerlink" title="应用service配置"></a>应用service配置</h2><p>[root@k8s-master01 oracle11g]# kubectl get service -n database<br>NAME                 TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                         AGE<br>oracle11g-nodeport   NodePort   10.105.188.84    <none>        8080:28080&#x2F;TCP,1521:21521&#x2F;TCP   7s<br>oracle12c-nodeport   NodePort   10.109.195.127   <none>        8080:38080&#x2F;TCP,1521:31521&#x2F;TCP   11d<br>[root@k8s-master01 oracle11g]# </p>
<p>在宿主机开放端口28080 21521</p>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p>管理数据库连接<br>Login <a href="http://ip:28080/apex/apex/_admin">http://ip:28080/apex/apex\_admin</a><br>username: ADMIN<br>password: admin  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-30-1024x527.png"></p>
<p>使用以下设置连接数据库：<br>hostname: 宿主机ip地址<br>port: 21521<br>sid: xe<br>username: system<br>password: oracle</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-31.png"></p>
<p>已上就是Docker部署oracle-xe-11g数据持久化的问题解决过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>部署</tag>
        <tag>oracle-xe-11g</tag>
        <tag>数据持久化</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Either the node already knows other nodes check with CLUSTER NODES or contains some key in databas</title>
    <url>/2021/12/15/either-the-node-already-knows-other-nodes-check-with-cluster-nodes-or-contains-some-key-in-databas/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-40.png" alt="redis"></p>
<p>redis</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>使用redis-trib.rb创建群集时报错<br>[ERR] Node 10.3.139.223:8001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><hr>
<p>修改redis.conf后，重新执行每个redis.conf，最后再创建集群，但报错</p>
<p>redis-trib.rb create –replicas 1 192.168.100.10:8001 192.168.100.10:8002 \<br>192.168.100.11:8001 192.168.100.11:8002 \<br>192.168.100.12:8001 192.168.100.12:8002 </p>
<blockquote>
<blockquote>
<blockquote>
<p>Creating cluster<br>[ERR] Node 10.3.139.223:8001 is not empty. Either the node already knows other nodes<br>(check with CLUSTER NODES) or contains some key in database 0.</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>停止每个节点上的redis服务</p>
<p>pkill redis</p>
<p>删除data文件夹中的文件</p>
<p>rm &#x2F;data&#x2F;redis&#x2F;data&#x2F;* -f</p>
<p>启动每个节点上的redis服务</p>
<p>redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis-8001.conf<br>redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis-8002.conf</p>
<h3 id="创建Redis集群"><a href="#创建Redis集群" class="headerlink" title="创建Redis集群"></a>创建Redis集群</h3><hr>
<p>redis-trib.rb create –replicas 1 192.168.100.10:8001 192.168.100.10:8002 \<br>192.168.100.11:8001 192.168.100.11:8002 \<br>192.168.100.12:8001 192.168.100.12:8002 </p>
<blockquote>
<blockquote>
<blockquote>
<p>Creating cluster<br>Performing hash slots allocation on 6 nodes…<br>Using 3 masters:<br>192.168.100.10:8001<br>192.168.100.11:8001<br>192.168.100.12:8001<br>Adding replica 192.168.100.11:8002 to 192.168.100.10:8001<br>Adding replica 192.168.100.11:8002 to 192.168.100.11:8001<br>Adding replica 192.168.100.10:8002 to 192.168.100.12:8001<br>M: 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c 192.168.100.10:8001<br>   slots:0-5460 (5461 slots) master<br>S: 5a3c23ee70ee1a77aabb33e93b59611aa48790e1 192.168.100.10:8002<br>   replicates fdc7022e98e9619a9dd4574501f3648627d58c38<br>M: 71663ec6304e762565cd73512bef7a7e4f764235 192.168.100.11:8001<br>   slots:5461-10922 (5462 slots) master<br>S: 0ac27a24f78ff7d3e5b4fff8c97ad4a09700d930 192.168.100.11:8002<br>   replicates 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c<br>M: fdc7022e98e9619a9dd4574501f3648627d58c38 192.168.100.12:8001<br>   slots:10923-16383 (5461 slots) master<br>S: 4a0a20b6c6c925e582997be447848edeee9e8456 192.168.100.11:8002<br>   replicates 71663ec6304e762565cd73512bef7a7e4f764235<br>Can I set the above configuration? (type ‘yes’ to accept): yes<br>Nodes configuration updated<br>Assign a different config epoch to each node<br>Sending CLUSTER MEET messages to join the cluster<br>Waiting for the cluster to join.<br>Performing Cluster Check (using node 192.168.100.10:8001)<br>M: 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c 192.168.100.10:8001<br>   slots:0-5460 (5461 slots) master<br>   1 additional replica(s)<br>S: 4a0a20b6c6c925e582997be447848edeee9e8456 192.168.100.11:8002<br>   slots: (0 slots) slave<br>   replicates 71663ec6304e762565cd73512bef7a7e4f764235<br>S: 0ac27a24f78ff7d3e5b4fff8c97ad4a09700d930 192.168.100.11:8002<br>   slots: (0 slots) slave<br>   replicates 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c<br>M: fdc7022e98e9619a9dd4574501f3648627d58c38 192.168.100.12:8001<br>   slots:10923-16383 (5461 slots) master<br>   1 additional replica(s)<br>M: 71663ec6304e762565cd73512bef7a7e4f764235 192.168.100.11:8001<br>   slots:5461-10922 (5462 slots) master<br>   1 additional replica(s)<br>S: 5a3c23ee70ee1a77aabb33e93b59611aa48790e1 192.168.100.10:8002<br>   slots: (0 slots) slave<br>   replicates fdc7022e98e9619a9dd4574501f3648627d58c38<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.</p>
</blockquote>
</blockquote>
</blockquote>
<p>创建集群成功</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch ES 服务部署 单机部署</title>
    <url>/2021/05/13/elasticsearch-es-%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2-%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-17.png"></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载地址：<code>https://www.elastic.co/cn/downloads/elasticsearch</code><br>ElasticSearch历史版本下载：<code>https://www.elastic.co/cn/downloads/past-releases</code></p>
<p>wget <a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.10.1-linux-x86/_64.tar.gz">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.10.1-linux-x86\_64.tar.gz</a></p>
<h3 id="源文地址："><a href="#源文地址：" class="headerlink" title="源文地址："></a>源文地址：</h3><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>[root@ODSP-DB data]# tar -xf elasticsearch-7.10.1-linux-x86_64.tar.gz<br>[root@ODSP-DB data]# ll<br>总用量 311644<br>drwxr-xr-x 9 root root      4096 12月  5 09:04 elasticsearch-7.10.1<br>-rw-r–r– 1 root root 318801277 5月  12 11:18 elasticsearch-7.10.1-linux-x86_64.tar.gz</p>
<p>[root@ODSP-DB data]# cd elasticsearch-7.10.1<br>[root@ODSP-DB elasticsearch-7.10.1]# ls<br>bin  config  jdk  lib  LICENSE.txt  logs  modules  NOTICE.txt  plugins  README.asciidoc<br>[root@ODSP-DB elasticsearch-7.10.1]# </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="修改ElasticSearch配置"><a href="#修改ElasticSearch配置" class="headerlink" title="修改ElasticSearch配置"></a>修改ElasticSearch配置</h3><p><code>cat config/elasticsearch.yml</code></p>
<p>cluster.name: docshare-cluster<br>network.host: 192.168.80.209<br>http.port: 9200<br>discovery.seed_hosts: [“192.168.80.209:9200”]<br>cluster.initial_master_nodes: [“192.168.80.209”]</p>
<h3 id="修改系统参数"><a href="#修改系统参数" class="headerlink" title="修改系统参数"></a>修改系统参数</h3><h4 id="修改limits-conf"><a href="#修改limits-conf" class="headerlink" title="修改limits.conf"></a>修改limits.conf</h4><p>编辑 &#x2F;etc&#x2F;security&#x2F;limits.conf，追加以下内容；</p>
<p>* soft nofile 65536<br>* hard nofile 65536</p>
<p>此文件修改后需要重新登录用户，才会生效</p>
<h4 id="修改sysctl-conf"><a href="#修改sysctl-conf" class="headerlink" title="修改sysctl.conf"></a>修改sysctl.conf</h4><p>在&#x2F;etc&#x2F;sysctl.conf文件最后添加一行<br><code>vm.max_map_count=262144</code><br>执行命令<br><code>sysctl -p</code> 使配置生效</p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>添加用户，以普通用户启动ElasticSearch<br><code>useradd es</code></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>使用 <code>bin/elasticsearch -d</code> 启动ElasticSearch</p>
<p>[root@ODSP-DB elasticsearch-7.10.1]# su - es<br>上一次登录：三 5月 12 10:11:31 CST 2021pts&#x2F;1 上<br>[es@ODSP-DB ~]$ cd &#x2F;data&#x2F;elasticsearch-7.10.1&#x2F;<br>[es@ODSP-DB elasticsearch-7.10.1]$ bin&#x2F;elasticsearch -d</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
        <tag>单机部署</tag>
        <tag>服务部署</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 海量数据查询性能优化</title>
    <url>/2021/05/29/elasticsearch-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-50.png"></p>
<p>ES 接收到查询请求后，会转发给所有相关的 Shard 分片，每个 Shard 在自己这块儿进行搜索，各自的结果汇总后再返回给客户端。</p>
<p>这个过程有2个核心性能关键点：</p>
<ul>
<li>Shard 执行查询计算的耗时</li>
<li>Shard 读取各个 Segment 文件的 I&#x2F;O 耗时</li>
</ul>
<p>所以，我们就要从这两个角度进行优化。</p>
<ol>
<li>尽量让 ES 的查询动作简单，避免进行复杂的查询计算。</li>
<li>尽量提升 I&#x2F;O 效率，也就是用好文件系统缓存（从 ES 写入流程可以知道文件缓存有很大的作用）</li>
</ol>
<h2 id="尽量让查询计算简单"><a href="#尽量让查询计算简单" class="headerlink" title="尽量让查询计算简单"></a>尽量让查询计算简单</h2><p>这就涉及到 ES 中的数据建模方式。<br>例如关系数据库有两张表：</p>
<ul>
<li>订单表（编号、总金额、用户、日期）</li>
<li>订单详情表（订单编号、商品信息）</li>
</ul>
<p>查询订单时，需要对两张表进行关联查询。</p>
<p>这在关系数据库中很正常，因为关系数据库是根据实体及其关系来建模的。</p>
<p>但在 ES 中最好就不要这么定义数据结构了，ES 是搜索引擎，要以搜索的角度来规划数据，怎么便于搜索怎么来。</p>
<p>例如直接把这两张表的数据放在一个Document中，一个简单查询就完事儿了，不用让 ES 进行Document的关联查询。</p>
<h2 id="最大化使用操作系统的文件缓存"><a href="#最大化使用操作系统的文件缓存" class="headerlink" title="最大化使用操作系统的文件缓存"></a>最大化使用操作系统的文件缓存</h2><p>操作系统喜欢用文件缓存，只要内存充足，读取 Segment 文件的时候，就会将其内容一直放在缓存中，直到内存不够用了。</p>
<p>比如读 Segment 01 这个文件的时候，先加载到文件缓存。</p>
<p>如果缓存空间足够，就直接加载进来。</p>
<p>否则，就会移除一部分缓存的文件，腾出空间后再加载进来。</p>
<p>例如，你的 ES 数据量是 1000G，集群有3个节点，每个节点上面就是 300 多个G。</p>
<p>假设，每个节点中操作系统可以使用内存为 16G，那么，搜索的时候，直接读文件缓存的最大概率也只有 5% 左右，绝大部分的数据都要读物理文件，一起争用那一点文件缓存空间，性能自然很差。</p>
<p>优化方向有 2 个：<br>1）增加内存<br>2）减少 ES 中的数据量</p>
<h3 id="增加内存"><a href="#增加内存" class="headerlink" title="增加内存"></a>增加内存</h3><p>增加内存很简单，只要有钱就行。</p>
<p>那么需要增加到多少呢？</p>
<p>建议：操作系统可用内存 &gt; 本节点数据量的 50%</p>
<p>这样数据命中缓存的概率就比较高了。如果不差钱，内存越大越好。</p>
<h3 id="减少-ES-中的数据量"><a href="#减少-ES-中的数据量" class="headerlink" title="减少 ES 中的数据量"></a>减少 ES 中的数据量</h3><p>再强调一次 ES 是搜索引擎，是用来干搜索的。</p>
<p>很多人喜欢把数据全都放 ES 里，感觉它是分布式的，多放几台服务器，硬盘大点，很能装。</p>
<p>比如一个表有上百个字段，真正搜索的时候，都会用到吗？不一定吧。</p>
<p>那么，搜索用不到的数据尽量别放在 ES 里。</p>
<p>ES 服务于搜索，不是服务于存储。</p>
<p>所以，ES 中应该放与搜索相关的数据，不应该放全量数据。</p>
<p>全量数据的存储应该使用专业的存储系统，例如 HBASE。</p>
<p>在大数据环境中，有几个T的数据很正常，如果都放在 ES 里面，并且想要保障查询性能，内存要多大呢？</p>
<p>如果经济实力不允许，内存不是很充足，那么查询性能就很悲催了，每次查询花费几秒钟很正常。</p>
<p>如果 ES 中只放搜索相关的少量数据，把全量数据放在 HBASE，性能就会快很多。<br><img src="https://img-blog.csdnimg.cn/20210528112051811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>先从 ES 中查询出结果数据集，其中只包含核心字段，然后根据结果集中各条数据的 Key 到 HBASE 中进行精准查询，再把结果进行整合。</p>
<p>虽然是两次查询，但因为每部分都很快，所以整体下来也很快。</p>
<h3 id="思路扩展"><a href="#思路扩展" class="headerlink" title="思路扩展"></a>思路扩展</h3><h4 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h4><p>数据通常有冷热之分，有一部分数据的使用频率明显高于其他数据。</p>
<p>如果文件系统的缓存不是很充足，那么数据就需要轮流呆在缓存中。</p>
<p>热数据自然呆的时间长，但是当加载冷数据时，就会把热数据挤出缓存了。那么下次就需要从磁盘重新加载。</p>
<p>所以，最好让热数据走一部分 Shard，冷数据走其他 Shard，防止冲刷缓存。</p>
<h4 id="数据预加载"><a href="#数据预加载" class="headerlink" title="数据预加载"></a>数据预加载</h4><p>还是基于热数据的角度，可以事先调用一下，使其提前进入文件缓存。</p>
<p>这样，客户第一次查询的时候也会很快。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>想要 ES 查询速度快，需要使查询动作尽量简单，这需要在数据建模上多花些心思。</p>
<p>最重要的是要利用好<strong>文件缓存</strong>。</p>
<p>增加内存是简单、粗暴、有效的方法。</p>
<p>还有就是尽量缩减 ES 中的数据量，不要存放与搜索需求无关的数据。可以配合 HBASE 这类的专业海量数据存储系统一起使用。</p>
<p>另外，冷热数据分离、数据预加载，也是比较有效的小技巧。</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>elsticsearch</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch启动后调用接口报master_not_discovered_exception</title>
    <url>/2021/12/16/elasticsearch%E5%90%AF%E5%8A%A8%E5%90%8E%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%8A%A5master-not-discovered-exception/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-8.png"></p>
<p>master_not_discovered_exception</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>elasticsearch 7 启动正常<br>配置</p>
<p>cluster.name: skywallking-es<br>path.data: &#x2F;pan_nfs&#x2F;moniter2&#x2F;data<br>network.host: 0.0.0.0<br>discovery.seed_hosts: [“10.64.35.14”]</p>
<h3 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h3><hr>
<p>使用curl调用接口报错master_not_discovered_exception</p>
<p>curl -X GET <a href="http://10.64.35.14:9200//_cat/nodes?pretty">http://10.64.35.14:9200/\_cat/nodes?pretty</a><br>{<br>    “error”: {<br>        “root_cause”: [<br>            {<br>                “type”: “master_not_discovered_exception”,<br>                “reason”: null<br>            }<br>        ],<br>        “type”: “master_not_discovered_exception”,<br>        “reason”: null<br>    },<br>    “status”: 503<br>}</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><hr>
<p>在elasticsearch每个配置文件指定初始节点<br>单实例的也要加上这个配置，否则就会报错</p>
<p>cluster.initial_master_nodes: node-1</p>
<h3 id="调整配置elasticsearch-yml"><a href="#调整配置elasticsearch-yml" class="headerlink" title="调整配置elasticsearch.yml"></a>调整配置elasticsearch.yml</h3><hr>
<p>vim config&#x2F;elasticsearch.yml</p>
<p>cluster.name: skywallking-es<br>network.host: 10.64.35.14<br>http.port: 9200<br>discovery.seed_hosts: [“10.64.35.14:9200”]<br>cluster.initial_master_nodes: [“10.64.35.14”]</p>
<h3 id="重启elasticsearch"><a href="#重启elasticsearch" class="headerlink" title="重启elasticsearch"></a>重启elasticsearch</h3><hr>
<p>#查看elasticsearch进程<br>ps -ef  grep elastic<br>#杀死进程<br>kill -9 PID<br>#启动elasticsearch<br>bin&#x2F;elasticsearch -d</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><hr>
<p>curl -X GET <a href="http://10.64.35.14:9200//_cat/nodes?pretty">http://10.64.35.14:9200/\_cat/nodes?pretty</a></p>
<p>10.64.35.14 12 23 0 0.07 0.08 0.08 dilmrt * code404.icu</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
        <tag>master_not_discovered_exception</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot exec</title>
    <url>/2022/01/02/error-1290-hy000-the-mysql-server-is-running-with-the-secure-file-priv-option-so-it-cannot-exec/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2022/01/image-2.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在Mysql中 使用 select from … into outfile 导出数据时报错<br>ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p>
<h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><hr>
<p>其实原因很简单，因为在安装MySQL的时候限制了导入与导出的目录权限。只允许在规定的目录下才能导入。<br>可以通过以下命令查看secure-file-priv当前的值是什么</p>
<p>SHOW VARIABLES LIKE “secure_file_priv”;</p>
<p><img src="https://img-blog.csdnimg.cn/bb4c51395b674859b722f5601ce97528.png" alt="在这里插入图片描述"><br>可以看到，本地value的值为 &#x2F;var&#x2F;lib&#x2F;mysql-files 。&#x2F;var&#x2F;lib&#x2F;mysql-files代表什么意思呢？经查资料：</p>
<ul>
<li>NULL，表示禁止。</li>
<li>如果value值有文件夹目录，则表示只允许该目录下文件（PS：测试子目录也不行）。</li>
<li>如果为空，则表示不限制目录。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><hr>
<p>把导入文件路径改成secure-file-priv目前的value值对应路径即可</p>
<p>如果secure-file-priv的value值为NULL<br>就把路径修改为准备导出文件的放置路径</p>
<p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p>
<p>vim &#x2F;etc&#x2F;my.cnf<br>secure_file_priv &#x3D; </p>
<p>重启mysql服务生效</p>
<p>mysql&gt; SHOW VARIABLES LIKE “secure_file_priv”;<br>+——————+——-+<br> Variable_name     Value<br>+——————+——-+<br> secure_file_priv<br>+——————+——-+<br>1 row in set (0.00 sec)</p>
<h3 id="重新导出表数据"><a href="#重新导出表数据" class="headerlink" title="重新导出表数据"></a>重新导出表数据</h3><hr>
<p>mysql&gt; select * from `dump-8005` into outfile ‘&#x2F;tmp&#x2F;dump8005.csv’ Fields terminated by ‘,,’;<br>Query OK, 0 rows affected (0.00 sec)<br>[root@mq2 ~]# ls &#x2F;tmp&#x2F;dump8005.csv<br>&#x2F;tmp&#x2F;dump8005.csv</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>outfile</tag>
        <tag>secure-file-priv</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR 1290 HY000: The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement</title>
    <url>/2021/12/19/error-1290-hy000-the-mysql-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this-statement/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-11.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>本地登录Mysql后执行下面语句报错<br>ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’;</p>
<p>ERROR 1290 HY000: The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement</p>
<h3 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h3><hr>
<p>The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement<br>意思貌似MYSQL还运行在 –skip-grant-tables模式，–skip-grant-tables模式可以重置root的密码，但是用–skip-grant-tables启动后修改密码又报错，如何让他回到原来的模式</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>执行命令关闭数据库只读属性</p>
<p>mysql&gt; set global read_only&#x3D;0;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; flush privileges;<br>Query OK, 0 rows affected (0.05 sec)<br>mysql&gt; show variables like ‘%read_only%’;<br>+——————+——-+<br> Variable_name   Value<br>+——————+——-+<br> innodb_read_only  OFF<br> read_only     OFF<br> tx_read_only    OFF<br>+——————+——-+<br>3 rows in set (0.00 sec) </p>
<h3 id="再次修改密码"><a href="#再次修改密码" class="headerlink" title="再次修改密码"></a>再次修改密码</h3><hr>
<p>这次就不报错了</p>
<p>mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’;<br>Query OK, 0 rows affected (0.04 sec)</p>
<h3 id="密码修改成功，退出skip-grant-tables模式"><a href="#密码修改成功，退出skip-grant-tables模式" class="headerlink" title="密码修改成功，退出skip-grant-tables模式"></a>密码修改成功，退出skip-grant-tables模式</h3><hr>
<p>kill 掉 mysqld_safe –skip-grant-tables 的进程就可以了</p>
<p>leenhem@DESKTOP-7SREO20:~$ sudo  &#x2F;etc&#x2F;init.d&#x2F;mysql start<br> * Starting MySQL database server mysqld<br>No directory, logging in with HOME&#x3D;&#x2F;[ OK ]</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>cannot execute this statement</tag>
        <tag>skip-grant-tables</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka 已停止的微服务节点注销慢或不注销怎么配置？</title>
    <url>/2021/11/05/eureka-%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%B3%A8%E9%94%80%E6%85%A2%E6%88%96%E4%B8%8D%E6%B3%A8%E9%94%80%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-5-1024x576.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在开发环境下，常常希望 Eureka Server 能迅速有效地注销已停止的微服务实例。然而由于 Eureka Server 清理无效节点周期长(默认 90s)，以及自我保护模式等原因，可能会遇到微服务注销慢甚至不注销的问题</p>
<h3 id="Eureka-Server端：配置关闭自我保护，并按需配置Eureka-Server清理无效节点的时间间隔。"><a href="#Eureka-Server端：配置关闭自我保护，并按需配置Eureka-Server清理无效节点的时间间隔。" class="headerlink" title="Eureka Server端：配置关闭自我保护，并按需配置Eureka Server清理无效节点的时间间隔。"></a>Eureka Server端：配置关闭自我保护，并按需配置Eureka Server清理无效节点的时间间隔。</h3><hr>
<p>eureka.server.enable-self-preservation # 设为false，关闭自我保护 从而保证会注销微服务<br>eureka.server.eviction-interval-timer-in-ms # 清理间隔（单位毫秒，默认是60*1000）</p>
<h3 id="Eureka-Client端：配置开启健康检查，并按需配置续约更新时间和到期时间。"><a href="#Eureka-Client端：配置开启健康检查，并按需配置续约更新时间和到期时间。" class="headerlink" title="Eureka Client端：配置开启健康检查，并按需配置续约更新时间和到期时间。"></a>Eureka Client端：配置开启健康检查，并按需配置续约更新时间和到期时间。</h3><hr>
<p>eureka.client .healthcheck .enabled #设为true，开启健康检查(需要spring-boot-starterractuator依赖)<br>eureka.instance.lease-renewal-interval-in-seconds # 续约更新时间间隔（默认30秒）<br>eureka.instance.lease-expiration-duration-in-seconds # 续约到期时间（默认90秒）</p>
<p>得注意的是，这些配置仅建议在开发或测试时使用，在生产环境下建议坚持便用默认</p>
<h3 id="下面给出两个示例"><a href="#下面给出两个示例" class="headerlink" title="下面给出两个示例"></a>下面给出两个示例</h3><hr>
<h4 id="Eureka-Server-配置-eureka-server"><a href="#Eureka-Server-配置-eureka-server" class="headerlink" title="Eureka Server 配置 eureka: server"></a>Eureka Server 配置 eureka: server</h4><p>eureka:<br>  server:<br>    enable-self-preservation: false<br>    eviction-interval-timer-in-ms: 4000</p>
<h4 id="Eureka-Client-配置-eureka-client"><a href="#Eureka-Client-配置-eureka-client" class="headerlink" title="Eureka Client 配置 eureka: client"></a>Eureka Client 配置 eureka: client</h4><p>eureka:<br>  client:<br>    healthcheck:<br>      enabled: true<br>  instance:<br>    lease-expiration-duration-in-seconds: 30<br>    lease-renewal-interval-in-seconds: 10</p>
<p>修改 Eureka 的续约频率可能会打破 Eureka 的自我保护特性，这意味着在生产环境中，如果想要使用 Eurcka 的自我保护特性，应坚持使用默认配置。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>Spring Cloud</tag>
        <tag>续约</tag>
        <tag>自我保护</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs-nginx-module file: ini_file_reader.c, line: 1036, include file &quot;http.conf&quot; not exists, line: &quot;#include http.conf&quot;</title>
    <url>/2021/12/04/fastdfs-nginx-module-file-ini-file-reader-c-line-1036-include-file-http-conf-not-exists-line-include-http-conf/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-2.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>fastdfs-nginx-module，nginx启动后，文件无法访问报错 include file “http.conf” not exists,</p>
<p>[2021-12-02 16:56:30] ERROR - file: ini_file_reader.c, line: 1036, include file “http.conf” not exists, line: “#include http.conf”<br>[2021-12-02 16:56:30] ERROR - file: &#x2F;data&#x2F;soft&#x2F;fastdfs-nginx-module&#x2F;src&#x2F;common.c, line: 155, load conf file “&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf” fail, ret code: 2<br>[2021-12-02 16:56:30] INFO - file: ini_file_reader.c, line: 1349, func: checkInitDynamicContentArray, init_pthread_lock<br>[2021-12-02 16:56:30] INFO - file: ini_file_reader.c, line: 1384, func: checkAllocDynamicContentArray, alloc count: 8<br>ngx_http_fastdfs_process_init pid&#x3D;69485</p>
<h3 id="fastdfs-nginx-module报错原因"><a href="#fastdfs-nginx-module报错原因" class="headerlink" title="fastdfs-nginx-module报错原因"></a>fastdfs-nginx-module报错原因</h3><hr>
<p>原因是 etc&#x2F;fdfs&#x2F; 下面没有 http.conf的配置</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>把&#x2F;FastDFS&#x2F;conf&#x2F;http.conf 复制到 etc&#x2F;fdfs&#x2F;下面就可以了</p>
<p>cp &#x2F;data&#x2F;soft&#x2F;FastDFS&#x2F;conf&#x2F;http.conf &#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;<br>cp &#x2F;data&#x2F;soft&#x2F;FastDFS&#x2F;conf&#x2F;mime.types &#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;</p>
<h3 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h3><hr>
<p>nginx&#x2F;sbin&#x2F;nginx -c nginx&#x2F;conf&#x2F;nginx.conf -s reload</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Fastdfs</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>fastdfs-nginx-module</tag>
        <tag>http.conf</tag>
        <tag>module</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs-nginx-module-master/src/common.c, line: 163, load conf file &quot;/etc/fdfs/mod_fastdfs.conf&quot;</title>
    <url>/2021/12/03/fastdfs-nginx-module-master-src-common-c-line-163-load-conf-file-etc-fdfs-mod-fastdfs-conf/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-1-1024x448.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在配置fastdfs-nginx-module时，nginx启动8888端口，访问<a href="http://localhost:8888/group1/M00/00/00/CgOYSGGoR5qASNqzAANi9H7oGe4006.jpg">http://localhost:8888/group1/M00/00/00/CgOYSGGoR5qASNqzAANi9H7oGe4006.jpg</a> 时无响应，查看nginx的error.log日志，发现报错 fastdfs-nginx-module-master&#x2F;src&#x2F;common.c, line: 163, load conf file “&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf” fail, ret code: 2</p>
<p>2021-11-30 17:13:01] ERROR - file: shared_func.c, line: 1163, file &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf not exist<br>[2021-11-30 17:13:01] ERROR - file: ..&#x2F;fastdfs-nginx-module-master&#x2F;src&#x2F;common.c, line: 163, load conf file “&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf” fail, ret code: 2<br>[2021-11-30 17:13:01] INFO - file: ini_file_reader.c, line: 1349, func: checkInitDynamicContentArray, init_pthread_lock<br>[2021-11-30 17:13:01] INFO - file: ini_file_reader.c, line: 1384, func: checkAllocDynamicContentArray, alloc count: 8<br>[2021-11-30 17:13:01] ERROR - file: shared_func.c, line: 1163, file &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf not exist<br>[2021-11-30 17:13:01] ERROR - file: ..&#x2F;fastdfs-nginx-module-master&#x2F;src&#x2F;common.c, line: 163, load conf file “&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf” fail, ret code: 2<br>2021&#x2F;11&#x2F;30 17:13:01 [alert] 128284#0: worker process 128288 exited with fatal code 2 and cannot be respawned<br>2021&#x2F;11&#x2F;30 17:13:01 [alert] 128284#0: worker process 128286 exited with fatal code 2 and cannot be respawned</p>
<h3 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h3><hr>
<p>fastdfs-nginx-module-master&#x2F;src&#x2F;common.c, line: 163, load conf file “&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf” fail, ret code: 2<br>看内容就知道加载配置文件 &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf 失败，出现这个报错的大概原因就是 &#x2F;etc&#x2F;fdfs 下面没有这个配置文件</p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><hr>
<p>由于自己安装fastdfs时修改了安装路径&#x2F;data&#x2F;fdfs&#x2F;，没有生成 &#x2F;etc&#x2F;dfs目录</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>修改 fastdfs-nginx-module-master&#x2F;src&#x2F;config<br>把 DFDFS_MOD_CONF_FILENAME 的路径改成自定义的目录就可以了<br>我这里 改成了&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf，一定要先把 mod_fastdfs.conf 复制过去</p>
<p>vim fastdfs-nginx-module-master&#x2F;src&#x2F;config</p>
<p>ngx_addon_name&#x3D;ngx_http_fastdfs_module</p>
<p>if test -n “${ngx_module_link}”; then<br>    ngx_module_type&#x3D;HTTP<br>    ngx_module_name&#x3D;$ngx_addon_name<br>    ngx_module_incs&#x3D;”&#x2F;usr&#x2F;include&#x2F;fastdfs &#x2F;usr&#x2F;include&#x2F;fastcommon&#x2F;“<br>    ngx_module_libs&#x3D;”-lfastcommon -lfdfsclient”<br>    ngx_module_srcs&#x3D;”$ngx_addon_dir&#x2F;ngx_http_fastdfs_module.c”<br>    ngx_module_deps&#x3D;<br>    CFLAGS&#x3D;”$CFLAGS -D_FILE_OFFSET_BITS&#x3D;64 -DFDFS_OUTPUT_CHUNK_SIZE&#x3D;’256*1024’ -DFDFS_MOD_CONF_FILENAME&#x3D;’\“&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf\“‘“<br>    . auto&#x2F;module<br>else<br>    HTTP_MODULES&#x3D;”$HTTP_MODULES ngx_http_fastdfs_module”<br>    NGX_ADDON_SRCS&#x3D;”$NGX_ADDON_SRCS $ngx_addon_dir&#x2F;ngx_http_fastdfs_module.c”<br>    CORE_INCS&#x3D;”$CORE_INCS &#x2F;usr&#x2F;include&#x2F;fastdfs &#x2F;usr&#x2F;include&#x2F;fastcommon&#x2F;“<br>    CORE_LIBS&#x3D;”$CORE_LIBS -lfastcommon -lfdfsclient”<br>    CFLAGS&#x3D;”$CFLAGS -D_FILE_OFFSET_BITS&#x3D;64 -DFDFS_OUTPUT_CHUNK_SIZE&#x3D;’256*1024’ -DFDFS_MOD_CONF_FILENAME&#x3D;’\“&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf\“‘“<br>fi</p>
<h3 id="重新编译nginx"><a href="#重新编译nginx" class="headerlink" title="重新编译nginx"></a>重新编译nginx</h3><hr>
<p>.&#x2F;configure –prefix&#x3D;&#x2F;data&#x2F;fdfsnginx –add-module&#x3D;..&#x2F;fastdfs-nginx-module&#x2F;src<br>make<br>make install</p>
<h3 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h3><hr>
<p>&#x2F;data&#x2F;fdfsnginx&#x2F;sbin&#x2F;nginx -c &#x2F;data&#x2F;fdfsnginx&#x2F;conf&#x2F;nginx.conf -s reload</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Fastdfs</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>fastdfs-nginx-module</tag>
        <tag>fastcommon</tag>
        <tag>mod_fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs-nginx-module 中报错 mod_fastdfs.conf\&quot;, host \&quot;tracker\&quot; is invalid</title>
    <url>/2021/12/05/fastdfs-nginx-module-%E4%B8%AD%E6%8A%A5%E9%94%99-mod-fastdfs-conf-host-tracker-is-invalid/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/03/2021033013033093.png" alt="fastdfs"></p>
<p>fastdfs</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>fastdfs-nginx-module 启动nginx 后 访问文件时报错 mod_fastdfs.conf”, host “tracker” is invalid</p>
<p>ngx_http_fastdfs_process_init pid&#x3D;69515<br>[2021-12-02 17:00:25] INFO - file: ini_file_reader.c, line: 1349, func: checkInitDynamicContentArray, init_pthread_lock<br>[2021-12-02 17:00:25] INFO - file: ini_file_reader.c, line: 1384, func: checkAllocDynamicContentArray, alloc count: 8<br>[2021-12-02 17:00:25] INFO - file: ini_file_reader.c, line: 1349, func: checkInitDynamicContentArray, init_pthread_lock<br>[2021-12-02 17:00:25] INFO - file: ini_file_reader.c, line: 1384, func: checkAllocDynamicContentArray, alloc count: 8<br>[2021-12-02 17:00:25] ERROR - file: client_func.c, line: 112, conf file “&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf”, host “tracker” is invalid<br>[2021-12-02 17:00:25] ERROR - file: client_func.c, line: 112, conf file “&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf”, host “tracker” is invalid<br>[2021-12-02 17:00:25] ERROR - file: client_func.c, line: 112, conf file “&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf”, host “tracker” is invalid<br>[2021-12-02 17:00:25] ERROR - file: client_func.c, line: 112, conf file “&#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf”, host “tracker” is invalid</p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><hr>
<p>原因就是 系统找不到tracker 对应的主机<br>查看 mod_fastdfs.conf 配置文件</p>
<p>vim &#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf<br>tracker_server&#x3D;tracker:22122 #把tracker 改成 tracker对应的IP地址就可以了</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<ol>
<li>把tracker 的改成对应的IP地址就可以说了</li>
</ol>
<p>vim &#x2F;data&#x2F;fdfs&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf<br>tracker_server&#x3D;192.168.1.100:22122</p>
<ol start="2">
<li>在系统的&#x2F;etc&#x2F;hosts上添加配置</li>
</ol>
<p>vim &#x2F;et&#x2F;hosts<br>192.168.1.100 tracker</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Fastdfs</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>fastdfs-nginx-module</tag>
        <tag>is invalid</tag>
        <tag>mod_fastdfs.conf</tag>
        <tag>tracker</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs-nginx-module 报错 ERROR - file: ../common/fdfs_global.c, line: 52, the format of filename &quot;group1/M00/00/00/CgOYSGGoR5qASNqzAANi9H7oGe4006.jpg” is invalid</title>
    <url>/2021/12/06/fastdfs-nginx-module-%E6%8A%A5%E9%94%99-error-file-common-fdfs-global-c-line-52-the-format-of-filename-group1-m00-00-00-cgoysggor5qasnqzaani9h7oge4006-jpg-is-invalid/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-3.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在使用fastdfs作为文件服务器时，上传文件成功后，访问时报如下错误：<br>[2021-12-02 17:10:15] ERROR - file: …&#x2F;common&#x2F;fdfs_global.c, line: 52, the format of filename “group1&#x2F;M00&#x2F;00&#x2F;00&#x2F;CgOYSGGoR5qASNqzAANi9H7oGe4006.jpg” is invalid</p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><hr>
<p>无法解析文件路径</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>etc&#x2F;fdfs&#x2F;mod_fastdfs.conf 中有个配置是url_have_group_name<br>意思是当mod_fastdfs.conf 配置文件中只有一个group1, 且配置了　url_have_group_name &#x3D; false　时，即访问地址不使用分组名称，我们这里有分组名称 group1<br>所以只需要改一下 url_have_group_name 就可以了</p>
<p>vim &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf<br>url_have_group_name &#x3D; true</p>
<p>然后重启fastdfs服务和nginx服务即可</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Fastdfs</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>fastdfs-nginx-module</tag>
        <tag>fdfs_global</tag>
        <tag>the format of filename</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs-nginx-moudle安装报错common.c:26:33: fatal error: fastdfs/fdfs_define.h: No such file or director</title>
    <url>/2021/11/30/fastdfs-nginx-moudle%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99common-c2633-fatal-error-fastdfs-fdfs-define-h-no-such-file-or-director/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-16.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>fastdfs 安装到了特定目录 ，普通用户安装fastdfs</p>
<p>TARGET_PREFIX&#x3D;&#x2F;data&#x2F;fastdfs&#x2F;user<br>TARGET_CONF_PATH&#x3D;&#x2F;data&#x2F;fastdfs&#x2F;etc&#x2F;fdfs<br>TARGET_INIT_PATH&#x3D;&#x2F;data&#x2F;fastdfs&#x2F;etc&#x2F;init.d</p>
<p>#mkdir -p &#x2F;etc&#x2F;fdfs #这一行注释掉了</p>
<p>Linux安装FastDFS报错 fastdfs-nginx-module-master&#x2F;src&#x2F;common.c:26:33: fatal error: fastdfs&#x2F;fdfs_define.h: No such file or directory</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr>
<p>安装时报错</p>
<p>&#x2F;data&#x2F;soft&#x2F;fastdfs-nginx-module-master&#x2F;src&#x2F;common.c:26:33: fatal error: fastdfs&#x2F;fdfs_define.h: No such file or directory<br> #include “fastdfs&#x2F;fdfs_define.h”</p>
<h3 id="查看fastdfs-nginx-module-x2F-src-x2F-config"><a href="#查看fastdfs-nginx-module-x2F-src-x2F-config" class="headerlink" title="查看fastdfs-nginx-module&#x2F;src&#x2F;config"></a>查看fastdfs-nginx-module&#x2F;src&#x2F;config</h3><hr>
<p># 这中间两行配置是引用fdfs的地方<br>if test -n “${ngx_module_link}”; then<br>    ngx_module_incs&#x3D;”&#x2F;usr&#x2F;local&#x2F;include”<br>    CORE_INCS&#x3D;”$CORE_INCS &#x2F;usr&#x2F;local&#x2F;include”<br>fi</p>
<p>也不用修改这个配置文件<br>我们把刚安装好的 lib 做好软链接</p>
<p># 看你安装的fastcommon在哪里，创建软链到&#x2F;usr&#x2F;local&#x2F;include<br>ln -sv &#x2F;usr&#x2F;include&#x2F;fastcommon &#x2F;usr&#x2F;local&#x2F;include&#x2F;fastcommon</p>
<h1 id="看你安装的fastdfs在哪里，创建软链到-x2F-usr-x2F-local-x2F-include-下"><a href="#看你安装的fastdfs在哪里，创建软链到-x2F-usr-x2F-local-x2F-include-下" class="headerlink" title="看你安装的fastdfs在哪里，创建软链到&#x2F;usr&#x2F;local&#x2F;include 下"></a>看你安装的fastdfs在哪里，创建软链到&#x2F;usr&#x2F;local&#x2F;include 下</h1><p>ln -sv &#x2F;data&#x2F;fastdfs&#x2F;usr&#x2F;include&#x2F;fastdfs &#x2F;usr&#x2F;local&#x2F;include&#x2F;fastdfs</p>
<h1 id="把libfastcommon-so-也做好软链"><a href="#把libfastcommon-so-也做好软链" class="headerlink" title="把libfastcommon.so 也做好软链"></a>把libfastcommon.so 也做好软链</h1><p>ln -sv &#x2F;usr&#x2F;lib64&#x2F;libfastcommon.so &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libfastcommon.so</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><hr>
<p>再次make</p>
<p>make install</p>
<p>OK。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>修改了Fastdfs的make.sh文件后，安装路径变了，导致fastdfs-nginx-moudle无法找到文件</p>
]]></content>
      <categories>
        <category>Fastdfs</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>fastdfs-nginx-module</tag>
        <tag>fdfs_define</tag>
        <tag>No such file or directory</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs报错 ERROR - file: /data/soft/fastdfs-nginx-module/src/common.c, line: 874, file: /home/yuqing/fastdfs/data/00/00/CgOYSGGoR5qASNqzAANi9H7oGe4006.jpg not exist</title>
    <url>/2021/12/07/fastdfs%E6%8A%A5%E9%94%99-error-file-data-soft-fastdfs-nginx-module-src-common-c-line-874-file-home-yuqing-fastdfs-data-00-00-cgoysggor5qasnqzaani9h7oge4006-jpg-not-exist/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-3.png" alt="fastdfs"></p>
<p>fastdfs</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>fastdfs上传文件后，下载报错<br>ERROR - file: &#x2F;data&#x2F;soft&#x2F;fastdfs-nginx-module&#x2F;src&#x2F;common.c, line: 874, file: &#x2F;home&#x2F;yuqing&#x2F;fastdfs&#x2F;data&#x2F;00&#x2F;00&#x2F;CgOYSGGoR5qASNqzAANi9H7oGe4006.jpg not exist</p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><hr>
<p>nginx 找不到上传的文件</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>mod_fastdfs.conf 配置里面的 下载路径，要和 storage.conf 的配置里面一样</p>
<p>修改 mod_fastdfs.conf 配置</p>
<p>store_path0&#x3D;&#x2F;data&#x2F;fdfs&#x2F; #文件存储目录</p>
<p>然后重启fastdfs服务和nginx服务即可</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Fastdfs</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>fastdfs-nginx-module</tag>
        <tag>store_path0</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>FastDFS高性能分布式文件系统安装手册</title>
    <url>/2021/04/01/fastdfs%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>FastDFS是一个开源的高性能分布式文件系统。</p>
<p>其主要功能包括：文件存储、文件同步和文件访问（文件上传和文件下载），解决了大容量和负载均衡问题。FastDFS应满足基于照片分享网站、视频分享网站等文件的网站的服务要求。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>服务</p>
<p>IP地址</p>
<p>系统</p>
<p>Tracker Server 跟踪器</p>
<p>192.168.10.130</p>
<p>Centos7.x</p>
<p>Storage Server1 存储节点</p>
<p>192.168.10.141</p>
<p>Centos7.x</p>
<p>Storage Server2 存储节点</p>
<p>192.168.10.142</p>
<p>Centos7.x</p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://github.com/happyfish100/FastDFS">https://github.com/happyfish100/FastDFS</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>名称</p>
<p>说明</p>
<p>Libfatscommon</p>
<p>FastDFS分离出的一些公用函数包</p>
<p>FastDFS</p>
<p>FastDFS分布式文件系统</p>
<p>Fastdfs-nginx-module</p>
<p>FastDFS和nginx的关联模块</p>
<p>Nginx</p>
<p>nginx1.15.4</p>
<h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y</span><br><span class="line">yum -y install net-tools #使用netstat查看端口需要</span><br></pre></td></tr></table></figure>

<p>如果服务器未联网状态需要手动下载缺少的环境包并进行安装</p>
<h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><p>说明</p>
<p>位置</p>
<p>所有安装包</p>
<p>&#x2F;dfs&#x2F;soft</p>
<p>tracker服务器数据存储位置</p>
<p>&#x2F;dfs&#x2F;tracker</p>
<p>storage服务器数据存储位置</p>
<p>&#x2F;dfs&#x2F;storage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /dfs/tracker #创建数据存储目录（tracker服务器）</span><br><span class="line">mkdir /dfs/storage #创建数据存储目录（storage服务器）</span><br></pre></td></tr></table></figure>

<h1 id="安装libfastcommon（tracker安装和storage安装）"><a href="#安装libfastcommon（tracker安装和storage安装）" class="headerlink" title="安装libfastcommon（tracker安装和storage安装）"></a>安装libfastcommon（tracker安装和storage安装）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /dfs/soft #切换到安装目录准备下载安装包</span><br><span class="line">git clone https://github.com/happyfish100/libfastcommon.git --depth 1</span><br><span class="line">#如果服务器未联网，需要手动下载libfastcommon的安装包，并且解压后进入libfastcommon目录，手动./make.sh &amp;&amp; ./make.sh install</span><br><span class="line">cd libfastcommon/</span><br><span class="line">./make.sh &amp;&amp; ./make.sh install #编译安装</span><br></pre></td></tr></table></figure>

<h1 id="安装FastDFS（tracker安装和storage安装）"><a href="#安装FastDFS（tracker安装和storage安装）" class="headerlink" title="安装FastDFS（tracker安装和storage安装）"></a>安装FastDFS（tracker安装和storage安装）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /dfs/soft #切换到安装目录准备下载安装包</span><br><span class="line">git clone https://github.com/happyfish100/fastdfs.git --depth 1</span><br><span class="line">#如果服务器未联网需要手动下载FastDfs的安装包，解压后进入fastdfs目录中，并手动./make.sh &amp;&amp; ./make.sh install</span><br><span class="line">cd fastdfs/</span><br><span class="line">./make.sh &amp;&amp; ./make.sh install #编译安装</span><br><span class="line">#配置文件准备</span><br><span class="line">cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf #tracker配置文件（tracker服务器使用）</span><br><span class="line">cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf #storage配置文件（storage服务器使用）</span><br><span class="line">cp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf #客户端文件，测试用</span><br><span class="line">cp /dfs/soft/Fastdfs/conf/http.conf /etc/fdfs/ #/dfs/soft/Fastdfs为fastdfs安装路径，这里是我的安装路径，请以自己的实际安装路径为准</span><br><span class="line">cp /dfs/soft/Fastdfs/conf/mime.types /etc/fdfs/ #/dfs/soft/Fastdfs为fastdfs安装路径，这里是我的安装路径，请以自己的实际安装路径为准</span><br></pre></td></tr></table></figure>

<h1 id="安装fastdfs-nginx-module（storage服务器安装）"><a href="#安装fastdfs-nginx-module（storage服务器安装）" class="headerlink" title="安装fastdfs-nginx-module（storage服务器安装）"></a>安装fastdfs-nginx-module（storage服务器安装）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /dfs/soft #切换到安装目录准备下载安装包</span><br><span class="line">git clone https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1</span><br><span class="line">#如果服务器未连接互联网，需要手动下载fastdfs-nginx-module包，并解压</span><br><span class="line">#此处的fastdfs-nginx-module包需要注意版本</span><br><span class="line">cp /dfs/soft/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs # /dfs/soft/fastdfs-nginx-module为解压目录，这里是我的目录，实际请以自己的为准</span><br></pre></td></tr></table></figure>

<h1 id="安装Nginx（storage服务器安装）"><a href="#安装Nginx（storage服务器安装）" class="headerlink" title="安装Nginx（storage服务器安装）"></a>安装Nginx（storage服务器安装）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /dfs/soft #切换到安装目录准备下载安装包</span><br><span class="line">wget http://nginx.org/download/nginx-1.15.4.tar.gz #下载nginx压缩包</span><br><span class="line">#如果服务器未连接互联网，需要手动下载nginx包，并解压</span><br><span class="line">tar -zxvf nginx-1.15.4.tar.gz #解压</span><br><span class="line">cd nginx-1.15.4/</span><br><span class="line">#添加fastdfs-nginx-module模块(prefix指定一个自己的nginx目录，add-module指定对应的fastdfs-nginx-module目录)</span><br><span class="line">./configure --prefix=/dfs/soft/nginx --add-module=/dfs/soft/fastdfs-nginx-module/src/ #/dfs/soft/fastdfs-nginx-module这里是我自己的目录，实际请以自己的为准</span><br><span class="line">make &amp;&amp; make install #编译安装</span><br></pre></td></tr></table></figure>

<h1 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h1><p>略</p>
<h1 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h1><h2 id="Tracker配置"><a href="#Tracker配置" class="headerlink" title="Tracker配置"></a>Tracker配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fdfs/tracker.conf</span><br><span class="line">#需要修改的内容如下</span><br><span class="line">port=22122  # tracker服务器端口（默认22122,一般不修改）</span><br><span class="line">base_path=/dfs/tracker  # 存储tracker日志和数据的根目录</span><br><span class="line">store_group=group1 #设置组名</span><br><span class="line">http.server_port = 8080 #tracker HTTP服务端口</span><br></pre></td></tr></table></figure>

<p>修改防火墙，开放22122端口和8080端口（iptables或firewall，此处以firewall为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开放端口</span><br><span class="line">firewall-cmd --permanent --add-port=22122/tcp</span><br><span class="line">firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line">#重启防火墙(修改配置后要重启防火墙)</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查询端口是否开放</span><br><span class="line">firewall-cmd --query-port=22122/tcp</span><br><span class="line">firewall-cmd --query-port=8080/tcp</span><br></pre></td></tr></table></figure>

<p>启动Tracker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/init.d/fdfs_trackerd start #启动tracker服务</span><br><span class="line">/etc/init.d/fdfs_trackerd restart #重启动tracker服务</span><br><span class="line">/etc/init.d/fdfs_trackerd stop #停止tracker服务</span><br><span class="line">chkconfig fdfs_trackerd on #自启动tracker服务</span><br></pre></td></tr></table></figure>

<h2 id="Storage配置"><a href="#Storage配置" class="headerlink" title="Storage配置"></a>Storage配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fdfs/storage.conf</span><br><span class="line">#需要修改的内容如下</span><br><span class="line">port=23000  # storage服务端口（默认23000,一般不修改）</span><br><span class="line">base_path=/dfs/storage  # 数据和日志文件存储根目录</span><br><span class="line">store_path0=/dfs/storage  # 第一个存储目录</span><br><span class="line">tracker_server=192.168.10.130:22122  # tracker服务器1</span><br><span class="line">#tracker_server=192.168.10.131:22122  # tracker服务器2</span><br><span class="line">#tracker_server=192.168.10.132:22122  # tracker服务器3</span><br><span class="line">http.server_port=8888  # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)</span><br></pre></td></tr></table></figure>

<p>修改防火墙，开放23000端口和8888端口（iptables或firewall，此处以firewall为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开放端口</span><br><span class="line">firewall-cmd --permanent --add-port=23000/tcp</span><br><span class="line">firewall-cmd --permanent --add-port=8888/tcp</span><br><span class="line">#重启防火墙(修改配置后要重启防火墙)</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查询端口是否开放</span><br><span class="line">firewall-cmd --query-port=23000/tcp</span><br><span class="line">firewall-cmd --query-port=8888/tcp</span><br></pre></td></tr></table></figure>

<p>启动Storage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/init.d/fdfs_storaged start #启动storage服务</span><br><span class="line">/etc/init.d/fdfs_storaged restart #重动storage服务</span><br><span class="line">/etc/init.d/fdfs_storaged stop #停止动storage服务</span><br><span class="line">chkconfig fdfs_storaged on #自启动storage服务</span><br></pre></td></tr></table></figure>

<h1 id="Client测试（storage服务器）"><a href="#Client测试（storage服务器）" class="headerlink" title="Client测试（storage服务器）"></a>Client测试（storage服务器）</h1><p>修改client.conf配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fdfs/client.conf</span><br><span class="line">#需要修改的内容如下</span><br><span class="line">base_path=/dfs/tracker #tracker服务器</span><br><span class="line">tracker_server=192.168.10.130:22122  # tracker服务器1</span><br><span class="line">#tracker_server=192.168.10.131:22122  # tracker服务器2</span><br><span class="line">#tracker_server=192.168.10.132:22122  # tracker服务器3</span><br><span class="line">http.tracker_server_port=8080 #修改端口</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gz</span><br><span class="line">fdfs_upload_file /etc/fdfs/client.conf /dfs/BLEACH.jpg</span><br></pre></td></tr></table></figure>

<h1 id="配置Nginx使可以通过HTTP访问"><a href="#配置Nginx使可以通过HTTP访问" class="headerlink" title="配置Nginx使可以通过HTTP访问"></a>配置Nginx使可以通过HTTP访问</h1><p>修改nginx-module</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fdfs/mod_fastdfs.conf</span><br><span class="line">#需要修改的内容如下</span><br><span class="line">tracker_server=192.168.10.130:22122  # 服务器1</span><br><span class="line">#tracker_server=192.168.10.131:22122  # 服务器2</span><br><span class="line">#tracker_server=192.168.10.132:22122  # 服务器3</span><br><span class="line">url_have_group_name=true #访问路径中携带组名,如group1</span><br><span class="line">store_path0=/dfs/storage #storage地址</span><br></pre></td></tr></table></figure>

<p>修改nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置nginx.config</span><br><span class="line">vim /dfs/soft/nginx/conf/nginx.conf #/dfs/soft为上面添加nginx模块的时候指定的--prefix地址</span><br><span class="line">#添加如下配置</span><br><span class="line">server &#123;</span><br><span class="line">    listen       8888;    ## 该端口为storage.conf中的http.server_port相同</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location ~/group[0-9]/ &#123;</span><br><span class="line">        ngx_fastdfs_module;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动Nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dfs/soft/nginx/sbin/nginx #启动nginx</span><br><span class="line">/dfs/soft/nginx/sbin/nginx -s reload #重启nginx</span><br><span class="line">/dfs/soft/nginx/sbin/nginx -s stop #停止nginx</span><br><span class="line">#/dfs/soft为上面添加nginx模块的时候指定的--prefix地址</span><br></pre></td></tr></table></figure>

<p>测试<a href="http://">http://192.168.10.141:8888/group1/M00/00/00/wKgKhV6k76eAZAdDAANi9E9uQJc047.jpg</a><a href="http://">http://192.168.10.142:8888/group1/M00/00/00/wKgKhV6k76eAZAdDAANi9E9uQJc047.jpg</a></p>
<h1 id="检测集群"><a href="#检测集群" class="headerlink" title="检测集群"></a>检测集群</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</span><br><span class="line"># 会显示会有几台服务器 有3台就会 显示 Storage 1-Storage 3的详细信息</span><br><span class="line">#ACTIVE 为启动状态  </span><br></pre></td></tr></table></figure>

<h1 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h1><p>1.如果不是root 用户 你必须在除了cd的命令之外 全部加sudo</p>
<p>2.如果不是root 用户 编译和安装分开进行 先编译再安装</p>
<p>3.如果上传成功 但是nginx报错404先检查mod_fastdfs.conf文件中的store_path0是否一致</p>
<p>4.如果nginx无法访问 先检查防火墙 和mod_fastdfs.conf文件tracker_server是否一致</p>
<p>5.如果不是在&#x2F;usr&#x2F;local&#x2F;src文件夹下安装 可能会编译出错</p>
<p>6.如果 unknown directive “ngx_fastdfs_module” in &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:151，可能是nginx一直是启动的，必须要重启nginx才可以，nginx -s reload无效。</p>
<p>7.如果遇到storage状态是WAIT_SYNC状态就把storage从集群中删除，然后在重新启动storage服务，使用如下命令，如果一次不成功，多试几次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭storage服务</span><br><span class="line">/usr/init.d/fdfs_storage stop</span><br><span class="line">#删除192.xx.xxx.151这台服务器上的storage </span><br><span class="line">/usr/bin/fdfs_monitor /etc/fdfs/client.conf delete group1 192.xx.xxx.141</span><br><span class="line">#启动storage服务</span><br><span class="line">/usr/init.d/fdfs_storage start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>分布式</tag>
        <tag>文件系统</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone报错 server certificate verification failed. CAfile: none CRLfile: none</title>
    <url>/2021/05/11/git-clone%E6%8A%A5%E9%94%99-server-certificate-verification-failed-cafile-none-crlfile-none/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-15.png"></p>
<p>当使用命令 git pull 出现错误信息如下:<br>server certificate verification failed. CAfile: none CRLfile: none<br>解决方案:</p>
<p>git config –global http.sslverify false<br>git config –global https.sslverify false</p>
<p>git clone报错：“server certificate verification failed. CAfile: &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ca-certificates.crt CRLfile: none”<br>I can push by clone project using ssh, but it doesn’t work when I clone project with https. it shows message error as below.</p>
<p>server certificate verification failed. CAfile: &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ca-certificates.crt CRLfile: none</p>
<p>解决方案：<br>Open your terminal and run following command:</p>
<p>export GIT_SSL_NO_VERIFY&#x3D;1</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>CAfile</tag>
        <tag>certificate</tag>
        <tag>git</tag>
        <tag>git clone</tag>
        <tag>verification</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub上传大文件_Github管理大文件lfs</title>
    <url>/2021/05/31/github%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6-github%E7%AE%A1%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6lfs/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-57.png"></p>
<p>GitHub不允许直接上传大文件（超过100M）的文件到远程仓库，若要想继续提交可以尝试使用大文件支持库：使用的简单步骤：</p>
<h2 id="安装git-lfs"><a href="#安装git-lfs" class="headerlink" title="安装git-lfs"></a>安装git-lfs</h2><p>去GitHub上找到自己需要的<a href="https://github.com/git-lfs/git-lfs/releases">版本</a></p>
<p>我用的是ubuntu的</p>
<p>sudo apt-get install git-lfs</p>
<h2 id="开启lfs功能"><a href="#开启lfs功能" class="headerlink" title="开启lfs功能"></a>开启lfs功能</h2><p>git lfs install</p>
<h2 id="添加大文件"><a href="#添加大文件" class="headerlink" title="添加大文件"></a>添加大文件</h2><p>使用 git lfs track 命令进行大文件追踪 例如git lfs track “*.png” 追踪所有后缀为png的文件</p>
<p>git lfs track Nessus8.14破解版&#x2F;Nessus-8.14.0-es7.x86_64.rpm</p>
<p>查看GIT LFS管理的文件</p>
<p>git lfs track</p>
<p>或者 显示当前跟踪的文件列表</p>
<p>git lfs ls-files</p>
<h2 id="自动生成-gitattributes"><a href="#自动生成-gitattributes" class="headerlink" title="自动生成.gitattributes"></a>自动生成.gitattributes</h2><p>上面 执行 <code>git lfs track ...</code>后会自动生成 <code>.gitattributes</code><br>如果没有生成，我们可以自己创建 <code>.gitattributes</code> 文件<br>文件内容为：</p>
<p>cat .gitattributes<br>Nessus8.14破解版&#x2F;Nessus-8.14.0-es7.x86_64.rpm filter&#x3D;lfs diff&#x3D;lfs merge&#x3D;lfs -text<br>Nessus8.14破解版&#x2F;all-2.0.tar.gz filter&#x3D;lfs diff&#x3D;lfs merge&#x3D;lfs -text</p>
<h2 id="提交-gitattributess配置文件"><a href="#提交-gitattributess配置文件" class="headerlink" title="提交 .gitattributess配置文件"></a>提交 .gitattributess配置文件</h2><p>注意：要先提交配置文件，再提交大文件</p>
<p> git add .gitattributes<br> git commit -m “添加大文件支持”<br> git push</p>
<h2 id="提交-大文件"><a href="#提交-大文件" class="headerlink" title="提交 大文件"></a>提交 大文件</h2><p> git add Nessus8.14破解版&#x2F;*<br> git commit -m “添加软件件Nessus”<br> git push</p>
<h2 id="1、提交时可能遇到问题"><a href="#1、提交时可能遇到问题" class="headerlink" title="1、提交时可能遇到问题"></a>1、提交时可能遇到问题</h2><p>remote: error: GH001: Large files detected. You may want to try Git Large File Storage - <a href="https://git-lfs.github.com/">https://git-lfs.github.com</a>.</p>
<p>leenhem@DESKTOP-0ACGT17:&#x2F;mnt&#x2F;c&#x2F;workspace&#x2F;code&#x2F;software$ git push<br>Username for ‘<a href="https://github.com&/#39;">https://github.com&#39;</a>: leenhem<br>Password for ‘<a href="https://leenhem@github.com&/#39;">https://leenhem@github.com&#39;</a>:<br>Enumerating objects: 11, done.<br>Counting objects: 100% (11&#x2F;11), done.<br>Delta compression using up to 4 threads<br>Compressing objects: 100% (10&#x2F;10), done.<br>Writing objects: 100% (10&#x2F;10), 342.56 MiB  25.16 MiB&#x2F;s, done.<br>Total 10 (delta 1), reused 0 (delta 0)<br>remote: Resolving deltas: 100% (1&#x2F;1), done.<br>remote: error: GH001: Large files detected. You may want to try Git Large File Storage - <a href="https://git-lfs.github.com/">https://git-lfs.github.com</a>.<br>remote: error: Trace: 0e943ab99b89439cfe86e15a06ca164ac242bda2fbe0c3e4fc156f3b8fcc24a9<br>remote: error: See <a href="http://git.io/iEPt8g">http://git.io/iEPt8g</a> for more information.<br>remote: error: File Nessus8.14破解版&#x2F;all-2.0.tar.gz is 301.99 MB; this exceeds GitHub’s file size limit of 100.00 MB<br>To <a href="https://github.com/leenhem/software.git">https://github.com/leenhem/software.git</a><br> ! [remote rejected] master -&gt; master (pre-receive hook declined)<br>error: failed to push some refs to ‘<a href="https://github.com/leenhem/software.git&#39;">https://github.com/leenhem/software.git&#39;</a></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>先把这个.gitattributes跟踪文件提交上传到远程，再把大文件提交并上传到远程的，这个要注意顺序。</p>
<h2 id="2、提交时可能遇到问题"><a href="#2、提交时可能遇到问题" class="headerlink" title="2、提交时可能遇到问题"></a>2、提交时可能遇到问题</h2><p>Remote “origin” does not support the LFS locking API. Consider disabling it with:<br>$ git config lfs.<a href="https://github.com/leenhem/software.git/info/lfs.locksverify">https://github.com/leenhem/software.git/info/lfs.locksverify</a> false<br>Post <a href="https://github.com/leenhem/software.git/info/lfs/locks/verify">https://github.com/leenhem/software.git/info/lfs/locks/verify</a>: unexpected EOF<br>error: failed to push some refs to ‘<a href="https://github.com/leenhem/software.git%E2%80%99">https://github.com/leenhem/software.git’</a></p>
<p>leenhem@DESKTOP-0ACGT17:&#x2F;mnt&#x2F;c&#x2F;workspace&#x2F;code&#x2F;software1&#x2F;software$ git push<br>Username for ‘<a href="https://github.com&/#39;">https://github.com&#39;</a>: leenhem<br>Password for ‘<a href="https://leenhem@github.com&/#39;">https://leenhem@github.com&#39;</a>:<br>Remote “origin” does not support the LFS locking API. Consider disabling it with:<br>  $ git config lfs.<a href="https://github.com/leenhem/software.git/info/lfs.locksverify">https://github.com/leenhem/software.git/info/lfs.locksverify</a> false<br>Post <a href="https://github.com/leenhem/software.git/info/lfs/locks/verify">https://github.com/leenhem/software.git/info/lfs/locks/verify</a>: unexpected EOF<br>error: failed to push some refs to ‘<a href="https://github.com/leenhem/software.git&#39;">https://github.com/leenhem/software.git&#39;</a></p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>按照提示执行命令</p>
<p>git config lfs.<a href="https://github.com/leenhem/software.git/info/lfs.locksverify">https://github.com/leenhem/software.git/info/lfs.locksverify</a> false</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>lfs</tag>
        <tag>大文件</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言如何连接Mysql数据库</title>
    <url>/2021/09/23/go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-20.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Go原生提供了连接数据库操作的支持，在用 Golang进行开发的时候，如果需要在和数据库交互，则可以使用database&#x2F;sql包。这是一个对关系型数据库的通用抽象，它提供了标准的、轻量的、面向行的接口。</p>
<p>在Go中访问数据库需要用到sql.DB接口：它可以创建语句(statement)和事务(transaction)，执行查询，获取结果。</p>
<p>使用数据库时，除了database&#x2F;sql包本身，还需要引入想使用的特定数据库驱动。官方不提供实现，先下载第三方的实现，点击这里查看各种各样的实现版本。</p>
<h3 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h3><hr>
<p>本文测试数据库为mysql，使用的驱动为:github.com&#x2F;go-sql-driver&#x2F;mysql,需要引入的包为：</p>
<p>“database&#x2F;sql”<br>_ “github.com&#x2F;go-sql-driver&#x2F;mysql”</p>
<p>解释一下导入包名前面的”_“作用：</p>
<p>import 下划线（如：import _ github&#x2F;demo）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。</p>
<p>上面的mysql驱动中引入的就是mysql包中各个init()方法，你无法通过包名来调用包中的其他函数。导入时，驱动的初始化函数会调用sql.Register将自己注册在database&#x2F;sql包的全局变量sql.drivers中，以便以后通过sql.Open访问。</p>
<p>执行数据库操作之前我们准备一张表：</p>
<p>CREATE TABLE `user` (<br>    `id` bigint(20) NOT NULL AUTO_INCREMENT,<br>    `name` varchar(45) DEFAULT ‘’,<br>    `age` int(11) NOT NULL DEFAULT ‘0’,<br>    `sex` tinyint(3) NOT NULL DEFAULT ‘0’,<br>    `phone` varchar(45) NOT NULL DEFAULT ‘’,<br>    PRIMARY KEY (`id`)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8;</p>
<h3 id="1-初始化数据库连接："><a href="#1-初始化数据库连接：" class="headerlink" title="1. 初始化数据库连接："></a>1. 初始化数据库连接：</h3><p>DB, _ :&#x3D; sql.Open(“mysql”, “root:123456@tcp(127.0.0.1:3306)&#x2F;test”)<br>&#x2F;&#x2F;设置数据库最大连接数<br>DB.SetConnMaxLifetime(100)<br>&#x2F;&#x2F;设置上数据库最大闲置连接数<br>DB.SetMaxIdleConns(10)<br>&#x2F;&#x2F;验证连接<br>if err :&#x3D; DB.Ping(); err !&#x3D; nil {<br>    fmt.Println(“open database fail”)<br>    return<br>}<br>fmt.Println(“connnect success”)</p>
<p>sql.Open()中的数据库连接串格式为：“用户名:密码@tcp(IP:端口)&#x2F;数据库?charset&#x3D;utf8”。</p>
<p>DB的类型为:*sql.DB，有了DB之后我们就可以执行CRUD操作。Go将数据库操作分为两类：Query与Exec。两者的区别在于前者会返回结果，而后者不会。</p>
<ul>
<li>Query表示查询，它会从数据库获取查询结果（一系列行，可能为空）。</li>
<li>Exec表示执行语句，它不会返回行。</li>
</ul>
<p>此外还有两种常见的数据库操作模式：</p>
<ul>
<li>QueryRow表示只返回一行的查询，作为Query的一个常见特例。</li>
<li>Prepare表示准备一个需要多次使用的语句，供后续执行用。</li>
</ul>
<h3 id="2-查询操作"><a href="#2-查询操作" class="headerlink" title="2. 查询操作"></a>2. 查询操作</h3><hr>
<p>var user User<br>rows, e :&#x3D; DB.Query(“select * from user where id in (1,2,3)”)<br>if e &#x3D;&#x3D; nil {<br>    errors.New(“query incur error”)<br>}<br>for rows.Next(){<br>    e :&#x3D; rows.Scan(user.sex, user.phone, user.name, user.id, user.age)<br>    if e !&#x3D; nil{<br>        fmt.Println(json.Marshal(user))<br>    }<br>}<br>rows.Close()<br>&#x2F;&#x2F;单行查询操作<br>DB.QueryRow(“select * from user where id&#x3D;1”).Scan(user.age, user.id, user.name, user.phone, user.sex)</p>
<p>整体工作流程如下：</p>
<ul>
<li>使用db.Query()来发送查询到数据库，获取结果集Rows，并检查错误。</li>
<li>使用rows.Next()作为循环条件，迭代读取结果集。</li>
<li>使用rows.Scan从结果集中获取一行结果。</li>
<li>使用rows.Err()在退出迭代后检查错误。</li>
<li>使用rows.Close()关闭结果集，释放连接。</li>
</ul>
<h3 id="3-增删改和Exec"><a href="#3-增删改和Exec" class="headerlink" title="3. 增删改和Exec"></a>3. 增删改和Exec</h3><hr>
<p>通常不会约束你查询必须用Query，只是Query会返回结果集，而Exec不会返回。所以如果你执行的是增删改操作一般用Exec会好一些。Exec返回的结果是Result，Result接口允许获取执行结果的元数据:</p>
<p>type Result interface {<br>    &#x2F;&#x2F; 用于返回自增ID，并不是所有的关系型数据库都有这个功能。<br>    LastInsertId() (int64, error)<br>    &#x2F;&#x2F; 返回受影响的行数。<br>    RowsAffected() (int64, error)<br>}</p>
<h3 id="4-准备查询"><a href="#4-准备查询" class="headerlink" title="4. 准备查询"></a>4. 准备查询</h3><hr>
<p>如果你现在想使用占位符的功能，where 的条件想以参数的形式传入，Go提供了db.Prepare语句来帮你绑定。准备查询的结果是一个准备好的语句（prepared statement），语句中可以包含执行时所需参数的占位符（即绑定值）。准备查询比拼字符串的方式好很多，它可以转义参数，避免SQL注入。同时，准备查询对于一些数据库也省去了解析和生成执行计划的开销，有利于性能。</p>
<p><strong>占位符</strong><br>PostgreSQL使用$N作为占位符，N是一个从1开始递增的整数，代表参数的位置，方便参数的重复使用。MySQL使用?作为占位符，SQLite两种占位符都可以，而Oracle则使用:param1的形式。</p>
<p>MySQL               PostgreSQL            Oracle<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;               &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;            &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>WHERE col &#x3D; ?       WHERE col &#x3D; $1        WHERE col &#x3D; :col<br>VALUES(?, ?, ?)     VALUES($1, $2, $3)    VALUES(:val1, :val2, :val3)<br>stmt, e :&#x3D; DB.Prepare(“select * from user where id&#x3D;?”)<br>query, e :&#x3D; stmt.Query(1)<br>query.Scan()</p>
<h3 id="5-事务的使用"><a href="#5-事务的使用" class="headerlink" title="5. 事务的使用"></a>5. 事务的使用</h3><p>通过db.Begin()来开启一个事务，Begin方法会返回一个事务对象Tx。在结果变量Tx上调用Commit()或者Rollback()方法会提交或回滚变更，并关闭事务。在底层，Tx会从连接池中获得一个连接并在事务过程中保持对它的独占。事务对象Tx上的方法与数据库对象sql.DB的方法一一对应，例如Query,Exec等。事务对象也可以准备(prepare)查询，由事务创建的准备语句会显式绑定到创建它的事务。</p>
<p>&#x2F;&#x2F;开启事务<br>tx, err :&#x3D; DB.Begin()<br>if err !&#x3D; nil {<br>    fmt.Println(“tx fail”)<br>}<br>&#x2F;&#x2F;准备sql语句<br>stmt, err :&#x3D; tx.Prepare(“DELETE FROM user WHERE id &#x3D; ?”)<br>if err !&#x3D; nil {<br>    fmt.Println(“Prepare fail”)<br>    return false<br>}<br>&#x2F;&#x2F;设置参数以及执行sql语句<br>res, err :&#x3D; stmt.Exec(user.id)<br>if err !&#x3D; nil {<br>    fmt.Println(“Exec fail”)<br>    return false<br>}<br>&#x2F;&#x2F;提交事务<br>tx.Commit()</p>
<p>我们来一个完整的sql操作：</p>
<p>package main</p>
<p>import (<br>    “database&#x2F;sql”<br>    “encoding&#x2F;json”<br>    “fmt”<br>    _ “github.com&#x2F;go-sql-driver&#x2F;mysql”<br>    “github.com&#x2F;pkg&#x2F;errors”<br>    “strings”<br>)</p>
<p>&#x2F;&#x2F;数据库配置<br>const (<br>    userName &#x3D; “root”<br>    password &#x3D; “123456”<br>    ip       &#x3D; “127.0.0.1”<br>    port     &#x3D; “3306”<br>    dbName   &#x3D; “test”<br>)</p>
<p>&#x2F;&#x2F;Db数据库连接池<br>var DB *sql.DB</p>
<p>type User struct {<br>    id    int64<br>    name  string<br>    age   int8<br>    sex   int8<br>    phone string<br>}</p>
<p>&#x2F;&#x2F;注意方法名大写，就是public<br>func InitDB() {<br>    &#x2F;&#x2F;构建连接：”用户名:密码@tcp(IP:端口)&#x2F;数据库?charset&#x3D;utf8”<br>    path :&#x3D; strings.Join([]string{userName, “:”, password, “@tcp(“, ip, “:”, port, “)&#x2F;“, dbName, “?charset&#x3D;utf8”}, “”)<br>    &#x2F;&#x2F;打开数据库,前者是驱动名，所以要导入： _ “github.com&#x2F;go-sql-driver&#x2F;mysql”<br>    DB, _ &#x3D; sql.Open(“mysql”, path)<br>    &#x2F;&#x2F;设置数据库最大连接数<br>    DB.SetConnMaxLifetime(100)<br>    &#x2F;&#x2F;设置上数据库最大闲置连接数<br>    DB.SetMaxIdleConns(10)<br>    &#x2F;&#x2F;验证连接<br>    if err :&#x3D; DB.Ping(); err !&#x3D; nil {<br>        fmt.Println(“open database fail”)<br>        return<br>    }<br>    fmt.Println(“connnect success”)<br>}</p>
<p>&#x2F;&#x2F;查询操作<br>func Query() {<br>    var user User<br>    rows, e :&#x3D; DB.Query(“select * from user where id in (1,2,3)”)<br>    if e &#x3D;&#x3D; nil {<br>        errors.New(“query incur error”)<br>    }<br>    for rows.Next() {<br>        e :&#x3D; rows.Scan(user.sex, user.phone, user.name, user.id, user.age)<br>        if e !&#x3D; nil {<br>            fmt.Println(json.Marshal(user))<br>        }<br>    }<br>    rows.Close()<br>    DB.QueryRow(“select * from user where id&#x3D;1”).Scan(user.age, user.id, user.name, user.phone, user.sex)</p>
<pre><code>stmt, e := DB.Prepare(&quot;select \* from user where id=?&quot;)
query, e := stmt.Query(1)
query.Scan()
</code></pre>
<p>}</p>
<p>func DeleteUser(user User) bool {<br>    &#x2F;&#x2F;开启事务<br>    tx, err :&#x3D; DB.Begin()<br>    if err !&#x3D; nil {<br>        fmt.Println(“tx fail”)<br>    }<br>    &#x2F;&#x2F;准备sql语句<br>    stmt, err :&#x3D; tx.Prepare(“DELETE FROM user WHERE id &#x3D; ?”)<br>    if err !&#x3D; nil {<br>        fmt.Println(“Prepare fail”)<br>        return false<br>    }<br>    &#x2F;&#x2F;设置参数以及执行sql语句<br>    res, err :&#x3D; stmt.Exec(user.id)<br>    if err !&#x3D; nil {<br>        fmt.Println(“Exec fail”)<br>        return false<br>    }<br>    &#x2F;&#x2F;提交事务<br>    tx.Commit()<br>    &#x2F;&#x2F;获得上一个insert的id<br>    fmt.Println(res.LastInsertId())<br>    return true<br>}</p>
<p>func InsertUser(user User) bool {<br>    &#x2F;&#x2F;开启事务<br>    tx, err :&#x3D; DB.Begin()<br>    if err !&#x3D; nil {<br>        fmt.Println(“tx fail”)<br>        return false<br>    }<br>    &#x2F;&#x2F;准备sql语句<br>    stmt, err :&#x3D; tx.Prepare(“INSERT INTO user (`name`, `phone`) VALUES (?, ?)”)<br>    if err !&#x3D; nil {<br>        fmt.Println(“Prepare fail”)<br>        return false<br>    }<br>    &#x2F;&#x2F;将参数传递到sql语句中并且执行<br>    res, err :&#x3D; stmt.Exec(user.name, user.phone)<br>    if err !&#x3D; nil {<br>        fmt.Println(“Exec fail”)<br>        return false<br>    }<br>    &#x2F;&#x2F;将事务提交<br>    tx.Commit()<br>    &#x2F;&#x2F;获得上一个插入自增的id<br>    fmt.Println(res.LastInsertId())<br>    return true<br>}</p>
<p>func main() {<br>    InitDB()<br>    Query()<br>    defer DB.Close()<br>}</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>go</tag>
        <tag>连接数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana如何配置钉钉告警？</title>
    <url>/2021/10/03/grafana%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-30-1024x534.png"></p>
<h3 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h3><hr>
<p>Grafana+钉钉只是告警渠道的其中之一，这种方式没有告警收敛、告警静默等功能，如果阈值设置不合适，很容易导致告警泛滥。</p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>依托于多数据源的特性，Grafana 可以说是运维监控中不可缺少的一环，可以将运维过程中隔离的数据进行集中展示，如：Zabbix 主机资源、ELK 流量、MySQL 运营数据、容器监控等等。<br>其中 Grafana 最新版本 v8.0 对告警系统的重构，也足以看出官方对 Grafana 在监控告警方面的重视。另外，阿里云云监控、蓝鲸监控等场景也都有 Grafana 的影子，也说明了用户对其不同程度的依赖。<br>言归正传，对于 Grafana 钉钉告警不是什么新鲜事，关键在于当 grafana 告警渠道配置”Include image”，而此时 grafana 又位于内网服务器无法上网，钉钉告警如何包含图片截图，就成了我们需要面对的问题。</p>
<h3 id="告警渠道"><a href="#告警渠道" class="headerlink" title="告警渠道"></a>告警渠道</h3><hr>
<h4 id="1-钉钉添加机器人"><a href="#1-钉钉添加机器人" class="headerlink" title="1.钉钉添加机器人"></a>1.钉钉添加机器人</h4><hr>
<p>新建“统一监控告警平台”，通过“智能群助手”添加钉钉机器人，一般选择 自定义（通过 Webhook 接入自定义服务）类型的机器人。<br><img src="https://img-blog.csdnimg.cn/fe3cc289d53a49718317985a13fb9e4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="2-Grafana-添加钉钉告警渠道"><a href="#2-Grafana-添加钉钉告警渠道" class="headerlink" title="2.Grafana 添加钉钉告警渠道"></a>2.Grafana 添加钉钉告警渠道</h4><hr>
<p>“Alerting”—“Notification channels”—“New channel”，新建告警渠道。<br>其中：</p>
<ul>
<li>Url 为钉钉机器人的 Webhook 地址；</li>
<li>Message Type 为消息类型，我们选择 AutoCard；</li>
<li>告警设置，我们选择”Include image”，告警包含截图并关闭问题解决信息；<br><img src="https://img-blog.csdnimg.cn/3b1363236e9c4632bc4635b60f251fbb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ul>
<h3 id="图片渲染"><a href="#图片渲染" class="headerlink" title="图片渲染"></a>图片渲染</h3><hr>
<p>当告警渠道开启”Include image”，意味着 Grafana 需要与警报规则关联 dashboard 呈现为 PNG 图像，并将其包含在通知中，此时就需要配置图片渲染功能。<br>图片渲染需要额外安装一个在后台运行的插件，将渲染面板和仪表板处理为 PNG 图像。<br>图片渲染服务的部署直接通过 grafana-cli 直接安装或 Docker 安装，部署位置可以是本机或者远程服务器，比较灵活。</p>
<h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h4><hr>
<p># 安装依赖包<br>yum install -y libXcomposite libXdamage libXtst cups libXScrnSaver pango atk adwaita-cursor-theme adwaita-icon-theme at at-spi2-atk at-spi2-core cairo-gobject colord-libs dconf desktop-file-utils ed emacs-filesystem gdk-pixbuf2 glib-networking gnutls gsettings-desktop-schemas gtk-update-icon-cache gtk3 hicolor-icon-theme jasper-libs json-glib libappindicator-gtk3 libdbusmenu libdbusmenu-gtk3 libepoxy liberation-fonts liberation-narrow-fonts liberation-sans-fonts liberation-serif-fonts libgusb libindicator-gtk3 libmodman libproxy libsoup libwayland-cursor libwayland-egl libxkbcommon m4 mailx nettle patch psmisc redhat-lsb-core redhat-lsb-submod-security rest spax time trousers xdg-utils xkeyboard-config</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>grafana-cli plugins install grafana-image-renderer</p>
<h1 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h1><p>systemctl restart grafana-server</p>
<h4 id="2-图片渲染"><a href="#2-图片渲染" class="headerlink" title="2. 图片渲染"></a>2. 图片渲染</h4><hr>
<p>在 dashboard 中”share”—“Direct link rendered image” 可渲染图片。<br><img src="https://img-blog.csdnimg.cn/d3fdb6f6399e496f97a2fe04226bbb9e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>注意：默认配置下，Link URL 的地址”<a href="http://localhost:3000&quot;。若要更改其地址，需要修改相应的配置文件，请继续往下看。">http://localhost:3000&quot;。若要更改其地址，需要修改相应的配置文件，请继续往下看。</a><br><img src="https://img-blog.csdnimg.cn/552890d437f6494ea76647dde68b4b73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图是渲染生成的图片，默认存放位置为”&#x2F;var&#x2F;lib&#x2F;grafana&#x2F;png”。<br>如果图片的标题“流量测试”为乱码，则原因可能有以下两种：</p>
<ul>
<li>时区及语言不对；</li>
<li>系统中没有中文字体；<br>注意： 一般情况下在修改时区及语言无效后，可考虑是缺少字体问题导致。<br>可以通过以下方式解决：</li>
</ul>
<p># 1.时区或语言问题</p>
<h1 id="修改全局配置文件或默认配置文件"><a href="#修改全局配置文件或默认配置文件" class="headerlink" title="修改全局配置文件或默认配置文件"></a>修改全局配置文件或默认配置文件</h1><p>vim &#x2F;usr&#x2F;share&#x2F;grafana&#x2F;conf&#x2F;defaults.ini vim &#x2F;etc&#x2F;grafana&#x2F;grafana.ini</p>
<h1 id="添加如下"><a href="#添加如下" class="headerlink" title="添加如下"></a>添加如下</h1><p>[plugin.grafana-image-render]rendering_timezone &#x3D; Asia&#x2F;Shanghairendering_language &#x3D; zh-CN,zh;q&#x3D;0.9<br>﻿# 重启<br>﻿systemctl restart grafana-server</p>
<h1 id="2-缺少中文字体"><a href="#2-缺少中文字体" class="headerlink" title="2.缺少中文字体"></a>2.缺少中文字体</h1><h1 id="确认是否存在中文字体"><a href="#确认是否存在中文字体" class="headerlink" title="确认是否存在中文字体"></a>确认是否存在中文字体</h1><p>fc-list :lang&#x3D;zh</p>
<h1 id="安装字体将-C-Windows-Fonts-下的字体-放到-Linux-服务器-x2F-usr-x2F-share-x2F-fonts-目录下"><a href="#安装字体将-C-Windows-Fonts-下的字体-放到-Linux-服务器-x2F-usr-x2F-share-x2F-fonts-目录下" class="headerlink" title="安装字体将 C:\Windows\Fonts 下的字体 放到 Linux 服务器&#x2F;usr&#x2F;share&#x2F;fonts 目录下"></a>安装字体将 C:\Windows\Fonts 下的字体 放到 Linux 服务器&#x2F;usr&#x2F;share&#x2F;fonts 目录下</h1><p>﻿# 安装字体<br>﻿cd &#x2F;usr&#x2F;share&#x2F;fontsmkfontscalemkfontdirfc-cache</p>
<h1 id="再次确认"><a href="#再次确认" class="headerlink" title="再次确认"></a>再次确认</h1><p>fc-list :lang&#x3D;zh</p>
<h4 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h4><hr>
<p># 修改全局配置文件<br>vim &#x2F;usr&#x2F;share&#x2F;grafana&#x2F;conf&#x2F;defaults.ini<br>[rendering]</p>
<h1 id="远程渲染服务地址，如果使用-grafana-cli-部署可忽略；server-url-x3D"><a href="#远程渲染服务地址，如果使用-grafana-cli-部署可忽略；server-url-x3D" class="headerlink" title="远程渲染服务地址，如果使用 grafana-cli 部署可忽略；server_url&#x3D;"></a>远程渲染服务地址，如果使用 grafana-cli 部署可忽略；server_url&#x3D;</h1><p>﻿# 本地 grafana 地址 callback_url&#x3D;<br>﻿# 图片渲染并发数，防止服务器负载过高；concurrent_render_request_limit &#x3D; 30</p>
<p>另外，渲染的图片每 10 分钟后自动清理，我们可以通过调整” temp-data-lifetime “ 参数来重新定义清理时间。</p>
<h3 id="钉钉告警"><a href="#钉钉告警" class="headerlink" title="钉钉告警"></a>钉钉告警</h3><hr>
<p>钉钉告警关键在于，当 grafana 服务器在内网并且无法访问公网，此时钉钉就无法获取渲染的图片。<br>而官网文档的解决方式是将渲染图片上传至可公网访问的外部图像存储，这样钉钉就可以直接访问外部图像存储来解决图片无法访问的问题。<br>Grafana 支持的存储有 s3、webdav、gcs、azure_blob、local，我们一般使用 local 本地存储，那么我们如何解决公网访问问题呢？</p>
<h4 id="1-公网-nginx-代理"><a href="#1-公网-nginx-代理" class="headerlink" title="1.公网 nginx 代理"></a>1.公网 nginx 代理</h4><hr>
<p>相信我们的生产环境肯定会有统一的公网 nginx 访问入口，我们只需要做一层代理即可。</p>
<p>vim grafana.test.com.conf<br>server {<br>   listen 80;<br>   listen 443 ssl;<br>   server_name grafana.test.com;<br>   underscores_in_headers on;<br>   ssl_certificate ssl&#x2F;server.crt;<br>   ssl_certificate_key ssl&#x2F;server.key;<br>   location &#x2F; {<br>   proxy_pass <a href="http://10.16.202.250:3000/">http://10.16.202.250:3000</a>;<br> }<br> }</p>
<p>}</p>
<h4 id="2-grafana-配置"><a href="#2-grafana-配置" class="headerlink" title="2.grafana 配置"></a>2.grafana 配置</h4><hr>
<p>vim &#x2F;usr&#x2F;share&#x2F;grafana&#x2F;defaults.ini</p>
<p>[server]</p>
<p>protocol &#x3D; http # 默认为 localhost http_addr &#x3D; # 启动端口 http_port &#x3D; 3000 ﻿# 绑定域名 domain &#x3D; grafana.test.comenforce_domain &#x3D; false ﻿# 访问地址 root_url &#x3D; <a href="http://grafana.test.com/">http://grafana.test.com/</a> ﻿serve_from_sub_path &#x3D; false</p>
<p>经以上配置，就能解决公网访问 grafana 问题。一旦触发告警阈值，钉钉就会报警。</p>
<p><img src="https://img-blog.csdnimg.cn/af876c52722c4af8bd8db3fccf32da64.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>此时由于钉钉没有访问到图片，因此是 404。此时需要开启的 local 本地存储。</p>
<p>vim &#x2F;usr&#x2F;share&#x2F;grafana&#x2F;defaults.ini<br>[external_image_storage]<br>provider &#x3D; local</p>
<p><img src="https://img-blog.csdnimg.cn/18b0297004054fffac1531581a68a1d8.png" alt="在这里插入图片描述"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>Grafana+钉钉只是告警渠道的其中之一，这种方式没有告警收敛、告警静默等功能，如果阈值设置不合适，很容易导致告警泛滥。</p>
]]></content>
      <categories>
        <category>运维监控</category>
        <category>运维</category>
        <category>Grafana</category>
      </categories>
      <tags>
        <tag>grafana</tag>
        <tag>grafana 配置</tag>
        <tag>webhook</tag>
        <tag>告警渠道</tag>
        <tag>钉钉告警</tag>
        <tag>钉钉机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>grafana密码修改 重置grafana密码</title>
    <url>/2021/03/29/grafana%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%87%8D%E7%BD%AEgrafana%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="【1】WEB重置"><a href="#【1】WEB重置" class="headerlink" title="【1】WEB重置"></a>【1】WEB重置</h1><hr>
<p>当Grafana的邮件通知配置正常时，你可以通过web界面 点击忘记密码，通过邮件中的链接重置密码</p>
<p>也可联系管理员进入web后台，修改该账户的密码</p>
<p><strong>1、点击 忘记密码</strong></p>
<p><img src="https://www.freesion.com/images/241/3aebe624303eb0adf3611d82513adb79.png?ynotemdtimestamp=1616982394320" alt="在这里插入图片描述"></p>
<p><strong>2、输入邮箱后，点击发送Reset Password。到你的邮箱等待邮件</strong></p>
<p><img src="https://www.freesion.com/images/999/e911c5d3bff1bb21c6355eca6afd1ff7.png?ynotemdtimestamp=1616982394320" alt="在这里插入图片描述"></p>
<p><img src="https://www.freesion.com/images/286/53662245cdd3b7ceca3e23117f751f3e.png?ynotemdtimestamp=1616982394320" alt="在这里插入图片描述"></p>
<p><strong>3、复制链接到浏览器</strong></p>
<p>将localhost:3000替换为这个Grafana的域名或IP+端口</p>
<p><img src="https://www.freesion.com/images/156/d6a7b46e8d6a0faaa29980f6ac19f87c.png?ynotemdtimestamp=1616982394320" alt="在这里插入图片描述"></p>
<p><strong>4、两次输入密码后，点击 Reset</strong></p>
<p>Password即可重置密码，返回首页用新密码即可登录。</p>
<p><img src="https://www.freesion.com/images/682/7119e2caef54693ee5b0b37102d90d2a.png?ynotemdtimestamp=1616982394320" alt="在这里插入图片描述"></p>
<h1 id="【2】SQLITE3重置"><a href="#【2】SQLITE3重置" class="headerlink" title="【2】SQLITE3重置"></a>【2】SQLITE3重置</h1><hr>
<p>此方式需要你可以登录Grafana服务器中</p>
<p><strong>1、根据你的实际情况查找grafana.db</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#find查找</span><br><span class="line">find / -name grafana.db</span><br><span class="line">or</span><br><span class="line">#查看Grafana配置文件，确定grafana.db的路径</span><br><span class="line">cat /etc/grafana/grafana.ini</span><br><span class="line">[paths]</span><br><span class="line">;data = /var/lib/grafana #通常默认位置为/var/lib/grafana/grafana.db</span><br></pre></td></tr></table></figure>

<p><strong>2、sqlite3重置密码</strong> (当前演示的是重置admin账号密码为admin)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#说明 重置：admin 账号密码为：admin</span><br><span class="line">#执行命令</span><br><span class="line">sqlite3 /var/lib/grafana/grafana.db</span><br><span class="line">update user set password = &#x27;59acf18b94d7eb0694c61e60ce44c110c7a683ac6a8f09580d626f90f4a242000746579358d77dd9e570e83fa24faa88a8a6&#x27;, salt = &#x27;F3FAxVm33R&#x27; where login = &#x27;admin&#x27;;</span><br><span class="line">59acf18b94d7eb0694c61e60ce44c110c7a683ac6a8f09580d626f90f4a242000746579358d77dd9e570e83fa24faa88a8a6</span><br><span class="line"></span><br><span class="line">[root@monitor1 grafana]# sqlite3 grafana.db </span><br><span class="line">SQLite version 3.7.17 2013-05-20 00:56:22</span><br><span class="line">Enter &quot;.help&quot; for instructions</span><br><span class="line">Enter SQL statements terminated with a &quot;;&quot;</span><br><span class="line">sqlite&gt; </span><br><span class="line">sqlite&gt; </span><br><span class="line">sqlite&gt; show databases;</span><br><span class="line">Error: near &quot;show&quot;: syntax error</span><br><span class="line">sqlite&gt; select * from user;</span><br><span class="line">10adminadmin@localhostdf66a6815245dbd4b60e5c5fdd14b14aa7f5b4504ccf26ffc1baef459203a13a160d96783a088ed8915a4d07b8961ef2292aLZDEE9xnpKpMS90l93cH1102020-11-25 02:19:592021-03-15 07:21:0902021-03-19 06:23:440</span><br><span class="line">sqlite&gt; update user set password=&#x27;59acf18b94d7eb0694c61e60ce44c110c7a683ac6a8f09580d626f90f4a242000746579358d77dd9e570e83fa24faa88a8a6&#x27;,salt=&#x27;F3FAxVm33R&#x27; where login=&#x27;admin&#x27;;</span><br><span class="line">sqlite&gt; </span><br><span class="line">sqlite&gt; </span><br><span class="line">sqlite&gt; .exit</span><br><span class="line">[root@monitor1 grafana]# </span><br></pre></td></tr></table></figure>

<p>也可在sqlite3进入后，修改一个已知密码的账号为管理员，通过管理员web重置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udpate user set is_admin = 1 where login = &#x27;账号&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备注：</span><br><span class="line"></span><br><span class="line">修改 password 后为&quot;admin&quot;字符经过grafana加密后的字符串</span><br><span class="line">where login为指定账号，也可指定其他账号，将其密码先修改成为admin</span><br><span class="line">在sqlite3 进入grafana后可通过 select * from user; 查询账号及密码信息</span><br><span class="line">修改完成后无需重启服务,即可用新密码登录</span><br></pre></td></tr></table></figure>

<h1 id="【3】API密码重置"><a href="#【3】API密码重置" class="headerlink" title="【3】API密码重置"></a>【3】API密码重置</h1><hr>
<p>当你没有忘记你的账户及对应的密码，仅想要重置密码，可使用curl进行重置，也可写入脚本中执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line">  &quot;oldPassword&quot;: &quot;旧密码&quot;,</span><br><span class="line">  &quot;newPassword&quot;: &quot;新密码&quot;,</span><br><span class="line">  &quot;confirmNew&quot;: &quot;新密码&quot;</span><br><span class="line">&#125;&#x27; http://账号:密码@你的grafana的IP:3000/api/user/password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">curl -X PUT -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;</span><br><span class="line">  &quot;oldPassword&quot;: &quot;admin123&quot;,</span><br><span class="line">  &quot;newPassword&quot;: &quot;admin123..123&quot;,</span><br><span class="line">  &quot;confirmNew&quot;: &quot;admin123..123&quot;</span><br><span class="line">&#125;&#x27; http://admin:admin123@123.123.121.123:3000/api/user/password</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#接口返回信息</span><br><span class="line">&#123;&quot;message&quot;:&quot;User password changed&quot;&#125;        修改成功</span><br><span class="line">&#123;&quot;message&quot;:&quot;Unauthorized&quot;&#125;                 访问的链接错误</span><br><span class="line">&#123;&quot;message&quot;:&quot;Invalid username or password&quot;&#125; 账户或密码错误</span><br></pre></td></tr></table></figure>

<h1 id="【4】GRAFANA-CLI密码重置"><a href="#【4】GRAFANA-CLI密码重置" class="headerlink" title="【4】GRAFANA-CLI密码重置"></a>【4】GRAFANA-CLI密码重置</h1><hr>
<p>前提是可登录服务器,可在4.1以上的grafana中使用 grafana-server -v 查看版本</p>
<p>参考链接： <a href="https://grafana.com/docs/grafana/latest/administration/cli/">https://grafana.com/docs/grafana/latest/administration/cli/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有两个参数可以用来设置homepath和配置文件路径</span><br><span class="line">grafana-cli admin reset-admin-password --homepath &quot;/usr/share/grafana&quot; 新密码</span><br><span class="line"></span><br><span class="line">systemctl restart grafana-server</span><br></pre></td></tr></table></figure>

<p>然而，根据官方提供的操作，即使提示修改成功。从首页登录依然只能使用旧密码登录。建议使用前3种方法。</p>
<p><img src="https://www.freesion.com/images/416/1195770a7c632860219c6b85855706c0.png?ynotemdtimestamp=1616982394320" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>运维监控</category>
      </categories>
      <tags>
        <tag>grafana</tag>
        <tag>grafana密码修改</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS是如何工作的？</title>
    <url>/2021/11/09/https%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://code404.icu/img/moveypu/2021/11/image-9-1024x427.png"></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我是一个浏览器，每到夜深人静的时候，主人就打开我开始学习。</p>
<p>为了不让别人看到浏览记录，主人选择了“无痕模式”。</p>
<p>但网络中总是有很多坏人，他们通过抓包截获我和服务器的通信，主人干了什么，请求了什么数据全被他们知道了！</p>
<p>光窃听也就罢了，他们还经常篡改内容，在网页里面插入诱人的小广告，真是太坏了！</p>
<p>为了保护主人的隐私还他一个干净的上网环境，我决定对通信加密！</p>
<h3 id="第一版：直接简单加密"><a href="#第一版：直接简单加密" class="headerlink" title="第一版：直接简单加密"></a>第一版：直接简单加密</h3><hr>
<p>加密嘛，很简单，把原来要发送的数据加密处理后再发给服务器就行了。</p>
<p><img src="https://img-blog.csdnimg.cn/542a0179caa4482e879da3ecfcd92773.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>为了安全，密钥当然不能固定，每一次通信都要随机生成。</p>
<p>不过接下来我犯难了，我该怎么把这个秘钥告诉服务器呢，服务器没有秘钥就解不了密，也就不知道我在请求什么资源了。</p>
<p>也不能直接弄个字段告诉服务器密钥，那样别人也能拿到，就跟没加密一样了。</p>
<p>我左思右想，灵机一动，决定把密钥放在数据的开头几个字节藏起来，只要私下跟服务器约定好，他用这前几个字节作为密钥解密，就能解开我发送的数据了。<br><img src="https://img-blog.csdnimg.cn/d8e1b95a476b4f0cadac6c66f2eccfa4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>你还别说，这办法还真好使，我跟服务器开始秘密通信起来。</p>
<p>后来，找我使用这种办法通信的服务器变得越来越多。</p>
<p>再后来这事就在圈子里传开了，大家都知道数据的前几个字节是密钥了，谁都能解密了。</p>
<p>看来这个办法不行，我得重新思考加密方法了。</p>
<h3 id="第二版：非对称加密"><a href="#第二版：非对称加密" class="headerlink" title="第二版：非对称加密"></a>第二版：非对称加密</h3><hr>
<p>服务器告诉我，我们之前用的那种加密算法叫对称加密算法，也就是加密和解密使用的同一个秘钥。</p>
<p>还有一种叫非对称加密算法，这种算法有两个秘钥，一个公开的叫公钥，一个私藏的叫私钥。</p>
<p><img src="https://img-blog.csdnimg.cn/468b4574c1e6407f9bc0f5f4caf1b672.png" alt="在这里插入图片描述"></p>
<p>最关键的是，公钥加密后只能用私钥解开，反过来也一样。</p>
<p>只要在正式的数据传输前，服务器把他的公钥告诉我，我后面用它加密数据就行了，就算被别人抓包，他也解不开，因为只有拥有私钥的服务器才能解开。</p>
<p><img src="https://img-blog.csdnimg.cn/27b9c2b8db1a4c5a878175852d80a326.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>不得不说，这非对称加密真是个好东西啊！</p>
<p>不过这样一来只能单程加密，服务器能解密我发的，但他发给我的，我却解不了，也不能让他用私钥加密，我用公钥解密，因为公钥是公开的，谁收到都能解，不安全。</p>
<p>没办法，我也弄了一对儿秘钥，通信之前我们双方都交换一下彼此的公钥，这样就可以双向加解密了！</p>
<p><img src="https://img-blog.csdnimg.cn/b98485c77ca844b2ba1874e52c41e47c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>虽然是有点麻烦，但为了数据安全，忍了吧！</p>
<h3 id="第三版：非对称与对称加密结合"><a href="#第三版：非对称与对称加密结合" class="headerlink" title="第三版：非对称与对称加密结合"></a>第三版：非对称与对称加密结合</h3><p>但我忍了没几天就忍不住了。</p>
<p>这个非对称加密算法好是好，就是加解密太费时间了，导致我渲染一个网页要花很久时间，卡的不行。</p>
<p>我打算去跟服务器商量一下办法，没想到服务器比我更头疼，他要服务很多浏览器，每一个都这么加解密，把他累的够呛。</p>
<p>于是我们决定，还是用原来的对称加密算法，这样快得多。但是一开始的时候可以用非对称加密算法来传输后面要用的秘钥，把两种算法的优势结合起来。</p>
<p><img src="https://img-blog.csdnimg.cn/144d1f24163d4916acb8d4758208cfc4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>这一来，我只需要把后面要用到的秘钥，通过服务器公钥加密后发给他就行了，我省去了不少事儿。</p>
<h3 id="第四版：秘钥计算"><a href="#第四版：秘钥计算" class="headerlink" title="第四版：秘钥计算"></a>第四版：秘钥计算</h3><hr>
<p>有一天，服务器告诉我，我们现在的秘钥就是一个随机数，而随机数并不是真正随机的，可能被预测出来，所以我们得提升这个秘钥的安全性。</p>
<p>一个随机数不够，那就多弄几个！</p>
<p>一端容易被猜出来，那就两端一起生成！</p>
<p>我们决定各自生成一个随机数发给对方，我再额外加密传输一个随机数给服务器，这一来，咱们双方都有3个随机数了，然后双方都用这三个随机数计算出真正的秘钥，这可比一个单纯的随机数要安全得多了。</p>
<p><img src="https://img-blog.csdnimg.cn/7474be16bf964439a9643dd5e2ccc631.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>不过为了验证双方计算出来的秘钥是一样的，我们在正式数据传输前，需要先来测试一下，现在的流程变成了这个样子：</p>
<p><img src="https://img-blog.csdnimg.cn/a2583b5519ec4e3db43bcc6f14de523c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们的这一方案很快得到了大家的认可，圈子里的浏览器和服务器们纷纷用上了这套方案。</p>
<h3 id="第五版：数字证书"><a href="#第五版：数字证书" class="headerlink" title="第五版：数字证书"></a>第五版：数字证书</h3><hr>
<p>原以为这个方案已经万无一失了，没想到我和服务器的通信还是泄露了···</p>
<p>原来有个家伙冒充服务器跟我通信，然后又冒充我跟服务器通信，把我的请求进行了转发，我们俩都被蒙在鼓里，这就是中间人攻击。</p>
<p><img src="https://img-blog.csdnimg.cn/f75b994b492c4fdcbdd376f15b56624c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>看来还缺乏一个认证机制！我得知道和我通信的是不是真的服务器。</p>
<p>经过大家的商量，圈子里的服务器们推选了一个德高望重的前辈做公证人，让这公证人准备一对非对称加密的密钥，并在圈子里公开了公钥，所有人都得把他的公钥记下来。</p>
<p>服务器得去公证人这里先登记，把自己的公钥、名字等等信息报上去，公证人拿到这些信息后，计算一个Hash值，然后再用公证人的私钥把Hash值进行加密，加密后的结果就是数字签名。</p>
<p><img src="https://img-blog.csdnimg.cn/95eecde40e33486bbdb71bf12abe86d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="证书的签发"></p>
<p>最后，公证人把登记的信息和这个数字签名合在一起，封装了一个新的文件发给服务器，登记就完成了，而这个新的文件就是数字证书。</p>
<p>服务器拿到证书后，可要好生保管，因为通信的时候，服务器须要将他们的证书发给我们浏览器验证。</p>
<p><img src="https://img-blog.csdnimg.cn/5786584e533b40c9ae56489274e776a0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="证书的验证"></p>
<p>我们浏览器拿到证书后，把证书里面的信息也计算一遍Hash，再用提前记录好的公证人的公钥把证书里的数字签名进行解密，得到公证人计算的Hash，两个一对比，就知道这证书是不是公证人签发的，以及有没有被篡改过了！</p>
<p>只有验证成功才能继续后面的流程，要不然就是冒充的！</p>
<p>这一下总算解决了中间人冒充的问题，除非中间人偷到了公证人的私钥，否则他是没办法伪造出一个证书来的。</p>
<p><strong>非对称加密除了加密数据，还能用来验证身份，真是YYDS！</strong></p>
<h3 id="第六版：信任链"><a href="#第六版：信任链" class="headerlink" title="第六版：信任链"></a>第六版：信任链</h3><hr>
<p>我们这加密方案一传十，十传百，很快就传遍了整个互联网，想要使用这套方案的服务器越来越多，毕竟，谁都不希望自己的网站被人插入小广告。</p>
<p>可原来的那个公证人有些忙不过来了，于是，大家开始推选更多的公证人，公证人开始多了起来，不仅多了起来，而且还形成了产业链。</p>
<p>原来的公证人变成了一代目，一代目可以给新的公证人签发证书，新的公证人就变成了二代目，还有三代目，搞得跟传销似的。</p>
<p>原来只有一个公证人的时候，大家直接保存他的公钥就行了。现在公证人越来越多，我们没办法保存所有的公证人的公钥了，就算能保存得下，但有新的公证人出现的时候我们也做不到实时更新。</p>
<p><img src="https://img-blog.csdnimg.cn/ca59d5a9507c493eab20698be6491d6d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>于是，大家约定，让所有的一代目公证人自己给自己签发一个证书，叫做根证书，并安装在我们的操作系统中。</p>
<p><img src="https://img-blog.csdnimg.cn/e6c083a7143645488130a4340a3718b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>以后在验证网站服务器的证书时，就得先去验证证书的签发者，然后再继续验证上一级签发者，直到验证最终的签发者是不是在根证书列表中。</p>
<p>只要最终的签发者在系统的根证书列表中，那这条链上签署的证书就都是受信任的，否则我们就会弹窗提醒用户：</p>
<p><img src="https://img-blog.csdnimg.cn/ef2aa0899eee47f4bd8460dde33127c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>如今，这套方案已经推广到了全世界，现在遇到使用这套方案的网站服务器时，我们浏览器就会在地址栏加上一把小锁，表示网站很安全，还把URL地址，从HTTP，改成了HTTPS···</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>信任链</tag>
        <tag>对称加密</tag>
        <tag>数字证书</tag>
        <tag>秘钥</tag>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS的工作原理</title>
    <url>/2021/06/11/https%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-29.png"></p>
<ol>
<li>用户通过浏览器请求https网站，服务器收到请求，选择浏览器支持的加密和hash算法，同时返回数字证书给浏览器，包含颁发机构、网址、公钥、证书有效期等信息。</li>
<li>浏览器对证书的内容进行校验，如果有问题，则会有一个提示警告。否则，就生成一个随机数X，同时使用证书中的公钥进行加密，并且发送给服务器。</li>
<li>服务器收到之后，使用私钥解密，得到随机数X，然后使用X对网页内容进行加密，返回给浏览器</li>
<li>浏览器则使用X和之前约定的加密算法进行解密，得到最终的网页内容</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>url</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码详解状态查询</title>
    <url>/2021/03/25/http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h2><p><strong>200</strong> - 服务器成功返回网页 <strong>404</strong> - 请求的网页不存在 <strong>503</strong> - 服务不可用</p>
<h4 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h4><p>表示临时响应并需要请求者继续执行操作的状态代码。</p>
<h4 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h4><p>表示成功处理了请求的状态代码。</p>
<h4 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h4><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<h4 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h4><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<h4 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h4><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<h2 id="响应状态码简单说明"><a href="#响应状态码简单说明" class="headerlink" title="响应状态码简单说明"></a>响应状态码简单说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1xx</span><br><span class="line">100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</span><br><span class="line">101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2xx</span><br><span class="line">200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line">201 （已创建） 请求成功并且服务器创建了新的资源。</span><br><span class="line">202 （已接受） 服务器已接受请求，但尚未处理。</span><br><span class="line">203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line">204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line">206 （部分内容） 服务器成功处理了部分 GET 请求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3xx</span><br><span class="line">300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line">301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line">302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line">303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line">304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line">305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line">307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4xx</span><br><span class="line">400 （错误请求） 服务器不理解请求的语法。</span><br><span class="line">401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line">403 （禁止） 服务器拒绝请求。</span><br><span class="line">404 （未找到） 服务器找不到请求的网页。</span><br><span class="line">405 （方法禁用） 禁用请求中指定的方法。</span><br><span class="line">406 （不接受） 无法使用请求的内容特性响应请求的网页。</span><br><span class="line">407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line">408 （请求超时） 服务器等候请求时发生超时。</span><br><span class="line">409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line">410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line">411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line">412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line">413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line">414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</span><br><span class="line">415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</span><br><span class="line">416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line">417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5xx</span><br><span class="line">500 （服务器内部错误） 服务器遇到错误，无法完成请求。</span><br><span class="line">501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</span><br><span class="line">504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line">505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>

<h2 id="所有状态速查详细解释"><a href="#所有状态速查详细解释" class="headerlink" title="所有状态速查详细解释"></a>所有状态速查详细解释</h2><p>状态码</p>
<p>含 义</p>
<p>100</p>
<p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>
<p>101</p>
<p>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p>
<p>102</p>
<p>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p>
<p>200</p>
<p>请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>
<p>201</p>
<p>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</p>
<p>202</p>
<p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p>
<p>203</p>
<p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>
<p>204</p>
<p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>
<p>205</p>
<p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>
<p>206</p>
<p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart&#x2F;byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和&#x2F;或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和&#x2F;或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</p>
<p>207</p>
<p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<p>300</p>
<p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p>
<p>301</p>
<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP&#x2F;1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</p>
<p>302</p>
<p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
<p>303</p>
<p>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP&#x2F;1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p>
<p>304</p>
<p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和&#x2F;或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和&#x2F;或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p>
<p>305</p>
<p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p>
<p>306</p>
<p>在最新版的规范中，306状态码已经不再被使用。</p>
<p>307</p>
<p>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<p>400</p>
<p>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</p>
<p>401</p>
<p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p>
<p>402</p>
<p>该状态码是为了将来可能的需求而预留的。</p>
<p>403</p>
<p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p>
<p>404</p>
<p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<p>405</p>
<p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<p>406</p>
<p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>
<p>407</p>
<p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</p>
<p>408</p>
<p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p>
<p>409</p>
<p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p>
<p>410</p>
<p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p>
<p>411</p>
<p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</p>
<p>412</p>
<p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>
<p>413</p>
<p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<p>414</p>
<p>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p>
<p>415</p>
<p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p>
<p>416</p>
<p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart&#x2F;byteranges 作为其 Content-Type。</p>
<p>417</p>
<p>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</p>
<p>421</p>
<p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p>
<p>422</p>
<p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p>
<p>422</p>
<p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</p>
<p>424</p>
<p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p>
<p>425</p>
<p>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p>
<p>426</p>
<p>客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p>
<p>449</p>
<p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p>
<p>500</p>
<p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</p>
<p>501</p>
<p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p>
<p>502</p>
<p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p>503</p>
<p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</p>
<p>504</p>
<p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</p>
<p>505</p>
<p>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p>
<p>506</p>
<p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p>
<p>507</p>
<p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p>
<p>509</p>
<p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p>
<p>510</p>
<p>获取资源所需要的策略并没有没满足。（RFC 2774）</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>200</tag>
        <tag>404</tag>
        <tag>502</tag>
        <tag>code</tag>
        <tag>Status</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>ImportError: libssl.so.10: cannot open shared object file: No such file or directory</title>
    <url>/2021/11/11/importerror-libssl-so-10-cannot-open-shared-object-file-no-such-file-or-directory/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-10.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Python项目在Centos上移植到Ubuntu系统时,启动发生错误<br>Python项目在CentOS上时是编译安装的Python环境<br>Ubuntu上自带Python3.8</p>
<h3 id="启动时发生错误"><a href="#启动时发生错误" class="headerlink" title="启动时发生错误"></a>启动时发生错误</h3><hr>
<p>import _ssl # if we can’t import it, let the error propagate<br>ImportError: libssl.so.10: cannot open shared object file: No such file or directory</p>
<p>Traceback (most recent call last):<br>  File “&#x2F;home&#x2F;leenhem&#x2F;code&#x2F;OpsGuide&#x2F;main.py”, line 2, in <module><br>    import tornado.httpserver<br>  File “&#x2F;home&#x2F;leenhem&#x2F;code&#x2F;OpsGuide&#x2F;tornado&#x2F;httpserver.py”, line 29, in <module><br>    import ssl<br>  File “&#x2F;home&#x2F;leenhem&#x2F;code&#x2F;OpsGuide&#x2F;python&#x2F;lib&#x2F;python3.7&#x2F;ssl.py”, line 98, in <module><br>    import _ssl             # if we can’t import it, let the error propagate<br>ImportError: libssl.so.10: cannot open shared object file: No such file or directory</p>
<h3 id="错误原因分析"><a href="#错误原因分析" class="headerlink" title="错误原因分析"></a>错误原因分析</h3><hr>
<p>新环境中的Python没有把ssl模块编译进去<br>我们需要在新的环境中重新安装Python环境并把ssl模块编译进去</p>
<h3 id="重新编译Python环境"><a href="#重新编译Python环境" class="headerlink" title="重新编译Python环境"></a>重新编译Python环境</h3><hr>
<p>下载Python<br><a href="https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz">https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz</a></p>
<p>sudo apt-get install libssl-dev<br>sudo apt-get install libffi-dev</p>
<p>tar -xvf Python-3.8.0.tar.xz<br>cd Python-3.8.0<br>.&#x2F;configure -prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.8<br>make<br>sudo make install</p>
<p>主要就是要重新编译<br>重新编译时要在系统上安装上libssl-dev,libffi-dev分别是对__ssl ,__ctypes 的支持</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>___ctypes</tag>
        <tag>__SSL</tag>
        <tag>ModuleNotFoundError</tag>
      </tags>
  </entry>
  <entry>
    <title>Ingress-Nginx 安装 高可用</title>
    <url>/2021/12/31/ingress-nginx-%E5%AE%89%E8%A3%85-%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2022/01/image.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>使用官方默认的mandatory.yaml去部署 nginx-ingress-controller，默认为 Deployment + Nodeport 模式，启动 nginx-ingress-controller 后，先使用 kubectl get pod -A -o wide grep nginx-ingress-controller 查看 nginx-ingress-controller 部署到哪个节点上了，再去 给ingress 创建一个 nodeport 服务，这种方式将集群内部的服务暴露出去。如果这个ingress-nginx出现了故障，将导致整个集群不可用。</p>
<p>本文介绍一种DaemonSet+HostNetwork+nodeSelector方式搭建的多ingress-nginx实例高可用集群。</p>
<h3 id="下载-nginx-ingress-controller-配置"><a href="#下载-nginx-ingress-controller-配置" class="headerlink" title="下载 nginx-ingress-controller 配置"></a>下载 nginx-ingress-controller 配置</h3><hr>
<p>mandatory.yaml 地址，下载默认的配置</p>
<p><a href="https://github.com/leenhem/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml">https://github.com/leenhem/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml</a></p>
<h3 id="修改-mandatory-yaml-配置为-DaemonSet"><a href="#修改-mandatory-yaml-配置为-DaemonSet" class="headerlink" title="修改 mandatory.yaml 配置为 DaemonSet"></a>修改 mandatory.yaml 配置为 DaemonSet</h3><hr>
<p>Deployment可能会把多个pod调度到同一个node，那就失去高可用的意义了。而DaemonSet在一个节点上只会有一个Pod，符合我们的要求。</p>
<p>kind: Deployment #修改为 DaemonSet<br>kind: DaemonSet</p>
<h3 id="修改-mandatory-yaml-配置为-nodeSelector"><a href="#修改-mandatory-yaml-配置为-nodeSelector" class="headerlink" title="修改 mandatory.yaml 配置为 nodeSelector"></a>修改 mandatory.yaml 配置为 nodeSelector</h3><hr>
<p>首先，给要部署 ingress 的节点打上标签 isIngress&#x3D;“true”</p>
<p>#打标签<br>kubectl label node k8s-node242 isIngress&#x3D;”true”</p>
<p>启用hostNetwork网络，并指定运行节点</p>
<pre><code>  nodeSelector:
    isIngress: &quot;true&quot;  # 此处添加一行 isIngress: &quot;true&quot; 配置,选择 node 节点
    kubernetes.io/os: linux
</code></pre>
<h3 id="修改-mandatory-yaml-配置为-hostNetwork"><a href="#修改-mandatory-yaml-配置为-hostNetwork" class="headerlink" title="修改 mandatory.yaml 配置为 hostNetwork"></a>修改 mandatory.yaml 配置为 hostNetwork</h3><hr>
<p>启用hostNetwork网络，是为了打通Cluster和node的网络，让Cluster直接监听node的端口，一般是80和443，不用再通过随机绑定的nodePort来访问集群服务</p>
<pre><code>spec:
  hostNetwork: true  # 此处添加一行 hostNetwork 配置
  # wait up to five minutes for the drain of connections
  terminationGracePeriodSeconds: 300
</code></pre>
<h3 id="创建-nginx-ingress-controller-服务"><a href="#创建-nginx-ingress-controller-服务" class="headerlink" title="创建 nginx-ingress-controller 服务"></a>创建 nginx-ingress-controller 服务</h3><hr>
<p>[root@k8s-master01 ingress]# kubectl apply -f nginx30-mandatory-deamonset.yaml<br>namespace&#x2F;ingress-nginx created<br>configmap&#x2F;nginx-configuration created<br>configmap&#x2F;tcp-services created<br>configmap&#x2F;udp-services created<br>serviceaccount&#x2F;nginx-ingress-serviceaccount created<br>Warning: rbac.authorization.k8s.io&#x2F;v1beta1 ClusterRole is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io&#x2F;v1 ClusterRole<br>clusterrole.rbac.authorization.k8s.io&#x2F;nginx-ingress-clusterrole created<br>Warning: rbac.authorization.k8s.io&#x2F;v1beta1 Role is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io&#x2F;v1 Role<br>role.rbac.authorization.k8s.io&#x2F;nginx-ingress-role created<br>Warning: rbac.authorization.k8s.io&#x2F;v1beta1 RoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io&#x2F;v1 RoleBinding<br>rolebinding.rbac.authorization.k8s.io&#x2F;nginx-ingress-role-nisa-binding created<br>Warning: rbac.authorization.k8s.io&#x2F;v1beta1 ClusterRoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io&#x2F;v1 ClusterRoleBinding<br>clusterrolebinding.rbac.authorization.k8s.io&#x2F;nginx-ingress-clusterrole-nisa-binding created<br>daemonset.apps&#x2F;nginx-ingress-controller created<br>limitrange&#x2F;ingress-nginx created</p>
<p><img src="https://img-blog.csdnimg.cn/6cc663678f2c41a6a468010646d08a9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="hostNetwork-true-自动打通Cluster和node的网络"><a href="#hostNetwork-true-自动打通Cluster和node的网络" class="headerlink" title="hostNetwork: true 自动打通Cluster和node的网络"></a>hostNetwork: true 自动打通Cluster和node的网络</h3><p><img src="https://img-blog.csdnimg.cn/c18faf72d1f940fca587c376df5ad2a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="高可用，参考下图"><a href="#高可用，参考下图" class="headerlink" title="高可用，参考下图"></a>高可用，参考下图</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/b7dcb46692504848941edbb9e6b37d0f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>DaemonSet</tag>
        <tag>hostNetwork</tag>
        <tag>ingress</tag>
        <tag>nginx-ingress-controller</tag>
        <tag>nodeSelector</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址是怎么组成的？</title>
    <url>/2021/07/19/ip%E5%9C%B0%E5%9D%80%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>IP 地址为 32 位的二进制数，由网络号和主机号组合而成。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-46.png"></p>
<p>其中，一个网络号在整个互联网范围内必须是唯一的，一个主机号在它前面的网络号所指定的网络范围内必须是唯一的。因此，一个 IP 地址在整个互联网范围内是唯一的。</p>
<h3 id="IP-地址分为网络号和主机号有两个好处："><a href="#IP-地址分为网络号和主机号有两个好处：" class="headerlink" title="IP 地址分为网络号和主机号有两个好处："></a>IP 地址分为网络号和主机号有两个好处：</h3><hr>
<ol>
<li>IP 地址管理机构（ICANN）在分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配，这样方便了对IP地址的管理；</li>
<li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑主机号），这样可以使路由表中的项目数大幅度减少，从而减小路由表的占用空间和查询路由表的时间。</li>
</ol>
<p>实际上，作为逻辑地址，IP 地址是标志一台主机（包括路由器）和一条链路的接口，当主机没有联网时，不一定有 IP 地址。因此，当一台主机同时连接到两个网络时，该主机就必须同时具备两个响应的 IP 地址，其网络号必须是不同的。这种主机成为多归属主机，比如路由器。</p>
<p>路由器的每个接口都对应一个网络，也对应一个 IP 地址。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-47.png"></p>
<p>这里有个特殊场景，便是两个路由器之间只有连线而无主机。过去会为这条线路专门分配一个 IP 地址，为了节省 IP 地址资源，现在经常采用一种不分配 IP 地址的方式，这类网络称为无名网络。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-48.png"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><hr>
<p>这里的 IP 地址指 IPv4，即第一代 IP 地址，目前仍旧使用广泛。</p>
<p>由于 IPv4 地址在 2011 年已被耗尽，目新的机器都只能用 IPv6 地址，目前互联网上 IPv4 和 IPv6 是共存的。帮助文档快捷键目录标题文本样式列表链接代码片表格注脚注释自定义列表LaTeX 数学公式插入甘特图插入UML图插入Mermaid流程图插入Flowchart流程图插入类图</p>
]]></content>
      <categories>
        <category>IP地址</category>
      </categories>
      <tags>
        <tag>IP地址</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java服务_GC内存溢出OOM问题如何定位？</title>
    <url>/2021/09/01/java%E6%9C%8D%E5%8A%A1-gc%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAoom%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-29-1024x689.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Java运行时环境内置了 垃圾收集(GC) 模块. 上一代的很多编程语言中并没有自动内存回收机制, 需要程序员手工编写代码来进行内存分配和释放, 以重复利用堆内存。</p>
<p>在Java程序中, 只需要关心内存分配就行。如果某块内存不再使用, 垃圾收集(Garbage Collection) 模块会自动执行清理。 一般来说, JVM内置的垃圾收集算法就能够应对绝大多数的业务场景。</p>
<p>java.lang.OutOfMemoryError: GC overhead limit exceeded 这种情况发生的原因是, 程序基本上耗尽了所有的可用内存, GC也清理不了。</p>
<h3 id="OutOfMemoryError常见原因"><a href="#OutOfMemoryError常见原因" class="headerlink" title="OutOfMemoryError常见原因"></a>OutOfMemoryError常见原因</h3><hr>
<p>某Java服务（假设PID&#x3D;103587）出现了OOM，最常见的原因</p>
<ul>
<li>有可能是内存分配确实过小，而正常业务使用了大量内存</li>
<li>某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽</li>
<li>某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接</li>
</ul>
<p>画外音：无非“本身资源不够”“申请资源太多”“资源耗尽”几个原因。</p>
<h3 id="确认是不是内存本身就分配过小"><a href="#确认是不是内存本身就分配过小" class="headerlink" title="确认是不是内存本身就分配过小"></a>确认是不是内存本身就分配过小</h3><hr>
<p>jmap -heap 103587</p>
<p>[root@NEWCWS-AS06 data]# jmap -heap 103587<br>Attaching to process ID 103587, please wait…<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 25.151-b12</p>
<p>using thread-local object allocation.<br>Parallel GC with 8 thread(s)</p>
<p>Heap Configuration:<br>   MinHeapFreeRatio         &#x3D; 0<br>   MaxHeapFreeRatio         &#x3D; 100<br>   MaxHeapSize              &#x3D; 1073741824 (1024.0MB)<br>   NewSize                  &#x3D; 536870912 (512.0MB)<br>   MaxNewSize               &#x3D; 536870912 (512.0MB)<br>   OldSize                  &#x3D; 536870912 (512.0MB)<br>   NewRatio                 &#x3D; 2<br>   SurvivorRatio            &#x3D; 8<br>   MetaspaceSize            &#x3D; 134217728 (128.0MB)<br>   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)<br>   MaxMetaspaceSize         &#x3D; 335544320 (320.0MB)<br>   G1HeapRegionSize         &#x3D; 0 (0.0MB)</p>
<p>Heap Usage:<br>PS Young Generation<br>Eden Space:<br>   capacity &#x3D; 529530880 (505.0MB)<br>   used     &#x3D; 453118544 (432.1275177001953MB)<br>   free     &#x3D; 76412336 (72.87248229980469MB)<br>   85.56980548518719% used<br>From Space:<br>   capacity &#x3D; 3670016 (3.5MB)<br>   used     &#x3D; 3375232 (3.2188720703125MB)<br>   free     &#x3D; 294784 (0.2811279296875MB)<br>   91.9677734375% used<br>To Space:<br>   capacity &#x3D; 3670016 (3.5MB)<br>   used     &#x3D; 0 (0.0MB)<br>   free     &#x3D; 3670016 (3.5MB)<br>   0.0% used<br>PS Old Generation<br>   capacity &#x3D; 536870912 (512.0MB)<br>   used     &#x3D; 410616392 (391.5943069458008MB)<br>   free     &#x3D; 126254520 (120.40569305419922MB)<br>   76.48326307535172% used</p>
<p>33292 interned Strings occupying 3675544 bytes.</p>
<p>上面可以查看新生代，老生代堆内存的分配大小以及使用情况，看是否本身分配过小。</p>
<h3 id="找到最耗内存的对象"><a href="#找到最耗内存的对象" class="headerlink" title="找到最耗内存的对象"></a>找到最耗内存的对象</h3><hr>
<h2 id="num-instances-bytes-class-name"><a href="#num-instances-bytes-class-name" class="headerlink" title=" num     #instances         #bytes  class name"></a> num     #instances         #bytes  class name</h2><p>   1:          8485       13503648  [B<br>   2:         25059       10963800  [Ljava.lang.Object;<br>   3:        100128       10175088  [C<br>   4:         99416        2385984  java.lang.String<br>   5:         59166        1893312  java.util.concurrent.ConcurrentHashMap$Node<br>   6:         15793        1747080  java.lang.Class<br>   7:          7507        1450440  [I<br>   8:         16454        1447952  java.lang.reflect.Method<br>   9:         30518        1220720  java.util.LinkedHashMap$Entry<br>  10:           449        1208128  [Ljava.util.concurrent.ConcurrentHashMap$Node;<br>  11:          1794        1176864  io.grpc.netty.shaded.io.netty.util.internal.shaded.org.jctools.queues.MpscArrayQueue<br>  12:         32515        1040480  java.util.HashMap$Node<br>  13:         11690         974592  [Ljava.util.HashMap$Node;<br>  14:         16384         786432  com.alipay.sofa.jraft.core.FSMCallerImpl$ApplyTask<br>  15:         11956         669536  java.util.LinkedHashMap<br>  16:         37191         595056  java.lang.Object<br>  17:         16384         524288  com.alipay.sofa.jraft.core.NodeImpl$LogEntryAndClosure<br>  18:         16384         524288  com.alipay.sofa.jraft.core.ReadOnlyServiceImpl$ReadIndexEvent<br>  19:         16384         393216  com.alipay.sofa.jraft.storage.impl.LogManagerImpl$StableClosureEvent<br>  20:          4055         338464  [Ljava.util.WeakHashMap$Entry;<br>  21:          7831         313240  java.lang.ref.Finalizer<br>  22:         13650         306008  [Ljava.lang.Class;<br>  23:         11306         271344  org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource$DefaultCacheKey<br>  24:          3787         242368  org.springframework.boot.loader.jar.JarFileWrapper</p>
<p>如上图，输入命令后，会以表格的形式显示存活对象的信息，并按照所占内存大小排序：</p>
<ul>
<li>实例数</li>
<li>所占内存大小</li>
<li>类名<br>是不是很直观？对于实例数较多，占用内存大小较多的实例&#x2F;类，相关的代码就要针对性review了。</li>
</ul>
<p>上图中占内存最多的对象 共占用内存才10几M，都属于正常使用范围。</p>
<p>如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放。例如：</p>
<ul>
<li>申请完资源后，未调用close()或dispose()释放资源</li>
<li>消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多<br>画外音：线上执行该命令会强制执行一次fgc。另外还可以dump内存进行分析。</li>
</ul>
<h3 id="确认是否是资源耗尽"><a href="#确认是否是资源耗尽" class="headerlink" title="确认是否是资源耗尽"></a>确认是否是资源耗尽</h3><hr>
<p>工具：</p>
<ul>
<li>pstree</li>
<li>netstat<br>查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM。</li>
</ul>
<p>这里介绍另一种方法，通过</p>
<ul>
<li>&#x2F;proc&#x2F;${PID}&#x2F;fd</li>
<li>&#x2F;proc&#x2F;${PID}&#x2F;task<br>可以分别查看句柄详情和线程数。</li>
</ul>
<p>例如，某一台线上服务器的sshd进程PID是9339，查看</p>
<ul>
<li>ll &#x2F;proc&#x2F;1309&#x2F;fd</li>
<li>ll &#x2F;proc&#x2F;1309&#x2F;task<br><img src="https://img-blog.csdnimg.cn/b30a356dcfed449b9ca9733d48e2a48e.png" alt="在这里插入图片描述"><br>如上图，sshd共占用了四个句柄</li>
<li>0 -&gt; 标准输入</li>
<li>1 -&gt; 标准输出</li>
<li>2 -&gt; 标准错误输出</li>
<li>3 -&gt; socket（容易想到是监听端口）</li>
</ul>
<p>sshd只有一个主线程PID为1309，并没有多线程。</p>
<p>所以，只要</p>
<ul>
<li>ll &#x2F;proc&#x2F;${PID}&#x2F;fd wc -l</li>
<li>ll &#x2F;proc&#x2F;${PID}&#x2F;task wc -l （效果等同pstree -p wc -l）</li>
</ul>
<p>就能知道进程打开的句柄数和线程数。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
        <tag>OutOfMemoryError</tag>
        <tag>内存溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA连接Oracle数据库报错：nested exception is java.sql.SQLException: oracle.jdbc.driver.OracleDriver</title>
    <url>/2021/07/05/java%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99%EF%BC%9Anested-exception-is-java-sql-sqlexception-oracle-jdbc-driver-oracledriver/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-17.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>Java项目 war包 copy到服务器上启动报错<br>Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: oracle.jdbc.OracleDriver</p>
<h3 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h3><hr>
<p>### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: oracle.jdbc.OracleDriver</p>
<h3 id="The-error-may-exist-in-file-x2F-data-x2F-tomcat-addressbook-x2F-webapps-x2F-addressbook-x2F-WEB-INF-x2F-classes-x2F-mybatis-x2F-system-x2F-SysConfigMapper-xml"><a href="#The-error-may-exist-in-file-x2F-data-x2F-tomcat-addressbook-x2F-webapps-x2F-addressbook-x2F-WEB-INF-x2F-classes-x2F-mybatis-x2F-system-x2F-SysConfigMapper-xml" class="headerlink" title="The error may exist in file [&#x2F;data&#x2F;tomcat-addressbook&#x2F;webapps&#x2F;addressbook&#x2F;WEB-INF&#x2F;classes&#x2F;mybatis&#x2F;system&#x2F;SysConfigMapper.xml]"></a>The error may exist in file [&#x2F;data&#x2F;tomcat-addressbook&#x2F;webapps&#x2F;addressbook&#x2F;WEB-INF&#x2F;classes&#x2F;mybatis&#x2F;system&#x2F;SysConfigMapper.xml]</h3><h3 id="The-error-may-involve-com-carsoa-project-system-mapper-SysConfigMapper-selectConfigList"><a href="#The-error-may-involve-com-carsoa-project-system-mapper-SysConfigMapper-selectConfigList" class="headerlink" title="The error may involve com.carsoa.project.system.mapper.SysConfigMapper.selectConfigList"></a>The error may involve com.carsoa.project.system.mapper.SysConfigMapper.selectConfigList</h3><h3 id="The-error-occurred-while-executing-a-query"><a href="#The-error-occurred-while-executing-a-query" class="headerlink" title="The error occurred while executing a query"></a>The error occurred while executing a query</h3><h3 id="Cause-org-springframework-jdbc-CannotGetJdbcConnectionException-Failed-to-obtain-JDBC-Connection-nested-exception-is-java-sql-SQLException-oracle-jdbc-OracleDriver"><a href="#Cause-org-springframework-jdbc-CannotGetJdbcConnectionException-Failed-to-obtain-JDBC-Connection-nested-exception-is-java-sql-SQLException-oracle-jdbc-OracleDriver" class="headerlink" title="Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: oracle.jdbc.OracleDriver"></a>Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: oracle.jdbc.OracleDriver</h3><pre><code>    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643)
    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1420)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516)
    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)
    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:897)
    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:879)
    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551)
    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141)
    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747)
    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:405)
    at org.springframework.boot.SpringApplication.run(SpringApplication.java:315)
    at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:152)
    at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:132)
    at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:92)
    at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:172)
    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5245)
    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
    ... 10 more
</code></pre>
<p>Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘userDetailsServiceImpl’: Unsatisfied dependency expressed through field ‘userService’;<br>nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘sysUserServiceImpl’: Unsatisfied dependency expressed through field ‘configService’;<br>nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sysConfigServiceImpl’:<br>Invocation of init method failed; nested exception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><hr>
<p>创建数据源的时候报错了，仔细发现是缺少oracle的驱动jar</p>
<p>我查询pom.xml发现驱动jar 被注释了，打开后，报红线，大概意思是说本地中的maven 中的没有对应的jar</p>
<p>怎么办，查询资料，发现maven3后，不会自带oracle的驱动jar，</p>
<p>需要通过下面的命令可以将jar加载到本地的maven的库中<br><img src="https://img-blog.csdnimg.cn/20210702172149178.png" alt="在这里插入图片描述"><br>war 包里面找不到 ojdbc的驱动</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>检查pom.xml文件，修改build项</p>
<pre><code>&lt;build&gt;
    &lt;finalName&gt;ccc-xxx&lt;/finalName&gt; &lt;!--项目名--&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;configuration&gt;
                &lt;webResources&gt;
                    &lt;resource&gt;
                        &lt;directory&gt;lib&lt;/directory&gt;
                        &lt;targetPath&gt;WEB-INF/lib/&lt;/targetPath&gt;
                        &lt;includes&gt;
                            &lt;include&gt;\*\*/\*.jar&lt;/include&gt;
                        &lt;/includes&gt;
                    &lt;/resource&gt;
                &lt;/webResources&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;default-war&lt;/id&gt;
                    &lt;phase&gt;prepare-package&lt;/phase&gt;
                    &lt;configuration&gt;
                        &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>重新打包，部署正常连接数据了</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ojdbc8.jar</tag>
        <tag>Oracle</tag>
        <tag>OracleDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins Failed to connect to http://xxx:8080/tcpSlaveAgentListener/: Connection refused (Connection refused)</title>
    <url>/2022/01/01/jenkins-failed-to-connect-to-http-xxx8080-tcpslaveagentlistener-connection-refused-connection-refused/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2022/01/image-1.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>K8s集群上运行的Jenkins报这个错SEVERE: Failed to connect to <a href="http://172.25.42.235:8081/tcpSlaveAgentListener/">http://172.25.42.235:8081/tcpSlaveAgentListener/</a>: Connection refused (Connection refused)<br>构建时创建Pod失败，后一直循环创建Jenkins-slave<br><img src="https://img-blog.csdnimg.cn/2eb733c0d3c9421db9ea47ea263a88b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="排查错误"><a href="#排查错误" class="headerlink" title="排查错误"></a>排查错误</h3><hr>
<p>查看Jenkins服务日志</p>
<p>[root@k8s-master01 jenkins]# kubectl get pod -n devopsgrep jenkins<br>jenkins-app-7b4ff4c854-zpcd2         1&#x2F;1     Running   5          105d<br>[root@k8s-master01 jenkins]# kubectl logs -f jenkins-app-7b4ff4c854-zpcd2 -n devops</p>
<p>发现如下报错</p>
<p>Jan 10, 2022 2:24:13 AM hudson.remoting.jnlp.Main$CuiListener error<br>SEVERE: Failed to connect to <a href="http://172.25.42.235:8081/tcpSlaveAgentListener/">http://172.25.42.235:8081/tcpSlaveAgentListener/</a>: Connection refused (Connection refused)<br>java.io.IOException: Failed to connect to <a href="http://172.25.42.235:8081/tcpSlaveAgentListener/">http://172.25.42.235:8081/tcpSlaveAgentListener/</a>: Connection refused (Connection refused)<br>at org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver.resolve(JnlpAgentEndpointResolver.java:217)<br>at hudson.remoting.Engine.innerRun(Engine.java:693)<br>at hudson.remoting.Engine.run(Engine.java:518)<br>Caused by: java.net.ConnectException: Connection refused (Connection refused)<br>at java.net.PlainSocketImpl.socketConnect(Native Method)<br>at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)<br>at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)<br>at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)<br>at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)<br>at java.net.Socket.connect(Socket.java:607)<br>at sun.net.NetworkClient.doConnect(NetworkClient.java:175)<br>at sun.net.<a href="http://www.http.HttpClient.openServer(HttpClient.java:463)">www.http.HttpClient.openServer(HttpClient.java:463)</a><br>at sun.net.<a href="http://www.http.HttpClient.openServer(HttpClient.java:558)">www.http.HttpClient.openServer(HttpClient.java:558)</a><br>at sun.net.<a href="http://www.http.httpclient/">www.http.HttpClient</a>.<init>(HttpClient.java:242)<br>at sun.net.<a href="http://www.http.HttpClient.New(HttpClient.java:339)">www.http.HttpClient.New(HttpClient.java:339)</a><br>at sun.net.<a href="http://www.http.HttpClient.New(HttpClient.java:357)">www.http.HttpClient.New(HttpClient.java:357)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1226)">www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1226)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1162)">www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1162)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1056)">www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1056)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:990)">www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:990)</a><br>at org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver.resolve(JnlpAgentEndpointResolver.java:214)</p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><hr>
<p>由于把Jenkins的访问方式由 nodeport 改也了 clusterip + ingress-nginx 方式，之前的IP地址 变也了域名，所以Jenkins 报错</p>
<p>SEVERE: Failed to connect to <a href="http://172.25.42.235:8081/tcpSlaveAgentListener/">http://172.25.42.235:8081/tcpSlaveAgentListener/</a>: Connection refused (Connection refused)<br>java.io.IOException: Failed to connect to <a href="http://172.25.42.235:8081/tcpSlaveAgentListener/">http://172.25.42.235:8081/tcpSlaveAgentListener/</a>: Connection refused (Connection refused)</p>
<h3 id="修改K8s访问Jenkins-地址"><a href="#修改K8s访问Jenkins-地址" class="headerlink" title="修改K8s访问Jenkins 地址"></a>修改K8s访问Jenkins 地址</h3><hr>
<h4 id="1-系统管理-节点管理"><a href="#1-系统管理-节点管理" class="headerlink" title="1. 系统管理-节点管理"></a>1. 系统管理-节点管理</h4><p><img src="https://img-blog.csdnimg.cn/afbc46bd72a449199b7a8ca58efce8fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="2-节点管理-Configure-Clouds"><a href="#2-节点管理-Configure-Clouds" class="headerlink" title="2. 节点管理-Configure Clouds"></a>2. 节点管理-Configure Clouds</h4><p><img src="https://img-blog.csdnimg.cn/ff658ae0778d4917bce2f725ce2f1dc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="3-Configure-Clouds-Kubernetes-Cloud-details"><a href="#3-Configure-Clouds-Kubernetes-Cloud-details" class="headerlink" title="3. Configure Clouds-Kubernetes Cloud details"></a>3. Configure Clouds-Kubernetes Cloud details</h4><p><img src="https://img-blog.csdnimg.cn/a44f306549f646d8a07a608ab5b816d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="4-Kubernetes-Cloud-details-Jenkins-地址"><a href="#4-Kubernetes-Cloud-details-Jenkins-地址" class="headerlink" title="4. Kubernetes Cloud details-Jenkins 地址"></a>4. Kubernetes Cloud details-Jenkins 地址</h4><p><img src="https://img-blog.csdnimg.cn/2154e85e7e9742a6be7f9240ae58f252.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>Jenkins访问地址改了，Kubernetes Cloud details上访问</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Kubernetes</tag>
        <tag>Connection refused</tag>
        <tag>tcpSlaveAgentListener</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 如何控制用户项目权限？</title>
    <url>/2021/11/26/jenkins-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%94%A8%E6%88%B7%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-13-1024x528.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在Jenkins做项目构建及持续集成过程中，我们需要考虑权限问题。比如不同项目组用户只能看到自己项目的任务，那如何实现用户权限管理呢，接下来我们详细介绍。</p>
<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><hr>
<p>为了测试权限控制，我们首先创建两个新的用户，后续会给这两个用户赋予权限。</p>
<h4 id="首页，-依次点击系统管理-全局安全配置。"><a href="#首页，-依次点击系统管理-全局安全配置。" class="headerlink" title="首页， 依次点击系统管理-全局安全配置。"></a>首页， 依次点击系统管理-全局安全配置。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/b57a677d900b4c17b1d7f80ce3eb8f0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="勾选允许用户注册，然后点击保存。"><a href="#勾选允许用户注册，然后点击保存。" class="headerlink" title="勾选允许用户注册，然后点击保存。"></a>勾选允许用户注册，然后点击保存。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/2ae74f1574da4bef9a78f0edff4b0c90.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="退出当前登录，在登录首页点击创建一个用户账号。"><a href="#退出当前登录，在登录首页点击创建一个用户账号。" class="headerlink" title="退出当前登录，在登录首页点击创建一个用户账号。"></a>退出当前登录，在登录首页点击创建一个用户账号。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/17eeb210cc2444f6a286a94065436d31.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="我创建了一个账号：code404"><a href="#我创建了一个账号：code404" class="headerlink" title="我创建了一个账号：code404"></a>我创建了一个账号：code404</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/904421b5cbef4e0d9738f7582100e50f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="二、安装权限控制插件"><a href="#二、安装权限控制插件" class="headerlink" title="二、安装权限控制插件"></a>二、安装权限控制插件</h3><hr>
<p>Jenkins提供了多种权限控制插件，我们这里使用Role-based Authorization Strategy。</p>
<h4 id="首页，依次点击系统管理–-gt-插件管理。"><a href="#首页，依次点击系统管理–-gt-插件管理。" class="headerlink" title="首页，依次点击系统管理–&gt;插件管理。"></a>首页，依次点击系统管理–&gt;插件管理。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/5fd80db8152b4aa8930a08dfa85cfe23.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="可选插件，搜索Role-based-Authorization-Strategy，勾选后下载插件。我这里已经安装好了"><a href="#可选插件，搜索Role-based-Authorization-Strategy，勾选后下载插件。我这里已经安装好了" class="headerlink" title="可选插件，搜索Role-based Authorization Strategy，勾选后下载插件。我这里已经安装好了"></a>可选插件，搜索Role-based Authorization Strategy，勾选后下载插件。我这里已经安装好了</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/74bfc8a3eb4743dfaebc37b777033e85.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="首页依次点击，系统管理-gt-全局安全配置，授权策略选择-Role-Based-Strategy。"><a href="#首页依次点击，系统管理-gt-全局安全配置，授权策略选择-Role-Based-Strategy。" class="headerlink" title="首页依次点击，系统管理-&gt;全局安全配置，授权策略选择 Role-Based Strategy。"></a>首页依次点击，系统管理-&gt;全局安全配置，授权策略选择 Role-Based Strategy。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/04c84a1a1b3e45278de42e1a0bc6fab1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="三、创建角色"><a href="#三、创建角色" class="headerlink" title="三、创建角色"></a>三、创建角色</h3><hr>
<h4 id="首页，依次点击系统管理–-gt-Manage-and-Assign-Roles–-gt-Manage-Roles。"><a href="#首页，依次点击系统管理–-gt-Manage-and-Assign-Roles–-gt-Manage-Roles。" class="headerlink" title="首页，依次点击系统管理–&gt;Manage and Assign Roles–&gt;Manage Roles。"></a>首页，依次点击系统管理–&gt;Manage and Assign Roles–&gt;Manage Roles。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/e0d9568f2cd6404b8b8e1ec0f08f7b06.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="Global-roles，用来分配全局策略，这里我们创建test-role，只有可读权限。"><a href="#Global-roles，用来分配全局策略，这里我们创建test-role，只有可读权限。" class="headerlink" title="Global roles，用来分配全局策略，这里我们创建test_role，只有可读权限。"></a>Global roles，用来分配全局策略，这里我们创建test_role，只有可读权限。</h4><hr>
<p>创建test_role角色，test_role角色赋予全局可读权限。</p>
<p><img src="https://img-blog.csdnimg.cn/a8013de0b7ce4b6fb7237b74e2702e12.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="Item-roles，用来分配项目权限，比如code404用户只能访问test项目，码404-role角色只能看到以test开头的视图与项目。"><a href="#Item-roles，用来分配项目权限，比如code404用户只能访问test项目，码404-role角色只能看到以test开头的视图与项目。" class="headerlink" title="Item roles，用来分配项目权限，比如code404用户只能访问test项目，码404_role角色只能看到以test开头的视图与项目。"></a>Item roles，用来分配项目权限，比如code404用户只能访问test项目，码404_role角色只能看到以test开头的视图与项目。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/135674d43f124796aa00f3739fab87df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>温馨提示：设置完后，点击保存。</p>
<h3 id="四、分配角色"><a href="#四、分配角色" class="headerlink" title="四、分配角色"></a>四、分配角色</h3><hr>
<h4 id="首页，依次点击系统管理–-gt-Manage-and-Assign-Roles–-gt-Assign-Roles。"><a href="#首页，依次点击系统管理–-gt-Manage-and-Assign-Roles–-gt-Assign-Roles。" class="headerlink" title="首页，依次点击系统管理–&gt;Manage and Assign Roles–&gt;Assign Roles。"></a>首页，依次点击系统管理–&gt;Manage and Assign Roles–&gt;Assign Roles。</h4><h4 id="Global-roles，分别添加我们一开始准备的账号并分配角色。"><a href="#Global-roles，分别添加我们一开始准备的账号并分配角色。" class="headerlink" title="Global roles，分别添加我们一开始准备的账号并分配角色。"></a>Global roles，分别添加我们一开始准备的账号并分配角色。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/6c981d66c36346f3a327734b0b975f5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>为 码404用户分配全局可读角色。</p>
<h4 id="Item-roles，添加码404用户，并分配项目角色权限。"><a href="#Item-roles，添加码404用户，并分配项目角色权限。" class="headerlink" title="Item roles，添加码404用户，并分配项目角色权限。"></a>Item roles，添加码404用户，并分配项目角色权限。</h4><hr>
<p>添加码404用户，为 码404 用户分配不同项目权限。</p>
<p><img src="https://img-blog.csdnimg.cn/bd050cc4f46b440d82ce0e4898e63c7a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>温馨提示：设置完后，点击保存。</p>
<h3 id="五、验证权限"><a href="#五、验证权限" class="headerlink" title="五、验证权限"></a>五、验证权限</h3><hr>
<h4 id="码404-用户登录后，只能看到test开头的任务。"><a href="#码404-用户登录后，只能看到test开头的任务。" class="headerlink" title="码404 用户登录后，只能看到test开头的任务。"></a>码404 用户登录后，只能看到test开头的任务。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/6a105f0181f7499f9eb5dc83c33b7e5d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>项目</tag>
        <tag>Role</tag>
        <tag>Role-Based Access Control</tag>
        <tag>权限</tag>
        <tag>权限控制</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 用户、角色及权限管理</title>
    <url>/2021/04/28/jenkins-%E7%94%A8%E6%88%B7%E3%80%81%E8%A7%92%E8%89%B2%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%9C%A8%E6%96%B0%E5%AE%89%E8%A3%85%E5%A5%BD%E7%9A%84jenkins%E4%B8%AD%EF%BC%8C%E9%BB%98%E8%AE%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-32.png"></p>
<h2 id="1、安装插件Role-based-Authorization-Strategy"><a href="#1、安装插件Role-based-Authorization-Strategy" class="headerlink" title="1、安装插件Role-based Authorization Strategy"></a>1、安装插件Role-based Authorization Strategy</h2><p>首先要以管理员身份登录Jenkins<br>在插件管理模块中，检查Role-based Authorization Strategy 插件是否已经安装。<br>插件地址：<a href="https://plugins.jenkins.io/role-strategy/">https://plugins.jenkins.io/role-strategy/</a>  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-33-1024x466.png"></p>
<p>用户管理Role-based Authorization Strategy插件安装完成后，在jenkins的 系统管理–&gt;全局安全配置 功能中，启用Enable security启用安全，安全Security Realm修改为 Jenkins专有用户数据库 并将授权认证策略方式Authorization设置为 Role-Based Strategy，然后应用  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-34-1024x466.png"></p>
<h2 id="2、角色管理"><a href="#2、角色管理" class="headerlink" title="2、角色管理"></a>2、角色管理</h2><p>配置角色<br>系统管理–&gt;Manage and Assign Roles –&gt;Manage Roles<br>组件中完成角色配置工作  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-35-1024x466.png"></p>
<h3 id="Manage-Roles角色管理配置"><a href="#Manage-Roles角色管理配置" class="headerlink" title="Manage Roles角色管理配置"></a>Manage Roles角色管理配置</h3><p>在这个配置页面可完成精细化，权限划分</p>
<h4 id="添加角色"><a href="#添加角色" class="headerlink" title="添加角色"></a>添加角色</h4><p>Global roles 用于配置全局，默认设置了admin角色<br>添加dev和test，对应开发和测试的角色权限  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-36-1024x466.png"></p>
<p>这里角色权限只在 全部 一列 中选择 read 即可，一般情况下普通用户不用选其它的角色权限</p>
<h4 id="配置项目Job-详细权限"><a href="#配置项目Job-详细权限" class="headerlink" title="配置项目Job 详细权限"></a>配置项目Job 详细权限</h4><p>添加一行 item roles  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-37-1024x345.png"></p>
<p>这里我只配置了可以 查看、构建、工作空间三个权限<br>可以根据自己的需求给权限</p>
<h2 id="2、分配角色"><a href="#2、分配角色" class="headerlink" title="2、分配角色"></a>2、分配角色</h2><p>选择Manage and Assign Roles 下面的 Assign Roles  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-38-1024x466.png"></p>
<p>在这个配置页面中，关联角色配置，张三疯用户关联全局test 角色和Item角色中的测试环境</p>
<p>OK，保存了应该就可以了</p>
<h2 id="登录用户测试"><a href="#登录用户测试" class="headerlink" title="登录用户测试"></a>登录用户测试</h2><p><img src="https://code404.icu/img/moveypu/2021/04/image-39-1024x469.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-40-1024x469.png"></p>
<p>可以看的到，用户权限已经分配好</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>权限管理</tag>
        <tag>用户角色</tag>
        <tag>项目权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins如何配置扩展共享库?</title>
    <url>/2021/10/04/jenkins%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%89%A9%E5%B1%95%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>共享库这并不是一个全新的概念，其实具有编程能力的同学应该清楚一些。例如在编程语言Python中，我们可以将Python代码写到一个文件中，当代码数量增加，我们可以将代码打包成模块然后再以import的方式使用此模块中的方法。<br>在Jenkins中使用Groovy语法，共享库中存储的每个文件都是一个groovy的类，每个文件（类）中包含一个或多个方法。每个方法包含groovy语句块。</p>
<h3 id="1-共享库内容"><a href="#1-共享库内容" class="headerlink" title="1. 共享库内容"></a>1. 共享库内容</h3><hr>
<p>这是一个demo演示的共享库，大家可以看到仓库的结构与内容。这个仓库中包含了很多类，例如：我将kubernetes中的API方法封装在了kubernetes.groovy文件中，便于后面引用。在此你只需要知道共享库的结构 ，具体该如何创建共享库后面会讲述😀</p>
<p>── docs<br>│   └── README.mdREADME.md<br>├── src<br>│   └── org<br>│       └── devops<br>│           └── tools.groovy<br>└── vars</p>
<p>src目录主要存放我们要编写的groovy类，执行流水线时，此目录将添加到class_path中。vars目录主要存放脚本文件，这些脚本文件在流水线中作为变量公开。resources目录允许从外部库中使用步骤来加载相关联的非Groovy文件。</p>
<h3 id="2-创建共享库"><a href="#2-创建共享库" class="headerlink" title="2. 创建共享库"></a>2. 创建共享库</h3><hr>
<p>新建文件src&#x2F;org&#x2F;devops&#x2F;tools.groovy, 在此我将这个文件定义为扩展工具类，主要放一些扩展方法。</p>
<p>例如：在构建日志中查看流水线详细日志会很乱，我们可以在日志中将重点步骤通过不同的颜色高亮显示，便于排错。我们开始写这样的一个方法PrintMes(),包含两个参数，输出内容value和内容的颜色color。</p>
<p>注意：我们需要安装 插件AnsiColor，这样才能使用ansiColor()方法，可以在片段生成器查看更多的用法。</p>
<p>package org.devops</p>
<p>&#x2F;&#x2F;格式化输出<br>def PrintMes(value,color){<br>    colors &#x3D; [‘red’   : “\033[40;31m &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;${value}&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; \033[0m”,<br>              ‘blue’  : “\033[47;34m ${value} \033[0m”,<br>              ‘green’ : “[1;32m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;${value}&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[m”,<br>              ‘green1’ : “\033[40;32m &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;${value}&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; \033[0m” ]<br>    ansiColor(‘xterm’) {<br>        println(colors[color])<br>    }<br>}</p>
<h3 id="3-使用共享库"><a href="#3-使用共享库" class="headerlink" title="3. 使用共享库"></a>3. 使用共享库</h3><hr>
<p>我们导航到 系统配置 -&gt; Global Pipeline Libraries</p>
<p>首先，我们为共享库设置一个名称jenkinslib，注意这个名称后续在Jenkinsfile中引用。再设置一个默认的版本，这里的版本是分支的名称。我默认配置的是master版本。<br><img src="https://img-blog.csdnimg.cn/506797ba929d487a94045e4cb2621558.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>接下来我们配置共享库的仓库地址，我的仓库在github中，所以这里我填写的是github的方式。（如果你用的是gitlab可以使用gitlab方式或者git方式）。如果仓库是私有的方式，需要在jenkins的凭据中添加一个账号用于下载共享库。<br><img src="https://img-blog.csdnimg.cn/27176a8a76864326bc55e8f6aba6a84b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>好，到此共享库在Jenkins的配置就完成了，接下来测试在Jenkinsfile中引用。</p>
<p>在Jenkinsfile中使用 <strong>@Library(‘jenkinslib’) _</strong> 来加载共享库，注意后面符号_用于加载。类的实例化 <strong>def tools &#x3D; new org.devops.tools()</strong> ,使用类中的方法 <strong>tools.PrintMes(“获取代码”,‘green’)</strong> 。</p>
<p>#!groovy</p>
<p>@Library(‘jenkinslib’) _     </p>
<p>def tools &#x3D; new org.devops.tools()</p>
<p>pipeline {<br>    agent { node {  label “master” }}</p>
<pre><code>stages &#123;
    //下载代码
    stage(&quot;GetCode&quot;)&#123; 
        steps&#123;  
            timeout(time:5, unit:&quot;MINUTES&quot;)&#123;   
                script&#123; 
                    tools.PrintMes(&quot;获取代码&quot;,&#39;green&#39;)
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>接下来在你的Jenkins上面运行一下吧，测试一下是否能够看到带有绿色的文字呢？</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>groovy</tag>
        <tag>共享库</tag>
        <tag>扩展</tag>
        <tag>流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins密码忘记重置方法</title>
    <url>/2021/12/17/jenkins%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E9%87%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-9.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Jenkins密码忘记分两种情况，</p>
<ol>
<li>刚开始安装Jenkins，没有修改过密码</li>
<li>密码之前修改过，但是再次登录时候忘记自己修改的密码了</li>
</ol>
<h3 id="1-刚开始安装Jenkins，没有修改过密码"><a href="#1-刚开始安装Jenkins，没有修改过密码" class="headerlink" title="1. 刚开始安装Jenkins，没有修改过密码"></a>1. 刚开始安装Jenkins，没有修改过密码</h3><hr>
<p>找回：直接找.jenkins&#x2F;secrets&#x2F;initialAdminPassword，安装初始密码保存在此文件中，具体路径因人而异，可使用find命令查找文件查看</p>
<h3 id="2-密码之前修改过，但是再次登录时候忘记自己修改的密码了"><a href="#2-密码之前修改过，但是再次登录时候忘记自己修改的密码了" class="headerlink" title="2. 密码之前修改过，但是再次登录时候忘记自己修改的密码了"></a>2. 密码之前修改过，但是再次登录时候忘记自己修改的密码了</h3><hr>
<h4 id="1、删除Jenkins目录下config-xml文件中下面代码，并保存文件"><a href="#1、删除Jenkins目录下config-xml文件中下面代码，并保存文件" class="headerlink" title="1、删除Jenkins目录下config.xml文件中下面代码，并保存文件"></a>1、删除Jenkins目录下config.xml文件中下面代码，并保存文件</h4><hr>
<p>  <useSecurity>true</useSecurity><br>  <authorizationStrategy class="hudson.security.FullControlOnceLoggedInAuthorizationStrategy"><br>    <denyAnonymousReadAccess>true</denyAnonymousReadAccess><br>  </authorizationStrategy><br>  <securityRealm class="hudson.security.HudsonPrivateSecurityRealm"><br>    <disableSignup>true</disableSignup><br>    <enableCaptcha>false</enableCaptcha><br>  </securityRealm></p>
<h4 id="2、重启Jenkins服务"><a href="#2、重启Jenkins服务" class="headerlink" title="2、重启Jenkins服务"></a>2、重启Jenkins服务</h4><hr>
<p>给你们提供一个Jenkins启动脚本</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<h2 id="java-jenkins-environment"><a href="#java-jenkins-environment" class="headerlink" title="java jenkins environment"></a>java jenkins environment</h2><p>export JENKINS_HOME&#x3D;&#x2F;home&#x2F;software&#x2F;jenkins&#x2F;.jenkins<br>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_161<br>export JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_161&#x2F;jre</p>
<p>##config<br>port&#x3D;9005<br>pid&#x3D;.jenkins.pid</p>
<p>#start<br>nohup &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_161&#x2F;bin&#x2F;java -jar &#x2F;home&#x2F;software&#x2F;jenkins&#x2F;jenkins.war –httpPort&#x3D;$port &amp;<br>echo $! &gt;$pid</p>
<h4 id="3、进入首页-gt-“系统管理”-gt-“Configure-Global-Security”；"><a href="#3、进入首页-gt-“系统管理”-gt-“Configure-Global-Security”；" class="headerlink" title="3、进入首页&gt;“系统管理”&gt;“Configure Global Security”；"></a>3、进入首页&gt;“系统管理”&gt;“Configure Global Security”；</h4><h4 id="4、勾选“启用安全”；"><a href="#4、勾选“启用安全”；" class="headerlink" title="4、勾选“启用安全”；"></a>4、勾选“启用安全”；</h4><h4 id="5、点选“Jenkins专有用户数据库”，并点击“保存”；"><a href="#5、点选“Jenkins专有用户数据库”，并点击“保存”；" class="headerlink" title="5、点选“Jenkins专有用户数据库”，并点击“保存”；"></a>5、点选“Jenkins专有用户数据库”，并点击“保存”；</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/af44f35bff964d9699c7c6195a32160e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="6、重新点击首页-gt-“系统管理”-发现此时出现“管理用户”；"><a href="#6、重新点击首页-gt-“系统管理”-发现此时出现“管理用户”；" class="headerlink" title="6、重新点击首页&gt;“系统管理”,发现此时出现“管理用户”；"></a>6、重新点击首页&gt;“系统管理”,发现此时出现“管理用户”；</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/f84b7d64deb345e880b08d3cbbe1c6d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="7、点击右侧进入修改密码页面，修改后即可重新登录"><a href="#7、点击右侧进入修改密码页面，修改后即可重新登录" class="headerlink" title="7、点击右侧进入修改密码页面，修改后即可重新登录"></a>7、点击右侧进入修改密码页面，修改后即可重新登录</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/f72dafa29d504925b579ed9587df63dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>重置密码</tag>
        <tag>忘记密码</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins添加node节点jenkins-agent.jar_jenkins从节点？</title>
    <url>/2021/10/13/jenkins%E6%B7%BB%E5%8A%A0node%E8%8A%82%E7%82%B9jenkins-agent-jar-jenkins%E4%BB%8E%E8%8A%82%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-9.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>为了在不同的环境上部署项目，使用多节点的jenkins环境，我这里补充一篇文章，介绍如何在一个master的jenkins环境上添加一个windows节点。由于我的master 机器是linux，所以我现在就一步一步介绍如何添加一个windows Jenkins 节点到一个linux的master的jenkins，顺便测试一下agent这个指令。</p>
<h3 id="master添加节点配置"><a href="#master添加节点配置" class="headerlink" title="master添加节点配置"></a>master添加节点配置</h3><hr>
<p>系统配置-节点管理-新建节点<br><img src="https://img-blog.csdnimg.cn/963ce9f899b64563b5aab6a0e2ceeb05.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h3><hr>
<p>名称：Jenkins从节点名称<br>描述：Jenkins从节点相关的描述信息<br>执行器数量：1，<br>远程工作目录：远程服务器Jenkins工作目录<br>标签：<br>用法：有两个选项，我选择的 只允许运行绑定到这台机器的Job</p>
<ul>
<li>只允许运行绑定到这台机器的Job</li>
<li>尽可能的使用这个节点</li>
</ul>
<p>启动方式：有三个选项，我选择的是 通过Java Web启动代理<br>意思就是说通过代理来启动Jenkins从节点<br><img src="https://img-blog.csdnimg.cn/b91f8805ded2400493cd1ad0c7366a0c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="master节点-从节点端口被禁用-配置链接"><a href="#master节点-从节点端口被禁用-配置链接" class="headerlink" title="master节点 从节点端口被禁用 配置链接."></a>master节点 从节点端口被禁用 配置链接.</h3><hr>
<p>遇到这个问题，需要配置代理端口<br><img src="https://img-blog.csdnimg.cn/910e21e5607f4485906b202897e80150.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里可以选择指定端口，也可以随机选取（Jenkins随机选取一个端口和agent通信）<br><img src="https://img-blog.csdnimg.cn/c481c9f7956a407dab3363b7692e7ca4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="agent节点配置"><a href="#agent节点配置" class="headerlink" title="agent节点配置"></a>agent节点配置</h3><hr>
<p>再次查看节点管理，就不报错了</p>
<p>slave-agent.jnlp<br>agent.jar<br>两个包都在这个页面找到<br><img src="https://img-blog.csdnimg.cn/d6c87ab4d92042cd85311d5f61c70400.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="agent节点配置-启动从节点"><a href="#agent节点配置-启动从节点" class="headerlink" title="agent节点配置 启动从节点"></a>agent节点配置 启动从节点</h3><hr>
<h4 id="下载agent-jar"><a href="#下载agent-jar" class="headerlink" title="下载agent.jar"></a>下载agent.jar</h4><hr>
<p>[root@code404 ~]# wget <a href="http://192.168.65.171:8081/jenkins/jnlpJars/agent.jar">http://192.168.65.171:8081/jenkins/jnlpJars/agent.jar</a><br>–2021-10-12 16:53:36–  <a href="http://192.168.65.171:8081/jenkins/jnlpJars/agent.jar">http://192.168.65.171:8081/jenkins/jnlpJars/agent.jar</a><br>正在连接 192.168.65.171:8081… 已连接。<br>已发出 HTTP 请求，正在等待回应… 200<br>长度：1521553 (1.5M) [application&#x2F;java-archive]<br>正在保存至: “agent.jar”</p>
<p>100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 1,521,553   –.-K&#x2F;s 用时 0.006s  </p>
<p>2021-10-12 16:53:36 (238 MB&#x2F;s) - 已保存 “agent.jar” [1521553&#x2F;1521553])</p>
<h4 id="启动agent-jar"><a href="#启动agent-jar" class="headerlink" title="启动agent.jar"></a>启动agent.jar</h4><hr>
<p>[root@code404 ~]# java -jar agent.jar -jnlpUrl <a href="http://192.168.65.171:8081/jenkins/computer/new-agent01/slave-agent.jnlp">http://192.168.65.171:8081/jenkins/computer/new-agent01/slave-agent.jnlp</a> -secret d86fa4c580458973e7b8cda9519557bd482f7398b5002d3d3326a33770870a38 -workDir “&#x2F;data&#x2F;jenkins”<br>[root@BJOIS-AS ~]# java -jar agent.jar -jnlpUrl <a href="http://192.168.65.171:8081/jenkins/computer/new-agent01/slave-agent.jnlp">http://192.168.65.171:8081/jenkins/computer/new-agent01/slave-agent.jnlp</a> -secret d86fa4c580458973e7b8cda9519557bd482f7398b5002d3d3326a33770870a38 -workDir “&#x2F;data&#x2F;jenkins”<br>十月 12, 2021 5:26:42 下午 org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir<br>信息: Using &#x2F;data&#x2F;jenkins&#x2F;remoting as a remoting work directory<br>十月 12, 2021 5:26:42 下午 org.jenkinsci.remoting.engine.WorkDirManager setupLogging<br>信息: Both error and output logs will be printed to &#x2F;data&#x2F;jenkins&#x2F;remoting<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main createEngine<br>信息: Setting up agent: new-agent01<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main$CuiListener <init><br>信息: Jenkins agent is running in headless mode.<br>十月 12, 2021 5:26:42 下午 hudson.remoting.Engine startEngine<br>信息: Using Remoting version: 4.5<br>十月 12, 2021 5:26:42 下午 org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir<br>信息: Using &#x2F;data&#x2F;jenkins&#x2F;remoting as a remoting work directory<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Locating server among [<a href="http://192.168.65.171:8081/jenkins//]">http://192.168.65.171:8081/jenkins/\]</a><br>十月 12, 2021 5:26:42 下午 org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver resolve<br>信息: Remoting server accepts the following protocols: [JNLP4-connect, Ping]<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Agent discovery successful<br>  Agent address: 192.168.65.171<br>  Agent port:    3306<br>  Identity:      4b:f9:41:00:cf:67:c2:a9:d1:13:a5:e7:0c:53:d6:d8<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Handshaking<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Connecting to 192.168.65.171:3306<br>十月 12, 2021 5:26:42 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Trying protocol: JNLP4-connect<br>十月 12, 2021 5:26:43 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Remote identity confirmed: 4b:f9:41:00:cf:67:c2:a9:d1:13:a5:e7:0c:53:d6:d8<br>十月 12, 2021 5:26:44 下午 hudson.remoting.jnlp.Main$CuiListener status<br>信息: Connected</p>
<p>现在Jenkins从节点就添加成功了<br><img src="https://img-blog.csdnimg.cn/c42b1634e6d44bc6a0ae8d0eed293a4d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>master</tag>
        <tag>node</tag>
        <tag>slave</tag>
        <tag>从节点</tag>
        <tag>节点</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins集群钉钉机器人_推送构建结果_构建通知_dingdingtalk</title>
    <url>/2021/07/03/jenkins%E9%9B%86%E7%BE%A4%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%8E%A8%E9%80%81%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C-%E6%9E%84%E5%BB%BA%E9%80%9A%E7%9F%A5-dingdingtalk/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-15.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>最早做Jenkins发布完成以后通过邮件发送信息通知相关的联系人，发现邮件会受限于大家接收的设置，导致不能及时的看到相关的发布内容，公司使用钉钉做为公司内部的通讯工具，所以想通过Jenkins发布完成以后通过钉钉来通知大家，研究发现钉钉提供机器人，所以我把机器人集成进来通知相关人员。</p>
<h3 id="添加群机器人"><a href="#添加群机器人" class="headerlink" title="添加群机器人"></a>添加群机器人</h3><hr>
<ul>
<li>打开 群设置 选择 智能群助手</li>
</ul>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-7.png"></p>
<ul>
<li>选择 添加机器人</li>
</ul>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-8.png"></p>
<ul>
<li>选择 自定义 通过webhook接入自定义服务</li>
</ul>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-9.png"></p>
<ul>
<li>名字：Jenkins通知，安全设置 自定义关键字 888</li>
</ul>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-10.png"></p>
<h3 id="记一下机器人的Webhook地址"><a href="#记一下机器人的Webhook地址" class="headerlink" title="记一下机器人的Webhook地址"></a>记一下机器人的Webhook地址</h3><hr>
<p><a href="https://oapi.dingtalk.com/robot/send?access_token=xxxx">https://oapi.dingtalk.com/robot/send?access_token&#x3D;xxxx</a></p>
<h3 id="Jenkins安装钉钉插件"><a href="#Jenkins安装钉钉插件" class="headerlink" title="Jenkins安装钉钉插件"></a>Jenkins安装钉钉插件</h3><hr>
<p>插件 DingTalk 机器人通知</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-11.png"></p>
<h3 id="在Jenkins上配置钉钉机器人"><a href="#在Jenkins上配置钉钉机器人" class="headerlink" title="在Jenkins上配置钉钉机器人"></a>在Jenkins上配置钉钉机器人</h3><hr>
<p>在Jenkins的全局配置里面<br>通知时机：全都选上吧<br>机器人id：随机码<br>名称：dingdingtalk<br>Webhook：<a href="https://oapi.dingtalk.com/robot/send?access%5C_token=xxxx">https://oapi.dingtalk.com/robot/send?access\_token=xxxx</a><br>关键字：跟上面钉钉机器人里面一样 都是 888</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-12.png"></p>
<h3 id="在Jenkins-Job上面配置钉钉通知"><a href="#在Jenkins-Job上面配置钉钉通知" class="headerlink" title="在Jenkins Job上面配置钉钉通知"></a>在Jenkins Job上面配置钉钉通知</h3><hr>
<p>这里我选择刚才配置的 dingdingtalk</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-13.png"></p>
<h3 id="构建一下，看看会不会发送通知"><a href="#构建一下，看看会不会发送通知" class="headerlink" title="构建一下，看看会不会发送通知"></a>构建一下，看看会不会发送通知</h3><hr>
<p>通知消息发送成功</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-14.png"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>通知</tag>
        <tag>钉钉</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetty启动项目失败,WebService在本机上发布后报错：</title>
    <url>/2021/03/30/jetty%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E5%A4%B1%E8%B4%A5webservice%E5%9C%A8%E6%9C%AC%E6%9C%BA%E4%B8%8A%E5%8F%91%E5%B8%83%E5%90%8E%E6%8A%A5%E9%94%99%EF%BC%9A/</url>
    <content><![CDATA[<p>启动报错:</p>
<p>Caused by: org.apache.cxf.interceptor.Fault: Could not start Jetty server on port 21,110: Cannot assign requested address</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-03-30 08:12:14.301 [main] ERROR org.apache.catalina.core.ContainerBase.[Tomcat].[localhost].[/] Line:175 - StandardWrapper.Throwable</span><br><span class="line">javax.xml.ws.WebServiceException: org.apache.cxf.interceptor.Fault: Could not start Jetty server on port 21,110: Cannot assign requested address</span><br><span class="line">at org.apache.cxf.jaxws.EndpointImpl.doPublish(EndpointImpl.java:375)</span><br><span class="line">at org.apache.cxf.jaxws.EndpointImpl.publish(EndpointImpl.java:255)</span><br><span class="line">at org.apache.cxf.jaxws.spi.ProviderImpl.createAndPublishEndpoint(ProviderImpl.java:134)</span><br><span class="line">at javax.xml.ws.Endpoint.publish(Endpoint.java:240)</span><br><span class="line">at OThinker.H3.Portal.webservices.impl.OrganizationImpl.startService(OrganizationImpl.java:370)</span><br><span class="line">at OThinker.servlet.StartServlet.init(StartServlet.java:46)</span><br><span class="line">at javax.servlet.GenericServlet.init(GenericServlet.java:158)</span><br><span class="line">at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1124)</span><br><span class="line">at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:974)</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.load(TomcatEmbeddedContext.java:83)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class="line">at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1380)</span><br><span class="line">at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)</span><br><span class="line">at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270)</span><br><span class="line">at java.util.TreeMap$ValueSpliterator.forEachRemaining(TreeMap.java:2897)</span><br><span class="line">at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)</span><br><span class="line">at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)</span><br><span class="line">at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)</span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)</span><br><span class="line">at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.lambda$deferredLoadOnStartup$0(TomcatEmbeddedContext.java:65)</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.doWithThreadContextClassLoader(TomcatEmbeddedContext.java:108)</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.deferredLoadOnStartup(TomcatEmbeddedContext.java:64)</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.performDeferredLoadOnStartup(TomcatWebServer.java:282)</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.start(TomcatWebServer.java:200)</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.startWebServer(ServletWebServerApplicationContext.java:311)</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:164)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142)</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775)</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:316)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248)</span><br><span class="line">at com.h3bpm.web.WebApiBootStartupApplication.main(WebApiBootStartupApplication.java:18)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)</span><br><span class="line">at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)</span><br><span class="line">at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)</span><br><span class="line">at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:58)</span><br><span class="line">Caused by: org.apache.cxf.interceptor.Fault: Could not start Jetty server on port 21,110: Cannot assign requested address</span><br><span class="line">at org.apache.cxf.transport.http_jetty.JettyHTTPServerEngine.addServant(JettyHTTPServerEngine.java:484)</span><br><span class="line">at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.activate(JettyHTTPDestination.java:187)</span><br><span class="line">at org.apache.cxf.transport.AbstractObservable.setMessageObserver(AbstractObservable.java:53)</span><br><span class="line">at org.apache.cxf.binding.AbstractBindingFactory.addListener(AbstractBindingFactory.java:95)</span><br><span class="line">at org.apache.cxf.binding.soap.SoapBindingFactory.addListener(SoapBindingFactory.java:894)</span><br><span class="line">at org.apache.cxf.endpoint.ServerImpl.start(ServerImpl.java:132)</span><br><span class="line">at org.apache.cxf.jaxws.EndpointImpl.doPublish(EndpointImpl.java:366)</span><br><span class="line">... 43 common frames omitted</span><br><span class="line">Caused by: java.net.BindException: Cannot assign requested address</span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:433)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:425)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)</span><br><span class="line">at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:339)</span><br><span class="line">at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:307)</span><br><span class="line">at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)</span><br><span class="line">at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:235)</span><br><span class="line">at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)</span><br><span class="line">at org.eclipse.jetty.server.Server.doStart(Server.java:395)</span><br><span class="line">at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)</span><br><span class="line">at org.apache.cxf.transport.http_jetty.JettyHTTPServerEngine.addServant(JettyHTTPServerEngine.java:473)</span><br><span class="line">... 49 common frames omitted</span><br></pre></td></tr></table></figure>

<h3 id="经调试发现是发布时发布的IP地址有误所致！将IP地址修改正确即可"><a href="#经调试发现是发布时发布的IP地址有误所致！将IP地址修改正确即可" class="headerlink" title="经调试发现是发布时发布的IP地址有误所致！将IP地址修改正确即可"></a>经调试发现是发布时发布的IP地址有误所致！将IP地址修改正确即可</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改配置地址为本机地址</span><br><span class="line">  webServices: #webservice发布地址</span><br><span class="line">    OrganizationAddress: http://10.10.10.107:21110/Portal/WebServices/Organization</span><br><span class="line">    SSOServiceAddress: http://10.10.10.107:21111/Portal/WebServices/SSOService</span><br><span class="line">    BPMServiceAddress: http://10.10.10.107:21112/Portal/WebServices/BPMService</span><br><span class="line">    ActivityInfoServiceAddress: http://10.10.10.107:21113/Portal/WebServices/ActivityInfoService</span><br></pre></td></tr></table></figure>

<h4 id="将IP地址修改正确即可正常启动"><a href="#将IP地址修改正确即可正常启动" class="headerlink" title="将IP地址修改正确即可正常启动"></a>将IP地址修改正确即可正常启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-03-30 08:30:49.966 [main-EventThread] INFO  org.I0Itec.zkclient.ZkClient Line:713 - zookeeper state changed (SyncConnected)</span><br><span class="line">2021-03-30 08:30:49.971 [main] INFO  com.authine.zk.impl.DiscoveryServiceImpl Line:85  - address node is /authine/h3bpm-engine/address-0000000016</span><br><span class="line">2021-03-30 08:30:49.976 [main] INFO  com.authine.zk.impl.DiscoveryServiceImpl Line:88  - data found.</span><br><span class="line">2021-03-30 08:30:49.978 [main] INFO  com.h3bpm.base.engine.connection.EngineConnectionUtil Line:63  - get engine</span><br><span class="line">2021-03-30 08:30:49.979 [main] INFO  com.h3bpm.base.engine.connection.EngineConnectionUtil Line:125 - Registry center is enabled, will get engine config from registry center...</span><br><span class="line">2021-03-30 08:30:49.980 [main] INFO  com.authine.zk.impl.DiscoveryServiceImpl Line:85  - address node is /authine/h3bpm-engine/address-0000000016</span><br><span class="line">2021-03-30 08:30:49.980 [main] INFO  com.authine.zk.impl.DiscoveryServiceImpl Line:88  - data found.</span><br><span class="line">2021-03-30 08:30:49.980 [main] DEBUG com.h3bpm.base.engine.AuthInfoHolder Line:61  - load user info from config file</span><br><span class="line">2021-03-30 08:30:50.000 [main] INFO  com.h3bpm.base.engine.connection.EngineConnectionUtil Line:125 - Registry center is enabled, will get engine config from registry center...</span><br><span class="line">2021-03-30 08:30:50.001 [main] INFO  com.authine.zk.impl.DiscoveryServiceImpl Line:85  - address node is /authine/h3bpm-engine/address-0000000016</span><br><span class="line">2021-03-30 08:30:50.002 [main] INFO  com.authine.zk.impl.DiscoveryServiceImpl Line:88  - data found.</span><br><span class="line">2021-03-30 08:30:50.049 [main] DEBUG com.h3bpm.base.engine.AuthInfoHolder Line:61  - load user info from config file</span><br><span class="line">2021-03-30 08:30:50.113 [main] INFO  OThinker.Common.util.ShutdownHookUtil Line:17  - register hook datasource</span><br><span class="line">2021-03-30 08:30:51.114 [main] INFO  com.alibaba.druid.pool.DruidDataSource Line:930 - &#123;dataSource-1&#125; inited</span><br><span class="line">2021-03-30 08:30:51.300 [main] DEBUG com.h3bpm.base.util.DataTableConvert Line:94  - toBean method cost 21 ms</span><br><span class="line">2021-03-30 08:30:51.456 [main] INFO  io.lettuce.core.EpollProvider Line:68  - Starting without optional epoll library</span><br><span class="line">2021-03-30 08:30:51.457 [main] INFO  io.lettuce.core.KqueueProvider Line:70  - Starting without optional kqueue library</span><br><span class="line">2021-03-30 08:30:52.041 [main] INFO  com.h3bpm.web.cars.cache.CacheInitialize Line:34  - 初始化缓存完成。。。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>assign</tag>
        <tag>cxf</tag>
        <tag>Jetty</tag>
        <tag>WebService</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title>Jire破解安装手册</title>
    <url>/2021/07/30/jire%E7%A0%B4%E8%A7%A3%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-68-1024x602.png"></p>
<h3 id="JIRA-介绍"><a href="#JIRA-介绍" class="headerlink" title="JIRA 介绍"></a>JIRA 介绍</h3><hr>
<p>JIRA 是目前比较流行的基于Java架构的管理系统，由于Atlassian公司对很多开源项目实行免费提供缺陷跟踪服务，因此在开源领域，其认知度比其他的产品要高得多，而且易用性也好一些。</p>
<h3 id="JIRA的主要功能"><a href="#JIRA的主要功能" class="headerlink" title="JIRA的主要功能"></a>JIRA的主要功能</h3><hr>
<p>问题追踪和管理：用它管理项目，跟踪任务、bug、需求，通过jira的邮件通知功能进行协作通知，在实际工作中使工作效率提高很多<br>问题跟进情况的分析报告：可以随时了解问题和项目的进展情况<br>项目类别管理功能：可以将相关的项目分组管理<br>组件&#x2F;模块负责人功能：可以将项目的不同组件&#x2F;模块指派相应的负责人，来处理所负责的组件的Issues<br>项目email地址功能：每个项目可以有不同的email（该项目的通知邮件从该地址发出）<br>无限制的工作流：可以创建多个工作流为不同的项目使用</p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本教程所用安装包-打包到了CSDN上面</span></span><br><span class="line">https://download.csdn.net/download/leenhem/20606795</span><br></pre></td></tr></table></figure>

<p>也可以去官网下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Jira安装包：atlassian-jira-software-8.18.1-x64.bin</span><br><span class="line"><span class="comment">#下载地址：https://www.atlassian.com/zh/software/jira/download-archives</span></span><br><span class="line">数据库驱动：mysql-connector-java-8.0.26.jar</span><br><span class="line"><span class="comment">#下载地址：https://downloads.mysql.com/archives/c-j/</span></span><br></pre></td></tr></table></figure>

<h3 id="安装atlassian-jira"><a href="#安装atlassian-jira" class="headerlink" title="安装atlassian-jira"></a>安装atlassian-jira</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@code404.icu confluence]<span class="comment"># ./atlassian-jira-software-8.18.1-x64.bin </span></span><br><span class="line">Unpacking JRE ...</span><br><span class="line">Starting Installer ...</span><br><span class="line"></span><br><span class="line">This will install Jira Software 8.18.1 on your computer.</span><br><span class="line">OK [o, Enter], Cancel [c]</span><br><span class="line">o</span><br><span class="line">Click Next to <span class="built_in">continue</span>, or Cancel to <span class="built_in">exit</span> Setup.</span><br><span class="line"></span><br><span class="line">Choose the appropriate installation or upgrade option.</span><br><span class="line">Please choose one of the following:</span><br><span class="line">Express Install (use default settings) [1], Custom Install (recommended <span class="keyword">for</span> advanced <span class="built_in">users</span>) [2, Enter], Upgrade an existing Jira installation [3]</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Details on <span class="built_in">where</span> Jira Software will be installed and the settings that will be used.</span><br><span class="line">Installation Directory: /opt/atlassian/jira </span><br><span class="line">Home Directory: /var/atlassian/application-data/jira </span><br><span class="line">HTTP Port: 8080 </span><br><span class="line">RMI Port: 8005 </span><br><span class="line">Install as service: Yes </span><br><span class="line">Install [i, Enter], Exit [e]</span><br><span class="line"></span><br><span class="line">Extracting files ...</span><br><span class="line"></span><br><span class="line">Please <span class="built_in">wait</span> a few moments <span class="keyword">while</span> Jira Software is configured.</span><br><span class="line"></span><br><span class="line">Installation of Jira Software 8.18.1 is complete</span><br><span class="line">Start Jira Software 8.18.1 now?</span><br><span class="line">Yes [y, Enter], No [n]</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">Please <span class="built_in">wait</span> a few moments <span class="keyword">while</span> Jira Software starts up.</span><br><span class="line">Launching Jira Software ...</span><br><span class="line"></span><br><span class="line">Installation of Jira Software 8.18.1 is complete</span><br><span class="line">Your installation of Jira Software 8.18.1 is now ready and can be accessed</span><br><span class="line">via your browser.</span><br><span class="line">Jira Software 8.18.1 can be accessed at http://localhost:8080</span><br><span class="line">Finishing installation ...</span><br><span class="line"><span class="comment">#安装完成</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-Jire"><a href="#配置-Jire" class="headerlink" title="配置 Jire"></a>配置 Jire</h3><hr>
<p>把数据库驱动 mysql-connector 复制到 atlassian&#x2F;jira&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@code404.icu opt]<span class="comment"># cp mysql-connector-java-5.1.39-bin.jar atlassian/jira/atlassian-jira/WEB-INF/lib/</span></span><br></pre></td></tr></table></figure>

<h4 id="重启jira"><a href="#重启jira" class="headerlink" title="重启jira"></a>重启jira</h4><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重新启动Jira</span></span><br><span class="line"></span><br><span class="line">[root@code404.icu opt]<span class="comment"># /etc/init.d/jira stop</span></span><br><span class="line">[root@code404.icu opt]<span class="comment"># /etc/init.d/jira start</span></span><br></pre></td></tr></table></figure>



<h4 id="Jira页面安装"><a href="#Jira页面安装" class="headerlink" title="Jira页面安装"></a>Jira页面安装</h4><hr>
<ul>
<li>打开Jira地址<a href="http://xxx.xxx.xxx.xxx:8080/">http://xxx.xxx.xxx.xxx:8080/</a></li>
<li>语言选择 <strong>中文</strong></li>
<li>下一步<br><img src="https://img-blog.csdnimg.cn/9fbe9c4ab8574b11ac031e1bc785ea37.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="输入许可"><a href="#输入许可" class="headerlink" title="输入许可"></a>输入许可</h4><p><img src="https://img-blog.csdnimg.cn/44dfc56e14c340719c9603acb9ca01a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="破解Jira"><a href="#破解Jira" class="headerlink" title="破解Jira"></a>破解Jira</h4><p>把&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F;atlassian-extras-3.2.jar 复制出来改名成atlassian-extras-2.4.jar</p>
<p>运行破解工具confluence_keygen.jar</p>
<p>把ServerID和Name填上，patch 选择 刚改名好的atlassian-extras-2.4.jar，然后进行gen</p>
<p><img src="https://img-blog.csdnimg.cn/a91e29e430384feeb440a1107fe8b3ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>gen成功后把 atlassian-extras-2.4.jar 改名成 atlassian-extras-3.2.jar </p>
<p>并且复制到程序目录&#x2F;opt&#x2F;atlassian&#x2F;jira&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F; 替换原来的 atlassian-extras-3.2.jar </p>
<p>把 破解包 atlassian-extras-3.2.jar 复制到 atlassian&#x2F;jira&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F; 覆盖原有的 atlassian-extras</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@code404.icu opt]<span class="comment"># cp atlassian-extras-3.2.jar  atlassian/jira/atlassian-jira/WEB-INF/lib/</span></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="配置完成后，重启jira"><a href="#配置完成后，重启jira" class="headerlink" title="配置完成后，重启jira"></a>配置完成后，重启jira</h4><hr>
<p>重新启动Jira</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@code404.icu opt]<span class="comment"># /etc/init.d/jira stop</span></span><br><span class="line">[root@code404.icu opt]<span class="comment"># /etc/init.d/jira start</span></span><br></pre></td></tr></table></figure>



<h3 id="回到页面，配置Jira"><a href="#回到页面，配置Jira" class="headerlink" title="回到页面，配置Jira"></a>回到页面，配置Jira</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/44091872eb6240c3b899f5922c1f9847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>设置Title：Jira</li>
<li>设置Mode：Private</li>
<li>BaseURL：自己的服务地址</li>
<li>下一步<br><img src="https://img-blog.csdnimg.cn/9ba751d7a2b946f0a8c9b941e3747467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="设置许可"><a href="#设置许可" class="headerlink" title="设置许可"></a>设置许可</h3><p>把上面生成的许可key填上就ok了</p>
<p>AAABLQ0ODAoPeJxtkEtrAjEQgO&#x2F;5FYGeI&#x2F;uoVAqBxiSIuA&#x2F;prpUe43asgZiVZLPUf9&#x2F;YrZdSmMu8P<br>r6Zh&#x2F;YUcKkczlOcps8xkkfMmxZnSZYhAb5z+jLo3lLe26MJYDtAVTgfwNXHnQfnKUkRd6BuQ0INQ<br>G+bJMlJHuu9HVQ3VOoM1ADYE5xRFzmzWNQj0MEFuA&#x2F;JUmlDtR211wcDL74DCzNrkByVCT94elTGw<br>0QodOx7aK8X+MHzuizlK1+zAkWQHcCqqCq&#x2F;LtpdJ608fyJpRrL5BLgfwU3wA7iq&#x2F;wBPE9TIir7XO<br>1yyjcSlxAw3TOAtqwSbodp9Kqv9JKOrN93oZSFxK1mJGnAjuLWgy4wLstrPF2TFdnuyyNkG&#x2F;drGb<br>rEW9+x&#x2F;uW1w3Ul5+PPLb0n4iSowLAIUEUOhf9kUuxvcm0PdPwZbdsBgLUkCFE79f&#x2F;OIQyUCCCOmy<br>g6QXW5odoFNX02f3</p>
<h3 id="设置管理员"><a href="#设置管理员" class="headerlink" title="设置管理员"></a>设置管理员</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/e787d185212b4654a739f9570c9e2a68.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/cdd83de1f628484b8d9b35f1c9fdc04e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="驱动问题"><a href="#驱动问题" class="headerlink" title="驱动问题"></a>驱动问题</h3><hr>
<p>配置数据库，如果上面的mysql-connector 没有复制到 atlassian&#x2F;jira&#x2F;atlassian-jira&#x2F;WEB-INF&#x2F;lib&#x2F;<br>就会报错 <strong>找不到驱动：com.mysql.cj.jdbc.Driver</strong><br><img src="https://img-blog.csdnimg.cn/23132d275e764e26908556e5f9b9ac4c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="数据库-不为空问题"><a href="#数据库-不为空问题" class="headerlink" title="数据库 不为空问题"></a>数据库 不为空问题</h3><hr>
<p>您指定的数据库, 不为空, 请指定空数据库。如果您要升级现有的安装, 请按照&lt; a target&#x3D;”_blank” href&#x3D;”<a href="https://docs.atlassian.com/jira/jadm-docs-0818/Connecting+Jira+applications+to+a+Database#ConnectingJiraapplicationstoadatabase-UpgradingJiraormigratingJiratoanotherserver?&quot;%E7%9A%84%E8%BF%99%E4%BA%9B%E8%AF%B4%E6%98%8E%E3%80%82">https://docs.atlassian.com/jira/jadm-docs-0818/Connecting+Jira+applications+to+a+Database#ConnectingJiraapplicationstoadatabase-UpgradingJiraormigratingJiratoanotherserver?&quot;的这些说明。</a><br>这个问题的解决方式 在下面有<br><img src="https://img-blog.csdnimg.cn/b0985f89056c457aabaa547f3a6b61c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="解决数据库-不为空问题"><a href="#解决数据库-不为空问题" class="headerlink" title="解决数据库 不为空问题"></a>解决数据库 不为空问题</h3><hr>
<p>这个数据库配置需要在服务器上来完成<br>执行 config.sh，根据提示一步一步来配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@oa-redis bin]<span class="comment"># pwd</span></span><br><span class="line">/opt/atlassian/jira/bin</span><br><span class="line">[root@oa-redis bin]<span class="comment"># sh config.sh </span></span><br><span class="line">Loading application properties from /opt/atlassian/jira/atlassian-jira/WEB-INF/classes/jira-application.properties</span><br><span class="line">DB config file <span class="string">&#x27;/var/atlassian/application-data/jira/dbconfig.xml&#x27;</span> is not created yet - loading database settings as blank.</span><br><span class="line"></span><br><span class="line">No graphics display available; using console.</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">JIRA Configurator v1.1</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">--- Main Menu ---</span><br><span class="line">  [H] Configure JIRA Home</span><br><span class="line">  [D] Database Selection</span><br><span class="line">  [W] Web Server (incl. HTTP/HTTPs configuration)</span><br><span class="line">  [A] Advanced Settings</span><br><span class="line">  [S] Save and Exit</span><br><span class="line">  [X] Exit without Saving</span><br><span class="line"></span><br><span class="line">Main Menu&gt; d</span><br><span class="line"></span><br><span class="line">--- Database Selection ---</span><br><span class="line">  Database Type : H2</span><br><span class="line">  Instance      : (unused)</span><br><span class="line">  Connect As    : sa / (no password)</span><br><span class="line"></span><br><span class="line">* [H] H2 (not <span class="keyword">for</span> production use)</span><br><span class="line">  [M] MySQL 8.0</span><br><span class="line">  [N] MySQL 5.7</span><br><span class="line">  [O] Oracle</span><br><span class="line">  [P] PostgreSQL</span><br><span class="line">  [A] Aurora PostgreSQL 9.6 (DC Only)</span><br><span class="line">  [S] SQL Server (MS-SQL)</span><br><span class="line"></span><br><span class="line">  [X] Return to Main Menu</span><br><span class="line"></span><br><span class="line">Database Selection [H]&gt; M</span><br><span class="line">MySQL 8.0 Database Configuration.</span><br><span class="line">Hostname ()&gt; 192.168.65.119</span><br><span class="line">Port ()&gt; 3306</span><br><span class="line">Database ()&gt; jire</span><br><span class="line">Username ()&gt; root</span><br><span class="line">Password ()&gt; </span><br><span class="line">Test Connection  ([Y]/N)? &gt; y</span><br><span class="line">Attempting to connect to 192.168.65.119:3306/jire</span><br><span class="line">Connection successful!</span><br><span class="line"></span><br><span class="line">--- Database Selection ---</span><br><span class="line">  Database Type : MySQL 8.0</span><br><span class="line">  Instance      : 192.168.65.119:3306/jire</span><br><span class="line">  Connect As    : root / *****</span><br><span class="line"></span><br><span class="line">  [H] H2 (not <span class="keyword">for</span> production use)</span><br><span class="line">* [M] MySQL 8.0</span><br><span class="line">  [N] MySQL 5.7</span><br><span class="line">  [O] Oracle</span><br><span class="line">  [P] PostgreSQL</span><br><span class="line">  [A] Aurora PostgreSQL 9.6 (DC Only)</span><br><span class="line">  [S] SQL Server (MS-SQL)</span><br><span class="line"></span><br><span class="line">  [X] Return to Main Menu</span><br><span class="line"></span><br><span class="line">Database Selection [M]&gt; x</span><br><span class="line"></span><br><span class="line">--- Main Menu ---</span><br><span class="line">  [H] Configure JIRA Home</span><br><span class="line">  [D] Database Selection</span><br><span class="line">  [W] Web Server (incl. HTTP/HTTPs configuration)</span><br><span class="line">  [A] Advanced Settings</span><br><span class="line">  [S] Save and Exit</span><br><span class="line">  [X] Exit without Saving</span><br><span class="line"></span><br><span class="line">Main Menu&gt; s</span><br><span class="line">Storing database configuration <span class="keyword">in</span> /var/atlassian/application-data/jira/dbconfig.xml</span><br><span class="line">Settings saved successfully.</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Jira</category>
      </categories>
      <tags>
        <tag>atlassian-jira</tag>
        <tag>jira</tag>
        <tag>Jira破解</tag>
      </tags>
  </entry>
  <entry>
    <title>jmap Unable to open socket file: target process not responding or HotSport VM not loaded解决</title>
    <url>/2021/09/28/jmap-unable-to-open-socket-file-target-process-not-responding-or-hotsport-vm-not-loaded%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-25-1024x444.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>排查内存溢出时，执行jmap命令报：</p>
<p>pid:Unable to open socket file: target process not responding or HotSport VM not loaded<br>The -F option can be used when the target process is not responding.</p>
<h3 id="解决办法1-根据提示加-F"><a href="#解决办法1-根据提示加-F" class="headerlink" title="解决办法1 根据提示加-F"></a>解决办法1 根据提示加-F</h3><p>根据提示加-F，结果如下</p>
<p>Dumping heap to dump.bin …<br>Exception in thread”main” java.lang.reflect.InvocationTargetException<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>    at java.lang.reflect.Method.invoke(Method.java:483)<br>    at sun.tools.jmap.JMap.runTool(JMap.java:201)<br>    at sun.tools.jmap.JMap.main(JMap.java:130)<br>Caused by: java.lang.InternalError: Metadata does not appear to be polymorphic<br>    at sun.jvm.hotspot.types.basic.BasicTypeDataBase.findDynamicTypeForAddress(BasicTypeDataBase.java:278)<br>    at sun.jvm.hotspot.runtime.VirtualBaseConstructor.instantiateWrapperFor(VirtualBaseConstructor.java:102)<br>    at sun.jvm.hotspot.oops.Metadata.instantiateWrapperFor(Metadata.java:68)<br>    at sun.jvm.hotspot.memory.DictionaryEntry.klass(DictionaryEntry.java:71)<br>    at sun.jvm.hotspot.memory.Dictionary.classesDo(Dictionary.java:66)<br>    at sun.jvm.hotspot.memory.SystemDictionary.classesDo(SystemDictionary.java:190)<br>    at sun.jvm.hotspot.memory.SystemDictionary.allClassesDo(SystemDictionary.java:183)<br>    at sun.jvm.hotspot.utilities.HeapHprofBinWriter.writeClasses(HeapHprofBinWriter.java:942)<br>    at sun.jvm.hotspot.utilities.HeapHprofBinWriter.write(HeapHprofBinWriter.java:427)<br>    at sun.jvm.hotspot.tools.HeapDumper.run(HeapDumper.java:62)<br>    at sun.jvm.hotspot.tools.Tool.startInternal(Tool.java:260)<br>    at sun.jvm.hotspot.tools.Tool.start(Tool.java:223)<br>    at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)<br>    at sun.jvm.hotspot.tools.HeapDumper.main(HeapDumper.java:83)<br>    … 6 more</p>
<h3 id="解决办法2-切换到进程用户-amp-cd-到进程用户文件夹下"><a href="#解决办法2-切换到进程用户-amp-cd-到进程用户文件夹下" class="headerlink" title="解决办法2 切换到进程用户 &amp; cd 到进程用户文件夹下"></a>解决办法2 切换到进程用户 &amp; cd 到进程用户文件夹下</h3><p>其实大部分情况是用户错误，切换到进程所在用户</p>
<p>使用 top，或 ps命令查看 进程用户</p>
<p>top - 16:16:49 up 152 days,  1:30,  3 users,  load average: 0.00, 0.01, 0.13<br>Tasks: 121 total,   1 running, 120 sleeping,   0 stopped,   0 zombie<br>%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>KiB Mem : 16412472 total, 12663144 free,  1150820 used,  2598508 buff&#x2F;cache<br>KiB Swap:  4063228 total,  4063228 free,        0 used. 14822356 avail Mem </p>
<p>   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<br> 30009 test      20   0 7892124 870748  14036 S   0.3  5.3   0:53.15 java -jar hdms-assembly.jar -Xms128m -Xmx512m<br>   510 root      20   0   63648  25424  25116 S   0.0  0.2   0:45.15 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-journald<br>  1256 root      20   0  341396  16056  14220 S   0.0  0.1   9:51.36 &#x2F;usr&#x2F;sbin&#x2F;rsyslogd -n<br>   690 polkitd   20   0  612936  12024   4940 S   0.0  0.1   0:45.10 &#x2F;usr&#x2F;lib&#x2F;polkit-1&#x2F;polkitd –no-debug<br>   827 root      20   0  476976   8872   6884 S   0.0  0.1  64:20.49 &#x2F;usr&#x2F;sbin&#x2F;NetworkManager –no-daemon<br>   943 root      20   0  198388   8612   5440 S   0.0  0.1 151:46.98 &#x2F;usr&#x2F;sbin&#x2F;vmtoolsd<br> 29917 root      20   0  116184   2800   1808 S   0.0  0.0  10:13.82 -bash<br>   720 root      20   0  103344   2736   2032 S   0.0  0.0   0:00.03 login – root                      </p>
<p>切换到进程对应的用户: su test</p>
<p>jmap -dump:file&#x3D;30009.bin 300009</p>
<p>然后执行命令</p>
<h3 id="解决办法3-内存快照"><a href="#解决办法3-内存快照" class="headerlink" title="解决办法3 内存快照"></a>解决办法3 内存快照</h3><hr>
<p>当发生内存溢出或者将要发生内存溢出的时候，我们首先需要去获取Heap Dump，在发生内存的时间点人工去获取Heap Dump是不现实的，因为我们不知道什么时候会发生内存溢出，但是在JVM启动的时候通过命令行给JVM传递如下的参数就可以在发生内存溢出的时候，自动生成Heap Dump</p>
<p>在启动服务的时候加上JVM参数-XXHeapDumpOnOutOfMemoryError<br>Tomcat</p>
<p>JAVA_OPTS&#x3D;”-server -Xms512m -Xmx512m -Xss1024K -XX:PermSize&#x3D;128m -XX:MaxPermSize&#x3D;256m -XXHeapDumpOnOutOfMemoryError”</p>
<p>在下次项目发生OOM时，自动生成内存快照</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>jmap</category>
        <category>jstack</category>
      </categories>
      <tags>
        <tag>内存溢出</tag>
        <tag>HeapDumpOnOutOfMemoryError</tag>
        <tag>jmap</tag>
        <tag>jstack</tag>
        <tag>Unable to open socket file</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter+Jenkins接口压力测试持续集成?</title>
    <url>/2021/10/06/jmeterjenkins%E6%8E%A5%E5%8F%A3%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-2-1024x361.png"></p>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><hr>
<h4 id="接口功能测试应用："><a href="#接口功能测试应用：" class="headerlink" title="接口功能测试应用："></a>接口功能测试应用：</h4><hr>
<p><a href="http://www.weather.com.cn/data/cityinfo/%3Ccity_code%3E.html%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E5%9F%8E%E5%B8%82%E7%9A%84%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%9AGet%E5%8E%8B%E6%B5%8B%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%9Ajmeter%E6%BA%90%E7%A0%81%E8%84%9A%E6%9C%AC%E4%BD%8D%E7%BD%AE%EF%BC%9Ahttps://github.com/shifengboy/iInterface_python/blob/master/jmx/iInterface.jmx">http://www.weather.com.cn/data/cityinfo/&lt;city_code&gt;.html测试功能：获取对应城市的天气预报请求方法：Get压测脚本开发工具：jmeter源码脚本位置：https://github.com/shifengboy/iInterface_python&#x2F;blob&#x2F;master&#x2F;jmx&#x2F;iInterface.jmx</a></p>
<h4 id="源功能点"><a href="#源功能点" class="headerlink" title="源功能点"></a>源功能点</h4><hr>
<p>将Jmeter压测任务集成到Jenkins<br>通过Jenkins运行Jmeter任务<br>在Jenkins上展示Jmeter压测报告</p>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><hr>
<h4 id="1、新建一个自由风格任务"><a href="#1、新建一个自由风格任务" class="headerlink" title="1、新建一个自由风格任务"></a>1、新建一个自由风格任务</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/e1eccefa836e4ed9945ae1e9aeb4bf09.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="2、添加git源码库地址"><a href="#2、添加git源码库地址" class="headerlink" title="2、添加git源码库地址"></a>2、添加git源码库地址</h4><hr>
<p>可自行添加自己的代码仓库地址<br><img src="https://img-blog.csdnimg.cn/0cafdcc7a37f4e7abd46e24209602ea5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="3、添加自动化压测运行代码"><a href="#3、添加自动化压测运行代码" class="headerlink" title="3、添加自动化压测运行代码"></a>3、添加自动化压测运行代码</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/ae9582161a9d4e218f6fbd3c0b758da4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>添加如下构建命令</p>
<p>. ~&#x2F;.bash_profile<br>cd iInterface_python&#x2F;jmx<br>sh auto_stress_test.sh </p>
<p>该命令可根据自己的实际项目进行添加</p>
<h4 id="4、导出压测报告"><a href="#4、导出压测报告" class="headerlink" title="4、导出压测报告"></a>4、导出压测报告</h4><hr>
<p>在Post-build Actions（构建后操作）中添加 Publish HTML reports<br><img src="https://img-blog.csdnimg.cn/d3b6a4c787ec482a881989cac107e43a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>需要注意的是，Jenkins出于的全策略的原因，会限制js脚本的渲染，默认生成的报告打开后会有样式问题，如下图：<br><img src="https://img-blog.csdnimg.cn/49cb4153072c4af6a9c1261310b5473d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="需要解除js脚本的渲染限制"><a href="#需要解除js脚本的渲染限制" class="headerlink" title="需要解除js脚本的渲染限制"></a>需要解除js脚本的渲染限制</h4><hr>
<p>具体解除限制的方法有</p>
<h5 id="1、临时解决方案（重启Jenkins失效）：在系统管理-gt-脚本命令行："><a href="#1、临时解决方案（重启Jenkins失效）：在系统管理-gt-脚本命令行：" class="headerlink" title="1、临时解决方案（重启Jenkins失效）：在系统管理-&gt;脚本命令行："></a>1、临时解决方案（重启Jenkins失效）：在系统管理-&gt;脚本命令行：</h5><p><img src="https://img-blog.csdnimg.cn/86a76bae9f1b460892fdf848c4061ebd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>执行：</p>
<p>System.setProperty(“hudson.model.DirectoryBrowserSupport.CSP”, “”)</p>
<p>点击运行</p>
<p><img src="https://img-blog.csdnimg.cn/09699b55eaa14a479275b91247769eea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h5 id="2、永久解决方案："><a href="#2、永久解决方案：" class="headerlink" title="2、永久解决方案："></a>2、永久解决方案：</h5><hr>
<p>1）.安装Groovy Postbuild 插件<br>该插件可能不是很好下载，若出现无法下载的情况，可访问我的百度网盘:<br><a href="https://pan.baidu.com/s/1qZ5csambF2yYyzpywO871Q">https://pan.baidu.com/s/1qZ5csambF2yYyzpywO871Q</a><br>提取码: xh6d<br>进行下载后，放在Jenkins的plugins目录下重启即可</p>
<p>2）.进入任务-&gt;配置-&gt;构建-&gt;增加构建步骤 Groovy Postbuild，Groovy Script填写：</p>
<p>System.setProperty(“hudson.model.DirectoryBrowserSupport.CSP”, “”)</p>
<p>之后保存<br><img src="https://img-blog.csdnimg.cn/cdb76f3778c8453eb29198e4f96dae4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="5、发送邮件"><a href="#5、发送邮件" class="headerlink" title="5、发送邮件"></a>5、发送邮件</h4><hr>
<p>在Post-build Actions（构建后操作）中添加 Editable Email Notification</p>
<p><img src="https://img-blog.csdnimg.cn/f947f70d72404a81a57f58270f3ae23b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>注：Editable Email Notification插件安装后需要系统管理-系统配置 Extended E-mail Notification选项中进行设置好后才能正常使用</p>
<p><img src="https://img-blog.csdnimg.cn/ff6b4998732e4cfcae24832affd41976.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/d3a9d068dac54f77bacbee57102a1a91.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/189efd5520fa4684aba36dd3a179cc19.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>设置完成后，保存，构建</p>
<p><img src="https://img-blog.csdnimg.cn/25f1b8f9dac343048374b04e843a0323.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>报告：</p>
<p><img src="https://img-blog.csdnimg.cn/eaca563906ff4683bb7869743425b496.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>邮件：</p>
<p><img src="https://img-blog.csdnimg.cn/f398dfcbf05e4446b32bbf46d94a18c2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
        <category>Jmeter</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>jmeter</tag>
        <tag>压力测试</tag>
        <tag>接口</tag>
        <tag>集成</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter如何通过数据库连接获取验证码</title>
    <url>/2021/09/10/jmeter%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-8.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>JMeter通过配置元件来从数据库获取数据，首先你得有jmeter环境，其次你得弄个数据库驱动包，这里我是连接的mysql数据，引用是mysql的驱动包。</p>
<h3 id="mysql驱动包下载地址"><a href="#mysql驱动包下载地址" class="headerlink" title="mysql驱动包下载地址"></a>mysql驱动包下载地址</h3><hr>
<p><a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a></p>
<h3 id="JMeter配置元件"><a href="#JMeter配置元件" class="headerlink" title="JMeter配置元件"></a>JMeter配置元件</h3><hr>
<p>首先测试计划页面，最下方点击 浏览 选中已经下载的驱动包：</p>
<p><img src="https://img-blog.csdnimg.cn/669773e299c7450b820a5d3158436a1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>其次配置一个线程组，线程组下再配置一个JDBC Connection Configuration、再配置一个JDBC Request、最后再配置一个查看结果树(主要是查看数据使用)：</p>
<p><img src="https://img-blog.csdnimg.cn/7cb3c7b9159949629e208522514d3f86.png" alt="在这里插入图片描述"></p>
<h3 id="JDBC-Connection-Configuration元件："><a href="#JDBC-Connection-Configuration元件：" class="headerlink" title="JDBC Connection Configuration元件："></a>JDBC Connection Configuration元件：</h3><hr>
<h4 id="Variable-Name-Bound-to-Pool版块："><a href="#Variable-Name-Bound-to-Pool版块：" class="headerlink" title="Variable Name Bound to Pool版块："></a>Variable Name Bound to Pool版块：</h4><ul>
<li>Variable Name：变量名称(自定义，用于JDBC Request中引用该变量)</li>
</ul>
<h4 id="Database-Connection-Configuration版块："><a href="#Database-Connection-Configuration版块：" class="headerlink" title="Database Connection Configuration版块："></a>Database Connection Configuration版块：</h4><ul>
<li>Database URL：jdbc:mysql:&#x2F;&#x2F;host:port&#x2F;数据库名</li>
<li>JDBC Driver class：是可以下拉选择的，选择对象的数据库驱动即可</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2e010cf3b5954e8ca34690fae921512e.png" alt="在这里插入图片描述"></p>
<ul>
<li>Username：数据库用户名</li>
<li>Password：数据库用户名密码</li>
</ul>
<h4 id="例如：示例1-1截图："><a href="#例如：示例1-1截图：" class="headerlink" title="例如：示例1-1截图："></a>例如：示例1-1截图：</h4><p><img src="https://img-blog.csdnimg.cn/992f30a22a50494d9abc419986ada97b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="JDBC-Request元件："><a href="#JDBC-Request元件：" class="headerlink" title="JDBC Request元件："></a>JDBC Request元件：</h3><hr>
<h4 id="Variable-Name-Bound-to-Pool版块：-1"><a href="#Variable-Name-Bound-to-Pool版块：-1" class="headerlink" title="Variable Name Bound to Pool版块："></a>Variable Name Bound to Pool版块：</h4><ul>
<li>Variable Name：变量名称</li>
</ul>
<p>Variable Name引用的是JDBC Connection Configuration元件中的Variable Name</p>
<h4 id="SQL-Query版块："><a href="#SQL-Query版块：" class="headerlink" title="SQL Query版块："></a>SQL Query版块：</h4><ul>
<li>Query Type：根据语句类型设置</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/eb977e793969477090b20d895e29b743.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>Query：框框中写sql语句或脚本</li>
<li>Parameter values：参数值</li>
<li>Parameter types：参数类型</li>
<li>Variable names：变量名称</li>
<li>Result variable name：结果变量名称</li>
<li>Query timeout（s）：查询超时时间</li>
<li>Handle ResultSet：处理结果集（存储的一些方式）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/b1260efa6bfb49a1bffbb3ae2ee6a16b.png" alt="在这里插入图片描述"></p>
<h4 id="例如：示例1-2截图："><a href="#例如：示例1-2截图：" class="headerlink" title="例如：示例1-2截图："></a>例如：示例1-2截图：</h4><p><img src="https://img-blog.csdnimg.cn/f6411497ed474f3aac8c6e7fdeca5c36.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>注意点</strong>：当使用占位符“ ? ”操作sql语句时，查询语句选择Prepared Select Statement；更新语句则选择Prepared Update Statement；不选择使用占位符，会抛出sql语句错误…</p>
<h4 id="示例1-2的运行结果截图："><a href="#示例1-2的运行结果截图：" class="headerlink" title="示例1-2的运行结果截图："></a>示例1-2的运行结果截图：</h4><p><img src="https://img-blog.csdnimg.cn/d9cfbbb3fc3a4b288b5bacd4ef5fe0e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="例如：示例1-3截图："><a href="#例如：示例1-3截图：" class="headerlink" title="例如：示例1-3截图："></a>例如：示例1-3截图：</h4><p><img src="https://img-blog.csdnimg.cn/eb28eb8cdac249ae8535037d759bcf4a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>示例1-3运行后的结果截图：<br><img src="https://img-blog.csdnimg.cn/80cbc2f331314824a5cd37b31817d118.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Debug Sampler是调试用的元件，以上就是几个元件的使用，下面就开始可用这几个元件，从数据库读取验证码并提取出来…</p>
<h3 id="连接数据库获取验证并提取"><a href="#连接数据库获取验证并提取" class="headerlink" title="连接数据库获取验证并提取"></a>连接数据库获取验证并提取</h3><hr>
<p>JDBC Request下增加一个后置处理器-正则表达式处理器，写入正则语法进行提取验证码</p>
<h4 id="例如：示例1-4截图："><a href="#例如：示例1-4截图：" class="headerlink" title="例如：示例1-4截图："></a>例如：示例1-4截图：</h4><p><img src="https://img-blog.csdnimg.cn/a3248db4d9a846c1895fcbb2b8ecf58a.png" alt="在这里插入图片描述"></p>
<p>编写sql语句，进行降序后，取第一条数据<br><img src="https://img-blog.csdnimg.cn/b8334bdd436c4ab8b4c28dd92213ae3a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>配置正则处理器元件，正则表达式(\d+)是只重复匹配数字<br><img src="https://img-blog.csdnimg.cn/391d4e2940354538af3bab1e9d576a49.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>模板：$$表示需要哪个正则表达式获取的值，1代表第一个，-1代表全部，0代表随机</li>
<li>匹配数字：1代表第一个，-1代表全部，0代表随机</li>
<li>缺省值：如果未匹配到，使用缺省值</li>
</ul>
<p>示例1-4运行后的结果截图：</p>
<p><img src="https://img-blog.csdnimg.cn/3aaafe1b0b1648dc96dbfcea81b62c29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>后续其他接口引用code变量时，接口参数的value值写入嵌套大括号，里面填充变量即可，例如：</p>
<p><img src="https://img-blog.csdnimg.cn/92c4e29d04e745859e9be3a23cf67d85.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jmeter</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>jmeter</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Web Token单点登录系统JWT原理</title>
    <url>/2021/07/20/json-web-token%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9Fjwt%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<p>让我们来假想一下一个场景。在A用户关注了B用户的时候，系统发邮件给B用户，并且附有一个链接“点此关注A用户”。链接的地址可以是这样的</p>
<p><a href="https://your.awesome-app.com/make-friend/?from%5C_user=B&amp;target%5C_user=A">https://your.awesome-app.com/make-friend/?from\_user=B&amp;target\_user=A</a></p>
<p>上面的URL主要通过URL来描述这个当然这样做有一个弊端，那就是要求用户B用户是一定要先登录的。可不可以简化这个流程，让B用户不用登录就可以完成这个操作。JWT就允许我们做到这点。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-49.png"></p>
<h3 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h3><hr>
<p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p>
<h3 id="载荷（Payload）"><a href="#载荷（Payload）" class="headerlink" title="载荷（Payload）"></a>载荷（Payload）</h3><hr>
<p>我们先将上面的添加好友的操作描述成一个JSON对象。其中添加了一些其他的信息，帮助今后收到这个JWT的服务器理解这个JWT。</p>
<p>{<br>    “iss”: “John Wu JWT”,<br>    “iat”: 1441593502,<br>    “exp”: 1441594722,<br>    “aud”: “<a href="http://www.example.com&quot;/">www.example.com&quot;</a>,<br>    “sub”: “<a href="mailto:&#x6a;&#114;&#111;&#99;&#x6b;&#x65;&#116;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x6a;&#114;&#111;&#99;&#x6b;&#x65;&#116;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a>“,<br>    “from_user”: “B”,<br>    “target_user”: “A”<br>}</p>
<p>这里面的前五个字段都是由JWT的标准所定义的。</p>
<ul>
<li>iss: 该JWT的签发者</li>
<li>sub: 该JWT所面向的用户</li>
<li>aud: 接收该JWT的一方</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li>iat(issued at): 在什么时候签发的</li>
</ul>
<p>这些定义都可以在标准中找到。</p>
<p>将上面的JSON对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）。</p>
<p>eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdW</p>
<p>如果你使用Node.js，可以用Node.js的包base64url来得到这个字符串。</p>
<blockquote>
<p>小知识：Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p>
</blockquote>
<p>var base64url &#x3D; require(‘base64url’)<br>var header &#x3D; {<br>    “from_user”: “B”,<br>    “target_user”: “A”<br>}<br>console.log(base64url(JSON.stringify(header)))<br>&#x2F;&#x2F; 输出：eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</p>
<h3 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h3><hr>
<p>JWT还需要一个头部，头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p>
<p>{<br>  “typ”: “JWT”,<br>  “alg”: “HS256”<br>}</p>
<p>在这里，我们说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法。</p>
<p>对它也要进行Base64编码，之后的字符串就成了JWT的Header（头部）。</p>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>
<h3 id="签名（签名）"><a href="#签名（签名）" class="headerlink" title="签名（签名）"></a>签名（签名）</h3><hr>
<p>将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了</p>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0</p>
<p>这一部分的过程在node-jws的源码中有体现</p>
<p>最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用mystar作为密钥的话，那么就可以得到我们加密后的内容</p>
<p>rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</p>
<p>这一部分又叫做签名。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-50.png"></p>
<p>最后将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的JWT</p>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn</p>
<p>于是，我们就可以将邮件中的URL改成</p>
<p><a href="https://your.awesome-app.com/make-friend/?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJm">https://your.awesome-app.com/make-friend/?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJm</a></p>
<p>这样就可以安全地完成添加好友的操作了！</p>
<p>且慢，我们一定会有一些问题：</p>
<ol>
<li>签名的目的是什么？</li>
<li>Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？<br>让我逐一为你说明。</li>
</ol>
<h3 id="签名的目的"><a href="#签名的目的" class="headerlink" title="签名的目的"></a>签名的目的</h3><hr>
<p>最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。</p>
<p>所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-51.png"></p>
<p>服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用alg字段指明了我们的加密算法了。</p>
<p>如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。</p>
<h3 id="信息会暴露？"><a href="#信息会暴露？" class="headerlink" title="信息会暴露？"></a>信息会暴露？</h3><hr>
<p>是的。</p>
<p>所以，在JWT中，不应该在载荷里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。</p>
<p>但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。</p>
<h3 id="JWT的适用场景"><a href="#JWT的适用场景" class="headerlink" title="JWT的适用场景"></a>JWT的适用场景</h3><hr>
<p>我们可以看到，JWT适合用于向Web应用传递一些非敏感信息。例如在上面提到的完成加好友的操作，还有诸如下订单的操作等等。</p>
<h3 id="用户认证八步走"><a href="#用户认证八步走" class="headerlink" title="用户认证八步走"></a>用户认证八步走</h3><hr>
<p>所谓用户认证（Authentication），就是让用户登录，并且在接下来的一段时间内让用户访问网站时可以使用其账户，而不需要再次登录的机制。</p>
<blockquote>
<p>小知识：可别把用户认证和用户授权（Authorization）搞混了。用户授权指的是规定并允许用户使用自己的权限，例如发布帖子、管理站点等。</p>
</blockquote>
<p>首先，服务器应用（下面简称“应用”）让用户通过Web表单将自己的用户名和密码发送到服务器的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-52-1024x503.png"></p>
<p>接下来，应用和数据库核对用户名和密码。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-53-1024x417.png"></p>
<p>核对用户名和密码成功后，应用将用户的id（图中的user_id）作为JWT Payload的一个属性，将其与头部分别进行Base64编码拼接后签名，形成一个JWT。这里的JWT就是一个形同lll.zzz.xxx的字符串。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-54-1024x434.png"></p>
<p>应用将JWT字符串作为该请求Cookie的一部分返回给用户。注意，在这里必须使用HttpOnly属性来防止Cookie被JavaScript读取，从而避免跨站脚本攻击（XSS攻击）。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-55.png"></p>
<p>在Cookie失效或者被删除前，用户每次访问应用，应用都会接受到含有jwt的Cookie。从而应用就可以将JWT从请求中提取出来。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-56.png"></p>
<p>应用通过一系列任务检查JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-57.png"></p>
<p>应用在确认JWT有效之后，JWT进行Base64解码（可能在上一步中已经完成），然后在Payload中读取用户的id值，也就是user_id属性。这里用户的id为1025。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-58-1024x433.png"></p>
<p>应用从数据库取到id为1025的用户的信息，加载到内存中，进行ORM之类的一系列底层逻辑初始化。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-59-1024x429.png"></p>
<p>应用根据用户请求进行响应。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/b78c0ae4af072e949fe9367c3afc9f5c-1024x463.jpg"></p>
<h3 id="和Session方式存储id的差异"><a href="#和Session方式存储id的差异" class="headerlink" title="和Session方式存储id的差异"></a>和Session方式存储id的差异</h3><hr>
<p>Session方式存储用户id的最大弊病在于要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。</p>
<p>而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分桶（见[《你所应该知道的A&#x2F;B测试基础》一文]( &#x2F;2015&#x2F;08&#x2F;27&#x2F;introduction-to-ab-testing&#x2F;）等。</p>
<p>虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘I&#x2F;O而言或许是半斤八两。具体是否采用，需要在不同场景下用数据说话。</p>
<h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><hr>
<p>Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：</p>
<ul>
<li><a href="http://www.taobao.com/">www.taobao.com</a></li>
<li>nv.taobao.com</li>
<li>nz.taobao.com</li>
<li>login.taobao.com<br>所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。</li>
</ul>
<p>使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。因此，我们只需要将含有JWT的Cookie的domain设置为顶级域名即可，例如</p>
<p>Set-Cookie: jwt&#x3D;lll.zzz.xxx; HttpOnly; max-age&#x3D;980000; domain&#x3D;.taobao.com</p>
<p>注意domain必须设置为一个点加顶级域名，即.taobao.com。这样，taobao.com和*.taobao.com就都可以接受到这个Cookie，并获取JWT了。</p>
]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>JSON Web Token</tag>
        <tag>JWT</tag>
        <tag>单点登录系统</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s/docker部署运行oracle12c数据库</title>
    <url>/2021/04/25/k8s-docker%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8Coracle12c%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>K8s&#x2F;docker部署运行oracle12c数据库</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-4.png"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。</p>
<h4 id="k8s部署Oracle12c"><a href="#k8s部署Oracle12c" class="headerlink" title="k8s部署Oracle12c"></a>k8s部署Oracle12c</h4><p>下面是Oracle部署的定义代码，此代码由两部分组成，即Oracle部署的部署以及其代理服务。此处部署的Oracle数据库为<strong>oracle12c</strong>，镜像使用的是 dockerHub 官方提供的 truevoly&#x2F;oracle-12c:latest。通过NodePort模式对外暴露了31521和38080这两个端口，并通过hostPath文件系统对Oracle的数据进行持久化。</p>
<h5 id="修改k8s的nodeport类型默认端口范围为1-65535"><a href="#修改k8s的nodeport类型默认端口范围为1-65535" class="headerlink" title="修改k8s的nodeport类型默认端口范围为1-65535"></a>修改k8s的nodeport类型默认端口范围为1-65535</h5><p><strong>修改k8s的nodeport类型端口范围provided port is not in the valid range. The range of valid ports is 30000-32767</strong></p>
<p>[root@k8s-master01 oracle]# kubectl apply -f service.yaml<br>The Service “oracle12c-nodeport” is invalid: spec.ports[0].nodePort: Invalid value: 38080: provided port is not in the valid range. The range of valid ports is 30000-32767<br>[root@k8s-master01 oracle]# vim &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml<br>​</p>
<p><strong>修改k8s的nodeport类型默认端口范围为1-65535</strong></p>
<p><strong>找到 <code>--service-cluster-ip-range</code> 这一行，在这一行的下一行增加 如下内容</strong></p>
<p>- –service-node-port-range&#x3D;1-65535</p>
<h5 id="kube-apiserver内容如下"><a href="#kube-apiserver内容如下" class="headerlink" title="kube-apiserver内容如下"></a>kube-apiserver内容如下</h5><p>[root@k8s-master01 oracle]# vim &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-apiserver.yaml<br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  annotations:<br>    kubeadm.kubernetes.io&#x2F;kube-apiserver.advertise-address.endpoint: 172.25.42.235:6443<br>  creationTimestamp: null<br>  labels:<br>    component: kube-apiserver<br>    tier: control-plane<br>  name: kube-apiserver<br>  namespace: kube-system<br>spec:<br>  containers:  </p>
<ul>
<li>command:<br>    - kube-apiserver<br>    - –advertise-address&#x3D;172.25.42.235<br>    - –allow-privileged&#x3D;true<br>    - –authorization-mode&#x3D;Node,RBAC<br>    - –client-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt<br>    - –enable-admission-plugins&#x3D;NodeRestriction<br>    - –enable-bootstrap-token-auth&#x3D;true<br>    - –etcd-cafile&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt<br>    - –etcd-certfile&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver-etcd-client.crt<br>    - –etcd-keyfile&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver-etcd-client.key<br>    - –etcd-servers&#x3D;<a href="https://127.0.0.1:2379/">https://127.0.0.1:2379</a><br>    - –insecure-port&#x3D;0<br>    - –kubelet-client-certificate&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver-kubelet-client.crt<br>    - –kubelet-client-key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver-kubelet-client.key<br>    - –kubelet-preferred-address-types&#x3D;InternalIP,ExternalIP,Hostname<br>    - –proxy-client-cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;front-proxy-client.crt<br>    - –proxy-client-key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;front-proxy-client.key<br>    - –requestheader-allowed-names&#x3D;front-proxy-client<br>    - –requestheader-client-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;front-proxy-ca.crt<br>    - –requestheader-extra-headers-prefix&#x3D;X-Remote-Extra-<br>    - –requestheader-group-headers&#x3D;X-Remote-Group<br>    - –requestheader-username-headers&#x3D;X-Remote-User<br>    - –secure-port&#x3D;6443<br>    - –service-account-issuer&#x3D;<a href="https://kubernetes.default.svc.cluster.local/">https://kubernetes.default.svc.cluster.local</a><br>    - –service-account-key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;sa.pub<br>    - –service-account-signing-key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;sa.key<br>    - –service-cluster-ip-range&#x3D;10.96.0.0&#x2F;12<br>    - –service-node-port-range&#x3D;1-65535<br>    - –tls-cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.crt<br>    - –tls-private-key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.key<br>    image: k8s.gcr.io&#x2F;kube-apiserver:v1.21.0<br>    imagePullPolicy: IfNotPresent<br>​</li>
</ul>
<h5 id="重启-kubelet"><a href="#重启-kubelet" class="headerlink" title="重启 kubelet"></a>重启 kubelet</h5><p>systemctl daemon-reload<br>systemctl restart kubelet</p>
<h4 id="配置-namespace"><a href="#配置-namespace" class="headerlink" title="配置 namespace"></a>配置 namespace</h4><p>Namespace.yaml</p>
<p>apiVersion: v1<br>kind: Namespace<br>metadata:<br>  name: database</p>
<h5 id="应用-namespace-配置"><a href="#应用-namespace-配置" class="headerlink" title="应用 namespace 配置"></a>应用 namespace 配置</h5><p>[root@k8s-master01 oracle]# kubectl apply -f namespace.yml<br>namespace&#x2F;database unchanged<br>[root@k8s-master01 oracle]# </p>
<h5 id="查看-namespace-是否创建"><a href="#查看-namespace-是否创建" class="headerlink" title="查看 namespace 是否创建"></a>查看 namespace 是否创建</h5><p>[root@k8s-master01 oracle]# kubectl get namespace<br>NAME              STATUS   AGE<br>database          Active   5d20h<br>default           Active   6d2h<br>ingress-nginx     Active   5d21h<br>kube-node-lease   Active   6d2h<br>kube-public       Active   6d2h<br>kube-system       Active   6d2h<br>nginx             Active   6d2h</p>
<h4 id="配置-deployment"><a href="#配置-deployment" class="headerlink" title="配置 deployment"></a>配置 deployment</h4><p>Deployment.yaml</p>
<p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: oracle12c<br>  namespace: database<br>spec:<br>  selector:<br>    matchLabels:<br>      app: oracle12c<br>  replicas: 1 # tells deployment to run 2 pods matching the template<br>  template:<br>    metadata:<br>      labels:<br>        app: oracle12c<br>    spec:<br>      containers:<br>      - name: oracle12c<br>        image: truevoly&#x2F;oracle-12c<br>        volumeMounts:<br>        - mountPath: &#x2F;u01&#x2F;app&#x2F;oracle<br>          name: data-app-volumes<br>        ports:<br>        - containerPort: 8080<br>        - containerPort: 1521<br>      volumes:<br>      - name: data-app-volumes<br>        hostPath:<br>          path: &#x2F;data&#x2F;oracle12c-data<br>          type: Directory</p>
<h5 id="应用-deployment-配置"><a href="#应用-deployment-配置" class="headerlink" title="应用 deployment 配置"></a>应用 deployment 配置</h5><p>[root@k8s-master01 oracle]# kubectl apply -f deployment.yaml<br>deployment.apps&#x2F;oracle12c unchanged<br>[root@k8s-master01 oracle]# </p>
<h5 id="查看-deployment-是否部署成功"><a href="#查看-deployment-是否部署成功" class="headerlink" title="查看 deployment 是否部署成功"></a>查看 deployment 是否部署成功</h5><p>[root@k8s-master01 oracle]# kubectl get po -n database -o wide<br>NAME                        READY   STATUS    RESTARTS   AGE    IP            NODE   NOMINATED NODE   READINESS GATES<br>oracle12c-ddd5f54b6-6z69g   1&#x2F;1     Running   0          148m   10.244.0.62   node   <none>           <none><br>[root@k8s-master01 oracle]#<br>​</p>
<h4 id="配置-service-暴露-31521-和-38080-端口"><a href="#配置-service-暴露-31521-和-38080-端口" class="headerlink" title="配置 service 暴露 31521 和 38080 端口"></a>配置 service 暴露 31521 和 38080 端口</h4><p>apiVersion: v1<br>kind: Service<br>metadata:<br>  namespace: database<br>  labels:<br>    app: oracle12c<br>  name: oracle12c-nodeport<br>spec:<br>  externalTrafficPolicy: Cluster<br>  type: NodePort<br>  ports:<br>    - name: manager<br>      protocol: TCP<br>      port: 8080<br>      targetPort: 8080<br>      nodePort: 38080<br>    - name: connect<br>      protocol: TCP<br>      port: 1521<br>      targetPort: 1521<br>      nodePort: 31521<br>  selector:<br>    app: oracle12c<br>​</p>
<h5 id="应用-service-配置"><a href="#应用-service-配置" class="headerlink" title="应用 service 配置"></a>应用 service 配置</h5><p>[root@k8s-master01 oracle]# kubectl get service -n database -o wide<br>NAME                 TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                         AGE     SELECTOR<br>oracle12c-nodeport   NodePort   10.109.195.127   <none>        8080:38080&#x2F;TCP,1521:31521&#x2F;TCP   5d19h   app&#x3D;oracle12c<br>[root@k8s-master01 oracle]# </p>
<h5 id="验证服务是否可用"><a href="#验证服务是否可用" class="headerlink" title="验证服务是否可用"></a>验证服务是否可用</h5><p>由于我们在宿主机上暴露了31521和38080端口，我们可以在宿主机上这样验证</p>
<p>[root@k8s-master01 oracle]# curl 172.25.42.235:38080<br><!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"><br><HTML><HEAD><br><TITLE>401 Unauthorized</TITLE><br></HEAD><BODY><H1>Unauthorized</H1><br></BODY></HTML><br>[root@k8s-master01 oracle]# telnet 172.25.42.235 31521<br>Trying 172.25.42.235…<br>Connected to 172.25.42.235.<br>Escape character is ‘^]‘.<br>^C^CConnection closed by foreign host.<br>[root@k8s-master01 oracle]# ^C</p>
<h4 id="看一下oracle12c启动日志"><a href="#看一下oracle12c启动日志" class="headerlink" title="看一下oracle12c启动日志"></a>看一下oracle12c启动日志</h4><p>[root@k8s-master01 oracle]# kubectl logs -f oracle12c-5975cbb54-qmmrx -n database<br>Database not initialized. Initializing database.<br>Starting tnslsnr<br>Copying database files<br>1% complete<br>3% complete<br>11% complete<br>18% complete<br>26% complete<br>37% complete<br>Creating and starting Oracle instance<br>40% complete<br>45% complete<br>50% complete<br>55% complete<br>56% complete<br>60% complete<br>62% complete<br>Completing Database Creation<br>66% complete<br>70% complete<br>73% complete<br>85% complete<br>96% complete<br>100% complete<br>Look at the log file “&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;cfgtoollogs&#x2F;dbca&#x2F;xe&#x2F;xe.log” for further details.<br>Configuring Apex console<br>Database initialized. Please visit http:&#x2F;&#x2F;#containeer:8080&#x2F;em http:&#x2F;&#x2F;#containeer:8080&#x2F;apex for extra configuration if needed<br>Starting web management console<br>​<br>PL&#x2F;SQL procedure successfully completed.<br>​<br>Starting import from ‘&#x2F;docker-entrypoint-initdb.d’:<br>ls: cannot access &#x2F;docker-entrypoint-initdb.d&#x2F;*: No such file or directory<br>Import finished<br>​<br>Database ready to use. Enjoy! ;)<br>​</p>
<p>启动成功</p>
<p>我们会在挂载目录看到软连接product -&gt; &#x2F;u01&#x2F;app&#x2F;oracle-product 可能有问题</p>
<p>这个坏的软连接没有影响</p>
<p>[root@k8s-master01 oracle12c-data]# pwd<br>&#x2F;data&#x2F;oracle12c-data<br>[root@k8s-master01 oracle12c-data]# ll<br>总用量 0<br>drwxr-x—. 3 1001 1001  16 4月  19 09:55 admin<br>drwxr-x—. 3 1001 1001  16 4月  19 09:59 audit<br>drwxr-x—. 3 1001 1001  18 4月  19 09:54 cfgtoollogs<br>drwxr-x—. 2 1001 1001   6 4月  19 10:04 checkpoints<br>drwxr-xr-x. 2 1001 1001 104 4月  19 10:03 dbs<br>drwxrwxr-x. 4 1001 1001  34 4月  19 09:55 diag<br>drwxr-x—. 4 1001 1001  26 4月  19 09:57 fast_recovery_area<br>drwxr-x—. 3 1001 1001  16 4月  19 09:55 oradata<br>lrwxrwxrwx. 1 root root  23 4月  19 09:54 product -&gt; &#x2F;u01&#x2F;app&#x2F;oracle-product</p>
<p>​</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-20210419101007810.png"></p>
<h4 id="重启oracle12c服务"><a href="#重启oracle12c服务" class="headerlink" title="重启oracle12c服务"></a>重启oracle12c服务</h4><p>[root@k8s-master01 oracle]# kubectl delete -f deployment.yaml<br>deployment.apps “oracle12c” deleted<br>[root@k8s-master01 oracle]# kubectl get pod -n database -o wide<br>NAME                        READY   STATUS        RESTARTS   AGE    IP            NODE   NOMINATED NODE   READINESS GATES<br>oracle11g-c4dd46556-s22p8   1&#x2F;1     Running       0          150m   10.244.0.65   node   <none>           <none><br>oracle12c-ddd5f54b6-6z69g   1&#x2F;1     Terminating   0          161m   10.244.0.62   node   <none>           <none><br>[root@k8s-master01 oracle]# kubectl get pod -n database -o wide<br>NAME                        READY   STATUS    RESTARTS   AGE    IP            NODE   NOMINATED NODE   READINESS GATES<br>oracle11g-c4dd46556-s22p8   1&#x2F;1     Running   0          150m   10.244.0.65   node   <none>           <none><br>​<br>[root@k8s-master01 oracle]# kubectl apply -f deployment.yaml<br>deployment.apps&#x2F;oracle12c created<br>[root@k8s-master01 oracle]#<br>​<br>​</p>
<h5 id="查看启动日志"><a href="#查看启动日志" class="headerlink" title="查看启动日志"></a>查看启动日志</h5><p>可以发现oracle12c在启动时，会自动判断数据文件是否存在</p>
<p>found files in &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata Using them instead of initial database</p>
<p>发现数据文件存在，则跳过数据库初始化步骤</p>
<p>[root@k8s-master01 oracle]# kubectl logs -f oracle12c-ddd5f54b6-9s4hf -n database<br>found files in &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata Using them instead of initial database<br>ORACLE instance started.<br>​<br>Total System Global Area 1610612736 bytes<br>Fixed Size          2924928 bytes<br>Variable Size         603983488 bytes<br>Database Buffers      989855744 bytes<br>Redo Buffers           13848576 bytes<br>Database mounted.<br>Database opened.<br>Starting web management console<br>​<br>PL&#x2F;SQL procedure successfully completed.<br>​<br>[IMPORT] Not a first start, SKIPPING Import from Volume ‘&#x2F;docker-entrypoint-initdb.d’<br>[IMPORT] If you want to enable import at any state - add ‘IMPORT_FROM_VOLUME&#x3D;true’ variable<br>​<br>Database ready to use. Enjoy! ;)<br>​</p>
<p>访问地址：<br>IP地址：172.25.42.235<br>端口：31521<br>SID：xe<br>用户名：system<br>密码：oracle</p>
<p>管理地址：172.25.42.235:38080<br>用户名：system<br>密码：oracle</p>
<p>已上就是K8s&#x2F;docker部署运行oracle12c数据库安装过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>docker</tag>
        <tag>Oracle</tag>
        <tag>docker部署</tag>
        <tag>K8S+Docker</tag>
        <tag>oracle12c</tag>
        <tag>Oracle数据库</tag>
        <tag>部署Oracle12c</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S_Kubernetes 出现 The connection to the server localhost:8080 was refused 的解决方法</title>
    <url>/2021/08/17/k8s-kubernetes-%E5%87%BA%E7%8E%B0-the-connection-to-the-server-localhost8080-was-refused-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-14-1024x405.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>最接几天在折腾 Kubernetes，记录一下遇到的一个问题以及解决方法。Kubernetes 是谷歌出品的一个容器集群管理系统，可以管理大规模分布式的容器集群，使用场景非常广泛。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr>
<p>在集群的工作节点上执行kubectl报错</p>
<p>[root@k8s-node239 ~]# kubectl get pods<br>The connection to the server localhost:8080 was refused - did you specify the right host or port?<br>[root@k8s-node239 ~]#<br>[root@k8s-node239 ~]# </p>
<p>作为集群管理的核心，工作节点上的kubectl可能一上来就跪了</p>
<p>安装的方法今天暂且不说，记录一下 The connection to the server localhost:8080 was refused 这个问题的解决方法。</p>
<h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h3><hr>
<p>在 kubectl init 之后，需要使用一个非 root 账户登录，然后运行下列命令：</p>
<p>sudo cp &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;<br>sudo chown $(id -u):$(id -g) $HOME&#x2F;admin.conf<br>export KUBECONFIG&#x3D;$HOME&#x2F;admin.conf</p>
<p>即可完美解决问题。</p>
<h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h3><p>出现这个问题的原因是kubectl命令需要使用kubernetes-admin的身份来运行，在“kubeadm int”启动集群的步骤中就生成了“&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf”。</p>
<p>因此，解决方法如下，将主节点中的【&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf】文件拷贝到工作节点相同目录下：</p>
<p>#复制admin.conf，请在主节点服务器上执行此命令<br>scp &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf 172.16.2.202:&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf<br>scp &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf 172.16.2.203:&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf</p>
<p>然后分别在工作节点上配置环境变量：</p>
<p>#设置kubeconfig文件<br>export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf<br>echo “export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf” &gt;&gt; ~&#x2F;.bash_profile</p>
<p>接下来，工作节点就正常了，如</p>
<p>[root@k8s-node239 ~] kubectl get pods -n devops<br>NAME                                                             READY   STATUS    RESTARTS   AGE<br>jenkins-app-5f6b59fd6c-28lq2                                     1&#x2F;1     Running   3          100d<br>jenkins-slave-1fb0bc24-0db2-40b4-a2fb-a08e63b233fa-7lv4s-c5vhq   5&#x2F;6     Error     0          18d<br>jenkins-slave-f0f10242-c76c-4ff6-b676-a010d67ddee9-qs4ms-5x3sk   5&#x2F;6     Error     0          4d22h<br>tomcat-deployment-766c6c7f44-cx2x9                               1&#x2F;1     Running   3          95d<br>[root@k8s-node239 ~]</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Kubernetes</tag>
        <tag>kubeadm</tag>
        <tag>refused</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s 报错cannot allocate memory或者no space left on device，修复Kubernetes内存泄露问题</title>
    <url>/2021/09/26/k8s-%E6%8A%A5%E9%94%99cannot-allocate-memory%E6%88%96%E8%80%85no-space-left-on-device%EF%BC%8C%E4%BF%AE%E5%A4%8Dkubernetes%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-23-1024x370.png"></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><hr>
<p>当Kubernetes集群运行日久以后，有的Node无法再新建Pod，并且出现如下错误，当重启服务器之后，才可以恢复正常使用。查看Pod状态的时候会出现以下报错。</p>
<p>applying cgroup … caused: mkdir …no space left on device<br>或者在describe pod的时候出现cannot allocate memory</p>
<p>这时候你的Kubernetes集群可能就存在内存泄露的问题了，当创建的Pod越多的时候内存会泄露的越多，越快。</p>
<h3 id="具体查看是否存在内存泄露"><a href="#具体查看是否存在内存泄露" class="headerlink" title="具体查看是否存在内存泄露"></a>具体查看是否存在内存泄露</h3><hr>
<p>cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;kubepods&#x2F;memory.kmem.slabinfo<br>当出现cat: &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;kubepods&#x2F;memory.kmem.slabinfo: Input&#x2F;output error则说明不存在内存泄露的情况<br>如果存在内存泄露会出现<br>slabinfo - version: 2.1</p>
<h1 id="name-lt-active-objs-gt-lt-num-objs-gt-tunables-slabdata-lt-active-slabs-gt-lt-num-slabs-gt"><a href="#name-lt-active-objs-gt-lt-num-objs-gt-tunables-slabdata-lt-active-slabs-gt-lt-num-slabs-gt" class="headerlink" title="name            &lt;active_objs&gt; &lt;num_objs&gt;    : tunables    : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; "></a>name            &lt;active_objs&gt; &lt;num_objs&gt; <objsize> <objperslab> <pagesperslab> : tunables <limit> <batchcount> <sharedfactor> : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; <sharedavail></h1><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><hr>
<ol>
<li>解决方法思路：关闭runc和kubelet的kmem，因为升级内核的方案改动较大，此处不采用。</li>
<li>kmem导致内存泄露的原因：<br>内核对于每个cgroup子系统的的条目数是有限制的，限制的大小定义在kernel&#x2F;cgroup.c #L139，当正常在cgroup创建一个group的目录时，条目数就加1。我们遇到的情况就是因为开启了kmem accounting功能，虽然cgroup的目录删除了，但是条目没有回收。这样后面就无法创建65535个cgroup了。也就是说，在当前内核版本下，开启了kmem accounting功能，会导致memory cgroup的条目泄漏无法回收。</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><hr>
<h4 id="需要重新编译runc"><a href="#需要重新编译runc" class="headerlink" title="需要重新编译runc"></a>需要重新编译runc</h4><hr>
<p>1、配置go语言环境</p>
<p>wget <a href="https://dl.google.com/go/go1.12.9.linux-amd64.tar.gz">https://dl.google.com/go/go1.12.9.linux-amd64.tar.gz</a><br>tar xf go1.12.9.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</p>
<p>写入bashrc<br>vim ~&#x2F;.bashrc<br>export GOPATH&#x3D;”&#x2F;data&#x2F;Documents”<br>export GOROOT&#x3D;”&#x2F;usr&#x2F;local&#x2F;go”<br>export PATH&#x3D;”$GOROOT&#x2F;bin:$GOPATH&#x2F;bin:$PATH”<br>export GO111MODULE&#x3D;off</p>
<p>验证<br>source ~&#x2F;.bashrc<br>go env</p>
<p>2、下载runc源码码</p>
<p>mkdir -p &#x2F;data&#x2F;Documents&#x2F;src&#x2F;github.com&#x2F;opencontainers&#x2F;<br>cd &#x2F;data&#x2F;Documents&#x2F;src&#x2F;github.com&#x2F;opencontainers&#x2F;<br>git clone <a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a><br>cd runc&#x2F;<br>git checkout v1.0.0-rc9  # 切到v1.0.0-rc9 tag</p>
<p>3、编译</p>
<p>安装编译组件</p>
<p>sudo yum install libseccomp-devel<br>make BUILDTAGS&#x3D;’seccomp nokmem’</p>
<p>编译完成之后会在当前目录下看到一个runc的可执行文件，等kubelet编译完成之后会将其替换</p>
<h4 id="编译kubelet"><a href="#编译kubelet" class="headerlink" title="编译kubelet"></a>编译kubelet</h4><hr>
<p>1、下载Kubernetes源码</p>
<p>mkdir -p &#x2F;root&#x2F;k8s&#x2F;<br>cd &#x2F;root&#x2F;k8s&#x2F;<br>git clone <a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a><br>cd kubernetes&#x2F;<br>git checkout v1.15.3</p>
<p>2、制作编译环境的镜像（Dockerfile如下）</p>
<p>FROM centos:centos7.3.1611</p>
<p>ENV GOROOT &#x2F;usr&#x2F;local&#x2F;go<br>ENV GOPATH &#x2F;usr&#x2F;local&#x2F;gopath<br>ENV PATH &#x2F;usr&#x2F;local&#x2F;go&#x2F;bin:$PATH</p>
<p>RUN yum install rpm-build which where rsync gcc gcc-c++ automake autoconf libtool make -y \<br>    &amp;&amp; curl -L <a href="https://studygolang.com/dl/golang/go1.12.9.linux-amd64.tar.gz">https://studygolang.com/dl/golang/go1.12.9.linux-amd64.tar.gz</a>  tar zxvf - -C &#x2F;usr&#x2F;local</p>
<p>3、在制作好的go环境镜像中来进行编译kubelet</p>
<p>docker run  -it –rm   -v &#x2F;root&#x2F;k8s&#x2F;kubernetes:&#x2F;usr&#x2F;local&#x2F;gopath&#x2F;src&#x2F;k8s.io&#x2F;kubernetes   build-k8s:centos-7.3-go-1.12.9-k8s-1.15.3   bash<br>cd &#x2F;usr&#x2F;local&#x2F;gopath&#x2F;src&#x2F;k8s.io&#x2F;kubernetes<br>#编译<br>GO111MODULE&#x3D;off KUBE_GIT_TREE_STATE&#x3D;clean KUBE_GIT_VERSION&#x3D;v1.15.3 make kubelet GOFLAGS&#x3D;”-tags&#x3D;nokmem”</p>
<h3 id="替换原有的runc和kubelet"><a href="#替换原有的runc和kubelet" class="headerlink" title="替换原有的runc和kubelet"></a>替换原有的runc和kubelet</h3><hr>
<p>1、将原有runc和kubelet备份</p>
<p>mv &#x2F;usr&#x2F;bin&#x2F;kubelet &#x2F;home&#x2F;kubelet<br>mv &#x2F;usr&#x2F;bin&#x2F;docker-runc &#x2F;home&#x2F;docker-runc</p>
<p>2、停止Docker和kubelet</p>
<p>systemctl stop docker<br>systemctl stop kubelet</p>
<p>3、将编译好的runc和kubelet进行替换</p>
<p>cp kubelet &#x2F;usr&#x2F;bin&#x2F;kubelet<br>cp kubelet &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubelet<br>cp runc &#x2F;usr&#x2F;bin&#x2F;docker-runc</p>
<p>4、检查kmem是否关闭前需要将此节点的Pod杀掉重启或者重启服务器，当结果为0时成功</p>
<p>cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;kubepods&#x2F;burstable&#x2F;memory.kmem.usage_in_bytes</p>
<p>5、是否还存在内存泄露的情况</p>
<p>cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;kubepods&#x2F;memory.kmem.slabinfo</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Kubernetes</tag>
        <tag>cannot allocate memory</tag>
        <tag>kubelet</tag>
        <tag>no space left on device</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 证书过期问题怎么处理？certificate has expired or is not yet valid</title>
    <url>/2022/04/07/k8s-%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9Fcertificate-has-expired-or-is-not-yet-valid/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/ae22870536364cb4a8ba5a1c2df10f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>公司测试环境的 k8s 集群使用已经很长时间了,突然有一天开发联系我说 k8s 集群无法访问，开始以为是测试环境的机器磁盘空间不够了，导致组件异常或者把开发使用的镜像自动清理掉了，但是当登上机器去查验的时候发现不是这个原因。当时觉得也很疑惑。因为开发环境使用人数较少，不应该会出问题，所以就去查验 log 的相关报错信息。</p>
<h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><hr>
<p>出现 k8s api 无法调取的现象，使用 kubectl 命令获取资源均返回如下报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Unable to connect to the server: x509: certificate has expired or is not yet valid</span><br></pre></td></tr></table></figure>

<p>经网上搜索之后发现应该是 k8s 集群的证书过期了，使用命令排查证书的过期时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> `find /etc/kubernetes/pki -maxdepth 2 -name <span class="string">&quot;*.crt&quot;</span>`</span><br><span class="line"><span class="keyword">do</span> openssl x509 -<span class="keyword">in</span> <span class="variable">$item</span> -text -noout| grep Not</span><br><span class="line"><span class="built_in">echo</span> ======================<span class="variable">$item</span>===================</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>或者使用kubeadm官方提供的检查证书是否过期</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm certs check-expiration</span><br></pre></td></tr></table></figure>

<p>发现确实是证书过期了</p>
<h3 id="相关介绍以及问题解决"><a href="#相关介绍以及问题解决" class="headerlink" title="相关介绍以及问题解决"></a>相关介绍以及问题解决</h3><hr>
<p>因为我们是使用 kubeadm 部署的 k8s 集群，所以更新起证书也是比较方便的，默认的证书时间有效期是一年，我们集群的 k8s 版本是 1.15.3 版本是可以使用以下命令来更新证书的，但是一年之后还是会到期，这样就很麻烦，所以我们需要了解一下 k8s 的证书，然后我们来生成一个时间很长的证书，这样我们就可以不用去总更新证书了。</p>
<h4 id="备份要过期的证书"><a href="#备份要过期的证书" class="headerlink" title="备份要过期的证书"></a>备份要过期的证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -rp /etc/kubernetes /etc/kubernetes.bak</span><br></pre></td></tr></table></figure>

<h4 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config view &gt; /tmp/cluster.yaml</span><br></pre></td></tr></table></figure>

<h4 id="更新新证书-生成新证书"><a href="#更新新证书-生成新证书" class="headerlink" title="更新新证书 生成新证书"></a>更新新证书 生成新证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm certs renew all --config=/tmp/cluster.yaml</span><br></pre></td></tr></table></figure>

<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><p>将生成的配置文件替换,重启 kube-apiserver、kube-controller、kube-scheduler、etcd 这4个容器即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps |grep -E <span class="string">&#x27;k8s_kube-apiserver|k8s_kube-controller-manager|k8s_kube-scheduler|k8s_etcd_etcd&#x27;</span> | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> |xargs docker restart</span><br></pre></td></tr></table></figure>



<p>另外 kubeadm 会在控制面板升级的时候自动更新所有证书，所以使用 kubeadm 搭建的集群最佳的做法是经常升级集群，这样可以确保你的集群保持最新状态并保持合理的安全性。但是对于实际的生产环境我们可能并不会去频繁的升级集群，所以这个时候我们就需要去手动更新证书。</p>
<h3 id="我们通过调用-k8s-的-api-来实现更新一个-10-年的证书"><a href="#我们通过调用-k8s-的-api-来实现更新一个-10-年的证书" class="headerlink" title="我们通过调用 k8s 的 api 来实现更新一个 10 年的证书"></a>我们通过调用 k8s 的 api 来实现更新一个 10 年的证书</h3><hr>
<p>首先在 &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;kube-controller-manager.yaml 文件加入配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="comment"># 设置证书有效期为 10年</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--experimental-cluster-signing-duration=87600h</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--client-ca-file=/etc/kubernetes/pki/ca.crt</span></span><br></pre></td></tr></table></figure>
<p>修改完成后 kube-controller-manager 会自动重启生效。然后我们需要使用下面的命令为 Kubernetes 证书 API 创建一个证书签名请求。如果您设置例如 cert-manager 等外部签名者，则会自动批准证书签名请求（CSRs）。否者，您必须使用 kubectl certificate 命令手动批准证书。以下 kubeadm 命令输出要批准的证书名称，然后等待批准发生：</p>
<p>需要将全部 pending 的证书全部批准</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm certs renew all --use-api --config kubeadm.yaml &amp;</span><br></pre></td></tr></table></figure>
<p>我们还不能直接重启控制面板的几个组件，这是因为使用 kubeadm 安装的集群对应的 etcd 默认是使用的 &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt 这个证书进行前面的，而上面我们用命令 kubectl certificate approve 批准过后的证书是使用的默认的 &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt 证书进行签发的，所以我们需要替换 etcd 中的 ca 机构证书:</p>
<p>先拷贝静态 Pod 资源清单</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">/etc/kubernetes/manifests/</span> <span class="string">/etc/kubernetes/manifests.bak</span></span><br><span class="line"><span class="string">$</span> <span class="string">vi</span> <span class="string">/etc/kubernetes/manifests/etcd.yaml</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">etcd</span></span><br><span class="line">    <span class="comment"># 修改为 CA 文件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--peer-trusted-ca-file=/etc/kubernetes/pki/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--trusted-ca-file=/etc/kubernetes/pki/ca.crt</span></span><br><span class="line">      <span class="string">......</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">etcd-data</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/kubernetes/pki</span>  <span class="comment"># 更改证书目录</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">etcd-certs</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/kubernetes/pki</span>  <span class="comment"># 将 pki 目录挂载到 etcd 中去</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">etcd-certs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">etcd-data</span></span><br><span class="line">      <span class="string">......</span></span><br></pre></td></tr></table></figure>
<p>由于 kube-apiserver 要连接 etcd 集群，所以也需要重新修改对应的 etcd ca 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vi</span> <span class="string">/etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="comment"># 将etcd ca文件修改为默认的ca.crt文件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-cafile=/etc/kubernetes/pki/ca.crt</span></span><br><span class="line">    <span class="string">......</span></span><br></pre></td></tr></table></figure>
<p>除此之外还需要替换 requestheader-client-ca-file 文件，默认是 &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;front-proxy-ca.crt 文件，现在也需要替换成默认的 CA 文件，否则使用聚合 API，比如安装了 metrics-server 后执行 kubectl top 命令就会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /etc/kubernetes/pki/ca.crt /etc/kubernetes/pki/front-proxy-ca.crt</span><br><span class="line">$ <span class="built_in">cp</span> /etc/kubernetes/pki/ca.key /etc/kubernetes/pki/front-proxy-ca.key</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了一个 10 年证书的 k8s 集群，还可以通过重新编译 kubeadm 来实现一个 10 年证书的，这个我没有尝试，不过在初始化集群的时候也是一个方法。</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Kubernetes</tag>
        <tag>kubeadm</tag>
        <tag>初始化</tag>
        <tag>证书</tag>
        <tag>过期</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s原生镜像仓库安装registry</title>
    <url>/2021/05/02/k8s%E5%8E%9F%E7%94%9F%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%AE%89%E8%A3%85registry/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-50.png"></p>
<p>在服务部署过程中，有很多的docker镜像文件，由于kubernetes是使用国外的镜像，可能会出现下载很慢或者下载不下来的情况，我们先搭建一个简单的镜像服务器，我们将需要的镜像下载回来，放到我们自己的镜像服务器，然后调用我们自己服务器的镜像就快很多。</p>
<p>Registry是Dcoker官方的一个私有仓库镜像，可以将本地的镜像打标签进行标记然后push到以Registry起的容器的私有仓库中。企业可以根据自己的需求，使用Dokcerfile生成自己的镜像，并推到私有仓库中，这样可以大大提高拉取镜像的效率。</p>
<h2 id="下载官方的registry镜像"><a href="#下载官方的registry镜像" class="headerlink" title="下载官方的registry镜像"></a>下载官方的registry镜像</h2><hr>
<p>[root@k8s-master01 data]# docker pull registry<br>Using default tag: latest<br>latest: Pulling from library&#x2F;registry<br>ddad3d7c1e96: Pull complete<br>6eda6749503f: Pull complete<br>363ab70c2143: Pull complete<br>5b94580856e6: Pull complete<br>12008541203a: Pull complete<br>Digest: sha256:bac2d7050dc4826516650267fe7dc6627e9e11ad653daca0641437abdf18df27<br>Status: Downloaded newer image for registry:latest<br>docker.io&#x2F;library&#x2F;registry:latest<br>[root@k8s-master01 data]# </p>
<p>下载完成</p>
<h2 id="启动Registry服务"><a href="#启动Registry服务" class="headerlink" title="启动Registry服务"></a>启动Registry服务</h2><h3 id="在k8s集群内启动registry服务-deployment-配置如下"><a href="#在k8s集群内启动registry服务-deployment-配置如下" class="headerlink" title="在k8s集群内启动registry服务 deployment 配置如下"></a>在k8s集群内启动registry服务 deployment 配置如下</h3><p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: registry<br>  namespace: docker-registry<br>spec:<br>  selector:<br>    matchLabels:<br>      app: registry<br>  replicas: 1<br>  template:<br>    metadata:<br>      labels:<br>        app: registry<br>    spec:<br>      nodeSelector:<br>        name: “node-235”<br>      containers:<br>      - name: registry<br>        image: registry:latest<br>        volumeMounts:<br>        - mountPath: &#x2F;var&#x2F;lib&#x2F;registry<br>          name: data-app-1<br>        ports:<br>        - containerPort: 5000<br>      volumes:<br>      - name: data-app-1<br>        hostPath:<br>          path: &#x2F;data&#x2F;registry-data #本地目录<br>          type: Directory</p>
<p>把本地 &#x2F;data&#x2F;registry-data 挂载到容器里，做镜像数据持久化</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>[root@k8s-master01 registry]# kubectl apply -f deployment.yaml<br>deployment.apps&#x2F;registry created</p>
<h3 id="查看服务是否启动"><a href="#查看服务是否启动" class="headerlink" title="查看服务是否启动"></a>查看服务是否启动</h3><p>[root@k8s-master01 registry]# kubectl get pod -n docker-registry<br>NAME                                READY   STATUS    RESTARTS   AGE<br>registry-6c58cb656-7lxgz            1&#x2F;1     Running   1          13m</p>
<h3 id="配置nodeport-5000端口访问service配置如下"><a href="#配置nodeport-5000端口访问service配置如下" class="headerlink" title="配置nodeport 5000端口访问service配置如下"></a>配置nodeport 5000端口访问service配置如下</h3><p>apiVersion: v1<br>kind: Service<br>metadata:<br>  namespace: docker-registry<br>  labels:<br>    app: registry<br>  name: registry-nodeport<br>spec:<br>  externalTrafficPolicy: Cluster<br>  type: NodePort<br>  ports:<br>    - name: manager<br>      protocol: TCP<br>      port: 5000<br>      targetPort: 5000<br>      nodePort: 5000<br>  selector:<br>    app: registry</p>
<h3 id="应用Service配置"><a href="#应用Service配置" class="headerlink" title="应用Service配置"></a>应用Service配置</h3><p>[root@k8s-master01 registry]# kubectl apply -f service.yaml<br>service&#x2F;registry-nodeport created<br>[root@k8s-master01 registry]# kubectl get service -n docker-registry<br>NAME                         TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE<br>registry-nodeport            NodePort   10.103.250.191   <none>        5000:5000&#x2F;TCP   10m</p>
<p>Service配置已生效</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><hr>
<h3 id="查看Registry中所有镜像信息"><a href="#查看Registry中所有镜像信息" class="headerlink" title="查看Registry中所有镜像信息"></a>查看Registry中所有镜像信息</h3><p>[root@k8s-master01 registry]# curl <a href="http://172.25.42.235:5000/v2//_catalog">http://172.25.42.235:5000/v2/\_catalog</a><br>{“repositories”:[]}</p>
<p>发现现在仓库列表为空，是因为我没有上传镜像文件</p>
<h3 id="上传镜像文件"><a href="#上传镜像文件" class="headerlink" title="上传镜像文件"></a>上传镜像文件</h3><h4 id="修改镜像标签tag"><a href="#修改镜像标签tag" class="headerlink" title="修改镜像标签tag"></a>修改镜像标签tag</h4><p>[root@k8s-master01 registry]# docker imagesgrep openresty-web<br>openresty-web                                                                 2021042804         a6b14c409cf4   20 hours ago    303MB<br>[root@k8s-master01 registry]# docker tag openresty-web:2021042804 172.25.42.235:5000&#x2F;web&#x2F;openresty-web:v1<br>[root@k8s-master01 registry]# docker imagesgrep openresty-web<br>172.25.42.235:5000&#x2F;web&#x2F;openresty-web                                          v1                 a6b14c409cf4   20 hours ago    303MB<br>openresty-web                                                                 2021042804         a6b14c409cf4   20 hours ago    303MB</p>
<p>上面把 openresty-web:2021042804 这个镜像 修改为 172.25.42.235:5000&#x2F;web&#x2F;openresty-web:v1</p>
<h4 id="把镜像push到镜像仓库"><a href="#把镜像push到镜像仓库" class="headerlink" title="把镜像push到镜像仓库"></a>把镜像push到镜像仓库</h4><p>[root@k8s-master01 registry]# docker push 172.25.42.235:5000&#x2F;web&#x2F;openresty-web:v1<br>The push refers to repository [172.25.42.235:5000&#x2F;web&#x2F;openresty-web]<br>Get <a href="https://172.25.42.235:5000/v2/">https://172.25.42.235:5000/v2/</a>: http: server gave HTTP response to HTTPS client<br>[root@k8s-master01 registry]# </p>
<p>上传镜像失败：原因：docker上传下载默认只支持https协议，搭建的的私有仓库没有https协议</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>修改&#x2F;etc&#x2F;docker&#x2F;daemon.json<br>增加 “insecure-registries”:[“172.25.42.235:5000”]<br>重启docker</p>
<p>[root@k8s-master01 registry]# cat &#x2F;etc&#x2F;docker&#x2F;daemon.json<br>{<br>“insecure-registries”:[“172.25.42.235:5000”],<br>“exec-opts”: [“native.cgroupdriver&#x3D;systemd”],<br>“log-driver”: “json-file”,<br>“log-opts”: {<br>“max-size”: “100m”<br>}<br>}<br>[root@k8s-master01 registry]# systemctl restart docker</p>
<p>172.25.42.235:5000 为仓库地址<br>等待docker服务重启完成</p>
<h4 id="再次把镜像push到镜像仓库"><a href="#再次把镜像push到镜像仓库" class="headerlink" title="再次把镜像push到镜像仓库"></a>再次把镜像push到镜像仓库</h4><p>再次把镜像push 172.25.42.235:5000&#x2F;web&#x2F;openresty-web:v1 到镜像仓库</p>
<p>[root@k8s-master01 registry]# docker push 172.25.42.235:5000&#x2F;web&#x2F;openresty-web:v1<br>The push refers to repository [172.25.42.235:5000&#x2F;web&#x2F;openresty-web]<br>19012cb487d1: Pushed<br>5809ac47fde6: Pushed<br>19ae150a9831: Pushed<br>94bde1a9815a: Pushed<br>0116810ae50c: Pushed<br>174f56854903: Pushed<br>v1: digest: sha256:4669d832f7cb2e60ff9974765ab605a6c8ca9a7640e18a03fdd85565539dd3ae size: 1575</p>
<p>上传完成</p>
<h2 id="查看仓库镜像"><a href="#查看仓库镜像" class="headerlink" title="查看仓库镜像"></a>查看仓库镜像</h2><p>[root@k8s-master01 registry]# curl <a href="http://172.25.42.235:5000/v2//_catalog">http://172.25.42.235:5000/v2/\_catalog</a><br>{“repositories”:[“web&#x2F;openresty-web”]}<br>[root@k8s-master01 registry]#</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>镜像仓库</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>registry</tag>
        <tag>原生</tag>
        <tag>仓库</tag>
        <tag>安装</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s如何修改限制节点启动的Pod数量？</title>
    <url>/2021/12/11/k8s%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%99%90%E5%88%B6%E8%8A%82%E7%82%B9%E5%90%AF%E5%8A%A8%E7%9A%84pod%E6%95%B0%E9%87%8F%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-23-1024x370.png" alt="k8s,kubernets"></p>
<p>k8s,kubernets</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>由于业务需要，我们在3个节点上需要运行大量资源消耗非常小的pod，每个节点运行200个pod；</p>
<p>今天意外发生故障，造成这3个节点上所有容器并发重启。造成这3个节点在容器重启过程中，资源耗尽，并进入挂掉的状态。</p>
<h3 id="Node节点默认的Pod数量"><a href="#Node节点默认的Pod数量" class="headerlink" title="Node节点默认的Pod数量"></a>Node节点默认的Pod数量</h3><hr>
<p>Kubernetes Node节点每个默认允许最多创建110个Pod，有时可能会由于系统硬件的问题，从而需要控制Node节点的Pod的运行数量。</p>
<p>即：需要调整Node节点的最大可运行Pod数量。<br>一般来说，我们只需要在kubelet启动命令中增加–max-pods参数，然后，重启kubelet 服务，就生效。<br>重启kubelet，不影响现有运行中的容器，不会造成容器重启。</p>
<h3 id="修改限制Pod启动数量"><a href="#修改限制Pod启动数量" class="headerlink" title="修改限制Pod启动数量"></a>修改限制Pod启动数量</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/128e720ccd124485920763089c3fe697.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>可以看到，集群当前有3台Node节点，且最大可运行Pod数量均为默认值：110。</p>
<p>接下来，我们来修改该参数值。</p>
<h3 id="修改Pod启动数量"><a href="#修改Pod启动数量" class="headerlink" title="修改Pod启动数量"></a>修改Pod启动数量</h3><h4 id="1、登录-Node-节点，查看kubelet启动文件路径"><a href="#1、登录-Node-节点，查看kubelet启动文件路径" class="headerlink" title="1、登录 Node 节点，查看kubelet启动文件路径"></a>1、登录 Node 节点，查看kubelet启动文件路径</h4><hr>
<p>[<a href="mailto:&#114;&#x6f;&#111;&#x74;&#x40;&#x63;&#x6f;&#100;&#101;&#x34;&#48;&#52;&#x2e;&#x69;&#x63;&#117;">&#114;&#x6f;&#111;&#x74;&#x40;&#x63;&#x6f;&#100;&#101;&#x34;&#48;&#52;&#x2e;&#x69;&#x63;&#117;</a> ~]# systemctl status kubelet</p>
<p><img src="https://img-blog.csdnimg.cn/c31823ca18144f75a23281188038945e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>从上图可以看到，kubelet 的启动文件为&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service</p>
<h4 id="2、查看-systemd-启动文件"><a href="#2、查看-systemd-启动文件" class="headerlink" title="2、查看 systemd 启动文件"></a>2、查看 systemd 启动文件</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/d571978b1c324959aef650578df5eb34.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，Environment文件是引用&#x2F;etc&#x2F;kubernetes&#x2F;kubelet，至此，我们只需要在&#x2F;etc&#x2F;kubernetes&#x2F;kubelet中增加max-pods的变量，然后在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service中，将变量添加到启动参数后即可。</p>
<h4 id="3、修改-x2F-etc-x2F-kubernetes-x2F-kubelet"><a href="#3、修改-x2F-etc-x2F-kubernetes-x2F-kubelet" class="headerlink" title="3、修改&#x2F;etc&#x2F;kubernetes&#x2F;kubelet"></a>3、修改&#x2F;etc&#x2F;kubernetes&#x2F;kubelet</h4><hr>
<p>强烈建议，在修改Pod数量的时候，如果是缩减（当前运行70个Pod，所见到20个），强烈建议先把Node上的Pod驱散，等驱散完了在重启，最后在激活Node。</p>
<p>[<a href="mailto:&#x72;&#111;&#x6f;&#x74;&#x40;&#99;&#x6f;&#x64;&#101;&#52;&#x30;&#x34;&#46;&#x69;&#x63;&#x75;">&#x72;&#111;&#x6f;&#x74;&#x40;&#99;&#x6f;&#x64;&#101;&#52;&#x30;&#x34;&#46;&#x69;&#x63;&#x75;</a> ~]# vim &#x2F;etc&#x2F;kubernetes&#x2F;kubelet</p>
<h1 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h1><p>MAX_PODS&#x3D;”–max-pods&#x3D;61”</p>
<h4 id="4、修改-x2F-usr-x2F-lib-x2F-systemd-x2F-system-x2F-kubelet-service"><a href="#4、修改-x2F-usr-x2F-lib-x2F-systemd-x2F-system-x2F-kubelet-service" class="headerlink" title="4、修改&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service"></a>4、修改&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service</h4><hr>
<p>注意：必须在启动命令后加入该变量，才可以使刚才定义的–max-pods&#x3D;61生效。<br><img src="https://img-blog.csdnimg.cn/b3dbde414db747d79c0f2f89bbd21069.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="5、重启kubelet"><a href="#5、重启kubelet" class="headerlink" title="5、重启kubelet"></a>5、重启kubelet</h4><hr>
<p>[<a href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#x63;&#x6f;&#100;&#101;&#52;&#x30;&#52;&#46;&#x69;&#x63;&#117;">&#x72;&#x6f;&#111;&#116;&#x40;&#x63;&#x6f;&#100;&#101;&#52;&#x30;&#52;&#46;&#x69;&#x63;&#117;</a> ~]# systemctl  daemon-reload<br>[<a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#x63;&#x6f;&#100;&#101;&#x34;&#48;&#x34;&#46;&#x69;&#99;&#x75;">&#114;&#x6f;&#111;&#116;&#x40;&#x63;&#x6f;&#100;&#101;&#x34;&#48;&#x34;&#46;&#x69;&#99;&#x75;</a> ~]# systemctl restart kubelet</p>
<p>查看修改结果<br><img src="https://img-blog.csdnimg.cn/d53fc24d39bf4869bfb211ac80d2bf70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，已经完成修改的节点的最大可调度Pod数量已经调整为61。配置生效。</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>节点</tag>
        <tag>kubelet</tag>
        <tag>kubernets</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s集群添加node节点遇到的问题</title>
    <url>/2021/06/01/k8s%E9%9B%86%E7%BE%A4%E6%B7%BB%E5%8A%A0node%E8%8A%82%E7%82%B9%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="加入集群卡住不动"><a href="#加入集群卡住不动" class="headerlink" title="加入集群卡住不动"></a>加入集群卡住不动</h2><p>kubeadm join 172.25.42.235:6443 –token abcdef.0123456789abcdef –discovery-token-ca-cert-hash sha256:98de276382a20d872f579a74ee924b38d3705ebfcf268b1658a0b6ddb3dccaaa</p>
<h3 id="开debug模式"><a href="#开debug模式" class="headerlink" title="开debug模式"></a>开debug模式</h3><p>kubeadm join 172.25.42.235:6443 –token abcdef.0123456789abcdef –discovery-token-ca-cert-hash sha256:98de276382a20d872f579a74ee924b38d3705ebfcf268b1658a0b6ddb3dccaaa  -v&#x3D;10</p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>I0531 05:04:20.734795    8706 round_trippers.go:435] curl -k -v -XGET  -H “Accept: application&#x2F;json, *&#x2F;*“ -H “User-Agent: kubeadm&#x2F;v1.21.1 (linux&#x2F;amd64) kubernetes&#x2F;5e58841” ‘<a href="https://172.25.42.235:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s&#39;">https://172.25.42.235:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s&#39;</a><br>I0531 05:04:20.736850    8706 round_trippers.go:454] GET <a href="https://172.25.42.235:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s">https://172.25.42.235:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s</a> 200 OK in 2 milliseconds<br>I0531 05:04:20.736865    8706 round_trippers.go:460] Response Headers:<br>I0531 05:04:20.736870    8706 round_trippers.go:463]     Cache-Control: no-cache, private<br>I0531 05:04:20.736873    8706 round_trippers.go:463]     Content-Type: application&#x2F;json<br>I0531 05:04:20.736876    8706 round_trippers.go:463]     X-Kubernetes-Pf-Flowschema-Uid: aabbe46b-393b-42d9-886b-aaf4b2fc7ce2<br>I0531 05:04:20.736879    8706 round_trippers.go:463]     X-Kubernetes-Pf-Prioritylevel-Uid: 3120be8e-1c11-4b11-ad37-0de38bb70030<br>I0531 05:04:20.736882    8706 round_trippers.go:463]     Content-Length: 2353<br>I0531 05:04:20.736915    8706 round_trippers.go:463]     Date: Mon, 31 May 2021 09:04:20 GMT<br>I0531 05:04:20.737280    8706 request.go:1123] Response Body: {“kind”:”ConfigMap”,”apiVersion”:”v1”,”metadata”:{“name”:”cluster-info”,”namespace”:”kube-public”,”uid”:”4e7f9c17-5dc6-41ce-a18d-1076606b97d1”,”resourceVersion”:”5183381”,”creationTimestamp”:”2021-04-14T07:01:55Z”,”managedFields”:[{“manager”:”kubeadm”,”operation”:”Update”,”apiVersion”:”v1”,”time”:”2021-04-14T07:01:55Z”,”fieldsType”:”FieldsV1”,”fieldsV1”:{“f:data”:{“.”:{},”f:kubeconfig”:{}}}},{“manager”:”kube-controller-manager”,”operation”:”Update”,”apiVersion”:”v1”,”time”:”2021-05-31T09:03:26Z”,”fieldsType”:”FieldsV1”,”fieldsV1”:{“f:data”:{“f:jws-kubeconfig-oumnnc”:{}}}}]},”data”:{“jws-kubeconfig-oumnnc”:”eyJhbGciOiJIUzI1NiIsImtpZCI6Im91bW5uYyJ9..2Omg4lzZWg82FA-nUq1UxpnLL2qUR7-cgls62ciTvOE”,”kubeconfig”:”apiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeE1EUXhOREEzTURBME5sb1hEVE14TURReE1qQTNNREEwTmxvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSy9uCk9wZEMyNlpBNnRHODA5NkxlcDVXY0w3eTdwRmNmcmVYVWVjNDlxNFlQekI4cW1NK2I0Vy9lTE45dnBRa3l1WHcKbWZCbVJsOVp0aDlXWGVDVjgxVzN5OXEyQUgrWTgwSmJiOGZEYkxsREwrWTZQa25DOW45bEFDVXRmMTlHNHlCbwprdTFtYlVMM215c2pKYWY3RC81RFhsaEZpaGFQVkRaT1M3RVZJNlRqRU4xWlV2VDQraEMxRkgrcUhVS0hIUGNYCnhtUXQzMUtxR1gyOW5sNkd3TzlQajRGbnVTV3JxQnpCM01YRHpESGlnSXBhMm9mVjY3OU9nZ1B3c0duVkRFbzUKU1k0dmFTK0djR29ZVFhoWGMyYm5kbFVuSDBIc0l3UmpPeWFldWpwREdYclhvMzh0Mk1hR0F2L3g1Z2NvTVM3KwplWVdYclFtKzJXRURDNlpDUkpjQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZLcTBobnNTMHNDUDcyQmFTaGR6cHRjc3lKRHhNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBVkgvNDVRUzVUb2VJMk4xaHVOQUZqMDJtb0RCQzQ3VXZIbmpva3NieVA2K2dYSE9wNQpCL1lKS0Njd2hwUTlWODAwUFRtc2FHK0kwZFliMjFEQW1SVnJTYVFsR1RtSnFmc1dpeFJQUERsRmRSOXg3dGNsCm85THV4ZDRzZnJmNG1GZHJuU1QzSndJWElzZXA2ZVRYWm1WK1NMREplR0ZmejVYSDlFUkRVRkJiTWxQSE1SbHUKNHp1anVIeENEa0JxSHhCMnpRZTA5YlN5TE1jNndtejJnL1dSM0xWakxpVkpRTWVaU0YySzduMmkzN29KY05EcgpEb29QSE40NWhESHNiRnFMU3FNRUU4eGUreFV5Y3JrVFdiWTRWQUpnUUFHMGpGV1prUmc4Ymg4RC9seXArNC81Cit3RHBUVW5lQU12L2VBdjBDQ01KWGIwdGZNbEhYYnBhSTVBNAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg&#x3D;&#x3D;\n    server: <a href="https://172.25.42.235:6443//n">https://172.25.42.235:6443\\n</a>  name: \“\“\ncontexts: null\ncurrent-context: \“\“\nkind: Config\npreferences: {}\nusers: null\n”}}<br>I0531 05:04:20.737406    8706 token.go:221] [discovery] The cluster-info ConfigMap does not yet contain a JWS signature for token ID “abcdef”, will try again</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>官方说是为了安全，初始化token后会在24小时候会被master删除,</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="在master节点重新生成一个"><a href="#在master节点重新生成一个" class="headerlink" title="在master节点重新生成一个"></a>在master节点重新生成一个</h4><p>[root@k8s-master01 data]# kubeadm token create<br>oumnnc.aqlxuvdbntlvzoiv</p>
<h4 id="在master查看Token"><a href="#在master查看Token" class="headerlink" title="在master查看Token"></a>在master查看Token</h4><p>[root@k8s-master01 data]# kubeadm token list<br>TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION                                                EXTRA GROUPS<br>oumnnc.aqlxuvdbntlvzoiv   23h         2021-06-01T17:03:25+08:00   authentication,signing   <none>                                                     system:bootstrappers:kubeadm:default-node-token</p>
<h2 id="重新加入，又报错"><a href="#重新加入，又报错" class="headerlink" title="重新加入，又报错"></a>重新加入，又报错</h2><p>[root@k8s-node240 docker]# kubeadm join 172.25.42.235:6443 –token oumnnc.aqlxuvdbntlvzoiv –discovery-token-ca-cert-hash sha256:98de276382a20d872f579a74ee924b38d3705ebfcf268b1658a0b6ddb3dccaaa<br>[preflight] Running pre-flight checks<br>error execution phase preflight: couldn’t validate the identity of the API Server: cluster CA found in cluster-info ConfigMap is invalid: none of the public keys “sha256:46a4b70fca4adb7ec0315e25e0712ff1a4eaebf002e4ded963a981de071431fe” are pinned<br>To see the stack trace of this error execute with –v&#x3D;5 or higher</p>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>如果找不到hash可以在master节点执行</p>
<p>[root@k8s-master01 data]# openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt  openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null  openssl dgst -sha256 -hex  sed ‘s&#x2F;^.* &#x2F;&#x2F;‘<br>46a4b70fca4adb7ec0315e25e0712ff1a4eaebf002e4ded963a981de071431fe</p>
<h4 id="重新加入，成功"><a href="#重新加入，成功" class="headerlink" title="重新加入，成功"></a>重新加入，成功</h4><p>[root@k8s-node240 docker]# kubeadm join 172.25.42.235:6443 –token oumnnc.aqlxuvdbntlvzoiv –discovery-token-ca-cert-hash sha256:46a4b70fca4adb7ec0315e25e0712ff1a4eaebf002e4ded963a981de071431fe<br>[preflight] Running pre-flight checks<br>[preflight] Reading configuration from the cluster…<br>[preflight] FYI: You can look at this config file with ‘kubectl -n kube-system get cm kubeadm-config -o yaml’<br>[kubelet-start] Writing kubelet configuration to file “&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml”<br>[kubelet-start] Writing kubelet environment file with flags to file “&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env”<br>[kubelet-start] Starting the kubelet<br>[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap…</p>
<p>This node has joined the cluster:<br>* Certificate signing request was sent to apiserver and a response was received.<br>* The Kubelet was informed of the new secure connection details.</p>
<p>Run ‘kubectl get nodes’ on the control-plane to see this node join the cluster.</p>
<p>成功加入集群</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl get nodes 缓慢问题排查_执行速读慢？</title>
    <url>/2021/10/07/kubectl-get-nodes-%E7%BC%93%E6%85%A2%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-%E6%89%A7%E8%A1%8C%E9%80%9F%E8%AF%BB%E6%85%A2%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-3.png"></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><hr>
<p>最近在某个 k8s 集群其中一个节点 (master1) 上执行 kubectl get nodes 大概需要 45s 的时间才有数据返回，而在另外的 master 上执行同样的命令却是很快返回。</p>
<p>通过 kube-apiserver 的日志来看，是无法连接上 metrics-server，从而导致超时。</p>
<p>进而发现这个 master 无法与其他节点的 flannel.1 的 IP 互相 ping 通。</p>
<h3 id="排查结果"><a href="#排查结果" class="headerlink" title="排查结果"></a>排查结果</h3><hr>
<p>因为我们的网络组件使用的 canal，跨主机通信时，通过 flannel (vxlan)。</p>
<p>除 master1 以外，其他节点的 arp 中 master1 上的 flannel.1 对应的 mac 地址缺失，最后是通过重启 canal 组件解决。</p>
<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><hr>
<p>环境信息<br><img src="https://img-blog.csdnimg.cn/0b758731d9fe4458b32d72c114f8e77f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>注：由于是 master1 有问题，其他节点无问题，因此以下拿 master1 与 master3 进行说明</p>
<h4 id="1-在-master1-上执行-kubectl-get-nodes-大概需要-45s，如下："><a href="#1-在-master1-上执行-kubectl-get-nodes-大概需要-45s，如下：" class="headerlink" title="1. 在 master1 上执行 kubectl get nodes 大概需要 45s，如下："></a>1. 在 master1 上执行 kubectl get nodes 大概需要 45s，如下：</h4><hr>
<p>[root@master1 ~]$ time kubectl get nodes<br>NAME     STATUS   ROLES    AGE    VERSION<br>master1   Ready    <none>   100d   v1.14.8<br>master2   Ready    <none>   100d   v1.14.8<br>master3   Ready    <none>   100d   v1.14.8<br>node1     Ready    <none>    100d  v1.14.8<br>node2     Ready    <none>   100d   v1.14.8</p>
<p>real    0m45.0s</p>
<p>同时在 master3 执行 kubectl get nodes，很快返回，如下：</p>
<p>[root@master3 ~]$ time kubectl get nodes<br>NAME    STATUS   ROLES    AGE    VERSION<br>master1   Ready    <none>   100d   v1.14.8<br>master2   Ready    <none>   100d   v1.14.8<br>master3   Ready    <none>   100d   v1.14.8<br>node1     Ready    <none>    100d  v1.14.8<br>node2     Ready    <none>   100d   v1.14.8</p>
<p>real    0m0.452s</p>
<p>开始认为是 master1 资源的问题 (也不知道怎么想的)，检查了一下，都正常。</p>
<h4 id="2-因为执行-kubectl-命令会经过-kube-apiserver，于是查看-master1-的-apiserver-的日志，"><a href="#2-因为执行-kubectl-命令会经过-kube-apiserver，于是查看-master1-的-apiserver-的日志，" class="headerlink" title="2. 因为执行 kubectl 命令会经过 kube-apiserver，于是查看 master1 的 apiserver 的日志，"></a>2. 因为执行 kubectl 命令会经过 kube-apiserver，于是查看 master1 的 apiserver 的日志，</h4><hr>
<p>如下：</p>
<p>E1124 11:40:21.145      1 available_controller.go:353] v1beta1.custom.metrics.k8s.io failed with: Get <a href="https://10.68.225.236/">https://10.68.225.236:443</a>: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p>
<p>E1124 11:40:22.237      1 available_controller.go:353] v1beta1.custom.metrics.k8s.io failed with: Get <a href="https://10.68.225.236/">https://10.68.225.236:443</a>: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p>
<p>E1124 11:40:23.358      1 available_controller.go:353] v1beta1.custom.metrics.k8s.io failed with: Get <a href="https://10.68.225.236/">https://10.68.225.236:443</a>: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p>
<p>E1124 11:40:34.469      1 available_controller.go:353] v1beta1.custom.metrics.k8s.io failed with: Get <a href="https://10.68.225.236/">https://10.68.225.236:443</a>: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p>
<p>以上，很明显是无法连接到 metrics。</p>
<p>尝试在 master1 和 master3 上进行 telnet 10.68.225.236 443，结果如下：</p>
<p>master1:</p>
<p>[root@master1 ~]$ telnet 10.68.225.236 443<br>Trying 10.68.225.236…</p>
<p>master3:</p>
<p>[root@master3 ~]$ telnet 10.68.225.236 443<br>Trying 10.68.225.236…<br>Connected to 10.68.225.236.<br>Escape character is ‘^]‘.</p>
<p>查看 metrics 的 pod 所在节点，如下：</p>
<p>[root@master3 ~]$ kubectl get pod -A -o wide grep “metric” awk ‘{print $1,$2,$7,$8}’<br>kube-system monitoring-kube-state-metrics-metrics-v1-0-645bc4cb6f-ch5dz 10.68.4.133 node1<br>kube-system monitoring-metrics-server-server-v1-0-6ff56d4d6d-fk9gd 10.68.3.210 node2<br>kube-system monitoring-metrics-server-server-v1-0-6ff56d4d6d-n7zgz 10.68.5.192 node3</p>
<p>很显然 metrics 不在 master1 上，也不再 master3 上。</p>
<p>而 master1 不能与之通信，但 master3 可以，说明 master1 跨主机通信时，有问题。</p>
<h4 id="3-canal-在-pod-跨主机通信时，参考-flannel-vxlan-数据流向，如下图所示："><a href="#3-canal-在-pod-跨主机通信时，参考-flannel-vxlan-数据流向，如下图所示：" class="headerlink" title="3. canal 在 pod 跨主机通信时，参考 flannel (vxlan) 数据流向，如下图所示："></a>3. canal 在 pod 跨主机通信时，参考 flannel (vxlan) 数据流向，如下图所示：</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/a97951a5386c46f1b0b0ddef331a516c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>整个过程需要封包解包 (这里就不说具体的啦)，需要通过主机网络。</p>
<p>尝试去看看 master1 与 master3 的 arp 与 fdb，如下：</p>
<p>master1:</p>
<p>[root@master1 ~]$ ip neigh grep flannel.1<br>10.68.1.0 dev flannel.1 lladdr 16:23:8e:ab:c6:5c PERMANENT<br>10.68.4.0 dev flannel.1 lladdr 82:67:5t:5f:43:3b PERMANENT<br>10.68.2.0 dev flannel.1 lladdr a2:23:78:a5:7d:de PERMANENT<br>10.68.3.0 dev flannel.1 lladdr 32:a3:2r:8e:fb:2r PERMANENT<br>[root@master1 ~]$ bridge  fdb  grep flannel.1<br>32:a3:2r:8e:fb:2r dev flannel.1 dst 192.168.1.143 self permanent<br>a2:23:78:a5:7d:de dev flannel.1 dst 192.168.1.141 self permanent<br>16:23:8e:ab:c6:5c dev flannel.1 dst 192.168.1.142 self permanent<br>82:67:5t:5f:43:3b dev flannel.1 dst 192.168.1.144 self permanent</p>
<p>master3:</p>
<p>[root@master3 ~]$ ip neigh grep flannel.1<br>10.68.0.0 dev flannel.1 INCOMPLETE<br>10.68.4.0 dev flannel.1 lladdr 82:67:5t:5f:43:3b PERMANENT<br>10.68.2.0 dev flannel.1 lladdr a2:23:78:a5:7d:de PERMANENT<br>10.68.3.0 dev flannel.1 lladdr 32:a3:2r:8e:fb:2r PERMANENT<br>[root@master3 ~]$ bridge  fdb  grep flannel.1<br>32:a3:2r:8e:fb:2r dev flannel.1 dst 192.168.1.143 self permanent<br>a2:23:78:a5:7d:de dev flannel.1 dst 192.168.1.141 self permanent<br>82:67:5t:5f:43:3b dev flannel.1 dst 192.168.1.144 self permanent<br>36:9u:9c:53:4a:10 dev flannel.1 dst 192.168.1.140 self permanent</p>
<p>由 master3 可知，master1 的 flannel.1 的 mac 地址缺失。</p>
<p>因此认为，master1 上的 pod 与其他节点上的 pod 通信时，数据包无法返回。</p>
<p>也就是说 master1 与其他节点的 flannel.1 的 IP 是不通的。</p>
<h4 id="4-以上只是猜想，但还是要抓包确认一下。"><a href="#4-以上只是猜想，但还是要抓包确认一下。" class="headerlink" title="4. 以上只是猜想，但还是要抓包确认一下。"></a>4. 以上只是猜想，但还是要抓包确认一下。</h4><hr>
<p>在 master1 上 ping master3 的 flannel.1 的 IP。</p>
<p>同时，在 master1、master3 上对 eth0、flannel.1 进行抓包，结果如下：</p>
<p>master1:</p>
<p>ping 10.68.1.0</p>
<p>master1 抓包显示:</p>
<p>[root@master1 ~]$ tcpdump -lnni flannel.1 grep 10.68.1.0<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on flannel.1, link-type EN10MB (Ethernet), capture size 262144 bytes<br>13:24:07.618633 IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 28296, seq 1, length 64<br>13:24:08.618726 IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 28296, seq 2, length 64<br>13:24:09.618719 IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 28296, seq 3, length 64<br>13:24:10.618710 IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 28296, seq 4, length 64<br>13:24:11.618723 IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 28296, seq 5, length 64</p>
<p>[root@master1 ~]$ tcpdump -lnni eth0 grep 10.68.1.0<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 25177, seq 1, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 25177, seq 2, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 25177, seq 3, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 25177, seq 4, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 25177, seq 5, length 64</p>
<p>master3 抓包显示：</p>
<p>[root@master3 ~]$ tcpdump  -lnni eth0 grep 10.68.0.0<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 1, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 2, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 3, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 4, length 64<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 5, length 64</p>
<p>[root@master3 ~]$ tcpdump  -lnni flannel.1 grep 10.68.0.0<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 1, length 64<br>ARP, Request who-has 10.68.0.0 tell 10.68.1.0, length 28<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 2, length 64<br>ARP, Request who-has 10.68.0.0 tell 10.68.1.0, length 28<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 3, length 64<br>ARP, Request who-has 10.68.0.0 tell 10.68.1.0, length 28<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 4, length 64<br>ARP, Request who-has 10.68.0.0 tell 10.68.1.0, length 28<br>IP 10.68.0.0 &gt; 10.68.1.0: ICMP echo request, id 30689, seq 5, length 64</p>
<p>由以上可知，在 master1，ping master3 的 flannel.1 的 IP 时，数据包已经到了 master3 的 flannel.1，但是因为 mac 信息无法获取，所以数据包无法返回。</p>
<h4 id="5-由以上可知，除-master1-以外的其他节点的-arp-中缺少了-master1-的-flannel-1-的-mac-地址，导致数据包无法返回。"><a href="#5-由以上可知，除-master1-以外的其他节点的-arp-中缺少了-master1-的-flannel-1-的-mac-地址，导致数据包无法返回。" class="headerlink" title="5. 由以上可知，除 master1 以外的其他节点的 arp 中缺少了 master1 的 flannel.1 的 mac 地址，导致数据包无法返回。"></a>5. 由以上可知，除 master1 以外的其他节点的 arp 中缺少了 master1 的 flannel.1 的 mac 地址，导致数据包无法返回。</h4><hr>
<p>而跨主机通信时，通过 flannel，而负责维护这些信息的是 flanneld。</p>
<p>所以只需要重启一下 canal 即可重新刷新相关信息。</p>
<h4 id="6-重启除-master1-以外节点的-canal"><a href="#6-重启除-master1-以外节点的-canal" class="headerlink" title="6. 重启除 master1 以外节点的 canal"></a>6. 重启除 master1 以外节点的 canal</h4><hr>
<p>kubectl delete po -n kube-system canal-xxx</p>
<h4 id="7-查看-master3-的-arp-与-fdb"><a href="#7-查看-master3-的-arp-与-fdb" class="headerlink" title="7. 查看 master3 的 arp 与 fdb"></a>7. 查看 master3 的 arp 与 fdb</h4><hr>
<p>[root@master3 ~]$ ip neigh grep flannel.1<br>10.68.0.0 dev flannel.1 lladdr 36:9u:9c:53:4a:10 PERMANENT<br>10.68.4.0 dev flannel.1 lladdr 82:67:5t:5f:43:3b PERMANENT<br>10.68.2.0 dev flannel.1 lladdr a2:23:78:a5:7d:de PERMANENT<br>10.68.3.0 dev flannel.1 lladdr 32:a3:2r:8e:fb:2r PERMANENT<br>[root@master3 ~]$ bridge  fdb  grep flannel.1<br>32:a3:2r:8e:fb:2r dev flannel.1 dst 192.168.1.143 self permanent<br>a2:23:78:a5:7d:de dev flannel.1 dst 192.168.1.141 self permanent<br>82:67:5t:5f:43:3b dev flannel.1 dst 192.168.1.144 self permanent<br>36:9u:9c:53:4a:10 dev flannel.1 dst 192.168.1.140 self permanent</p>
<h4 id="8-在-master1-上执行-kubectl-get-nodes"><a href="#8-在-master1-上执行-kubectl-get-nodes" class="headerlink" title="8. 在 master1 上执行 kubectl get nodes"></a>8. 在 master1 上执行 kubectl get nodes</h4><hr>
<p>[root@master1 ~]$ time kubectl get nodes<br>NAME    STATUS   ROLES    AGE    VERSION<br>master1   Ready    <none>   100d   v1.14.8<br>master2   Ready    <none>   100d   v1.14.8<br>master3   Ready    <none>   100d   v1.14.8<br>node1     Ready    <none>   100d   v1.14.8<br>node2     Ready    <none>   100d   v1.14.8</p>
<p>real    0m0.538s<br>user    0m0.153s<br>sys     0m0.104s</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Kubernetes</tag>
        <tag>kubectl</tag>
        <tag>kubectl get nodes</tag>
        <tag>执行速度慢</tag>
        <tag>缓慢</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Date 命令使用示例 date获取7天前的日期</title>
    <url>/2021/07/13/linux-date-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-date%E8%8E%B7%E5%8F%967%E5%A4%A9%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-40.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>date 命令用于显示和设置 Linux 系统上的日期和时间设置。本教程简要介绍了如何使用 date 命令在 Linux 系统上显示和设置日期。希望对各位有帮助！</p>
<h3 id="1-不带选项的Date命令"><a href="#1-不带选项的Date命令" class="headerlink" title="1.不带选项的Date命令"></a>1.不带选项的Date命令</h3><hr>
<p>date命令不加任何命令选项，它显示当前日期和时间，包括星期几，月份，年份，h:m :s格式的时间以及时区，如下所示。</p>
<p>[root@k8s-master01 ~]# date<br>2021年 07月 13日 星期二 08:29:02 CST</p>
<h3 id="2-以世界标准时间显示"><a href="#2-以世界标准时间显示" class="headerlink" title="2.以世界标准时间显示"></a>2.以世界标准时间显示</h3><hr>
<p>要以UTC（世界标准时间）显示时间，需要加-u选项。</p>
<p>[root@k8s-master01 ~]# date -u<br>2021年 07月 13日 星期二 00:33:30 UTC</p>
<h3 id="3-以字符串格式显示特定日期"><a href="#3-以字符串格式显示特定日期" class="headerlink" title="3.以字符串格式显示特定日期"></a>3.以字符串格式显示特定日期</h3><hr>
<p>可以使用–date选项以字符串格式显示特定日期，这不会影响系统的日期和时间，只是将日期格式转换为字符串：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”7&#x2F;13&#x2F;2021 8:35”<br>2021年 07月 13日 星期二 08:35:00 CST</p>
<h3 id="4-使用date命令检查过去的日期"><a href="#4-使用date命令检查过去的日期" class="headerlink" title="4.使用date命令检查过去的日期"></a>4.使用date命令检查过去的日期</h3><hr>
<p>date命令还可以打印相对于当前日期的过去日期和时间。例如查看7天前的日期是多少，请运行命令：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”7 days ago”<br>2021年 07月 06日 星期二 08:36:57 CST</p>
<p>查看三个月前的日期是多少：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”3 months ago”<br>2021年 04月 13日 星期二 08:37:31 CST</p>
<p>查看两年前的今天日期是多少：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”2 years ago”<br>2019年 07月 13日 星期六 08:38:09 CST</p>
<h3 id="5-使用date命令检查未来的日期"><a href="#5-使用date命令检查未来的日期" class="headerlink" title="5.使用date命令检查未来的日期"></a>5.使用date命令检查未来的日期</h3><hr>
<p>date命令也可以显示将来的日期，例如查看明天的日期是多少：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”tomorrow”<br>2021年 07月 14日 星期三 08:38:57 CST</p>
<p>要检查从现在起一周后的确切日期，请运行：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”next week”<br>2021年 07月 20日 星期二 08:40:19 CST</p>
<p>显示3周后的日期：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”3 weeks”<br>2021年 08月 03日 星期二 08:40:41 CST</p>
<p>显示4个月后的日期，请执行以下操作：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”4 months”<br>2021年 11月 13日 星期六 08:41:04 CST</p>
<p>显示两年后今天的日期：</p>
<p>[root@k8s-master01 ~]# date –date&#x3D;”2 years”<br>2023年 07月 13日 星期四 08:41:19 CST</p>
<h3 id="6-date命令的选项"><a href="#6-date命令的选项" class="headerlink" title="6.date命令的选项"></a>6.date命令的选项</h3><hr>
<p>使用date选项的语法非常简单：<code>date &quot;+%option&quot;</code></p>
<p>%D – 日期显示格式为 月&#x2F;日&#x2F;年<br>%Y – 年份(例如：2021)<br>%m – 月份(01-12)<br>%B – 月份的完整名称 (例如 January)<br>%b – 月份的短名称 (例如 Jan)<br>%d – 月份中的哪一天 (例如 01)<br>%j – 一年中的第几天(001-366)<br>%u – 一个星期中的第几天 (1-7)<br>%A – 星期几的全程(例如 Friday)<br>%a – 星期几的短名称 (例如 Fri)<br>%H – 小时，24小时制 (00-23)<br>%I – 小时，12小时制 (01-12)<br>%M – 分钟 (00-59)<br>%S – 秒 (00-60)</p>
<p>例如，要以yy&#x2F;mm&#x2F;dd格式打印日期，请运行：</p>
<p>[root@k8s-master01 ~]# date “+%Y&#x2F;%m&#x2F;%d”<br>2021&#x2F;07&#x2F;13</p>
<p>要打印星期几，月份，日，年份和当前时间，请执行以下操作：</p>
<p>[root@k8s-master01 ~]# date “+%A %B %d %Y %T”<br>星期二 七月 13 2021 08:43:58</p>
<h3 id="7-如何设置日期和时间"><a href="#7-如何设置日期和时间" class="headerlink" title="7.如何设置日期和时间"></a>7.如何设置日期和时间</h3><hr>
<p>date命令还允许设置日期和时间。例如，要将日期和时间设置为2021年6月25日上午11:15，请运行以下命令：</p>
<p>[root@k8s-master01 ~]# date –set&#x3D;”20210625 11:15”<br>Fri Jun 25 11:15:00 CST 2021</p>
<h3 id="8-在变量中使用date命令"><a href="#8-在变量中使用date命令" class="headerlink" title="8.在变量中使用date命令"></a>8.在变量中使用date命令</h3><hr>
<p>在创建Shell脚本的时候，我们将date命令保存到一个变量中，然后使用该变量创建日志文件，示例如下所示：</p>
<p>#!&#x2F;bin&#x2F;bash<br>LOGFILE&#x3D;&#x2F;tmp&#x2F;logs-$(date +%d-%m-%Y_%T)<br>echo “##Check Cluster for Failed Resources##”  &gt;&gt; $LOGFILE<br>crm_mon -1 -rf  grep FAILED  &gt;&gt; $LOGFILE<br>echo -e “\n\n” &gt;&gt; $LOGFILE<br>echo “##Check Cluster for Stopped Resources##”  &gt;&gt; $LOGFILE<br>crm_mon -1 -rf  grep -i STOPPED  &gt;&gt; $LOGFILE<br>echo -e “\n\n” &gt;&gt; $LOGFILE</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>7天前的日期</tag>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Grep 常见用法大全</title>
    <url>/2021/11/10/linux-grep-%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021111003294355.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>你是否遇到过需要在文件中查找一个特定的字符串或者样式，但是不知道从哪儿开始？那么,就请grep来帮你吧。</p>
<p>grep是每个Linux发行版都预装的一个强有力的文件模式搜索工具。无论何种原因，如果你的系统没有预装它的话，你可以很容易的通过系统的包管理器来安装它（Debian&#x2F;Ubuntu系中的apt-get和RHEl&#x2F;CentOS&#x2F;Fedora系中的yum）。</p>
<p>$ sudo apt-get install grep #Debian&#x2F;Ubuntu $ sudo yum install grep #RHEL&#x2F;CentOS&#x2F;Fedora</p>
<p>我发现使用现实世界中的真实例子让你投身其中是让你接触grep命令的最容易方式。</p>
<h3 id="1-搜索和寻找文件"><a href="#1-搜索和寻找文件" class="headerlink" title="1.搜索和寻找文件"></a>1.搜索和寻找文件</h3><hr>
<p>假设你已经在你的电脑上安装了一个全新的Ubuntu，然后你打算卸载Python。你浏览网页寻找教程，但是你发现存在两个不同版本的Python在使用，而你不知道你的Ubuntu安装器到底在你的系统中安装了哪个版本的Python，也不知道它安装了哪些模块。解决这个烦恼只需简单的运行以下命令：</p>
<p>$ sudo dpkg -l  grep -i python</p>
<p>输出例子</p>
<p>ii python2.7         2.7.3-0ubuntu3.4Interactive high-level object-oriented language(version2.7)</p>
<p>ii python2.7-minimal2.7.3-0ubuntu3.4Minimal subset of the Python language(version2.7)</p>
<p>ii python-openssl 0.12-1ubuntu2.1  Python wrapper around the OpenSSL library</p>
<p>ii python-pam 0.4.2-12.2ubuntu4APython interfacetothe PAM library</p>
<p>首先，我们运行dpkg -l列出你系统上安装的.deb包。接着，我们使用管道将输出结果传输给命令grep -i python，这一步可以简单解释为把结果传输给grep然后过滤出所有含有python的项，并返回结果。–i选项用于忽略大小写,因为 grep 是大小写敏感的。使用选项-i是个好习惯，除非你打算进行更细节的搜索。</p>
<h3 id="2-搜索和过滤文件"><a href="#2-搜索和过滤文件" class="headerlink" title="2.搜索和过滤文件"></a>2.搜索和过滤文件</h3><hr>
<p>grep还可以在一个或多个文件里用于搜索和过滤。让我们来看一个这样的情景：</p>
<p>你的Apache网页服务器出现了问题，你不得不从许多专业网站里找一个发帖询问。好心回复你的人让你粘贴上来你的&#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;default-ssl文件内容。假如你能移除掉所有的注释行，那么对你，对帮你的人，以及所有阅读该文件的人，不是更容易发现问题吗？你当然可以很容易的做到！只需这样做就可以了：</p>
<p>$ sudo grep -v “#” &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;default-ssl</p>
<p>选项-v是告诉grep命令反转它的输出结果，意思就是不输出匹配的项，做相反的事，打印出所有不匹配的项。这个例子中，有#的是注释行（译注：其实这个命令并不准确，包含“#”的行不全是注释行。关于如何精确匹配注释行，可以了解更多的关于正则表达式的内容。）。（欢迎关注公众号：网络工程师阿龙，提升网络技术。）</p>
<h3 id="3-找出所有的mp3文件"><a href="#3-找出所有的mp3文件" class="headerlink" title="3.找出所有的mp3文件"></a>3.找出所有的mp3文件</h3><hr>
<p>grep命令对于过滤来自于标准输出的结果非常有用。例如，假设你的一个文件夹里面全是各种格式的音乐文件。你要找出艺术家jayZ的所有mp3格式的音乐文件，里面也不要有任何混合音轨。使用find命令再结合管道使用grep就可以完成这个魔法：</p>
<p>$ sudo find . -name “.mp3”  grep -i JayZ  grep -vi “remix””</p>
<p>在这个例子中，我们使用find命令打印出所有以.mp3为后缀名的文件，接着将其使用管道传递给grep -i过滤和打印出名字为“JayZ”的文件,再使用管道传送给grep -vi以便过滤掉含有“remix”的项。</p>
<h3 id="4-在搜索字符串前面或者后面显示行号"><a href="#4-在搜索字符串前面或者后面显示行号" class="headerlink" title="4.在搜索字符串前面或者后面显示行号"></a>4.在搜索字符串前面或者后面显示行号</h3><hr>
<p>另外两个选项是-A和-B之间的切换，是用以显示匹配的行以及行号，分别控制在字符串前或字符串后显示的行数。Man页给出了更加详细的解释，我发现一个记忆的小窍门：-A&#x3D;after、-B&#x3D;before。</p>
<p>$ sudo ifconfig  grep -A 4 etho $ sudo ifconfig  grep -B 2 UP</p>
<h3 id="5-在匹配字符串周围打印出行号"><a href="#5-在匹配字符串周围打印出行号" class="headerlink" title="5.在匹配字符串周围打印出行号"></a>5.在匹配字符串周围打印出行号</h3><hr>
<p>grep命令的-C选项和例4中的很相似，不过打印的并不是在匹配字符串的前面或后面的行，而是打印出两个方向都匹配的行（译注：同上面的记忆窍门一样：-C&#x3D;center，以此为中心）：</p>
<p>$ sudo ifconfig  grep -C 2 lo</p>
<h3 id="6-计算匹配项的数目"><a href="#6-计算匹配项的数目" class="headerlink" title="6.计算匹配项的数目"></a>6.计算匹配项的数目</h3><hr>
<p>这个功能类似于将grep输出的结果用管道传送给计数器（wc程序），grep内建的选项可以达到同样的目的：</p>
<p>$ sudo ifconfig  grep -c inet6</p>
<h3 id="7-按给定字符串搜索文件中匹配的行号"><a href="#7-按给定字符串搜索文件中匹配的行号" class="headerlink" title="7.按给定字符串搜索文件中匹配的行号"></a>7.按给定字符串搜索文件中匹配的行号</h3><hr>
<p>当你在编译出错时需要调试时，grep命令的-n选项是个非常有用的功能。它能告诉你所搜索的内容在文件的哪一行：</p>
<p>$ sudo grep -n “main” setup.py</p>
<h3 id="8-在所有目录里递归的搜索"><a href="#8-在所有目录里递归的搜索" class="headerlink" title="8.在所有目录里递归的搜索"></a>8.在所有目录里递归的搜索</h3><hr>
<p>假若你要在当前文件夹里搜索一个字符串，而当前文件夹里又有很多子目录，你可以指定一个-r选项以便于递归的搜索：</p>
<p>$ sudo grep -r “function” *</p>
<h3 id="9-进行精确匹配搜索"><a href="#9-进行精确匹配搜索" class="headerlink" title="9.进行精确匹配搜索"></a>9.进行精确匹配搜索</h3><hr>
<p>传递-w选项给grep命令可以在字符串中进行精确匹配搜索（译注：包含要搜索的单词，而不是通配）。例如，像下面这样输入：</p>
<p>$ sudo ifconfig  grep -w “RUNNING”</p>
<p>将打印出含有引号内匹配项的行。另外，你还可以试一下这个：</p>
<p>$ sudo ifconfig  grep -w “RUN”</p>
<p>搜索这个匹配项时，若搜索的东西里面没有这样的一个单独的单词，将什么也不会返回。（欢迎关注公众号：网络工程师阿龙，提升网络技术。）</p>
<h3 id="10-在Gzip压缩文件中搜索"><a href="#10-在Gzip压缩文件中搜索" class="headerlink" title="10.在Gzip压缩文件中搜索"></a>10.在Gzip压缩文件中搜索</h3><hr>
<p>我们还要关注一下grep的衍生应用。第一个是zgrep，这个与zcat很相似，可以用于gzip压缩过的文件。它有与grep相似的命令选项，使用方式也一样：</p>
<p>$ sudo zgrep -i error &#x2F;var&#x2F;log&#x2F;syslog.2.gz</p>
<h3 id="11-在文件中匹配正则表达式"><a href="#11-在文件中匹配正则表达式" class="headerlink" title="11.在文件中匹配正则表达式"></a>11.在文件中匹配正则表达式</h3><hr>
<p>egrep是另一个衍生应用，代表着“扩展全局正则表达式”。它可以识别更多的正则表达式元字符，例如at + ? 和（）。在搜索源代码文件时，egrep是一个非常有用的工具，还有其他的一些零碎代码文件的搜索需要，使得这样的搜索能力成为必需。可以在grep命令中使用选项-E来启用它。</p>
<p>$ sudo grep -E</p>
<h3 id="12-搜索一个固定匹配字符串"><a href="#12-搜索一个固定匹配字符串" class="headerlink" title="12.搜索一个固定匹配字符串"></a>12.搜索一个固定匹配字符串</h3><hr>
<p>fgrep用于在一个文件或文件列表中搜索固定样式的字符串。功能与grep -F同。fgrep的一个通常用法为传递一个含有样式的文件给它：</p>
<p>$ sudo fgrep -f file_full_of_patterns.txt file_to_search.txt</p>
<p>这仅仅是grep命令的开始，你可能已经注意到，它对于实现各种各样的需求简直是太有用了。除了这种我们运行的这种只有一行的命令，grep还可以写成cron任务或者自动的shell脚本去执行。保持好奇心，试验一下man页的各个选项，为实现你的目的写出一些grep表达式吧。只有一行的命令，grep还可以写成cron任务或者自动的shell脚本去执行。保持好奇心，试验一下man页的各个选项，为实现你的目的写出一些grep表达式吧。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
        <tag>用法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell脚本调试模式</title>
    <url>/2021/08/13/linux-shell%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-11.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>shell 是用户和操作系统交互的一个程序，经常用于执行一些自动化或者重复繁琐的任务，现在所有的 Linux 系统基本都自带了该程序，我们只需要编写好shell脚本，直接执行就可以了，不需要额外安装软件、配置编译环境，可以说使用起来非常的方便，但是它在调试方面常常令人头大，本文主要介绍shell脚本常用的调试方法</p>
<h3 id="调试常用选项"><a href="#调试常用选项" class="headerlink" title="调试常用选项"></a>调试常用选项</h3><p>调试shell脚本时，常常用到几个调试选项，让脚本在执行的过程中，会输出一些调试信息，根据调试信息，就可以定位出具体出问题的代码</p>
<p>具体的选项以及说明如下：</p>
<p>选项</p>
<p>说明</p>
<p>-x</p>
<p>输出结果之前，先输出执行的命令</p>
<p>-u</p>
<p>遇到不存在的变量就会报错，并停止执行</p>
<p>-e</p>
<p>发生错误时，终止执行</p>
<p>-n</p>
<p>检查语法错误</p>
<p>-o pipefail</p>
<p>管道子命令发生错误，终止执行</p>
<h3 id="跟踪脚本的执行"><a href="#跟踪脚本的执行" class="headerlink" title="跟踪脚本的执行"></a>跟踪脚本的执行</h3><hr>
<ul>
<li>输出调试信息</li>
</ul>
<p>通常，脚本执行之后，只有结果输出，当运行多条命令的时候，就会连续输出多条结果，无法分清哪条命令对应哪条结果, 使用 -x选项，会先输出将要执行的那一行命令的调试信息，然后再执行命令</p>
<p>现有脚本ta.sh，功能是输出当前日期, 内容如下</p>
<p>#!&#x2F;bin&#x2F;bash<br>echo “today is :”$(date +’%Y-%m-%d’)</p>
<p>我们使用 -x 选项来执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# bash -x ta.sh<br>++ date +%Y-%m-%d</p>
<ul>
<li>echo ‘today is :2021-07-10’<br>today is :2021-07-10</li>
</ul>
<p>从结果中可以看到，在执行前打印出了每一行命令，行前面的 + 号表示调试信息，它实际是环境变量 PS4 的值, PS4 的第一个字符会根据嵌套层次进行重复，命令所处的层次越深，前面的 + 号越多</p>
<p>结果中第一行表示执行 date +’%Y-%m-%d’ 命令，它处于第内层，所以打印两个 + 号 ，第二行表示执行 echo “today is :”$(date +’%Y-%m-%d’) 命令，它处于外层，只打印一个 + 号</p>
<p>把 -x 选项放到 #!&#x2F;bin&#x2F;bash 语句后面，执行的时候不带 -x 也能实现同样的效果，上述脚本只需要把 #!&#x2F;bin&#x2F;bash 改成 #!&#x2F;bin&#x2F;bash -x 即可</p>
<ul>
<li>输出行号</li>
</ul>
<p>上面示例中脚本内容很少，试想下，如果脚本内容达到了几百行或者几千行之后，输出每一行命令的提示信息，阅读起来就很费劲了，在这种情况下，我们在每行输出前加上行号，可以直接定位到具体的行</p>
<p>修改下 ta.sh 脚本，修改后的内容如下</p>
<p>#!&#x2F;bin&#x2F;bash </p>
<p>PS4&#x3D;’+${BASH_SOURCE}:${LINENO} ‘<br>echo “start…”<br>set -x<br>echo “today is :”$(date +’%Y-%m-%d’)<br>set +x<br>echo “end…”</p>
<p>修改之后的脚本加入了 PS4 变量, 它是调试信息的前缀，默认值是 “+”, 我们可以修改它的值，达到输出的调试信息中包含行号的目的</p>
<p>上述代码中 “${BASH_SOURCE}” 表示 当前执行的shell脚本的相对路径，在这里用来表示脚本文件名，”${LINENO}” 表示行号，修改 PS4 之后，输出的调试信息就会包括 脚本名字以及行号</p>
<p>我们执行脚本，看下结果</p>
<p>[root@VM-0-2-centos shell_debug]# bash -x ta.sh </p>
<ul>
<li>PS4&#x3D;’+${BASH_SOURCE}:${LINENO} ‘</li>
</ul>
<p>+ta.sh:4 echo start…<br>start…<br>++ta.sh:5 date +%Y-%m-%d<br>+ta.sh:5 echo ‘today is :2021-07-10’<br>today is :2021-07-10<br>+ta.sh:6 echo end…<br>end…</p>
<p>从结果可以看出，每一行命令的调试信息中都包含了文件名和行号</p>
<ul>
<li>输出部分调试信息</li>
</ul>
<p>有时，我们只需要输出部分调试信息，这个时候就需要我们手动去设置 -x 选项了，把需要输出调试信息的命令放到 set -x 和set +x 之间</p>
<p>修改下 ta.sh 脚本，内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>echo “test…”</p>
<p>set -x<br>echo “today is :”$(date +’%Y-%m-%d’)<br>set +x</p>
<p>echo “finish…”</p>
<p>执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# .&#x2F;ta.sh<br>[root@VM-0-2-centos shell_debug]# .&#x2F;ta.sh<br>test…<br>++ date +%Y-%m-%d</p>
<ul>
<li>echo ‘today is :2021-07-10’<br>today is :2021-07-10</li>
<li>set +x<br>finish…</li>
</ul>
<p>从结果可以看出，只有 echo today is :”$(date +’%Y-%m-%d’) 命令输出了调试信息，set -x 相当于开启调试信息，set +x 则是关闭调试信息</p>
<p>这里需要注意下，脚本中使用了 set -x 时 , 执行的时候就不要再加 -x 了</p>
<h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><hr>
<p>通过打印日志来调试shell脚本是常用的方式，在一行命令前后打印变量值或者命令结果，通过日志来判断是否有错误</p>
<p>但是，当脚本比较长的时候，需要打印的日志就有点儿多了，而且，调试完了后，这些调试日志就不再需要了，这时就要一行行的删掉日志打印</p>
<p>下面介绍一种方法，把脚本中所有的日志打印加一个开关，当开关打开的时候，就会输出调试相关的日志，不需要的时候，直接关闭开关即可</p>
<p>现有脚本 debug1.sh, 内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#调试开关, on 表示开启,其他表示关闭<br>IS_DEBUG&#x3D;”on”<br>#调试开关函数<br>function _DEBUG()<br>{<br>   [ “$IS_DEBUG” &#x3D;&#x3D; “on” ] &amp;&amp; $@<br>}</p>
<p>va&#x3D;1<br>_DEBUG echo ‘old value:’$va<br>#变量val加1<br>let va++<br>echo ‘new value:’$va</p>
<p>上述脚本中，IS_DEBUG变量是调试开关，“on” 表示开启，其他表示关闭</p>
<p>_DEBUG() 是调试开关函数，它的功能是：如果 IS_DEBUG 为 “on” ，执行后面的命令，否则忽略</p>
<p>先打开调试开关， 执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# .&#x2F;debug1.sh<br>old value:1<br>new value:2</p>
<p>再关闭调试开关，执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# .&#x2F;debug1.sh<br>new value:2</p>
<p>从上面两组测试结果可以看出，当打开调试开关，也即设置 IS_DEBUG&#x3D;“on” 后， 语句 _DEBUG echo ‘old value:’$va 会执行 echo ‘old value:’$va 命令，当 IS_DEBUG&#x3D;“off” 时, 就会忽略 echo ‘old value:’$va 命令</p>
<p>所以，当调试的时候，打开调试开关，调试完成之后，脚本不需要做任何修改，只需要关闭开关，调试相关的命令就都不会执行了</p>
<h3 id="常见的错误处理"><a href="#常见的错误处理" class="headerlink" title="常见的错误处理"></a>常见的错误处理</h3><hr>
<ul>
<li>不存在的变量</li>
</ul>
<p>执行脚本的时候，遇到不存在的变量，默认会忽略它</p>
<p>现有脚本 td.sh, 内容如下</p>
<p>#!&#x2F;bin&#x2F;bash<br>echo “start…”<br>echo $ta<br>echo “end…”</p>
<p>脚本中 ta 是一个不存在的变量，脚本执行结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# .&#x2F;td.sh<br>start…</p>
<p>end…</p>
<p>可以看到，echo $ta 输出了一个空行，脚本直接忽略了不存在的 ta 变量， 并且继续执行后面的命令</p>
<p>这种情况通常并不是我们希望的结果，遇到不存在的变量，应该直接报错，并停止执行后面的命令，在脚本开头加上 set -u 语句或者执行脚本的时候加上 -u ，可以得到我们期望的结果</p>
<p>在脚本开头加上 set -u 语句，整个脚本内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>set -u<br>echo “start…”<br>echo $ta<br>echo “end…”</p>
<p>执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# .&#x2F;td.sh<br>start…<br>.&#x2F;td.sh: line 5: ta: unbound variable</p>
<p>可以看到，加了 set -u 语句之后，遇到不存在的变量 ta, 直接报错，并且停止执行后面的命令</p>
<p>当然，我们使用 bash -u td.sh 命令执行脚本也会得到相同的结果</p>
<ul>
<li>语法错误</li>
</ul>
<p>语法错误是shell脚本执行错误的原因之一，执行脚本的时候加上 -n, 当脚本有语法错误，不会继续执行，而是打印错误信息</p>
<p>现有脚本 te.sh, 内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>if [ $# -le 0 ];then<br>   echo “no param..”</p>
<p>输入 bash -n te.sh 命令，并回车，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# bash -n te.sh<br>te.sh: line 5: syntax error: unexpected end of file</p>
<p>上面的脚本中的 if 缺少结尾的 fi, 所以执行 bash -n te.sh 命令之后会出现语法错误的提示</p>
<p>这个选项很实用，特别是当我们写完shell脚本之后，不要急着执行，先使用 -n 选项检查下有没有语法错误，它可以帮我们提前发现错误</p>
<ul>
<li>发生错误，终止执行</li>
</ul>
<p>一般情况下，脚本执行时发生错误了，还是会继续执行后面的命令</p>
<p>现有脚本 tf.sh, 内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>echo “start…”<br>abc<br>echo “end…”</p>
<p>执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# .&#x2F;tf.sh<br>start…<br>.&#x2F;tf.sh: line 4: abc: command not found<br>end…</p>
<p>从结果可以看到，脚本中第四行的 abc 是未知的命令，执行时发生了错误，但是脚本还是继续向后执行，一直到结束</p>
<p>这种行为不利于脚本的安全和错误排查，在实际应用中，发生了错误应该停止执行脚本，防止错误越积越多，我们可以使用 -e 选项来避免这个问题</p>
<p>加上 -e 选项，再次执行上述脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# bash -e .&#x2F;tf.sh<br>start…<br>.&#x2F;tf.sh: line 4: abc: command not found</p>
<p>从上面结果可以知道，脚本执行到第四行的时候发生了错误，此时脚本停止往下执行了</p>
<ul>
<li>管道下 子命令失败，终止执行</li>
</ul>
<p>上面提到的 -e 选项有个特殊的情况，不适用于管道命令，管道命令是通过管道符 “” 组合的命令， 具体的看下面的例子吧</p>
<p>现有脚本 tg.sh, 内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>echo “start…”<br>abc  echo “111”<br>echo “end…”</p>
<p>脚本的第四行， abc echo “111” 是管道命令，我们执行 bash -e .&#x2F;tg.sh 命令后，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# bash -e .&#x2F;tg.sh<br>start…<br>.&#x2F;tg.sh: line 4: abc: command not found<br>111<br>end…</p>
<p>可以看到，即使使用 -e 选项执行脚本，发生错误的时候，还是会继续往下执行，直到结束</p>
<p>我们使用 set -o pipefail来解决这种情况，只要管道命令中一个子命令发生了错误,整个管道命令就失败了，脚本就会终止执行</p>
<p>修改下上述脚本，内容如下</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>set -o pipefail<br>echo “start…”<br>abc  echo “111”<br>echo “end…”</p>
<p>再次执行脚本，结果如下</p>
<p>[root@VM-0-2-centos shell_debug]# bash -e tg.sh<br>start…<br>tg.sh: line 5: abc: command not found<br>111</p>
<p>可以看到，在 tg.sh 脚本开头加上 set -o pipefail 语句之后，再次执行脚本， 管道命令 abc echo “111” 执行子命令 abc 时发生错误，后续的子命令不再执行了，整个管道命令失败了</p>
<p>由于执行时加了 -e 选项，当管道命令执行失败了，脚本就会终止执行，所以 echo “end…” 没有执行</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Bash</tag>
        <tag>Debug</tag>
        <tag>shell</tag>
        <tag>shell脚本</tag>
        <tag>调试模式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 中 zip打包 如何添加密码认证?</title>
    <url>/2021/11/14/linux-%E4%B8%AD-zip%E6%89%93%E5%8C%85-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/Install-Zip-in-Linux.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Linux 下 怎么保护你的zip压缩包不被被人随意解压?</p>
<h3 id="安装zip命令"><a href="#安装zip命令" class="headerlink" title="安装zip命令"></a>安装zip命令</h3><hr>
<p>如果系统中没有zip命令,需要用以下的命令安装。</p>
<p>$ sudo yum install zip    [On CentOS&#x2F;RHEL]<br>$ sudo dnf install zip    [On Fedora 22+]<br>$ sudo apt install zip    [On Debian&#x2F;Ubuntu]</p>
<h3 id="Linux中创建受密码保护的zip压缩包"><a href="#Linux中创建受密码保护的zip压缩包" class="headerlink" title="Linux中创建受密码保护的zip压缩包"></a>Linux中创建受密码保护的zip压缩包</h3><hr>
<p>可以使用 zip带有-P参数的命令来创建一个名为code404.zip的压缩包。</p>
<p>leenhem@leenhem-code404:<del>&#x2F;code&#x2F;tmp$ find<br>.<br>.&#x2F;code404<br>.&#x2F;code404&#x2F;code404.icu.txt<br>leenhem@leenhem-code404:</del>&#x2F;code&#x2F;tmp$ zip -r -P1234 code404.zip code404<br>  adding: code404&#x2F; (stored 0%)<br>  adding: code404&#x2F;code404.icu.txt (deflated 100%)<br>leenhem@leenhem-code404:~&#x2F;code&#x2F;tmp$ </p>
<p>但是上述方法是绝对不安全的，因为这里的密码是在命令行中以明文形式提供的。其次它也将存储在历史文件中(例如.bash_history)，这意味着另一个用户可以访问你的帐户(尤其是root用户)将很容易看到密码。</p>
<p>因此可以使用该-e参数，它会显示一个提示，允许你输入隐藏密码。</p>
<p>leenhem@leenhem-code404:<del>&#x2F;code&#x2F;tmp$ rm code404.zip<br>leenhem@leenhem-code404:</del>&#x2F;code&#x2F;tmp$ zip -r -e code404.zip code404<br>Enter password:<br>Verify password:<br>  adding: code404&#x2F; (stored 0%)<br>  adding: code404&#x2F;code404.icu.txt (deflated 100%)<br>leenhem@leenhem-code404:~&#x2F;code&#x2F;tmp$ </p>
<h3 id="如何在-Linux-中解压受密码保护的zip压缩包"><a href="#如何在-Linux-中解压受密码保护的zip压缩包" class="headerlink" title="如何在 Linux 中解压受密码保护的zip压缩包"></a>如何在 Linux 中解压受密码保护的zip压缩包</h3><hr>
<p>解压缩和解密名为的存档文件的内容rumenz.zip， 使用unzip程序并提供你在上面输入的密码。</p>
<p>leenhem@leenhem-code404:~&#x2F;code&#x2F;tmp$ unzip code404.zip<br>Archive:  code404.zip<br>[code404.zip] code404&#x2F;code404.icu.txt password:<br>replace code404&#x2F;code404.icu.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: A<br>  inflating: code404&#x2F;code404.icu.txt</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>zip</tag>
        <tag>密码</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中如何修改打开文件的数量限制?</title>
    <url>/2021/11/15/linux-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021111501411677-1024x509.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在 Linux中你可以更改打开文件的最大数量。你可以使用ulimit命令。它使你能够控制可用于 shell 或由它启动的进程的资源。</p>
<h3 id="查找-Linux-打开文件限制"><a href="#查找-Linux-打开文件限制" class="headerlink" title="查找 Linux 打开文件限制"></a>查找 Linux 打开文件限制</h3><hr>
<p># cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
<p>365004</p>
<p>该值表示每次登录会话可以打开的文件数。不同系统结果可能会有所不同。</p>
<p>例如在一个 CentOS 我的服务器，限制设置为 365004</p>
<h3 id="在-Linux-中检查硬限制"><a href="#在-Linux-中检查硬限制" class="headerlink" title="在 Linux 中检查硬限制"></a>在 Linux 中检查硬限制</h3><hr>
<p># ulimit -Hn</p>
<p>65535</p>
<h3 id="检查-Linux-中的软限制"><a href="#检查-Linux-中的软限制" class="headerlink" title="检查 Linux 中的软限制"></a>检查 Linux 中的软限制</h3><hr>
<p># ulimit -Sn</p>
<p>65535</p>
<p>要查看不同用户的硬值和软值，你可以su切换用户查看比较。</p>
<p>例如：</p>
<p># su code404<br>$ ulimit -Sn<br>1024<br>$ ulimit -Hn<br>1024</p>
<h3 id="如何在-Linux-中检查系统范围的文件描述符限制"><a href="#如何在-Linux-中检查系统范围的文件描述符限制" class="headerlink" title="如何在 Linux 中检查系统范围的文件描述符限制"></a>如何在 Linux 中检查系统范围的文件描述符限制</h3><hr>
<p>如果你正在运行服务器，你的某些应用程序可能需要更高的打开文件描述符限制。一个很好的例子是MySQL&#x2F;MariaDB 服务或 Apache 网络服务器。</p>
<p>你可以通过编辑内核指令来增加 Linux 中打开文件的限制 fs.file-max。sysctl用于在运行时配置内核参数。</p>
<p>例如，将打开文件限制增加到 500000，你可以以 root 身份使用以下命令：</p>
<p># sysctl -w fs.file-max&#x3D;500000</p>
<p>你可以使用以下命令检查打开文件的当前值：</p>
<p>$ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
<p>使用上述命令，你所做的更改将仅在下次重新启动之前保持活动状态。如果你希望永久应用它们，则必须编辑以下文件：</p>
<p># vi &#x2F;etc&#x2F;sysctl.conf</p>
<p>添加以下行：</p>
<p>fs.file-max&#x3D;500000</p>
<p>也可以根据需要更改数量。</p>
<p># cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
<p>用户需要注销并重新登录才能使更改生效。如果要立即应用限制，可以使用以下命令：</p>
<p># sysctl -p</p>
<h3 id="在-Linux-中设置用户级别打开文件限制"><a href="#在-Linux-中设置用户级别打开文件限制" class="headerlink" title="在 Linux 中设置用户级别打开文件限制"></a>在 Linux 中设置用户级别打开文件限制</h3><hr>
<p>上面的示例展示了如何设置全局限制，但你可能希望对每个用户应用限制。root 用户需要编辑以下文件：</p>
<p># vi &#x2F;etc&#x2F;security&#x2F;limits.conf</p>
<p>格式：</p>
<p><domain>        <type>  <item>  <value></p>
<p>这是为用户设置软限制和硬限制的示例 code404用户：</p>
<p>## Example hard limit for max opened files<br>code404        hard nofile 4096</p>
<h2 id="Example-soft-limit-for-max-opened-files"><a href="#Example-soft-limit-for-max-opened-files" class="headerlink" title="Example soft limit for max opened files"></a>Example soft limit for max opened files</h2><p>code404        soft nofile 1024</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ulimit</tag>
        <tag>文件数</tag>
        <tag>文件描述符</tag>
        <tag>限制</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令 su 和 sudo 的区别 ?</title>
    <url>/2021/11/08/linux-%E5%91%BD%E4%BB%A4-su-%E5%92%8C-sudo-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-8.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>之前一直对 su 和 sudo 这两个命令犯迷糊，最近专门搜了这方面的资料，总算是把两者的关系以及用法搞清楚了，这篇文章来系统总结一下。</p>
<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><hr>
<p>因为本篇博客中涉及到用户切换，所以我需要提前准备好几个测试用户，方便后续切换。</p>
<p>Linux 中新建用户的命令是 useradd ，一般系统中这个命令对应的路径都在 PATH 环境变量里，如果直接输入 useradd 不管用的话，就用绝对路径名的方式：&#x2F;usr&#x2F;sbin&#x2F;useradd 。</p>
<p>useradd 新建用户命令只有 root 用户才能执行，我们先从普通用户 ubuntu 切换到 root 用户（如何切换后文会介绍）：</p>
<p>ubuntu@VM-0-14-ubuntu:<del>$ su -<br>Password:                                         # 输入 root 用户登录密码<br>root@VM-0-14-ubuntu:</del># useradd -m test_user       # 带上 -m 参数<br>root@VM-0-14-ubuntu:~# ls &#x2F;home<br>test_user  ubuntu                                 # 可以看到 &#x2F;home 目录下面有两个用户了</p>
<p>因为还没有给新建的用户 test_user 设置登录密码，这就导致我们无法从普通用户 ubuntu 切换到 test_user，所以接下来，我们需要用 root 来设置 test_user 的登录密码。需要用到 passwd 命令：</p>
<p>root@VM-0-14-ubuntu:<del># passwd test_user<br>Enter new UNIX password:                          # 输出 test_user 的密码<br>Retype new UNIX password:<br>passwd: password updated successfully<br>root@VM-0-14-ubuntu:</del>#</p>
<p>接着我们输入 exit 退出 root 用户到 普通用户 ubuntu：</p>
<p>root@VM-0-14-ubuntu:<del># exit<br>logout<br>ubuntu@VM-0-14-ubuntu:</del>$</p>
<p>可以看到，命令提示符前面已经由 root 变成 ubuntu，说明我们现在的身份是 ubuntu 用户。</p>
<h3 id="2-su-命令介绍及主要用法"><a href="#2-su-命令介绍及主要用法" class="headerlink" title="2. su 命令介绍及主要用法"></a>2. su 命令介绍及主要用法</h3><hr>
<p>首先需要解释下 su 代表什么意思。</p>
<p>之前一直以为 su 是 super user，查阅资料之后才知道原来表示 switch user。</p>
<p>知道 su 是由什么缩写来的之后，那么它提供的功能就显而易见了，就是切换用户。</p>
<h4 id="2-1-参数"><a href="#2-1-参数" class="headerlink" title="2.1 - 参数"></a>2.1 - 参数</h4><hr>
<p>su 的一般使用方法是：</p>
<p>su  &lt;user_name&gt;</p>
<p>或者</p>
<p>su - &lt;user_name&gt;</p>
<p>两种方法只差了一个字符 -，会有比较大的差异：</p>
<ul>
<li>如果加入了 - 参数，那么是一种 login-shell 的方式，意思是说切换到另一个用户 &lt;user_name&gt; 之后，当前的 shell 会加载 &lt;user_name&gt; 对应的环境变量和各种设置；</li>
<li>如果没有加入 - 参数，那么是一种 non-login-shell 的方式，意思是说我现在切换到了 &lt;user_name&gt;，但是当前的 shell 还是加载切换之前的那个用户的环境变量以及各种设置。<br>光解释会比较抽象，我们看一个例子就比较容易理解了。<br>我们首先从 ubuntu 用户以 non-login-shell 的方式切换到 root 用户，比较两种用户状态下环境变量中 PWD 的值（su 命令不跟任何 &lt;user_name&gt; ，默认切换到 root 用户）：</li>
</ul>
<p>ubuntu@VM-0-14-ubuntu:~$ env  grep ubuntu<br>USER&#x3D;ubuntu<br>PWD&#x3D;&#x2F;home&#x2F;ubuntu                                         # 是 &#x2F;home&#x2F;ubuntu<br>HOME&#x3D;&#x2F;home&#x2F;ubuntu</p>
<h1 id="省略……"><a href="#省略……" class="headerlink" title="省略……"></a>省略……</h1><p>ubuntu@VM-0-14-ubuntu:~$ su                              # non-login-shell 方式<br>Password:                                                # 输入 root 用户登录密码<br>root@VM-0-14-ubuntu:&#x2F;home&#x2F;ubuntu# env  grep ubuntu<br>PWD&#x3D;&#x2F;home&#x2F;ubuntu                                         # 可以发现还是 &#x2F;home&#x2F;ubuntu<br>root@VM-0-14-ubuntu:&#x2F;home&#x2F;ubuntu#</p>
<p>我们的确是切换到 root 用户了，但是 shell 环境中的变量并没有改变，还是用之前 ubuntu 用户的环境变量。</p>
<p>接着我们从 ubuntu 用户以 login-shell 的方式切换到 root 用户，同样比较两种用户转台下环境变量中 PWD 的值：</p>
<p>ubuntu@VM-0-14-ubuntu:~$ env  grep ubuntu<br>USER&#x3D;ubuntu<br>PWD&#x3D;&#x2F;home&#x2F;ubuntu                               # 是 &#x2F;home&#x2F;ubuntu<br>HOME&#x3D;&#x2F;home&#x2F;ubuntu</p>
<h1 id="省略……-1"><a href="#省略……-1" class="headerlink" title="省略……."></a>省略…….</h1><p>ubuntu@VM-0-14-ubuntu:<del>$ su -                  # 是 login-shell 方式<br>Password:<br>root@VM-0-14-ubuntu:</del># env  grep root<br>USER&#x3D;root<br>PWD&#x3D;&#x2F;root                                      # 已经变成 &#x2F;root 了<br>HOME&#x3D;&#x2F;root<br>MAIL&#x3D;&#x2F;var&#x2F;mail&#x2F;root<br>LOGNAME&#x3D;root<br>root@VM-0-14-ubuntu:~#</p>
<p>可以看到用 login-shell 的方式切换用户的话，shell 中的环境变量也跟着改变了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<p>具体使用哪种方式切换用户看个人需求：</p>
<ul>
<li>如果不想因为切换到另一个用户导致自己在当前用户下的设置不可用，那么用 non-login-shell 的方式；</li>
<li>如果切换用户后，需要用到该用户的各种环境变量（不同用户的环境变量设置一般是不同的），那么使用 login-shell 的方式。</li>
</ul>
<h4 id="2-2-切换到指定用户"><a href="#2-2-切换到指定用户" class="headerlink" title="2.2 切换到指定用户"></a>2.2 切换到指定用户</h4><hr>
<p>前面已经介绍了，如果 su 命令后面不跟任何，那么默认是切换到 root 用户：</p>
<p>ubuntu@VM-0-14-ubuntu:~$ su -<br>Password:                                       # root 用户的密码<br>root@VM-0-14-ubuntu:&#x2F;home&#x2F;ubuntu#</p>
<p>因为我们在 1. 准备工作 部分已经新建了一个 test_user 用户，并且我们也知道 test_user 用户的登录密码（root 用户设置的），我们就能从 ubuntu 用户切换到 test_user 用户：</p>
<p>ubuntu@VM-0-14-ubuntu:~$ su - test_user<br>Password:                                       # test_user 用户的密码<br>$</p>
<h4 id="2-3-c-参数"><a href="#2-3-c-参数" class="headerlink" title="2.3 -c 参数"></a>2.3 -c 参数</h4><hr>
<p>前面的方法中，我们都是先切换到另一个用户（root 或者 test_user），在哪个用户的状态下执行命令，最后输入 exit 返回当前 ubuntu 用户。</p>
<p>还有一种方式是：不需要先切换用户再执行命令，可以直接在当前用户下，以另一个用户的方式执行命令，执行结束后就返回当前用户。这就得用到 -c 参数。</p>
<p>另外，Linux 系列面试题和答案全部整理好了，微信搜索Java技术栈，在后台发送：面试，可以在线阅读。</p>
<p>具体使用方法是：</p>
<p>su - -c “指令串”                                  # 以 root 的方式执行 “指令串”</p>
<p>我么看个例子：</p>
<p>ubuntu@VM-0-14-ubuntu:~$ cat &#x2F;etc&#x2F;shadow<br>cat: &#x2F;etc&#x2F;shadow: Permission denied                # ubuntu 用户不能直接查看 &#x2F;etc&#x2F;shadow 文件内容</p>
<p>ubuntu@VM-0-14-ubuntu:<del>$ su - -c “tail -n 4 &#x2F;etc&#x2F;shadow”<br>Password:                                          # 输入 root 用户密码<br>ubuntu:$1$fZKcWEDI$uwZ64uFvVbwpHTbCSgim0&#x2F;:18352:0:99999:7:::<br>ntp:*:17752:0:99999:7:::<br>mysql:!:18376:0:99999:7:::<br>test_user:$6$.ZY1lj4m$ii0x9CG8h.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS&#x2F;&#x2F;89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS&#x2F;:18406:0:99999:7:::<br>ubuntu@VM-0-14-ubuntu:</del>$                            # 执行完马上返回 ubuntu 用户而不是 root 用户</p>
<p>这种执行方式和后面要介绍的 sudo 很像，都是临时申请一下 root 用户的权限。但还是有差异，我们接着往后看。</p>
<h3 id="3-sudo-命令介绍及主要用法"><a href="#3-sudo-命令介绍及主要用法" class="headerlink" title="3. sudo 命令介绍及主要用法"></a>3. sudo 命令介绍及主要用法</h3><hr>
<p>首先还是解释下 sudo 命令是什么意思。</p>
<p>sudo 的英文全称是 super user do，即以超级用户（root 用户）的方式执行命令。这里的 sudo 和之前 su 表示的 switch user 是不同的，这点需要注意，很容易搞混。</p>
<p>我们先介绍 sudo 命令能做什么事情，然后说明为何能做到这些，以及如何做到这些。</p>
<p>我们开始。</p>
<h4 id="3-1-主要用法"><a href="#3-1-主要用法" class="headerlink" title="3.1 主要用法"></a>3.1 主要用法</h4><hr>
<p>我们在 Linux 中经常会碰到 Permission denied 这种情况，比如以 ubuntu 用户的身份查看 &#x2F;etc&#x2F;shadow 的内容。因为这个文件的内容是只有 root 用户能查看的。</p>
<p>那如果我们想要查看怎么办呢？这时候就可以使用 sudo :</p>
<p>ubuntu@VM-0-14-ubuntu:<del>$ tail -n 3 &#x2F;etc&#x2F;shadow<br>tail: cannot open ‘&#x2F;etc&#x2F;shadow’ for reading: Permission denied      # 没有权限<br>ubuntu@VM-0-14-ubuntu:</del>$ sudo !!                                    # 跟两个惊叹号<br>sudo tail -n 3 &#x2F;etc&#x2F;shadow<br>ntp:*:17752:0:99999:7:::<br>mysql:!:18376:0:99999:7:::<br>test_user:$6$.ZY1lj4m$ii0x9CG8h.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS&#x2F;&#x2F;89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS&#x2F;:18406:0:99999:7:::<br>ubuntu@VM-0-14-ubuntu:~$</p>
<p>实例中，我们使用了 sudo !! 这个小技巧，表示重复上面输入的命令，只不过在命令最前面加上 sudo 。</p>
<p>因为我已经设置了 sudo 命令不需要输入密码，所以这里 sudo !! 就能直接输出内容。如果没有设置的话，需要输入当前这个用户的密码，例如本例中，我就应该输入 ubuntu 用户的登录密码。</p>
<p>两次相邻的 sudo 操作，如果间隔在 5min 之内，第二次输入 sudo 不需要重新输入密码；如果超过 5min，那么再输入 sudo 时，又需要输入密码。所以一个比较省事的方法是设置 sudo 操作不需要密码。后面介绍如何设置。</p>
<p>sudo 除了以 root 用户的权限执行命令外，还有其它几个用法，这里做简单介绍。</p>
<p>切换到 root 用户：</p>
<p>sudo su -</p>
<p>这种方式也能以 login-shell 的方式切换到 root 用户，但是它和 su - 方法是有区别的：</p>
<p>前者输入 sudo su - 后，需要提供当前用户的登录密码，也就是 ubuntu 用户的密码；<br>后者输入 su - 后，需要提供 root 用户的登录密码。<br>还有一个命令：</p>
<p>sudo -i</p>
<p>这个命令和 sudo su - 效果一致，也是切换到 root 用户，也是需要提供当前用户（ubuntu 用户）的登录密码。</p>
<p>我们现在切换到 test_user 用户，尝试显示 &#x2F;etc&#x2F;shadow 文件的内容：</p>
<p>ubuntu@VM-0-14-ubuntu:~$ su - test_user<br>Password:                                       # test_user 的密码<br>$ sudo cat &#x2F;etc&#x2F;shadow<br>[sudo] password for test_user:                  # test_user 的密码<br>test_user is not in the sudoers file.  This incident will be reported.<br>$</p>
<p>我们会看到倒数第二行中的错误提示信息，我们无法查看 &#x2F;etc&#x2F;shadow 的内容，这是为什么？为什么 ubuntu 可以使用 sudo 但是 test_user 不行呢？</p>
<p>这就涉及到 sudo 的工作原理了。</p>
<h4 id="3-2-sudo-工作原理"><a href="#3-2-sudo-工作原理" class="headerlink" title="3.2 sudo 工作原理"></a>3.2 sudo 工作原理</h4><hr>
<p>一个用户能否使用 sudo 命令，取决于 &#x2F;etc&#x2F;sudoers 文件的设置。</p>
<p>从 3.1 节中我们已经看到，ubuntu 用户可以正常使用 sudo ，但是 test_user 用户却无法使用，这是因为 &#x2F;etc&#x2F;sudoers 文件里没有配置 test_user。</p>
<p>&#x2F;etc&#x2F;sudoers 也是一个文本文件，但是因其有特定的语法，我们不要直接用 vim 或者 vi 来编辑它，需要用 visudo 这个命令。输入这个命令之后就能直接编辑 &#x2F;etc&#x2F;sudoers 这个文件了。</p>
<p>需要说明的是，只有 root 用户有权限使用 visudo 命令。</p>
<p>我们先来看下输入 visudo 命令后显示的内容。</p>
<p>输入（root 用户）：</p>
<p>root@VM-0-14-ubuntu:~# visudo</p>
<p>输出：</p>
<p># User privilege specification<br>root    ALL&#x3D;(ALL:ALL) ALL</p>
<h1 id="Members-of-the-admin-group-may-gain-root-privileges"><a href="#Members-of-the-admin-group-may-gain-root-privileges" class="headerlink" title="Members of the admin group may gain root privileges"></a>Members of the admin group may gain root privileges</h1><p>%admin ALL&#x3D;(ALL) ALL</p>
<h1 id="Allow-members-of-group-sudo-to-execute-any-command"><a href="#Allow-members-of-group-sudo-to-execute-any-command" class="headerlink" title="Allow members of group sudo to execute any command"></a>Allow members of group sudo to execute any command</h1><p>%sudo   ALL&#x3D;(ALL:ALL) ALL</p>
<h1 id="See-sudoers-5-for-more-information-on-“-include”-directives"><a href="#See-sudoers-5-for-more-information-on-“-include”-directives" class="headerlink" title="See sudoers(5) for more information on “#include” directives:"></a>See sudoers(5) for more information on “#include” directives:</h1><p>#includedir &#x2F;etc&#x2F;sudoers.d<br>ubuntu  ALL&#x3D;(ALL:ALL) NOPASSWD: ALL</p>
<p>解释下每一行的格式：</p>
<ul>
<li>第一个表示用户名，如 root 、ubuntu 等；</li>
<li>接下来等号左边的 ALL 表示允许从任何主机登录当前的用户账户；</li>
<li>等号右边的 ALL 表示：这一行行首对一个的用户可以切换到系统中任何一个其它用户；</li>
<li>行尾的 ALL 表示：当前行首的用户，能以 root 用户的身份下达什么命令，ALL 表示可以下达任何命令。</li>
</ul>
<p>我们还注意到 ubuntu 对应的那一行有个 NOPASSWD 关键字，这就是表明 ubuntu 这个用户在请求 sudo 时不需要输入密码，到这里就解释了前面的问题。</p>
<p>同时我们注意到，这个文件里并没有 test_user 对应的行，这也就解释了为什么 test_user 无法使用 sudo 命令。</p>
<p>接下来，我们尝试将 test_user 添加到 &#x2F;etc&#x2F;sudoers 文件中，使 test_user 也能使用 sudo 命令。我们在最后一行添加：</p>
<p>test_user  ALL&#x3D;(ALL:ALL)  ALL       # test_user 使用 sudo 需要提供 test_user 的密码</p>
<p>接下来我们再在 test_user 账户下执行 sudo ：</p>
<p>ubuntu@VM-0-14-ubuntu:~$ su - test_user<br>Password:<br>$ tail -n 3 &#x2F;etc&#x2F;shadow<br>tail: cannot open ‘&#x2F;etc&#x2F;shadow’ for reading: Permission denied<br>$ sudo tail -n 3 &#x2F;etc&#x2F;shadow                   # 加上 sudo<br>ntp:*:17752:0:99999:7:::<br>mysql:!:18376:0:99999:7:::<br>test_user:$6$.ZY1lj4m$ii0x9CG8h.JHlh6zKbfBXRuolJmIDBHAd5eqhvW7lbUQXTRS&#x2F;&#x2F;89jcuTzRilKqRkP8YbYW4VPxmTVHWRLYNGS&#x2F;:18406:0:99999:7:::<br>$</p>
<p>可以看到，现在已经可以使用 sudo 了。</p>
<h4 id="3-3-思考"><a href="#3-3-思考" class="headerlink" title="3.3 思考"></a>3.3 思考</h4><hr>
<p>我们已经看到了，如果一个用户在 &#x2F;etc&#x2F;sudoers 文件中，那么它就具有 sudo 权限，就能通过 sudo su - 或者 sudo -i 等命令切换到 root 用户了，那这时这个用户就变成 root 用户了，那这不对系统造成很大的威胁吗？</p>
<p>实际上的确是这样的。所以如果在编辑 &#x2F;etc&#x2F;sudoers 文件赋予某种用户 sudo 权限时，必须要确定该用户是可信任的，不会对系统造成恶意破坏，否则将所有 root 权限都赋予该用户将会有非常大的危险。</p>
<p>当然，root 用户也可以编辑 &#x2F;etc&#x2F;sudoers 使用户只具备一部分权限，即只能执行一小部分命令。有兴趣的读者可以参考 Reference 部分第二条，这篇文章不再赘述。</p>
<h3 id="4-二者的差异对比"><a href="#4-二者的差异对比" class="headerlink" title="4. 二者的差异对比"></a>4. 二者的差异对比</h3><hr>
<p>我们已经看到：</p>
<ul>
<li>使用 su - ，提供 root 账户的密码，可以切换到 root 用户；</li>
<li>使用 sudo su - ，提供当前用户的密码，也可以切换到 root 用户</li>
</ul>
<p>两种方式的差异也显而易见：如果我们的 Linux 系统有很多用户需要使用的话，前者要求所有用户都知道 root 用户的密码，这显然是非常危险的；后者是不需要暴露 root 账户密码的，用户只需要输入自己的账户密码就可以，而且哪些用户可以切换到 root，这完全是受 root 控制的（root 通过设置 &#x2F;etc&#x2F;sudoers 实现的），这样系统就安全很多了。</p>
<p>一般都是推荐使用 sudo 方式。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>区别</tag>
        <tag>权限</tag>
        <tag>su</tag>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 性能分析工具汇总之dstat--系统监控工具</title>
    <url>/2021/04/21/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E4%B9%8Bdstat-%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-2.png"></p>
<h4 id="官方对dstat的定义"><a href="#官方对dstat的定义" class="headerlink" title="官方对dstat的定义"></a>官方对dstat的定义</h4><p>多功能系统资源统计生成工具（ versatile tool for generating system resource statistics）。在获取的信息上有点类似于top、free、iostat、vmstat等多个工具的合集，官方解释为vmstat、iostat、ifstat等工具的多功能替代品，且添加了许多额外的功能（Dstat is a versatile replacement for vmstat, iostat and ifstat. Dstat overcomes some of the limitations and adds some extra features.）；其结果可以保持到csv文件，使用脚本或第三方工具对性能进行分析利用（如通过监控平台监控，也可以保持到数据库）。在Centos 6.x系统上安装基本服务器即默认安装，而在其他操作系统可能需要手动安装。</p>
<p>dstat显示了cpu使用情况，磁盘io情况，网络发包情况和换页情况，输出是彩色的，可读性较强，相对于vmstat和iostat的输入更加详细且较为直观。在使用时，直接输入命令即可，当然也可以使用特定参数。</p>
<h4 id="安装dstat"><a href="#安装dstat" class="headerlink" title="安装dstat"></a>安装dstat</h4><p>[root@k8s-master01 ~]# yum install ‘dstat’<br>上次元数据过期检查：1:35:12 前，执行于 2021年04月19日 星期一 16时00分54秒。<br>依赖关系解决。<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> 软件包                                            架构                                    版本                                               仓库                                        大小<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>安装:<br> pcp-system-tools                                  x86_64                                  5.1.1-3.el8                                        appstream                                  191 k<br>安装依赖关系:<br> libuv                                             x86_64                                  1:1.38.0-2.el8                                     appstream                                  151 k<br> pcp                                               x86_64                                  5.1.1-3.el8                                        appstream                                  1.2 M<br> pcp-conf                                          x86_64                                  5.1.1-3.el8                                        appstream                                   50 k<br> pcp-libs                                          x86_64                                  5.1.1-3.el8                                        appstream                                  536 k<br> pcp-selinux                                       x86_64                                  5.1.1-3.el8                                        appstream                                   47 k<br> python3-pcp                                       x86_64                                  5.1.1-3.el8                                        appstream                                  167 k<br>​<br>事务概要<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>安装  7 软件包<br>​<br>总计：2.3 M<br>安装大小：6.8 M<br>确定吗？[y&#x2F;N]： y<br>下载软件包：<br>运行事务检查<br>事务检查成功。<br>运行事务测试<br>事务测试成功。<br>运行事务<br>  准备中  :                                                                                                                                                                                1&#x2F;1<br>  安装    : libuv-1:1.38.0-2.el8.x86_64                                                                                                                                                    1&#x2F;7<br>  安装    : pcp-selinux-5.1.1-3.el8.x86_64                                                                                                                                                 2&#x2F;7<br>  运行脚本: pcp-selinux-5.1.1-3.el8.x86_64                                                                                                                                                 2&#x2F;7<br>  安装    : pcp-conf-5.1.1-3.el8.x86_64                                                                                                                                                    3&#x2F;7<br>  安装    : pcp-libs-5.1.1-3.el8.x86_64                                                                                                                                                    4&#x2F;7<br>  运行脚本: pcp-5.1.1-3.el8.x86_64                                                                                                                                                         5&#x2F;7<br>  安装    : pcp-5.1.1-3.el8.x86_64                                                                                                                                                         5&#x2F;7<br>  运行脚本: pcp-5.1.1-3.el8.x86_64                                                                                                                                                         5&#x2F;7<br>  安装    : python3-pcp-5.1.1-3.el8.x86_64                                                                                                                                                 6&#x2F;7<br>  安装    : pcp-system-tools-5.1.1-3.el8.x86_64                                                                                                                                            7&#x2F;7<br>  运行脚本: pcp-system-tools-5.1.1-3.el8.x86_64                                                                                                                                            7&#x2F;7<br>  验证    : libuv-1:1.38.0-2.el8.x86_64                                                                                                                                                    1&#x2F;7<br>  验证    : pcp-5.1.1-3.el8.x86_64                                                                                                                                                         2&#x2F;7<br>  验证    : pcp-conf-5.1.1-3.el8.x86_64                                                                                                                                                    3&#x2F;7<br>  验证    : pcp-libs-5.1.1-3.el8.x86_64                                                                                                                                                    4&#x2F;7<br>  验证    : pcp-selinux-5.1.1-3.el8.x86_64                                                                                                                                                 5&#x2F;7<br>  验证    : pcp-system-tools-5.1.1-3.el8.x86_64                                                                                                                                            6&#x2F;7<br>  验证    : python3-pcp-5.1.1-3.el8.x86_64                                                                                                                                                 7&#x2F;7<br>Installed products updated.<br>​<br>已安装:<br>  libuv-1:1.38.0-2.el8.x86_64      pcp-5.1.1-3.el8.x86_64   pcp-conf-5.1.1-3.el8.x86_64   pcp-libs-5.1.1-3.el8.x86_64   pcp-selinux-5.1.1-3.el8.x86_64   pcp-system-tools-5.1.1-3.el8.x86_64<br>  python3-pcp-5.1.1-3.el8.x86_64<br>​<br>完毕！<br>[root@k8s-master01 ~]#<br>​</p>
<h4 id="dstat命令有默认选项"><a href="#dstat命令有默认选项" class="headerlink" title="dstat命令有默认选项"></a>dstat命令有默认选项</h4><p>与许多命令一样，dstat命令有默认选项，执行dstat命令不加任何参数，它默认会收集-cpu-、-disk-、-net-、－paging-、-system-的数据，一秒钟收集一次。 默认输入 dstat 等于输入了dstat -cdngy 1或dstat -a 1。</p>
<p>[root@k8s-master01 ~]# dstat -a 1<br>—-total-usage—- -dsk&#x2F;total- -net&#x2F;total- —paging– —system–<br>usr sys idl wai stl read  writ recv  send  in   out  int   csw<br>  2   0  97   0   0   0    76k 969   985    0     0 7669    12k^C<br>[root@k8s-master01 ~]# dstat<br>You did not select any stats, using -cdngy by default.<br>—-total-usage—- -dsk&#x2F;total- -net&#x2F;total- —paging– —system–<br>usr sys idl wai stl read  writ recv  send  in   out  int   csw<br>  1   0  97   2   0   0    96k 831   670    0     0 5870  8466<br>  2   0  97   0   0   0    32k 320   382    0     0 6697    11k<br>  2   0  96   2   0   0    80k 375   318    0     0 6042  8870 ^C<br>[root@k8s-master01 ~]# dstat -cdngy 1<br>—-total-usage—- -dsk&#x2F;total- -net&#x2F;total- —paging– —system–<br>usr sys idl wai stl read  writ recv  send  in   out  int   csw<br>  1   0  98   0   0   0    32k  64   318    0     0 6433  9522<br>  1   0  98   1   0   0   112k 898   318    0     0 7556    11k<br>  1   1  98   0   0   0     0 4433  3882    0     0 5701  7908<br>​</p>
<p>使用 dstat -h查看全部选项，这里不逐一列举，下面简单介绍下常用选项</p>
<h4 id="常用选项如下"><a href="#常用选项如下" class="headerlink" title="常用选项如下"></a>常用选项如下</h4><p>常用选项：</p>
<h1 id="直接跟数字，表示-秒收集一次数据，默认为一秒；dstat-5表示5秒更新一次"><a href="#直接跟数字，表示-秒收集一次数据，默认为一秒；dstat-5表示5秒更新一次" class="headerlink" title="直接跟数字，表示#秒收集一次数据，默认为一秒；dstat 5表示5秒更新一次"></a>直接跟数字，表示#秒收集一次数据，默认为一秒；dstat 5表示5秒更新一次</h1><p>  -c, –cpu<br>    统计CPU状态，包括 user, system, idle (空闲等待时间百分比), wait (等待磁盘IO),<br>    hardware interrupt (硬件中断), software interrupt (软件中断) 等；<br>  -d, –disk<br>    统计磁盘读写状态，主要包括了读写信息；<br>  -l, –load<br>    统计系统负载情况，包括1分钟、5分钟、15分钟平均值；<br>  -m, –mem<br>    统计系统物理内存使用情况，包括used, buffers, cache, free；<br>  -s, –swap<br>    统计swap已使用和剩余量；<br>  -n, –net<br>    统计网络使用情况，包括接收和发送数据；<br>  -p, –proc<br>    统计进程信息，包括runnable、uninterruptible、new；<br>  -N eth1,total<br>    统计eth1接口汇总流量；<br>  -r, –io<br>    统计I&#x2F;O请求，包括读写请求；<br>  -y, –sys<br>    统计系统信息，包括中断、上下文切换；<br>  -t<br>    显示统计时时间，对分析历史数据非常有用；<br>  –fs<br>    统计文件打开数和inodes数；</p>
<p><strong>以上这些就是最常用的选项，而一般都组合使用，个人比较常用的是：</strong></p>
<h4 id="组合使用参数"><a href="#组合使用参数" class="headerlink" title="组合使用参数"></a>组合使用参数</h4><p>[root@k8s-master01 ~]# dstat -cdlmnpsy<br>—-total-usage—- -dsk&#x2F;total- —load-avg— ——memory-usage—– -net&#x2F;total- —procs— —-swap— —system–<br>usr sys idl wai stl read  writ 1m   5m  15m  used  free  buf   cach recv  sendrun blk new used  free int   csw<br>  1   0  97   1   0   0    92k0.16 0.27 0.306572M  429M 2012k   10G 972   618   0   0 1.0   0     0 6023  8748<br>  2   0  98   0   0   0     0 0.15 0.26 0.296572M  429M 2012k   10G 192  1476   0   0 1.0   0     0 5721  8559<br>  2   1  97   1   0   0    48k0.22 0.28 0.306572M  429M 2012k   10G1760   903   0   0 1.0   0     0 7186    11k<br>  2   0  98   0   0   0     0 0.20 0.27 0.306571M  429M 2012k   10G 704   542   0   0 1.0   0     0 5788  8707<br>  1   0  94   5   0   0   236k0.20 0.27 0.306571M  429M 2012k   10G 381   462 1.0 2.0  25   0     0 7679    13k<br>  1   1  94   4   0   0    72k0.20 0.27 0.306571M  429M 2012k   10G2935  2636   0   0 5.0   0     0 6370  9522<br>  1   0  98   0   0   0    48k0.20 0.27 0.306572M  428M 2012k   10G6228  2702   0 2.0  18   0     0 6666  9810<br>  1   0  98   1   0   0    88k0.20 0.27 0.306572M  429M 2012k   10G2995   698   0   0 1.0   0     0 5667  8150<br>  1   0  98   0   0   0   108k0.18 0.27 0.296572M  428M 2012k   10G1279   614   0   0  22   0     0 6508  9752<br>  1   0  98   0   0   0    32k0.18 0.27 0.296572M  429M 2012k   10G 320   470   0 1.0 1.0   0     0 5799  8516<br>​</p>
<p>这个输出还是比较全面的</p>
<h4 id="监测界面各个指标含义"><a href="#监测界面各个指标含义" class="headerlink" title="监测界面各个指标含义"></a>监测界面各个指标含义</h4><p><strong>total-usage</strong> <em>CPU统计</em></p>
<ul>
<li>usr：用户态进程占用CPU次数</li>
<li>sys：系统进程的CPU使用率</li>
<li>idl：CPU空闲率</li>
<li>wai：CPU的wait时间</li>
<li>stl：不知道是啥，有知道的铁子，评论区见</li>
<li>hiq：硬中断次数</li>
<li>siq ：软件中断次数</li>
</ul>
<p><strong>procs</strong> <em>进程统计</em></p>
<ul>
<li>正在运行（run）、被阻止（blk）和新（new）生成的进程数。</li>
</ul>
<p><strong>dsk&#x2F;total</strong> <em>磁盘统计</em></p>
<ul>
<li>磁盘上读（read）和写（writ）操作的总数</li>
</ul>
<p><strong>load-avg</strong> <em>1分钟，5分钟，15分钟系统负载</em></p>
<p><strong>memory-usage</strong> <em>内存统计</em></p>
<ul>
<li>已使用（used）、缓冲（buff）、缓存（cach）和可用（free）内存的数量</li>
</ul>
<p><strong>net&#x2F;total</strong> <em>网络统计</em></p>
<ul>
<li>网络接口上接收（recv）和发送（send）的字节总数。</li>
</ul>
<p><strong>swap</strong></p>
<ul>
<li>缓存区使用used和空闲free空间</li>
</ul>
<p><strong>system</strong> <em>系统状态</em></p>
<ul>
<li>int：为系统的中断次数（interrupt）</li>
<li>csw：上下文切换（context switch）</li>
</ul>
<p>已上就是Linux 性能分析工具汇总之dstat–系统监控工具使用过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>dstat</tag>
        <tag>分析</tag>
        <tag>工具</tag>
        <tag>性能</tag>
        <tag>监控</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 性能分析工具汇总之iostat--用于报告中央处理器统计信息</title>
    <url>/2021/04/20/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E4%B9%8Biostat-%E7%94%A8%E4%BA%8E%E6%8A%A5%E5%91%8A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-1.png"></p>
<p>iostat–用于统计CPU信息</p>
<p>iostat是I&#x2F;O statistics（输入&#x2F;输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。iostat也有一个弱点，就是<code>它不能对某个进程进行深入分析，仅对系统的整体情况进行分析</code></p>
<h4 id="显示所有设备负载情况"><a href="#显示所有设备负载情况" class="headerlink" title="显示所有设备负载情况"></a>显示所有设备负载情况</h4><p>[root@k8s-master01 oracle]# iostat<br>Linux 4.18.0-240.el8.x86_64 (k8s-master01)  2021年04月19日     _x86_64_    (12 CPU)<br>​<br>avg-cpu:  %user   %nice %system %iowait  %steal   %idle<br>           8.38    0.02    4.01    0.56    0.00   87.03<br>​<br>Device             tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn<br>sda              15.42        11.37       146.22    5765350   74170246<br>scd0              0.00         0.00         0.00          2          0<br>dm-0             14.66        10.64       108.31    5395544   54942712<br>dm-1              0.00         0.01         0.00       3260          0<br>dm-2              1.25         0.63        40.53     319536   20560056</p>
<h5 id="avg-cpu属性值说明"><a href="#avg-cpu属性值说明" class="headerlink" title="avg-cpu属性值说明"></a>avg-cpu属性值说明</h5><blockquote>
<p>%user：CPU处在用户模式下的时间百分比</p>
<p>%nice：CPU处在带NICE值的用户模式下的时间百分比</p>
<p>%system：CPU处在系统模式下的时间百分比</p>
<p>%iowait：CPU等待输入输出完成时间的百分比</p>
<p>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</p>
<p>%idle：CPU空闲时间百分比</p>
<p>Device：设备名</p>
<p>tps：该设备每秒的传输次数</p>
<p>kB_read&#x2F;s：每秒从设备（drive expressed）读取的数据量</p>
<p>kB_wrtn&#x2F;s：每秒向设备（drive expressed）写入的数据量</p>
<p>kB_read： 读取的总数据量</p>
<p>kB_wrtn：写入的总数量数据量</p>
</blockquote>
<h5 id="系统优化方法"><a href="#系统优化方法" class="headerlink" title="系统优化方法"></a>系统优化方法</h5><ul>
<li>如果<code>%iowait的值过高</code>，表示硬盘存在I&#x2F;O瓶颈</li>
<li>如果<code>%idle值高</code>，表示CPU较空闲</li>
<li>如果<code>%idle值高但系统响应慢</code>时，可能是CPU等待分配内存，应加大内存容量</li>
<li>如果<code>%idle值持续低于10</code>，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU</li>
</ul>
<h4 id="显示扩展的设备统计"><a href="#显示扩展的设备统计" class="headerlink" title="显示扩展的设备统计"></a>显示扩展的设备统计</h4><p>iostat用于报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入&#x2F;输出统计信息，默认显示了与vmstat相同的cpu使用信息，使用以下命令显示扩展的设备统计：</p>
<p>[root@k8s-master01 oracle]# iostat -dx 5<br>Linux 4.18.0-240.el8.x86_64 (k8s-master01)  2021年04月19日     _x86_64_    (12 CPU)<br>​<br>Device            r&#x2F;s     w&#x2F;s     rkB&#x2F;s     wkB&#x2F;s   rrqm&#x2F;s   wrqm&#x2F;s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util<br>sda              0.25   15.17     11.42    146.70     0.00     0.55   0.40   3.47   10.67    8.84   0.13    45.63     9.67   4.71   7.26<br>scd0             0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    1.00    0.00   0.00     0.20     0.00   1.40   0.00<br>dm-0             0.19   14.48     10.69    108.69     0.00     0.00   0.00   0.00    6.20    9.72   0.14    56.97     7.50   4.45   6.53<br>dm-1             0.00    0.00      0.01      0.00     0.00     0.00   0.00   0.00   12.74    0.00   0.00    22.48     0.00   9.96   0.00<br>dm-2             0.05    1.20      0.63     40.65     0.00     0.00   0.00   0.00    2.94    9.97   0.01    13.14    33.79   7.08   0.89</p>
<p>说明：</p>
<p>第一行显示的是自系统启动以来的平均值，然后显示增量的平均值，每个设备一行。</p>
<h5 id="linux的磁盘IO指标的缩写"><a href="#linux的磁盘IO指标的缩写" class="headerlink" title="linux的磁盘IO指标的缩写"></a>linux的磁盘IO指标的缩写</h5><ul>
<li>rq是request</li>
<li>r是read</li>
<li>w是write</li>
<li>qu是queue</li>
<li>sz是size</li>
<li>a是average</li>
<li>tm是time</li>
<li>svc是service</li>
</ul>
<h5 id="iostat磁盘IO指标说明"><a href="#iostat磁盘IO指标说明" class="headerlink" title="iostat磁盘IO指标说明"></a>iostat磁盘IO指标说明</h5><ul>
<li><p>r&#x2F;s和w&#x2F;s：每秒发送到设备的读和写请求数。</p>
</li>
<li><p>rkB&#x2F;s和wkB&#x2F;s：每秒千字节为单位显示了读和写的数据量</p>
</li>
<li><p>rrqm&#x2F;s和wrqm&#x2F;s：每秒合并的读和写请求，“合并的”意味着操作系统从队列中拿出多个逻辑请求合并为一个请求到实际磁盘。</p>
</li>
<li><p>%rrqm和%wrqm：在发送到设备之前合并到一起的读和写请求的百分比</p>
</li>
<li><p>r_await和w_await：平均每次读请求的时间(以毫秒为单位)。这包括请求在队列中花费的时间和执行它们所花费的时间</p>
</li>
<li><p>areq-sz：向设备发出的 I&#x2F;O 请求的平均大小(单位为 k)</p>
</li>
<li><p>rareq-sz：向设备发出的读请求的平均大小(单位为 k)</p>
</li>
<li><p>wareq-sz：向设备发出的写请求的平均大小(单位为 k)</p>
</li>
<li><p>svctm：实际请求（服务）时间。</p>
</li>
<li><p>%util：至少有一个活跃请求所占时间的百分比。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>分析</tag>
        <tag>工具</tag>
        <tag>性能</tag>
        <tag>iostat</tag>
        <tag>中央处理器</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 性能分析工具汇总之iotop--LINUX进程实时IO监控工具</title>
    <url>/2021/04/22/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E4%B9%8Biotop-linux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E6%97%B6io%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-3.png"></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Linux下的IO统计工具如iostat, nmon等大多数是只能统计到per设备的读写情况, 如果你想知道每个进程是如何使用IO的就比较麻烦.</p>
<p>iotop 是一个用来监视磁盘 I&#x2F;O 使用状况的 top 类工具。iotop 具有与 top 相似的 UI，其中包括 PID、用户、I&#x2F;O、进程等相关信息。</p>
<p>iotop命令是专门显示硬盘IO的命令，界面风格类似top命令，可以显示IO负载具体是由哪个进程产生的。是一个用来监视磁盘I&#x2F;O使用状况的top类工具，具有与top相似的UI，其中包括PID、用户、I&#x2F;O、进程等相关信息。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>直接运行就好</p>
<p>iotop</p>
<p>输出如下</p>
<p>[root@k8s-master01 oracle]# iotop<br>Total DISK READ :   0.00 B&#x2F;s  Total DISK WRITE :      83.74 K&#x2F;s<br>Actual DISK READ:   0.00 B&#x2F;s  Actual DISK WRITE:      83.74 K&#x2F;s<br>    TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND<br> 262357 be&#x2F;4 root        0.00 B&#x2F;s   30.45 K&#x2F;s  0.00 %  5.01 % etcd –advertise-client-urls&#x3D;<a href="https://172.25.42.235:2379/">https://172.25.42.235:2379</a> –cert-f<del>ot-count&#x3D;10000 –trusted-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt<br>1180158 be&#x2F;4 1001        0.00 B&#x2F;s   30.45 K&#x2F;s  0.00 %  4.00 % ora_ckpt_xe<br> 262339 be&#x2F;4 root        0.00 B&#x2F;s   19.03 K&#x2F;s  0.00 %  1.53 % etcd –advertise-client-urls&#x3D;<a href="https://172.25.42.235:2379/">https://172.25.42.235:2379</a> –cert-f</del>ot-count&#x3D;10000 –trusted-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt<br> 262624 be&#x2F;4 root        0.00 B&#x2F;s    3.81 K&#x2F;s  0.00 %  0.25 % etcd –advertise-client-urls&#x3D;<a href="https://172.25.42.235:2379/">https://172.25.42.235:2379</a> –cert-f~ot-count&#x3D;10000 –trusted-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt<br>      1 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % systemd –switched-root –system –deserialize 17<br>​</p>
<h4 id="只显示有IO输出的进程"><a href="#只显示有IO输出的进程" class="headerlink" title="只显示有IO输出的进程"></a>只显示有IO输出的进程</h4><p>o键是只显示有IO输出的进程</p>
<p>[root@k8s-master01 oracle]# iotop -o<br>Total DISK READ :   0.00 B&#x2F;s  Total DISK WRITE :      49.52 K&#x2F;s<br>Actual DISK READ:   0.00 B&#x2F;s  Actual DISK WRITE:      57.14 K&#x2F;s<br>    TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND<br> 262354 be&#x2F;4 root        0.00 B&#x2F;s   38.09 K&#x2F;s  0.00 %  4.38 % etcd –advertise-client-urls&#x3D;<a href="https://172.25.42.235:2379/">https://172.25.42.235:2379</a> –cert-f<del>ot-count&#x3D;10000 –trusted-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt<br> 262337 be&#x2F;4 root        0.00 B&#x2F;s    3.81 K&#x2F;s  0.00 %  1.41 % etcd –advertise-client-urls&#x3D;<a href="https://172.25.42.235:2379/">https://172.25.42.235:2379</a> –cert-f</del>ot-count&#x3D;10000 –trusted-ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt<br>2063621 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.30 % [kworker&#x2F;0:1-events_power_efficient]</p>
<p>通过输出结果，我们可以清楚地知晓是什么程序在读写磁盘，速度以及命令行，pid 等信息。</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>[root@k8s-master01 oracle]# iotop -h<br>Usage: &#x2F;usr&#x2F;sbin&#x2F;iotop [OPTIONS]<br>​<br>DISK READ and DISK WRITE are the block I&#x2F;O bandwidth used during the sampling<br>period. SWAPIN and IO are the percentages of time the thread spent respectively<br>while swapping in and waiting on I&#x2F;O more generally. PRIO is the I&#x2F;O priority at<br>which the thread is running (set using the ionice command).<br>​<br>Controls: left and right arrows to change the sorting column, r to invert the<br>sorting order, o to toggle the –only option, p to toggle the –processes<br>option, a to toggle the –accumulated option, i to change I&#x2F;O priority, q to<br>quit, any other key to force a refresh.<br>​<br>Options:<br>  –version             show program’s version number and exit<br>  –version #显示版本号</p>
<p>  -h, –help            show this help message and exit<br>  -h, –help #显示帮助信息</p>
<p>  -o, –only            only show processes or threads actually doing I&#x2F;O<br>  -o, –only #显示进程或者线程实际上正在做的I&#x2F;O，而不是全部的，可以随时切换按o</p>
<p>  -b, –batch           non-interactive mode<br>  -b, –batch #运行在非交互式的模式</p>
<p>  -n NUM, –iter&#x3D;NUM    number of iterations before ending [infinite]<br>  -n NUM, –iter&#x3D;NUM #在非交互式模式下，设置显示的次数<br>​<br>  -d SEC, –delay&#x3D;SEC   delay between iterations [1 second]<br>  -d SEC, –delay&#x3D;SEC #设置显示的间隔秒数，支持非整数值</p>
<p>  -p PID, –pid&#x3D;PID     processes&#x2F;threads to monitor [all]<br>  -p PID, –pid&#x3D;PID #只显示指定PID的信息</p>
<p>  -u USER, –user&#x3D;USER  users to monitor [all]<br>  -u USER, –user&#x3D;USER #显示指定的用户的进程的信息</p>
<p>  -P, –processes       only show processes, not all threads<br>  -P, –processes #只显示进程，一般为显示所有的线程</p>
<p>  -a, –accumulated     show accumulated I&#x2F;O instead of bandwidth<br>  -a, –accumulated #显示从iotop启动后每个线程完成了的IO总数</p>
<p>  -k, –kilobytes       use kilobytes instead of a human friendly unit<br>  -k, –kilobytes #以千字节显示</p>
<p>  -t, –time            add a timestamp on each line (implies –batch)<br>  -t, –time #在每一行前添加一个当前的时间</p>
<p>  -q, –quiet           suppress some lines of header (implies –batch)
　　</p>
<p>已上就是Linux 性能分析工具汇总之LINUX进程实时IO监控工具使用过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>分析</tag>
        <tag>工具</tag>
        <tag>性能</tag>
        <tag>iotop</tag>
        <tag>IO监控</tag>
        <tag>实时</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 性能分析工具汇总之vmstat--虚拟内存统计</title>
    <url>/2021/04/19/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%E4%B9%8Bvmstat-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监视。它是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。</p>
<p>vmstat (VirtualMeomoryStatistics,虚拟内存统计) 是Linux中监控内存的常用工具,可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。</p>
<p>vmstat的常规用法：vmstat interval times 即每隔 interval 秒采样一次，共采样 times 次，如果省略 times，则一直采集数据，直到用户手动停止为止。</p>
<p><code>第一行显示了系统自启动以来的平均值</code></p>
<p><code>第二行开始显示现在正在发生的情况</code></p>
<p><code>接下来的行会显示每5秒间隔发生了什么</code></p>
<p><code>每一列的含义在头部</code></p>
<h4 id="简单举个例子："><a href="#简单举个例子：" class="headerlink" title="简单举个例子："></a>简单举个例子：</h4><p>[root@k8s-master01 ~]# vmstat 5<br>procs ———–memory———- —swap– —–io—- -system– ——cpu—–<br> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st<br> 1  0      0 5501672    992 6074152    0    0     1    10    1    3  1  0 98  0  0<br> 1  0      0 5500952    992 6074156    0    0     0    58 5622 8466  1  1 98  0  0<br>^C<br>[root@k8s-master01 ~]# </p>
<p>可以使用ctrl+c停止vmstat采集数据。</p>
<h4 id="vmstat-使用说明"><a href="#vmstat-使用说明" class="headerlink" title="vmstat 使用说明:"></a>vmstat 使用说明:</h4><ul>
<li>procs：进程数，此数由 linux 计算得出，但 linux 并不耗尽交换空间<ul>
<li>r：这一列显示了多少进程在等待cpu（等待运行的进程数）</li>
<li>b：列显示多少进程正在不可中断的休眠（非中断睡眠状态的进程数）</li>
<li>w：被交换出去的可运行的进程数</li>
</ul>
</li>
<li>memory：内存使用情况<ul>
<li>swapd：列显示了多少块被换出了磁盘（页面交换）</li>
<li>free：剩下的列显示了多少块是空闲的（未被使用）</li>
<li>buff：多少块正在被用作缓冲区</li>
<li>cache：以及多少正在被用作操作系统的缓存</li>
</ul>
</li>
<li>swap：显示交换活动<ul>
<li>si：每秒有多少块正在被换入，从磁盘交换到内存的交换页数量</li>
<li>so 从内存交换到磁盘的交换页数量</li>
</ul>
</li>
<li>io：显示了多少块从块设备读取bi和写出，通常反映了硬盘I&#x2F;O<ul>
<li>bi：发送到块设备的块数</li>
<li>bo：从块设备接收到的块数</li>
</ul>
</li>
<li>system：<ul>
<li>显示每秒中断 (in) 的数量</li>
<li>上下文切换（cs）的数量。</li>
</ul>
</li>
<li>cpu：显示所有的cpu时间花费在各类操作的百分比<ul>
<li>用户进程使用的时间，包括执行用户代码（非内核）</li>
<li>系统进程使用的时间，执行系统代码（内核）</li>
<li>cpu空闲的时间以及等待IO</li>
</ul>
</li>
</ul>
<h4 id="vmstat的语法如下："><a href="#vmstat的语法如下：" class="headerlink" title="vmstat的语法如下："></a>vmstat的语法如下：</h4><p>vmstat [-V] [-n] [delay [count]]</p>
<p>参数说明：</p>
<p>其中，－V表示打印出版本信息；－n表示在周期性循环输出时，输出的头部信息仅显示一次；delay是两次输出之间的延迟时间；count是指按照这个时间间隔统计的次数。对于vmstat输出各字段的含义，可运行man vmstat查看。</p>
<h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>通常使用vmstat 5 5（表示在5秒时间内进行5次采样）命令测试。</p>
<p>将得到一个数据汇总它可以反映真正的系统情况。</p>
<p>[root@k8s-master01 ~]# vmstat 5 5<br>procs ———–memory———- —swap– —–io—- -system– ——cpu—–<br> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st<br> 1  0      0 5505828    992 6073660    0    0     1    10    0    3  1  0 98  0  0<br> 0  0      0 5505608    992 6073756    0    0     0    38 5653 8671  1  1 98  0  0<br> 0  0      0 5505924    992 6073760    0    0     0    26 5854 9084  1  1 98  0  0<br> 0  0      0 5505988    992 6073764    0    0     0    34 6269 9794  1  1 98  0  0<br> 0  0      0 5505504    992 6073768    0    0     0   330 5827 8759  1  0 97  1  0<br>[root@k8s-master01 ~]# </p>
<h4 id="系统问题判断："><a href="#系统问题判断：" class="headerlink" title="系统问题判断："></a>系统问题判断：</h4><p><strong>内存不足的表现</strong>：free memory急 剧减少，回收buffer和cacher也无济于事，大量使用交换分区（swpd）,页面交换（swap）频繁，读写磁盘数量（io）增多，缺页中断（in）增多，上下文切换（cs）次数增多，等待IO的进程数（b）增多，大量CPU时间用于等待IO（wa）</p>
<p><strong>cpu的负荷很重表现</strong>：r经常大于 4 ，且id经常少于40</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
        <tag>统计</tag>
        <tag>vmstat</tag>
        <tag>内存</tag>
        <tag>性能分析</tag>
        <tag>汇总</tag>
        <tag>虚拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 或 Windows 上实现端口映射</title>
    <url>/2021/08/12/linux-%E6%88%96-windows-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-10.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>通常服务器会有许多块网卡，因此也可能会连接到不同的网络，在隔离的网络中，某些服务可能会需要进行通信，此时服务器经过配置就可以承担起了转发数据包的功能。</p>
<h3 id="一、Windows下实现端口映射"><a href="#一、Windows下实现端口映射" class="headerlink" title="一、Windows下实现端口映射"></a>一、Windows下实现端口映射</h3><hr>
<ol>
<li>查询端口映射情况</li>
</ol>
<p>netsh interface portproxy show v4tov4</p>
<ol start="2">
<li>查询某一个IP的所有端口映射情况</li>
</ol>
<p>netsh interface portproxy show v4tov4  find “[IP]“<br>例：<br>netsh interface portproxy show v4tov4  find “192.168.1.1”</p>
<ol start="3">
<li>增加一个端口映射</li>
</ol>
<p>netsh interface portproxy add v4tov4 listenaddress&#x3D;[外网IP] listenport&#x3D;[外网端口] connectaddress&#x3D;[内网IP] connectport&#x3D;[内网端口]<br>例：<br>netsh interface portproxy add v4tov4 listenaddress&#x3D;2.2.2.2 listenport&#x3D;8080 connectaddress&#x3D;192.168.1.50 connectport&#x3D;80</p>
<ol start="4">
<li>删除一个端口映射</li>
</ol>
<p>netsh interface portproxy delete v4tov4 listenaddress&#x3D;[外网IP] listenport&#x3D;[外网端口]<br>例：<br>netsh interface portproxy delete v4tov4 listenaddress&#x3D;2.2.2.2 listenport&#x3D;8080</p>
<h4 id="二、Linux下端口映射"><a href="#二、Linux下端口映射" class="headerlink" title="二、Linux下端口映射"></a>二、Linux下端口映射</h4><hr>
<ol>
<li>允许数据包转发</li>
</ol>
<p>echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br>iptables -t nat -A POSTROUTING -j MASQUERADE<br>iptables -A FORWARD -i [内网网卡名称] -j ACCEPT<br>iptables -t nat -A POSTROUTING -s [内网网段] -o [外网网卡名称] -j MASQUERADE<br>例：<br>echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br>iptables -t nat -A POSTROUTING -j MASQUERADE<br>iptables -A FORWARD -i ens33 -j ACCEPT<br>iptables -t nat -A POSTROUTING -s 192.168.50.0&#x2F;24 -o ens37 -j MASQUERADE</p>
<ol start="2">
<li>设置端口映射</li>
</ol>
<p>iptables -t nat -A PREROUTING -p tcp -m tcp –dport [外网端口] -j DNAT –to-destination [内网地址]:[内网端口]<br>例：<br>iptables -t nat -A PREROUTING -p tcp -m tcp –dport 6080 -j DNAT –to-destination 10.0.0.100:6090</p>
<h3 id="实验：将部署在内网的服务映射到外网"><a href="#实验：将部署在内网的服务映射到外网" class="headerlink" title="实验：将部署在内网的服务映射到外网"></a>实验：将部署在内网的服务映射到外网</h3><hr>
<h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><ul>
<li>VMWare Workstation Pro</li>
<li>5台最小化安装的centos 7虚拟机<br><img src="https://img-blog.csdnimg.cn/d929eeb0033244e2bc62cd7f418e1867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>内网和外网是相对Server4来说的。<br>Server1和Server2为内网环境的两台服务器；<br>Server3为外网环境下的一台服务器；<br>Server4为一台双网卡主机，分别连接192.168.50.0&#x2F;24和172.16.2.0&#x2F;24两个网络。</li>
</ul>
<h3 id="配置实验环境"><a href="#配置实验环境" class="headerlink" title="配置实验环境"></a>配置实验环境</h3><hr>
<ol>
<li>Server1,2,3上搭建HTTP服务</li>
</ol>
<p>用Python在Server1上搭建一个简单的HTTP服务</p>
<p>cd ~<br>echo “server1” &gt; index.html<br>python -m SimpleHTTPServer 8080</p>
<p><img src="https://img-blog.csdnimg.cn/0fcb44a06f264b2e8a5a32b823c89b23.png" alt="在这里插入图片描述"><br>Server2、Server3同理</p>
<h3 id="对照实验"><a href="#对照实验" class="headerlink" title="对照实验"></a>对照实验</h3><hr>
<p>在client上访问Server1的资源</p>
<p>curl <a href="http://192.168.50.11:8080/index.html">http://192.168.50.11:8080/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/afa5a12141534d14a00becb610eeff42.png" alt="在这里插入图片描述"><br>在client上访问Server2的资源</p>
<p>curl <a href="http://192.168.50.12:8080/index.htm">http://192.168.50.12:8080/index.htm</a></p>
<p><img src="https://img-blog.csdnimg.cn/618894bb51974df7bcf71f12fd046092.png" alt="在这里插入图片描述"><br>在client上访问Server3的资源</p>
<p>curl <a href="http://172.16.2.11:8080/index.html">http://172.16.2.11:8080/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/95e85458d53c4d28bd0a6c398169a67c.png" alt="图片"><br>可以看到，外网的client是无法访问内网Server1,Server2的资源的。</p>
<h3 id="在Server4上配置端口映射"><a href="#在Server4上配置端口映射" class="headerlink" title="在Server4上配置端口映射"></a>在Server4上配置端口映射</h3><hr>
<p>临时配置</p>
<p>#允许数据包转发<br>echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br>iptables -t nat -A POSTROUTING -j MASQUERADE<br>iptables -A FORWARD -i ens33 -j ACCEPT<br>iptables -t nat -A POSTROUTING -s 192.168.50.0&#x2F;24 -o ens37 -j MASQUERADE<br>#设置端口映射<br>iptables -t nat -A PREROUTING -p tcp -m tcp –dport 8081 -j DNAT –to-destination 192.168.50.11:8080<br>iptables -t nat -A PREROUTING -p tcp -m tcp –dport 8082 -j DNAT –to-destination 192.168.50.12:8080</p>
<p>永久配置</p>
<p>如果需要永久配置，则将以上命令追加到&#x2F;etc&#x2F;rc.local文件。</p>
<p>检查效果<br>在client上访问Server1的资源</p>
<p>curl <a href="http://172.16.2.100:8081/index.html">http://172.16.2.100:8081/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/87f504bff9ad441ba7aa123021c9ae6b.png" alt="在这里插入图片描述"><br>在client上访问Server2的资源</p>
<p>curl <a href="http://172.16.2.100:8082/index.html">http://172.16.2.100:8082/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/fbe419e635524626aedb3bc02d1bbc3b.png" alt="在这里插入图片描述"><br>在client上访问Server3的资源</p>
<p>curl <a href="http://172.16.2.11:8080/index.html">http://172.16.2.11:8080/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/93798a2e03564445b29e07dedcf6dfe5.png" alt="在这里插入图片描述"></p>
<h3 id="如果Server4为Windows，替换一下相应的命令即可"><a href="#如果Server4为Windows，替换一下相应的命令即可" class="headerlink" title="如果Server4为Windows，替换一下相应的命令即可"></a>如果Server4为Windows，替换一下相应的命令即可</h3><hr>
<p>Windows的IP信息如下</p>
<p>网卡</p>
<p>IP地址</p>
<p>子网掩码</p>
<p>默认网关</p>
<p>备注</p>
<p>Ethernet0</p>
<p>192.168.50.105</p>
<p>255.255.255.0</p>
<p>-</p>
<p>内网网卡</p>
<p>Ethernet1</p>
<p>172.16.2.105</p>
<p>255.255.255.0</p>
<p>-</p>
<p>外网网卡</p>
<p><img src="https://img-blog.csdnimg.cn/faa98744c13449de9cf45109a2a04e52.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="配置并查看端口映射情况"><a href="#配置并查看端口映射情况" class="headerlink" title="配置并查看端口映射情况"></a>配置并查看端口映射情况</h3><p>netsh interface portproxy add v4tov4 listenaddress&#x3D;172.16.2.105 listenport&#x3D;8081 connectaddress&#x3D;192.168.50.11 connectport&#x3D;8080<br>netsh interface portproxy add v4tov4 listenaddress&#x3D;172.16.2.105 listenport&#x3D;8082 connectaddress&#x3D;192.168.50.12 connectport&#x3D;8080<br>netsh interface portproxy show v4tov4</p>
<p><img src="https://img-blog.csdnimg.cn/d374ca96c6d6496fbc1e63df9c9625da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="检查效果"><a href="#检查效果" class="headerlink" title="检查效果"></a>检查效果</h3><hr>
<p>在client节点上</p>
<p>curl <a href="http://172.16.2.105:8081/index.html">http://172.16.2.105:8081/index.html</a><br>curl <a href="http://172.16.2.105:8082/index.html">http://172.16.2.105:8082/index.html</a><br>curl <a href="http://172.16.2.11:8080/index.html">http://172.16.2.11:8080/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/7e9d656be19343ffb1a0e7ddf0746abb.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Windows</tag>
        <tag>端口映射</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 执行 netstat -ntpl 命令卡住不动怎么办</title>
    <url>/2021/04/23/linux-%E6%89%A7%E8%A1%8C-netstat-ntpl-%E5%91%BD%E4%BB%A4%E5%8D%A1%E4%BD%8F%E4%B8%8D%E5%8A%A8%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h4 id="Netstat的定义"><a href="#Netstat的定义" class="headerlink" title="Netstat的定义"></a>Netstat的定义</h4><p>Netstat是在内核中访问中国络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告</p>
<p>从定义上和执行命令后的显示过程中就可以看出，运行此命令会产生很多条结果，都是关于IP或者各个已经产生连接的端口信息，相当于病毒软件查杀病毒时的状态，会对电脑已经产生的连接进行逐条扫描，因此它显得很慢，这是很正常的。 netstat命令的功能是显示中国络连接、路由表和中国络接口信息，可以让用户得知有哪些中国络连接正在运作。使用时如果不带参数，netstat 显示活动的 TCP 连接</p>
<h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>大家有没有遇到这种情况，登录服务器是卡在那里不动，ctrl+c才能出现命令提示符；执行netstat -tlnp grep mongo时，又卡住了，ctrl+c也无法退出，ctrl+z也不行；类似的ps 和top也有这样的情况，这是那里出了问题</p>
<p>根据netstat的原理可以知道 netstat会对产生的连接进行逐条扫描，这也就影响了netstat的查询效率</p>
<p>可以确认的是系统负载无压力。　　</p>
<h4 id="在Linux下，如果连接数比较大，可以使用效率更高的ss来替代netstat。"><a href="#在Linux下，如果连接数比较大，可以使用效率更高的ss来替代netstat。" class="headerlink" title="在Linux下，如果连接数比较大，可以使用效率更高的ss来替代netstat。"></a><strong>在Linux下，如果连接数比较大，可以使用效率更高的ss来替代netstat。</strong></h4><h4 id="ss-和-netstat-命令"><a href="#ss-和-netstat-命令" class="headerlink" title="ss 和 netstat 命令"></a>ss 和 netstat 命令</h4><p>netstat 命令和 ss 命令比较类似，主要功能也是统计系统中socket相关信息，和 netstat相比，ss 命令在跟踪TCP连接和套接字方面速度更快，功能更强大，下面是 ss 和 netstat 统计速度的对比</p>
<p>[cgyx@cghost35 ~]$ time ss -a  wc -l<br>439<br>​<br>real    0m0.014s<br>user    0m0.004s<br>sys     0m0.010s<br>[cgyx@cghost35 ~]$ time netstat -a  wc -l<br>366<br>​<br>real    0m0.029s<br>user    0m0.005s<br>sys     0m0.008s</p>
<p><em>从上面例子可以看出，<strong>ss</strong> 统计 439 条 socket 信息花费了 <strong>0.014s</strong>, <strong>netstat</strong> 统计366条socket信息花费了<strong>0.029s</strong>，<strong>ss 统计信息的速度更快</strong>，所以实际使用中一般都是用 <strong>ss 替代 netstat</strong></em></p>
<p><strong>注意： netstat命令 上的参数在 ss命令上都通用</strong></p>
<p>套接字处于什么状态，下面是<strong>TCP套接字的所有状态及说明</strong>,</p>
<p>实际上就是TCP的三次握手和四次挥手的所有状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSED         初始（无连接）状态。LISTEN         侦听状态，等待远程机器的连接请求。SYN_SEND       在TCP三次握手期间，主动连接端发送了SYN包后，进入SYN_SEND状态，等待对方的ACK包。SYN_RECV       在TCP三次握手期间，主动连接端收到SYN包后，进入SYN_RECV状态。ESTABLISHED    完成TCP三次握手后，主动连接端进入ESTABLISHED状态。此时，TCP连接已经建立，可以进行通信。FIN_WAIT_1     在TCP四次挥手时，主动关闭端发送FIN包后，进入FIN_WAIT_1状态。FIN_WAIT_2     在TCP四次挥手时，主动关闭端收到ACK包后，进入FIN_WAIT_2状态。TIME_WAIT      在TCP四次挥手时，主动关闭端发送了ACK包之后，进入TIME_WAIT状态，等待最多MSL时间，让被动关闭端收到ACK包。CLOSING        在TCP四次挥手期间，主动关闭端发送了FIN包后，没有收到对应的ACK包，却收到对方的FIN包，此时，进入CLOSING状态。CLOSE_WAIT     在TCP四次挥手期间，被动关闭端收到FIN包后，进入CLOSE_WAIT状态。LAST_ACK       在TCP四次挥手时，被动关闭端发送FIN包后，进入LAST_ACK状态，等待对方的ACK包。 主动连接端可能的状态有：    CLOSED        SYN_SEND        ESTABLISHED主动关闭端可能的状态有：    FIN_WAIT_1    FIN_WAIT_2      TIME_WAIT被动连接端可能的状态有：    LISTEN        SYN_RECV        ESTABLISHED被动关闭端可能的状态有：    CLOSE_WAIT    LAST_ACK        CLOSED 在Linux下，如果连接数比较大，可以使用效率更高的ss来替代netstat。查看tomcat的并发数：netstat -angrep 10050awk &#x27;&#123;count[$6]++&#125; END&#123;for (i in count) print(i,count[i])&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>netstat</tag>
        <tag>ntpl</tag>
        <tag>不动</tag>
        <tag>卡住</tag>
        <tag>命令</tag>
        <tag>怎么办</tag>
        <tag>执行</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 搭建 LAMP 环境</title>
    <url>/2021/05/20/linux-%E6%90%AD%E5%BB%BA-lamp-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-41.png"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LAMP 是建立 WEB 应用的平台，是 Linux、ApacheHTTP ，MySQL（有时也指MariaDB，数据库软件） 和 PHP（有时也是指 Perl 或 Python ） 的简称。</p>
<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><p>CentOS 6.8 64 位</p>
<h2 id="搭建-MySQL-数据库"><a href="#搭建-MySQL-数据库" class="headerlink" title="搭建 MySQL 数据库"></a>搭建 MySQL 数据库</h2><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><p>使用 yum 安装 MySQL：</p>
<p>yum install mysql-server -y</p>
<h3 id="启动-MySQL"><a href="#启动-MySQL" class="headerlink" title="启动 MySQL"></a>启动 MySQL</h3><p>安装完成后，启动 MySQL 服务：</p>
<p>service mysqld restart</p>
<h3 id="设置-MySQL-账户-root-密码"><a href="#设置-MySQL-账户-root-密码" class="headerlink" title="设置 MySQL 账户 root 密码"></a>设置 MySQL 账户 root 密码</h3><p>&#x2F;usr&#x2F;bin&#x2F;mysqladmin -u root password ‘Password’</p>
<p>下面命令中的密码是教程为您自动生成的，如果设置其它密码，请把密码记住。</p>
<h2 id="安装-Apache-服务"><a href="#安装-Apache-服务" class="headerlink" title="安装 Apache 服务"></a>安装 Apache 服务</h2><h3 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h3><p>使用 yum 安装 Apache</p>
<p>yum install httpd -y</p>
<h3 id="启动-Apache-服务"><a href="#启动-Apache-服务" class="headerlink" title="启动 Apache 服务"></a>启动 Apache 服务</h3><p>service httpd start</p>
<h2 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 PHP</h2><h3 id="安装-PHP-和-PHP-MYSQL-支持工具"><a href="#安装-PHP-和-PHP-MYSQL-支持工具" class="headerlink" title="安装 PHP 和 PHP-MYSQL 支持工具"></a>安装 PHP 和 PHP-MYSQL 支持工具</h3><p>使用 yum 安装 PHP：</p>
<p>yum install php php-mysql -y</p>
<p>CentOS 6 默认已经安装了 php-mysql，下面命令执行的可能会提示已经安装。</p>
<h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p>检验 PHP 是否安装成功<br>我们在 <code>/var/www/html</code> 目录下创建一个<code>info.php</code>文件来检查php是否安装成功，示例代码参考如下</p>
<p>示例代码：&#x2F;var&#x2F;www&#x2F;html&#x2F;info.php</p>
<?php phpinfo(); ?>

<h3 id="重启-Apache-服务"><a href="#重启-Apache-服务" class="headerlink" title="重启 Apache 服务"></a>重启 Apache 服务</h3><p>service httpd restart</p>
<p>此时，访问 http:&#x2F;&#x2F;&lt;IP 地址&gt;&#x2F;info.php 可浏览到我们刚刚创建的 <code>info.php</code> 页面了</p>
<p>恭喜！您已经成功完成了搭建 LAMP 服务器。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>apache</tag>
        <tag>lamp</tag>
        <tag>php</tag>
        <tag>搭建lamp</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 服务器 如何使用 alias 命令</title>
    <url>/2021/07/27/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-alias-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-66.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>通常情况下alias命令适合下面场景：</p>
<ul>
<li>简化过长且过于复杂的命令</li>
<li>记住复杂名称的命令</li>
<li>使用你经常使用的命令节省时间</li>
</ul>
<h3 id="如何创建alias"><a href="#如何创建alias" class="headerlink" title="如何创建alias"></a>如何创建alias</h3><hr>
<p>例如，设置一个别名列出所有文件包括隐藏文件，别名为la：</p>
<p>[root@server1 ~]# alias la&#x3D;’ls -al’</p>
<p>执行一下别名la看一下：</p>
<p>[root@server1 ~]# la<br>total 68<br>dr-xr-x—.  3 root root   216 May 25 13:13 .<br>drwxr-xr-x. 19 root root   271 May  7 15:12 ..<br>-rw——-.  1 root root  1178 Dec 29  2019 anaconda-ks.cfg<br>-rw——-.  1 root root 14798 May 20 01:48 .bash_history<br>-rw-r–r–.  1 root root    18 May 11  2019 .bash_logout<br>-rw-r–r–.  1 root root   176 May 11  2019 .bash_profile<br>-rw-r–r–.  1 root root   176 May 11  2019 .bashrc<br>drwx——   3 root root    17 Mar 11 11:17 .cache<br>-rw-r–r–.  1 root root   100 May 11  2019 .cshrc<br>-rw——-   1 root root    64 May 25 13:13 .lesshst<br>-rw-r–r–   1 root root   234 May 19 09:52 sample.html<br>-rw-r–r–.  1 root root   129 May 11  2019 .tcshrc<br>-rw-r–r–   1 root root  1178 May 19 09:32 test.txt<br>-rw——-   1 root root 15904 May 25 10:15 .viminfo</p>
<p>如果要永久使用，可以将该命令写入~&#x2F;.bashrc文件里面。</p>
<p>[root@server1 ~]# echo “alias la&#x3D;’ls -al’” &gt;&gt; ~&#x2F;.bashrc</p>
<h3 id="如何列出alias"><a href="#如何列出alias" class="headerlink" title="如何列出alias"></a>如何列出alias</h3><hr>
<p>使用alias命令列出系统中已设置的所有别名：</p>
<p>[root@server1 ~]# alias</p>
<h3 id="检查命令类型是否是别名"><a href="#检查命令类型是否是别名" class="headerlink" title="检查命令类型是否是别名"></a>检查命令类型是否是别名</h3><hr>
<p>要检查命令是否为别名，请使用which命令。如下实例显示的内容就是别名。</p>
<p>[root@server1 ~]# which la<br>alias la&#x3D;’ls -al’<br>&#x2F;usr&#x2F;bin&#x2F;ls</p>
<h3 id="如何删除alias"><a href="#如何删除alias" class="headerlink" title="如何删除alias"></a>如何删除alias</h3><hr>
<p>如果需要停用别名，则可以使用unalias命令。要使更改永久生效，就需要在~&#x2F;.bashrc文件中删掉对应的别名。</p>
<p>[root@server1 ~]# unalias la</p>
<h3 id="对常用命令使用alias"><a href="#对常用命令使用alias" class="headerlink" title="对常用命令使用alias"></a>对常用命令使用alias</h3><hr>
<p>对于经常使用的命令，通过使用别名来缩短它们就可以节省更多的时间。在下面显示的别名中，我们用一个字母清除屏幕，使用ll显示目录中的文件，并仅查看最近创建或更新的五个文件：</p>
<p>[root@server1 ~]# alias c&#x3D;’clear’<br>[root@server1 ~]# alias ll&#x3D;’ls -al’<br>[root@server1 ~]# alias new&#x3D;’ls -1tr  tail -5’</p>
<h3 id="使用alias来更改命令的行为"><a href="#使用alias来更改命令的行为" class="headerlink" title="使用alias来更改命令的行为"></a>使用alias来更改命令的行为</h3><hr>
<p>例如，想让ping命令只请求4次，则可以使用此别名确保它仅发出四个ping请求：</p>
<p>[root@server1 ~]# alias ping&#x3D;’ping -c 4’</p>
<h3 id="用alias避免长字符串的选项"><a href="#用alias避免长字符串的选项" class="headerlink" title="用alias避免长字符串的选项"></a>用alias避免长字符串的选项</h3><hr>
<p>别名对于记住较长的命令选项非常有用。例如，要解压文件可以使用如下别名：</p>
<p>[root@server1 ~]# alias untar&#x3D;’tar -xvf’</p>
<h3 id="使用alias查看命令的历史记录"><a href="#使用alias查看命令的历史记录" class="headerlink" title="使用alias查看命令的历史记录"></a>使用alias查看命令的历史记录</h3><hr>
<p>要使用搜索字词查看历史记录，请执行以下操作：</p>
<p>[root@server1 ~]# alias rec&#x3D;’history  grep’</p>
<p>这可以看到在历史记录中保留的相关记录，例如：</p>
<p>[root@server1 ~]# rec alias</p>
<h3 id="使用alias搜索相关的命令"><a href="#使用alias搜索相关的命令" class="headerlink" title="使用alias搜索相关的命令"></a>使用alias搜索相关的命令</h3><hr>
<p>要查找与搜索词相关的命令，使用apropos命令，但是该命令有点陌生，可以设置一个别名，使用以下命令：</p>
<p>[root@server1 ~]# alias ?&#x3D;”apropos”</p>
<p>下面使用?搜索和compress相关的命令：</p>
<p>[root@server1 ~]# ? compress</p>
<h3 id="显示你的IP地址"><a href="#显示你的IP地址" class="headerlink" title="显示你的IP地址"></a>显示你的IP地址</h3><hr>
<p>[root@server1 ~]# alias myip&#x3D;’hostname -I’</p>
<h3 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h3><hr>
<p>alias命令在Linux中经常使用，可以使在Linux命令行上的工作更加顺畅，但是它们也可能很复杂且难以记住，这篇文章探讨了如何使alias命令。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
        <tag>alias</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统中如何恢复已删除的文件？</title>
    <url>/2021/11/23/linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021112209303966.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。<br>这里将解释它是如何工作的。在一个文件系统中，有一个叫做 文件分配表 的东西，这个表跟踪文件在存储单元（如硬盘， MicroSD 卡，闪存驱动器等等）中的位置。</p>
<p>当一个文件被删除，文件系统将会在文件分配表中执行以下两个任务之一：这个文件在文件分配表上的条目被标记为 “自由空间” 或删除文件分配表里这个文件的条目，且将相应的空间被标记为自由空间 。</p>
<p>现在，如果有一个新的文件需要被放置在一个存储单元上，操作系统将会把这个文件放置到标记为空位的地方。在新文件被写入到这个空位后，被删除的文件就彻底消失了。</p>
<p>当需要恢复一个已经删除的文件时，用户绝对不能再对任何文件进行操作，因为假如该文件对应的“空位”被占用，这个文件就永远也不能恢复了。</p>
<h3 id="恢复软件是如何工作的？"><a href="#恢复软件是如何工作的？" class="headerlink" title="恢复软件是如何工作的？"></a>恢复软件是如何工作的？</h3><hr>
<p>大多数的文件系统（在删除文件时）只是标记空间为空白。在这些文件系统下，恢复软件查看文件分配表这个文件，然后复制被删除的文件到另外的存储单元中。假如该文件被复制到其它需要恢复的被删除的存储单元中，那么用户将有可能会失去那个所需的删除文件。</p>
<p>文件系统很少会擦除文件分配表中的条目。假如文件系统真的这样做了， 这便是恢复软件在恢复文件了。恢复软件在存储单元中扫描文件头，所有文件都拥有一个特殊的编码字符串，它们位于文件的最前面，也被叫做 魔法数字。例如，一个编译的 JAVA 类文件的魔法数字在十六进制中是“CAFEBABE”。</p>
<p>所以，假如要恢复该类型的文件，恢复软件会查找 “CAFEBABE” 然后复制文件到另一个存储单元。一些恢复软件可以查找某种特殊的文件类型。若用户想恢复一个 PDF 文件，则恢复软件将会查找十六进制的魔法数字 “25504446”，这恰恰是 ASCII 编码中的 “%PDF”。恢复软件将会查找所有的魔法数字，然后用户可以选择恢复哪个已删除的文件。</p>
<p>假如一个文件的部分被覆写了，则整个文件就会被损坏。通常这个文件可以被恢复，但是其中的内容可能已经没有什么用处。例如，恢复一个已损坏的 JPEG 文件将会是无意义的，因为图片查看器不能从这个损坏的文件产生一幅图片。因此，即使用户拥有了这个文件，该文件也将毫无用处。</p>
<h3 id="设备的位置"><a href="#设备的位置" class="headerlink" title="设备的位置"></a>设备的位置</h3><hr>
<p>在我们继续之前，下面的一些信息将会对指引恢复软件找到正确的存储单元起到一定的帮助。所有的设备均挂载在 &#x2F;dev&#x2F; 目录下。操作系统赋予每个设备的名称（并不是管理员给予每个分区或设备的名称）遵循一定的命名规律。</p>
<p>第一个 SATA 硬盘的第二个分区的名称将会是 sda2。名称的第一个字母暗示了存储类型，在这里指的是 SATA，但字母 “s” 也可能指的是 SCSI、 FireWire（火线端口）或 USB。第二个字母 “d” 指的是 disk(硬盘)。第三个字母指的是设备序数，即字母 “a” 指的是第一个 SATA 而 “b” 指的是第二个。最后的数字代表分区。没有分区数字的设备名代表该设置的所有分区。对于上面的例子，对应的名称为 sda 。作为命名的第一个字母还可能是 “h” ，这对应 PATA 硬盘（IDE）。</p>
<p>以下为命名规律的一些例子。假如一个用户有一个 SATA 硬盘（sda），这个设备有 4 个分区- sda1、 sda2、 sda3 和 sda4 。该用户删除了第三个分区，但直到格式化第四个分区之前，第四个分区名 sda4 都将保留不变。然后该用户插入了一个带有一个分区 - 即sdb1- 的 usb 存储卡（sdb），又增加了一个带有一个分区 -hda1- 的 IDE 硬盘 ，接着该用户又增加了一个 SCSI 硬盘 - sdc1 。接着用户移除了 USB 存储卡（sdb）。</p>
<p>现在，SCSI 硬盘的名称仍然为 sdc，但如果这个 SCSI 被移除接着再被插入，则它的名称将变为 sdb。虽然还有其他的存储设备存在， 那个 IDE 硬盘的名称仍会有一个 “a”， 因为它是第一个 IDE 硬盘，IDE 设备的命名与 SCSI、 SATA、 FireWire 和 USB 设备要分开计数。</p>
<h3 id="使用-TestDisk-进行恢复"><a href="#使用-TestDisk-进行恢复" class="headerlink" title="使用 TestDisk 进行恢复"></a>使用 TestDisk 进行恢复</h3><hr>
<p>每个恢复软件有其不同的功能，特征及支持的不同文件系统。下面是一些关于 使用 TestDisk 在各种文件系统中恢复文件的指南。</p>
<h4 id="FAT16、-FAT32、-exFAT-FAT64-、-NTFS-以及-ext2-x2F-3-x2F-4"><a href="#FAT16、-FAT32、-exFAT-FAT64-、-NTFS-以及-ext2-x2F-3-x2F-4" class="headerlink" title="FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2&#x2F;3&#x2F;4"></a>FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2&#x2F;3&#x2F;4</h4><hr>
<p>TestDisk 是一个运行在 Linux、 *BSD、 SunOS、 Mac OS X、 DOS 和 Windows 等操作系统下的开源的自由软件。TestDisk 可以从下面的链接中找到 ：<a href="http://www.cgsecurity.org/wiki/TestDisk%E3%80%82">http://www.cgsecurity.org/wiki/TestDisk。</a></p>
<p>TestDisk 也可以通过键入 sudo apt-get install testdisk 来安装。TestDisk 有着许多的功能，但这篇文章将只关注恢复文件这个功能。</p>
<p>使用 root 权限从终端中打开 TestDisk 可以通过键入 sudo testdisk 命令。</p>
<p>现在， TestDisk 命令行应用将会被执行。终端的显示将会改变。TestDisk 询问用户它是否可以保留日志，这完全由用户决定。假如一个用户正从系统存储中恢复文件，则不必保留日志。可选择的选项有“生成”、 “追加” 和 “无日志”。假如用户想保留日志，则日志将会保留在该用户的主目录。</p>
<p><img src="https://img-blog.csdnimg.cn/c047f6168f1e452f9b92baa5c6dc5f23.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>在接着的屏幕中，存储设备以 &#x2F;dev&#x2F;*的方式被罗列出来。对于我的系统，系统的存储单元为 &#x2F;dev&#x2F;sda，这意味着我的存储单元为 一个 SATA硬盘（sd）且它是第一个硬盘（a）。每个存储单元的容量以 Gigabyte（千兆字节）为单位显示的。使用上下键来选择一个存储设备然后点击进入。</p>
<p><img src="https://img-blog.csdnimg.cn/140cda71ec1b410c9d617f35ba91287c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>下一屏显示出一个列有分区表（也叫做分区映射表）的清单。正如文件有文件配置表，分区有着分区表。分区是存储设备上的分段。例如在几乎所有的 Linux 系统中，至少存在两种分区类型 - EXT3&#x2F;4 和 Swap 。每一个分区表将会在下面被简要地描述。TestDisk 并不支持所有类型的分区表，所以这并不是完整的列表。</p>
<p><img src="https://img-blog.csdnimg.cn/62950034790e4e5083272cbd9a31ce7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>Intel - 这类分区表在 Windows 系统和许多的 Linux 系统中非常普遍，它也常常称作 MBR 分区表。</li>
<li>EFI GPT - 这种类型的分区表通常用在 Linux 系统中。对于 Linux 系统，这种分区表是最为推荐的， 因为逻辑分区或扩展分区的概念并不适用于 GPT (GUID Partition Table) 分区表。这意味着，如果每个分区中有一个 Linux 系统，一个 Linux 用户可以从多种类型的 Linux 系统中进行多重启动。当然使用 GPT 分区表还有其他的优势，但那些已超出了本文的讨论范围。</li>
<li>Humax - Humax 分区映射表适用于韩国公司 Humax 生产的设备。</li>
<li>Mac - Apple 分区映射表 (APM) 适用于 Apple 的设备。</li>
<li>None - 某些设备并没有分区表。例如，许多 Subor 游戏控制台不使用分区映射表。如果一个用户试图以其它分区表类型从这类设备中恢复文件，用户就会困扰 TestDisk 为何找卟到任何的文件系统或者文件。</li>
<li>Sun - Sun 分区表适用于 Sun 系统。</li>
<li>Xbox -Xbox 适用于使用 Xbox 分区映射表的存储设备。</li>
</ul>
<p>假如用户选择了 “Xbox” ，尽管他的系统使用了 GPT 分区表， 那么 TestDisk 将不能找到任何分区或文件系统。假如 TestDisk 按照用户的选择执行，则它可能猜测错误。（下面的图片显示的是当分区表类型错误时的输出）</p>
<p><img src="https://img-blog.csdnimg.cn/092a1c079ef246f5bde230683a775c3b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当用户为他们的设备选择了正确的选项，则在下一屏中，选择 “高级” 选项。</p>
<p><img src="https://img-blog.csdnimg.cn/bed55e8a8678409aa03477b50e828b3b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>现在，用户将看到一个列有用户存储设备中所有的文件系统或分区的列表。假如用户选择了错误的分区映射表，则在这一步中用户就将会知道他们做出了错误的选择。假如没有错误，通过移动文字光标来高亮选择含有被删除文件的分区。使用 左右键来高亮位于终端底部的 “列表”。接着，按下回车确认。</p>
<p><img src="https://img-blog.csdnimg.cn/e4bfc2c219f54f1da0c518c2fc54cdef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>新的一屏便会呈现出列有文件和目录的列表。那些白色的文件名就是未被删除的文件，而红色的文件名是那些已被删除的文件。最右边的一列是文件的名称，从右到左方向的接着一列是文件的创建日期，再往左的一列是文件的大小（以 byte&#x2F; 比特为单位），最左边带有“-”，“d” ,“r”, “w” 和”x”的一列则代表的是文件的权限情况。“d” 表示该文件为一个目录，其他的权限术语与本文关系不大。在列表的最顶端以“.”代表的一项表示当前目录，第二行以”…”代表的一项表示当前目录的上级目录，所以用户可以通过选择目录所在行到达该目录。</p>
<p><img src="https://img-blog.csdnimg.cn/02b737fd07f04dd08c1e128c0a7b72af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>举个例子，我想进入”Xaiml_Dataset” 目录，该目录基本上由被删除的文件组成。通过按键盘上的 “c”键，我将恢复文件 “computers.xaiml”，接着我被询问选择一个目标目录，当然，我应该放置该文件到另一个分区中。现在，当我在我的家目录时，按下了“c”键。（选择目标目录时）哪个目录被高亮并没有什么影响，当前目录就是目标目录，在屏幕的上方，将会显示“复制完成”的消息。在我的家目录中便会有一个名为”Xaiml_Dataset”的目录，里面里有一个 Xaiml 文件。假如我在更多的已删除文件上按“c” 键，则这些文件将会被放置到新的文件夹中而无需再向我询问目标目录。</p>
<p><img src="https://img-blog.csdnimg.cn/87d64b85308e4b37add8f6c186bdeb1a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当这些步骤完成后，重复按“q”键直到看到正常的终端模样。目录”Xaiml_Dataset” 只能被 root 用户访问。为了解决这个问题，使用 root 权限改变该目录及其子目录的权限。做完这些后，文件便被恢复了且用户可以访问它们。</p>
<h3 id="特别的-ReiserFS："><a href="#特别的-ReiserFS：" class="headerlink" title="特别的 ReiserFS："></a>特别的 ReiserFS：</h3><hr>
<p>为了从 ReiserFS 文件系统中恢复一个文件，首先需将分区中的所有文件做一个备份。因为如果发生某些错误， 这个方法可能会引起文件丢失。接着执行下面的命令，其中 DEVICE指的是那些以 sda2 形式命名的设备。一些文件将被放入 lost+found 目录而其他则会保存到原先被删除的位置。</p>
<p>reiserfsck –rebuild-tree –scan-whole-partition &#x2F;dev&#x2F;DEVICE</p>
<h3 id="恢复被某个程序打开的删除文件"><a href="#恢复被某个程序打开的删除文件" class="headerlink" title="恢复被某个程序打开的删除文件"></a>恢复被某个程序打开的删除文件</h3><hr>
<p>假设用户意外地删除了一个文件，且该文件被某个程序打开。虽然在硬盘中该文件被删除了，但这个程序正使用着位于 RAM 中的该文件的副本。幸好，我们有两种简单的解决方法来恢复该文件。</p>
<p>假如这个软件有保存功能，如文本编辑器，则用户可以重新保存该文件，这样，文本编辑器可以将该文件写入硬盘中。</p>
<p>假设在音乐播放器中有一个 MP3 文件，而该音乐播放器并不能保存该 MP3 文件，则这种情形下需要比先前花更多的时间来恢复文件。不幸的是，这种方法并不能保证在所有的系统和应用中有效。首先，键入下面的命令。</p>
<p>lsof -c smplayer  grep mp3</p>
<p>上面的命令会列出所有由 smplayer 使用的文件，这个列表由 grep 命令通过管道搜索 mp3 。命令的输入类似于下面：</p>
<p>smplayer  10037 collier  mp3    169r      8,1  676376  1704294 &#x2F;usr&#x2F;bin&#x2F;smplayer</p>
<p>现在，键入下面的命令来直接从 RAM（在 Linux 系统中，&#x2F;proc&#x2F;映射到 RAM）中恢复文件，并复制该文件到选定的文件夹中。其中 cp 指的是复制命令，输出中的数字 10037 来自于进程数，输出中的数字 169 指的是文件描述符，”~&#x2F;Music&#x2F;“为目标目录，最后的 “music.mp3” 为用户想恢复的文件的名称。</p>
<p>cp &#x2F;proc&#x2F;10037&#x2F;fd&#x2F;169 ~&#x2F;Music&#x2F;music.mp3</p>
<h3 id="真正的删除"><a href="#真正的删除" class="headerlink" title="真正的删除"></a>真正的删除</h3><hr>
<p>为确保一个文件不能被恢复，可以使用一个命令来 “擦除” 硬盘。擦除硬盘实际上是向硬盘中写入无意义的数据。例如，许多擦除程序向硬盘中写入零，随机字母或随机数据。不会有空间被占用或丢失，擦除程序只是对空位进行重写覆盖。假如存储单元被文件占满而没有空余空间，则所有先前被删除的文件将会消失而不能恢复。</p>
<p>擦除硬盘的目的是确保隐私数据不被他人看见。举个例子，一个公司可能预订了一些新的电脑，总经理决定将旧的电脑卖掉，然而，新的电脑拥有者可能会看到公司的一些机密或诸如信用卡号码，地址等顾客信息。幸好，公司的电脑技术人员可以在卖掉这些旧电脑之前，擦除这些硬盘。</p>
<p>为了安装擦除程序 secure-delete，键入 sudo apt-get install secure-delete，这个命令将会安装一个包含 4 个程序的程序集，用以确保被删除的文件不能被恢复。</p>
<ul>
<li>srm - 永久删除一个文件。使用方法：srm -f .&#x2F;secret_file.txt</li>
<li>sfill - 擦除空白空间。使用方法: sfill -f &#x2F;mount&#x2F;point&#x2F;of&#x2F;partition</li>
<li>sswap - 擦除 swap 空间。使用方法: sswap -f &#x2F;dev&#x2F;SWAP_DEVICE<br>假如电脑实际去清除那些删除的文件，那么就需要花费更长的时间去执行删除任务。将某些空间标记为空位是快速且容易的，但使得文件永远消失需要花费一定的时间。例如，擦除一个存储单元，可能需要花费几个小时的时间（根据磁盘容量大小）。</li>
</ul>
<p>总之，现在的系统工作的就挺好，因为即便用户清空了垃圾箱，他们仍然有另一次机会来改变他们当初的想法（或错误）。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>FAT32</tag>
        <tag>TestDisk</tag>
        <tag>恢复</tag>
        <tag>恢复数据</tag>
        <tag>误删除</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统切换 root 用户权限 管理 sudo</title>
    <url>/2021/10/18/linux-%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2-root-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90-%E7%AE%A1%E7%90%86-sudo/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-14.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>超级用户在操作系统管理中的作用</p>
<ol>
<li>可以对任何文件、目录或进程进行操作</li>
</ol>
<p>超级用户的操作是在系统最高许可范围内的操作，有些操作就是具有超级权限的root也无法完成。比如&#x2F;proc目录，&#x2F;proc是用来反应系统运行的实时状态信息的，因此即便是root也无法对其进行写操作。</p>
<ol start="2">
<li>对涉及系统全局的系统管理</li>
</ol>
<p>硬件管理、文件系统管理、用户管理以及涉及的系统全局配置等，如果执行某个指令或工具时，提示无权限，大多是需要超级权限来完成。比如用adduser来添加用户，这跟只能使用通过超级权限的用户来完成。</p>
<h3 id="普通用户授予root权限"><a href="#普通用户授予root权限" class="headerlink" title="普通用户授予root权限"></a>普通用户授予root权限</h3><hr>
<h4 id="1-su指令"><a href="#1-su指令" class="headerlink" title="1. su指令"></a>1. su指令</h4><hr>
<p>su是英文“switch user”的缩写，即切换用户。使用su指令切换到其他用户模式，提示输入密码时，该密码为切换后账户的密码，用法为：su 账户名称<br>如果后面不加账户时默认为root账户，密码也为超级账户的密码。没有时间限制。</p>
<h4 id="2-su指令使用条件"><a href="#2-su指令使用条件" class="headerlink" title="2. su指令使用条件"></a>2. su指令使用条件</h4><hr>
<p>su指令就是切换用户的工具，当前系统登录为普通用户handuoduo，但要完成添加用户任务，执行useradd指令后，提示普通用户handuoduo没有权限，而这跟权限恰恰由root所拥有。解决的办法有两个：</p>
<ol>
<li>退出handuoduo用户，重新以root用户登录，但这种办法并不是最好的。</li>
<li>不退出handuoduo用户，可以用su来切换到root下进行添加用户的工作，等任务完成后再退出root。</li>
</ol>
<p>我们可以看到当然通过su切换是一种比较好的办法。<br>通过su可以在用户之间切换，超级权限用户root向普通或虚拟用户切换不需要密码，而普通用户切换到其他任何用户都需要密码验证。</p>
<h4 id="3-su指令用法"><a href="#3-su指令用法" class="headerlink" title="3. su指令用法"></a>3. su指令用法</h4><hr>
<p>su指令常用的选项如下所示：</p>
<ul>
<li>-c, -command 执行相关指令，然后退出所切换到的用户环境</li>
<li>-l, -login 登录并改变到所切换的用户环境。</li>
</ul>
<p>关于su指令更详细的使用，可以参考man su</p>
<h4 id="4-su指令实例"><a href="#4-su指令实例" class="headerlink" title="4. su指令实例"></a>4. su指令实例</h4><hr>
<p>su指令在不加任何参数，默认为切换到root用户，但没有转到root用户主目录的情况下，也就是说这时虽然是切换为root用户了，但并没有改变root登录环境，即用户默认登录环境。可以在&#x2F;etc&#x2F;passwd中查到，包括主目录、shell定义等。</p>
<p>#普通用户切换到root用户$ whoamihanduoduo$ suPassword:$ whoamiroot</p>
<p>在上述代码中，普通用户模式下，直接输入su指令即可切换到root用户，su加参数“-”表示默认切换到root用户，并且改变到root用户的环境。</p>
<p># 普通用户切换到root用户并改变环境变量<br>$whoami<br>handuoduo<br>$ su<br>Password:<br>$ whoami<br>root<br>$ echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;home&#x2F;handuoduo&#x2F;bin<br>$ exit<br>exit<br>$ su -<br>Password:<br>$ whoami<br>root<br>$ echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin</p>
<p>su 指令加上 “-” 参数，目标用户的环境变量一起被切换，“su 参数 - 用户名”，下面代码和上述实例中的作用相同。</p>
<p>$whoami<br>handuoduo<br>$ su<br>Password:<br>$ whoami<br>root<br>$ echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;home&#x2F;handuoduo&#x2F;bin<br>$ exit<br>exit<br>$ su - root<br>Password:<br>$ whoami<br>root<br>$ echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin</p>
<p>“su - root”指令和“su -”功能相同。</p>
<h4 id="5-su-的优缺点"><a href="#5-su-的优缺点" class="headerlink" title="5. su 的优缺点"></a>5. su 的优缺点</h4><hr>
<p>su的确为管理带来方便，通过切换到root下，能完成所有系统管理工具。只要把root的密码交给任何一个普通用户，它都能切换到root来完成所有的系统管理工作。但通过su切换到root后，也有不安全因素，比如系统有10个用户，而且都参与管理。如果这10个用户都涉及超级权限的运用，作为管理员如果让其他用户通过su来切换到超级权限的root，必须把root权限密码都告诉这10个用户；如果这10个用户都有root权限，通过root权限可以做任何事，这在一定程度上就对系统的安全造成了威胁。</p>
<p>“没有不安全的系统，只有不安全的人”，我们不能保证这10个用户都能按正常操作流程来管理系统，这其中任何一个人对系统操作的重大失误，都可能导致系统崩溃或数据损失。所以su工具在多人参与的系统管理中，并不是最好的选择。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<ul>
<li>su - root 和 su root 指令的区别如下：</li>
<li>su指令后面不加用户是默认切换到root；</li>
<li>su指令不改变当前变量；</li>
<li>“su -”指令组合改变为切换到用户的变量；</li>
<li>su指令只能获得root的执行权限，不能获得环境变量；</li>
<li>“su -”指令组合是切换到root用户，并获得root用户的环境变量及执行权限。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>su</tag>
        <tag>sudo</tag>
        <tag>root</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上如何禁止用户登录？</title>
    <url>/2021/09/24/linux%E4%B8%8A%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-21-1024x548.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>默认情况下，Linux中创建用户帐户时，用户具有shell访问权限。在某些情况下不需要用户帐户登录shell。本文介绍如何设置已存在的用户禁止shell登录、创建用户时禁止shell登录。</p>
<h3 id="创建用户时设置禁止shell登录"><a href="#创建用户时设置禁止shell登录" class="headerlink" title="创建用户时设置禁止shell登录"></a>创建用户时设置禁止shell登录</h3><hr>
<p>默认情况下，创建用户时，将按照&#x2F;etc&#x2F;default&#x2F;useradd文件中定义的为用户分配shell。<br>Linux中附带了一个&#x2F;sbin&#x2F;nologinshell，当用户尝试连接时，它会显示一条消息“This account is current not available”。这是禁止用户登录shell的一种方法。下面是使用方式：</p>
<p>useradd -s &#x2F;sbin&#x2F;nologin {username}</p>
<p>下面实例，创建一个用户，shell设置为&#x2F;sbin&#x2F;nologin：</p>
<p>[<a href="mailto:&#114;&#111;&#x6f;&#116;&#x40;&#x63;&#x6f;&#x64;&#101;&#x34;&#x30;&#x34;&#x2e;&#105;&#x63;&#x75;">&#114;&#111;&#x6f;&#116;&#x40;&#x63;&#x6f;&#x64;&#101;&#x34;&#x30;&#x34;&#x2e;&#105;&#x63;&#x75;</a> ~]# useradd  -s &#x2F;sbin&#x2F;nologin test01<br>[<a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#99;&#111;&#x64;&#x65;&#52;&#x30;&#x34;&#46;&#x69;&#x63;&#117;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#99;&#111;&#x64;&#x65;&#52;&#x30;&#x34;&#46;&#x69;&#x63;&#117;</a> ~]# tail -1 &#x2F;etc&#x2F;passwd<br>test01:x:1001:1001::&#x2F;home&#x2F;test01:&#x2F;sbin&#x2F;nologin</p>
<p>查看 <strong>&#x2F;etc&#x2F;passwd</strong>可以看到<strong>test01</strong>的<strong>shell</strong>为 <strong>&#x2F;sbin&#x2F;nologin</strong><br><img src="https://img-blog.csdnimg.cn/0bd6e8c8ecfe4e62b64976d41886c817.png" alt="在这里插入图片描述"></p>
<p>给<strong>test01</strong>用户设置密码，然后<strong>ssh</strong>登录测试一下：</p>
<p>[<a href="mailto:&#x72;&#x6f;&#111;&#116;&#64;&#99;&#111;&#x64;&#101;&#52;&#48;&#x34;&#46;&#105;&#x63;&#x75;">&#x72;&#x6f;&#111;&#116;&#64;&#99;&#111;&#x64;&#101;&#52;&#48;&#x34;&#46;&#105;&#x63;&#x75;</a> ~]# echo ‘123’ passwd –stdin test01<br>Changing password for user test01.<br>passwd: all authentication tokens updated successfully.<br>[<a href="mailto:&#114;&#111;&#111;&#116;&#64;&#99;&#111;&#x64;&#x65;&#52;&#x30;&#x34;&#x2e;&#x69;&#x63;&#x75;">&#114;&#111;&#111;&#116;&#64;&#99;&#111;&#x64;&#x65;&#52;&#x30;&#x34;&#x2e;&#x69;&#x63;&#x75;</a> ~]# ssh test01@localhost<br>The authenticity of host ‘localhost (::1)’ can’t be established.<br>ED25519 key fingerprint is SHA256:m5Jq5lPu+cyabudG7fzf5E9A4QjKojGm9j3bAacIlTw.<br>This key is not known by any other names<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes<br>Warning: Permanently added ‘localhost’ (ED25519) to the list of known hosts.<br>test01@localhost’s password:<br>Last failed login: Thu Sep 23 13:55:10 CST 2021 from ::1 on ssh:notty<br>There was 1 failed login attempt since the last successful login.<br>This account is currently not available.<br>Connection to localhost closed.</p>
<p><img src="https://img-blog.csdnimg.cn/2d8cda8d167c4d08a1f8c0be55749976.png" alt="在这里插入图片描述"></p>
<p>输入密码之后，提示<strong>This account is current not available</strong>，然后连接就关闭了。</p>
<h3 id="为现有用户时设置禁止shell登录"><a href="#为现有用户时设置禁止shell登录" class="headerlink" title="为现有用户时设置禁止shell登录"></a>为现有用户时设置禁止shell登录</h3><hr>
<p>更改现有用户的shell，可以使用usermod和chsh两个命令来修改：<br><strong>chsh</strong>命令使用语法如下：</p>
<p>chsh -s &#x2F;sbin&#x2F;nologin {username}</p>
<p>下面修改<strong>user02</strong>用户的<strong>shell</strong>：</p>
<p># Centos8默认没有安装chsh，使用下面命令安装：<br>[<a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#99;&#x6f;&#x64;&#x65;&#52;&#x30;&#52;&#x2e;&#x69;&#x63;&#117;">&#114;&#x6f;&#111;&#x74;&#64;&#99;&#x6f;&#x64;&#x65;&#52;&#x30;&#52;&#x2e;&#x69;&#x63;&#117;</a> ~]# yum -y install util-linux-user<br>[<a href="mailto:&#x72;&#x6f;&#111;&#116;&#64;&#99;&#111;&#100;&#101;&#x34;&#x30;&#x34;&#46;&#105;&#99;&#x75;">&#x72;&#x6f;&#111;&#116;&#64;&#99;&#111;&#100;&#101;&#x34;&#x30;&#x34;&#46;&#105;&#99;&#x75;</a> ~]# useradd user02<br>[<a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#x40;&#x63;&#x6f;&#100;&#101;&#52;&#48;&#x34;&#46;&#105;&#x63;&#x75;">&#x72;&#x6f;&#x6f;&#x74;&#x40;&#x63;&#x6f;&#100;&#101;&#52;&#48;&#x34;&#46;&#105;&#x63;&#x75;</a> ~]# tail -1 &#x2F;etc&#x2F;passwd<br>user02:x:1002:1002::&#x2F;home&#x2F;user02:&#x2F;bin&#x2F;bash<br>[<a href="mailto:&#x72;&#111;&#111;&#x74;&#64;&#x63;&#111;&#x64;&#x65;&#x34;&#48;&#x34;&#x2e;&#105;&#x63;&#x75;">&#x72;&#111;&#111;&#x74;&#64;&#x63;&#111;&#x64;&#x65;&#x34;&#48;&#x34;&#x2e;&#105;&#x63;&#x75;</a> ~]# chsh -s &#x2F;sbin&#x2F;nologin user02<br>Changing shell for user02.<br>Shell changed.<br>[<a href="mailto:&#x72;&#x6f;&#111;&#x74;&#x40;&#99;&#x6f;&#100;&#101;&#x34;&#48;&#x34;&#x2e;&#x69;&#99;&#117;">&#x72;&#x6f;&#111;&#x74;&#x40;&#99;&#x6f;&#100;&#101;&#x34;&#48;&#x34;&#x2e;&#x69;&#99;&#117;</a> ~]# tail -1 &#x2F;etc&#x2F;passwd<br>user02:x:1002:1002::&#x2F;home&#x2F;user02:&#x2F;sbin&#x2F;nologin</p>
<p><img src="https://img-blog.csdnimg.cn/87215b368559423f81e8b77da7326966.png" alt="在这里插入图片描述"></p>
<p>usermod命令使用语法如下：</p>
<p>usermod -s &#x2F;sbin&#x2F;nologin {username} </p>
<p>下面修改user03用户的shell：</p>
<p>[<a href="mailto:&#114;&#111;&#x6f;&#116;&#64;&#x63;&#x6f;&#x64;&#x65;&#x34;&#x30;&#x34;&#46;&#x69;&#99;&#x75;">&#114;&#111;&#x6f;&#116;&#64;&#x63;&#x6f;&#x64;&#x65;&#x34;&#x30;&#x34;&#46;&#x69;&#99;&#x75;</a> ~]# useradd user04<br>[<a href="mailto:&#x72;&#111;&#x6f;&#116;&#64;&#99;&#111;&#x64;&#x65;&#x34;&#48;&#52;&#x2e;&#x69;&#99;&#x75;">&#x72;&#111;&#x6f;&#116;&#64;&#99;&#111;&#x64;&#x65;&#x34;&#48;&#52;&#x2e;&#x69;&#99;&#x75;</a> ~]# tail -1 &#x2F;etc&#x2F;passwd<br>user04:x:1004:1004::&#x2F;home&#x2F;user04:&#x2F;bin&#x2F;bash<br>[<a href="mailto:&#x72;&#x6f;&#111;&#x74;&#x40;&#x63;&#x6f;&#x64;&#101;&#52;&#x30;&#52;&#x2e;&#x69;&#x63;&#117;">&#x72;&#x6f;&#111;&#x74;&#x40;&#x63;&#x6f;&#x64;&#101;&#52;&#x30;&#52;&#x2e;&#x69;&#x63;&#117;</a> ~]# usermod -s &#x2F;sbin&#x2F;nologin user04<br>[<a href="mailto:&#114;&#111;&#111;&#116;&#64;&#99;&#111;&#100;&#101;&#52;&#48;&#x34;&#46;&#105;&#99;&#x75;">&#114;&#111;&#111;&#116;&#64;&#99;&#111;&#100;&#101;&#52;&#48;&#x34;&#46;&#105;&#99;&#x75;</a> ~]# tail -1 &#x2F;etc&#x2F;passwd<br>user04:x:1004:1004::&#x2F;home&#x2F;user04:&#x2F;sbin&#x2F;nologin</p>
<p><img src="https://img-blog.csdnimg.cn/eaa08bc1a6334705adf8888e8e2155a3.png" alt="在这里插入图片描述"></p>
<p>也可以手动修改&#x2F;etc&#x2F;passwd文件中的用户shell。</p>
<h3 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h3><hr>
<p>在本教程中讲述了如何禁止用户访问默认Shell。希望对你有帮助！</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>用户</tag>
        <tag>nologin</tag>
        <tag>禁止登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Tomcat和nginx日志切割轮转</title>
    <url>/2021/04/30/linux%E4%B8%8Btomcat%E5%92%8Cnginx%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E8%BD%AE%E8%BD%AC/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-42-1024x549.png"></p>
<p>程序在运行的时候为了了解运行状态，会输出日志文件，时间久了日志文件会变得非常大，每次在监控上看到磁盘空间都要满了，还需要手动清理，非常的麻烦。为此下面介绍一款强大的系统软件，对日志文件有着一套完整的操作模式。</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-41.png"></p>
<h2 id="logrotate功能简单介绍："><a href="#logrotate功能简单介绍：" class="headerlink" title="logrotate功能简单介绍："></a>logrotate功能简单介绍：</h2><hr>
<p>1、把旧的日志文件删除，并创建新的日志文件。<br>2、可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 cron 程序来执行。<br><code>默认logrotate加到cron（/etc/cron.daily/logrotate）作为每日任务执行。 通过让用户来配置规则的方式，检测和处理日志文件。 并且可以配合Cron处理定时任务。 预制了大量判断条件和处理方式。</code></p>
<h2 id="下面举例说明"><a href="#下面举例说明" class="headerlink" title="下面举例说明"></a>下面举例说明</h2><hr>
<h3 id="上配置"><a href="#上配置" class="headerlink" title="上配置"></a>上配置</h3><p>logrotate的主配置在 <code>/etc/logrotate.conf</code>，在主配置文件内会引入 <code>/etc/logrotate.d</code> 配置目录<br>一般来说我们只需要把自己的配置文件放到<code>/etc/logrotate.d/</code>下面就可以了</p>
<p>[root@NEWCWS-AS06 logrotate.d]# cat &#x2F;etc&#x2F;logrotate.d&#x2F;tomcat<br>&#x2F;data&#x2F;tomcat-*&#x2F;logs&#x2F;catalina.out{<br>    daily<br>    size 500M<br>    rotate 7<br>    missingok<br>    copytruncate<br>    create 644 root root<br>    dateext<br>    notifempty<br>    compress<br>}</p>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>daily # 每天分割<br>size 500M # 日志文件大于500M才会去轮转<br>rotate 7 # 保留最近7次轮转的日志<br>missingok # 如果日志文件丢失,不要显示错误<br>copytruncate #用于还在打开中的日志文件,把当前日志备份并截断<br>create 644 root root # 使用指定的文件模式创建新的日志文件，创建的轮转文件权限<br>dateext # 轮询的文件名字带有日期信息<br>notifempty # 如果日志文件为空，则不转储<br>compress #通过gzip压缩转储以后的日志,以*.gz结尾</p>
<h2 id="测试一下轮转"><a href="#测试一下轮转" class="headerlink" title="测试一下轮转"></a>测试一下轮转</h2><hr>
<p>[root@k8s-master01 logrotate.d]# logrotate &#x2F;etc&#x2F;logrotate.d&#x2F;tomcat<br>[root@k8s-master01 logrotate]# ls &#x2F;data&#x2F;tomcat-document-aggregation&#x2F;logs&#x2F;catalina.out* -l<br>-rw-r—– 1 root root   4401613 4月  29 09:19 &#x2F;data&#x2F;tomcat-document-aggregation&#x2F;logs&#x2F;catalina.out<br>-rw-r—– 1 root root 385944620 4月  29 08:43 &#x2F;data&#x2F;tomcat-document-aggregation&#x2F;logs&#x2F;catalina.out-20210429.gz</p>
<p>OK。配置文件没有问题</p>
<p>下面我们看一下crond服务配置</p>
<p>[root@k8s-master01 ~]# cat &#x2F;etc&#x2F;cron.daily&#x2F;logrotate<br>#!&#x2F;bin&#x2F;sh</p>
<p>&#x2F;usr&#x2F;sbin&#x2F;logrotate &#x2F;etc&#x2F;logrotate.conf<br>EXITVALUE&#x3D;$?<br>if [ $EXITVALUE !&#x3D; 0 ]; then<br>    &#x2F;usr&#x2F;bin&#x2F;logger -t logrotate “ALERT exited abnormally with [$EXITVALUE]“<br>fi<br>exit $EXITVALUE<br>[root@k8s-master01 ~]#<br>[root@k8s-master01 ~]# systemctl status crond<br>● crond.service - Command Scheduler<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;crond.service; enabled; vendor preset: enabled)<br>   Active: active (running) since Mon 2021-04-26 14:52:20 CST; 2 days ago<br> Main PID: 1503 (crond)<br>    Tasks: 1 (limit: 99475)<br>   Memory: 8.5M<br>   CGroup: &#x2F;system.slice&#x2F;crond.service<br>           └─1503 &#x2F;usr&#x2F;sbin&#x2F;crond -n</p>
<p>4月 29 03:01:01 k8s-master01 anacron[3213759]: Jobs will be executed sequentially<br>4月 29 03:46:01 k8s-master01 anacron[3213759]: Job `cron.daily’ started<br>4月 29 03:46:01 k8s-master01 anacron[3213759]: Job `cron.daily’ terminated<br>4月 29 03:46:01 k8s-master01 anacron[3213759]: Normal exit (1 job run)<br>4月 29 04:01:01 k8s-master01 CROND[3266006]: (root) CMD (run-parts &#x2F;etc&#x2F;cron.hourly)<br>4月 29 05:01:01 k8s-master01 CROND[3318305]: (root) CMD (run-parts &#x2F;etc&#x2F;cron.hourly)<br>4月 29 06:01:01 k8s-master01 CROND[3370655]: (root) CMD (run-parts &#x2F;etc&#x2F;cron.hourly)<br>4月 29 07:01:01 k8s-master01 CROND[3422976]: (root) CMD (run-parts &#x2F;etc&#x2F;cron.hourly)<br>4月 29 08:01:01 k8s-master01 CROND[3475277]: (root) CMD (run-parts &#x2F;etc&#x2F;cron.hourly)<br>4月 29 09:01:01 k8s-master01 CROND[3527598]: (root) CMD (run-parts &#x2F;etc&#x2F;cron.hourly)</p>
<p>crond在运行中，到这里就可以了配置成功，等明天上班看一下效果</p>
<h2 id="全部配置说明"><a href="#全部配置说明" class="headerlink" title="全部配置说明"></a>全部配置说明</h2><p>有需要自己选用，但我们项目上面配置已够用</p>
<p>daily,weekly,monthly  # 转储周期分别是每天&#x2F;每周&#x2F;每月;<br>minsize 15M           # 日志体积大于此值时轮换(例如:100K,4M);<br>dateext              # 轮询的文件名字带有日期信息;<br>missingok             # 如果日志文件丢失,不要显示错误;<br>rotate 5              # 轮转存储中包含多少备份日志文件,0为无备份,以数字为准;<br>compress              # 通过gzip压缩转储以后的日志,以*.gz结尾;<br>nocompress            # 不需要压缩时,用这个参数;<br>delaycompress         # 延迟压缩,和compress一起使用时压缩所有日志,除当前和下一个最近的;<br>nodelaycompress       # 覆盖delaycompress选项，转储同时压缩;<br>copytruncate          # 用于还在打开中的日志文件,把当前日志备份并截断;<br>nocopytruncate        # 备份日志文件但是不截断;<br>create 644 www root   # 转储文件,使用指定的文件模式创建新的日志文件;<br>nocreate              # 不建立新的日志文件;<br>errors <a href="mailto:&#114;&#x65;&#110;&#119;&#111;&#108;&#x65;&#x40;&#x6d;&#x79;&#x2e;&#x6f;&#114;&#103;">&#114;&#x65;&#110;&#119;&#111;&#108;&#x65;&#x40;&#x6d;&#x79;&#x2e;&#x6f;&#114;&#103;</a> # 专储时的错误信息发送到指定的Email地址;<br>ifempty               # 即使是空文件也转储，这个是logrotate的缺省选项；<br>notifempty            # 如果日志文件为空，则不转储;<br>mail <a href="mailto:&#x72;&#x65;&#110;&#119;&#111;&#x6c;&#x65;&#x40;&#x6d;&#x79;&#x2e;&#111;&#x72;&#103;">&#x72;&#x65;&#110;&#119;&#111;&#x6c;&#x65;&#x40;&#x6d;&#x79;&#x2e;&#111;&#x72;&#103;</a>   # 把转储的日志文件发送到指定的E-mail地;<br>nomail                # 转储时不发送日志文件;<br>olddir &#x2F;tmp           # 转储后的日志文件放入指定目录,必须和当前日志文件在同一个文件系统;<br>noolddir              # 转储后的日志文件和当前日志文件放在同一个目录下;<br>prerotate&#x2F;endscript   # 在转储以前需要执行的命令可以放入这个对,这两个关键字必须单独成行;<br>postrotate&#x2F;endscript  # 在转储以后需要执行的命令可以放入这个对,这两个关键字必须单独成行;<br>tabooext              # 不转储指定扩展名的文件,缺省扩展名：cfsaved,.disabled,.dpkg-dist等;<br>sharedscripts         # 共享脚本,让postrotate&#x2F;endscript包含脚本只执行一次即可;<br>dateformat            # 配合dateext使用可以为切割后的日志加上YYYYMMDD格式的日期;</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>nginx</tag>
        <tag>日志切割</tag>
        <tag>日志轮转</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中wall向所有在线用户发送广播消息</title>
    <url>/2021/12/24/linux%E4%B8%ADwall%E5%90%91%E6%89%80%E6%9C%89%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-16.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>通常，系统管理员发送消息以宣布维护，并要求用户注销并关闭所有打开的程序。在终端打开的情况下，消息将显示给所有登录用户。使用没有终端打开的图形桌面环境的用户将看不到该消息。</p>
<p>wall是一个命令行程序，可在所有已登录用户的终端上显示一条消息。可以在终端上键入消息，也可以在文件内容中读取消息。wall 代表全部写入，使用write命令仅向特定用户发送消息。每个用户都可以使用 mesg 程序控制对其终端的写访问。超级用户调用wall命令时，无论其mesg设置如何，所有用户都会收到消息。</p>
<h3 id="发送广播消息"><a href="#发送广播消息" class="headerlink" title="发送广播消息"></a>发送广播消息</h3><hr>
<p>wall命令的语法如下：</p>
<p>wall [OPTIONS] [<FILE><MESSAGE>]</p>
<p>如果未指定文件，则wall从标准输入中读取消息。</p>
<p>广播消息的最直接方法是使用消息作为参数来调用wall命令：</p>
<p>wall “The system will be restarted in 10 minutes.”</p>
<p>Broadcast message from root@rumenz (pts&#x2F;0) (Sat Dec 25 21:11:39 2021):<br>The system will be restarted in 10 minutes.</p>
<p>该消息将广播给当前登录的所有用户。</p>
<p>要查看所有已登录用户，请运行 w 或 who 命令。</p>
<p>要隐藏横幅并仅显示您输入的文本给登录用户，请使用-n（–nobanner）选项调用命令：</p>
<p>wall -n “The system will be restarted in 10 minutes.”</p>
<p>The system will be restarted in 10 minutes.</p>
<p>如果要编写多行消息，请在不带参数的情况下调用命令：</p>
<p>wall</p>
<p>wall命令将等待您输入文本。输入完信息后，请按Ctrl+D结束程序并广播信息。</p>
<p>您也可以使用here doc or here-string重定向或将另一个命令的输出通过管道传递到wall。<br>这是显示如何使用 echo 命令广播多行消息的示例：</p>
<p>echo “The system will be restarted in 10 minutes. \\nPlease save your work.”   wall</p>
<h3 id="发送广播文件中的消息"><a href="#发送广播文件中的消息" class="headerlink" title="发送广播文件中的消息"></a>发送广播文件中的消息</h3><p>如果您要定期发送相同的邮件，则可以将其中的每一封邮件都写入一个文件，这样就无需重新输入相同的文本。wall仅当以root身份调用时才从文件读取。</p>
<p>要广播文件的内容，请调用wall命令，后跟文件名：</p>
<p>vim message1_file.txt<br>The system will be restarted in 10 minutes.</p>
<p>wall message1_file.txt</p>
<p>Broadcast message from root@rumenz (pts&#x2F;0) (Sat Dec 25 21:11:39 2021):<br>The system will be restarted in 10 minutes.</p>
<h3 id="向群组中发送广播消息"><a href="#向群组中发送广播消息" class="headerlink" title="向群组中发送广播消息"></a>向群组中发送广播消息</h3><hr>
<p>要仅向给定组的成员发送消息，请运行带有-g（–group）选项的命令，然后输入组名。例如，要只在 devs组的成员的终端上写，可以运行：</p>
<p>wall -g devs “The system will be restarted in 10 minutes.”</p>
<p>也可以通过其GID（组ID）指定该组。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wall</tag>
        <tag>发送广播</tag>
        <tag>发送消息</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用usermod修改用户主目录</title>
    <url>/2021/11/21/linux%E4%BD%BF%E7%94%A8usermod%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%B8%BB%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-12.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>创建用户帐户后，在一些需要更改现有用户属性的场景中，例如更改用户的主目录、登录名、登录 shell、密码到期日期等，在这种情况下使用 usermod 命令。</p>
<p>当我们在终端中执行 usermod 命令时，会使用和影响以下文件。</p>
<ul>
<li>&#x2F;etc&#x2F;passwd– 用户帐户信息。</li>
<li>&#x2F;etc&#x2F;shadow– 帐户密码信息。</li>
<li>&#x2F;etc&#x2F;group– 组帐户信息。</li>
<li>&#x2F;etc&#x2F;gshadow– 组密码信息。</li>
<li>&#x2F;etc&#x2F;login.defs– 是设置用户帐号限制的文件。该文件里的配置对root用户无效。</li>
</ul>
<h3 id="usermod命令的基本语法是"><a href="#usermod命令的基本语法是" class="headerlink" title="usermod命令的基本语法是"></a>usermod命令的基本语法是</h3><hr>
<p>usermod [options] username</p>
<h3 id="usermod要求"><a href="#usermod要求" class="headerlink" title="usermod要求"></a>usermod要求</h3><hr>
<p>我们必须有现有的用户帐户才能执行 usermod 命令。<br>只允许超级用户（root）执行 usermod 命令。<br>usermod 命令可以在任何 Linux 发行版上执行。<br>必须具有带选项的 usermod 命令的基本知识</p>
<h3 id="usermod-的选项"><a href="#usermod-的选项" class="headerlink" title="usermod 的选项"></a>usermod 的选项</h3><hr>
<p>这 usermod 命令使用起来很简单，有很多选项可以对现有用户进行更改。让我们通过以下选项的帮助，通过修改 Linux box 中的一些现有用户来看看如何使用 usermod 命令。</p>
<ul>
<li>-c&#x3D; 我们可以为用户帐户添加评论字段。</li>
<li>-d&#x3D; 修改任何现有用户帐户的目录。</li>
<li>-e&#x3D; 使用此选项，我们可以使帐户在特定时期到期。</li>
<li>-g&#x3D; 更改用户的主要组。</li>
<li>-G&#x3D; 添加补充组。</li>
<li>-a&#x3D; 将组中的任何人添加到辅助组。</li>
<li>-l&#x3D; 将登录名从 rumenz 更改为 rumenz_admin。</li>
<li>-L&#x3D; 锁定用户帐户。这将锁定密码，因此我们无法使用该帐户。</li>
<li>-m&#x3D; 将主目录的内容从现有主目录移动到新目录。</li>
<li>-p&#x3D; 使用未加密的密码作为新密码。（不安全）。</li>
<li>-s&#x3D; 为新帐户创建一个指定的 shell。</li>
<li>-u&#x3D; 用于为 0 到 999 之间的用户帐户分配 UID。</li>
<li>-U&#x3D; 解锁用户帐户。这将删除密码锁并允许我们使用用户帐户。</li>
</ul>
<h3 id="1-向用户账户添加信息"><a href="#1-向用户账户添加信息" class="headerlink" title="1. 向用户账户添加信息"></a>1. 向用户账户添加信息</h3><hr>
<p>-c 选项用于设置关于用户帐户的简短备注。例如添加有关的信息rumenz 用户，使用以下命令。</p>
<p>usermod -c “This is rumenz” rumenz</p>
<p>添加用户信息后，相同的评论可以在&#x2F;etc&#x2F;passwd文件。</p>
<p>grep -E –color ‘rumenz’ &#x2F;etc&#x2F;passwd<br>rumenz:x:500:500:This is rumenz:&#x2F;home&#x2F;rumenz:&#x2F;bin&#x2F;sh</p>
<h3 id="2-更改用户主目录"><a href="#2-更改用户主目录" class="headerlink" title="2. 更改用户主目录"></a>2. 更改用户主目录</h3><hr>
<p>在上面的步骤中,我们可以看到我们的主目录在&#x2F;home&#x2F;rumenz&#x2F;下，如果我们需要将其更改为其他目录，我们可以使用-d选项和 usermod 命令来更改它。</p>
<p>例如，我想将我们的主目录更改为&#x2F;var&#x2F;www&#x2F;，但在更改之前，让我们使用以下命令检查用户的当前主目录。</p>
<p>grep -E –color ‘&#x2F;home&#x2F;rumenz’ &#x2F;etc&#x2F;passwd<br>rumenz:x:500:500:This is rumenz:&#x2F;home&#x2F;rumenz:&#x2F;bin&#x2F;sh</p>
<p>现在，将主目录从&#x2F;home&#x2F;rumenz到&#x2F;var&#x2F;www&#x2F;并在更改后确认主控制器。</p>
<p>usermod -d &#x2F;var&#x2F;www&#x2F; rumenz<br>grep -E –color ‘&#x2F;var&#x2F;www&#x2F;‘ &#x2F;etc&#x2F;passwd<br>rumenz:x:500:500:This is rumenz:&#x2F;var&#x2F;www:&#x2F;bin&#x2F;sh</p>
<h3 id="3-设置用户账户到期日"><a href="#3-设置用户账户到期日" class="headerlink" title="3. 设置用户账户到期日"></a>3. 设置用户账户到期日</h3><hr>
<p>选项 -e 用于在具有日期格式的用户帐户上设置到期日期YYYY-MM-DD.在为用户设置到期日期之前，让我们首先使用检查当前帐户的到期状态chage(更改用户密码到期信息)命令。</p>
<p>chage -l rumenz</p>
<p>Last password change     : Nov 02, 2014<br>Password expires     : never<br>Password inactive     : never<br>Account expires      : Dec 01, 2014<br>Minimum number of days between password change  : 0<br>Maximum number of days between password change  : 99999<br>Number of days of warning before password expires : 7</p>
<p>到期状态rumenz 用户是2021 年 12 月 1 日，将其更改为2021 年 11 月 1 日 usermod -e选项并用确认到期日期chage 命令。</p>
<p>usermod -e 2014-11-01 rumenz<br>chage -l rumenz</p>
<p>Last password change     : Nov 02, 2021<br>Password expires     : never<br>Password inactive     : never<br>Account expires      : Nov 01, 2021<br>Minimum number of days between password change  : 0<br>Maximum number of days between password change  : 99999<br>Number of days of warning before password expires : 7</p>
<h3 id="4-更改用户主要组"><a href="#4-更改用户主要组" class="headerlink" title="4. 更改用户主要组"></a>4. 更改用户主要组</h3><hr>
<p>要设置或更改用户主要组，我们使用选项 -g 使用 usermod 命令。在更改用户主要组之前，首先确保检查用户rumenz_test的当前组。</p>
<p>id rumenz_test<br>uid&#x3D;501(rumenz_test) gid&#x3D;502(rumenz_test) groups&#x3D;502(rumenz_test)</p>
<p>现在，将babin组设置为用户rumenz_test的主要组并确认更改。</p>
<p>usermod -g babin rumenz_test<br>id rumenz_test</p>
<p>uid&#x3D;501(rumenz_test) gid&#x3D;502(babin) groups&#x3D;502(rumenz_test)</p>
<h3 id="5-向现有用户添加组"><a href="#5-向现有用户添加组" class="headerlink" title="5. 向现有用户添加组"></a>5. 向现有用户添加组</h3><hr>
<p>如果您想添加一个名为rumenz_test0的新组到rumenz用户，您可以使用选项-G 使用 usermod 命令，如下所示。</p>
<p>usermod -G rumenz_test0 rumenz<br>id rumenz</p>
<p>将组添加到用户</p>
<p>Note: 在向现有用户添加新组时使用 -G单独选项，将删除用户所属的所有现有组。所以，总是添加 -a（附加）与-G 添加或追加新组的选项。</p>
<h3 id="6-为用户添加补充组和主组"><a href="#6-为用户添加补充组和主组" class="headerlink" title="6. 为用户添加补充组和主组"></a>6. 为用户添加补充组和主组</h3><hr>
<p>如果您需要将用户添加到任何一个补充组，您可以使用选项 -a和-G。例如，这里我们要添加一个用户帐户rumenz_test0与wheel用户。</p>
<p>usermod -a -G wheel rumenz_test0<br>id rumenz_test0</p>
<p>因此，用户rumenz_test0保留在其主要组和次要组中（wheel）。这将使我的普通用户帐户在 Linux 框中执行任何 root 特权命令。</p>
<p>eg : sudo service httpd restart</p>
<h3 id="7-更改用户登录名"><a href="#7-更改用户登录名" class="headerlink" title="7. 更改用户登录名"></a>7. 更改用户登录名</h3><hr>
<p>要更改任何现有的用户登录名，我们可以使用 -l(帐号名称)选项。在下面的示例中，我们更改登录名rumenz到rumenz_admin.所以用户名rumenz已使用新名称重命名rumenz_admin.</p>
<p>usermod -l rumenz_admin rumenz</p>
<p>现在检查rumenz用户，它将不存在，因为我们已将其更改为rumenz_admin.</p>
<p>id rumenz</p>
<p>检查rumenz_admin帐户它将以相同的方式存在UID以及我们之前添加的现有组。</p>
<p>id rumenz_admin</p>
<h3 id="8-锁定用户账户"><a href="#8-锁定用户账户" class="headerlink" title="8. 锁定用户账户"></a>8. 锁定用户账户</h3><hr>
<p>要锁定任何系统用户帐户，我们可以使用 -L(锁定)选项，帐户被锁定后我们无法使用密码登录，你将看到一个``在加密密码之前添加&#x2F;etc&#x2F;shadow文件，表示禁用密码。</p>
<p>usermod -L babin</p>
<p>检查锁定的帐户。</p>
<p>grep -E –color ‘babin’ cat &#x2F;etc&#x2F;shadow</p>
<h3 id="9-解锁用户账户"><a href="#9-解锁用户账户" class="headerlink" title="9. 解锁用户账户"></a>9. 解锁用户账户</h3><hr>
<p>这 -U 选项用于解锁任何锁定的用户，这将删除!在加密密码之前。</p>
<p>grep -E –color ‘babin’ &#x2F;etc&#x2F;shadow<br>usermod -U babin</p>
<p>解锁后验证用户。</p>
<p>grep -E –color ‘babin’ &#x2F;etc&#x2F;shadow</p>
<p>解锁用户帐户</p>
<h3 id="10-将用户主目录移动到新位置"><a href="#10-将用户主目录移动到新位置" class="headerlink" title="10. 将用户主目录移动到新位置"></a>10. 将用户主目录移动到新位置</h3><hr>
<p>可以使用选项 -d和-m 将现有用户文件从当前主目录移动到新的主目录。</p>
<p>检查帐户及其当前主目录。</p>
<p>grep -E –color ‘pinky’ &#x2F;etc&#x2F;passwd</p>
<p>然后列出用户拥有的文件。</p>
<p>ls -l &#x2F;home&#x2F;pinky&#x2F;</p>
<p>现在我们必须将主目录从&#x2F;home&#x2F;pinky到&#x2F;var&#x2F;pinky.</p>
<p>usermod -d &#x2F;var&#x2F;pinky&#x2F; -m pinky</p>
<p>接下来，验证目录更改。</p>
<p>grep -E –color ‘pinky’ &#x2F;etc&#x2F;passwd</p>
<p>检查下的文件&#x2F;home&#x2F;pinky。在这里，我们使用了移动文件-m选项，所以不会有文件。小指用户文件现在位于&#x2F;var&#x2F;pinky.</p>
<p>ls -l &#x2F;home&#x2F;pinky&#x2F;<br>ls -l &#x2F;var&#x2F;pinky&#x2F;</p>
<p>移动用户主目录</p>
<h3 id="11-为用户创建未加密的密码"><a href="#11-为用户创建未加密的密码" class="headerlink" title="11. 为用户创建未加密的密码"></a>11. 为用户创建未加密的密码</h3><hr>
<p>要创建未加密的密码，我们使用选项 -p (密码)。出于演示目的，我正在设置一个新密码，例如 redhat 对用户pinky.</p>
<p>usermod -p redhat pinky</p>
<p>设置密码后，现在检查影子文件，看看它是加密格式还是未加密格式。</p>
<p>grep -E –color ‘pinky’ &#x2F;etc&#x2F;shadow</p>
<h3 id="12-更改用户shell"><a href="#12-更改用户shell" class="headerlink" title="12. 更改用户shell"></a>12. 更改用户shell</h3><hr>
<p>用户登录shell可以在用户创建期间更改或定义useradd命令或更改为 usermod命令使用选项-s （shell）。例如，用户 babin 有&#x2F;bin&#x2F;bashshell 默认情况下，现在我想将其更改为&#x2F;bin&#x2F;sh.</p>
<p>grep -E –color ‘babin’ &#x2F;etc&#x2F;passwd<br>usermod -s &#x2F;bin&#x2F;sh babin</p>
<p>更改用户shell后，使用以下命令验证用户shell。</p>
<p>grep -E –color ‘babin’ &#x2F;etc&#x2F;passwd</p>
<p>更改用户登录shell</p>
<h3 id="13-更改用户-ID-UID"><a href="#13-更改用户-ID-UID" class="headerlink" title="13. 更改用户 ID (UID)"></a>13. 更改用户 ID (UID)</h3><hr>
<p>在下面的示例中，您可以看到我的用户帐户 babin 持有的 UID502，现在我想把它改成888作为我的 UID。我们可以在之间分配 UID0到999.</p>
<p>grep -E –color ‘babin’ &#x2F;etc&#x2F;passwd<br>OR<br>id babin</p>
<p>现在，让我们更改用户的 UIDbabin使用 -u (uid) 选项并验证更改。</p>
<p>usermod -u 888 babin<br>id babin</p>
<p>更改用户 UID</p>
<h3 id="14-使用多个选项修改用户帐户"><a href="#14-使用多个选项修改用户帐户" class="headerlink" title="14. 使用多个选项修改用户帐户"></a>14. 使用多个选项修改用户帐户</h3><hr>
<p>这里我们有一个用户rumenz，现在我想使用一个带有我们上面讨论的所有选项的单个命令一次修改他的主目录、shell、到期日期、标签、UID 和组。</p>
<p>用户rumenz的默认主目录为&#x2F;home&#x2F;rumenz，现在我想将其更改为&#x2F;var&#x2F;www&#x2F;html并将其 shell 指定为bash，将到期日期设置为 2021 年 12 月 10 日，添加新标签为This is rumenz，更改 UID 到 555，改到deploy组。</p>
<p>现在让我们看看如何使用多个选项修改 rumenz 帐户。</p>
<p>usermod -d &#x2F;var&#x2F;www&#x2F;html&#x2F; -s &#x2F;bin&#x2F;bash -e 2021-12-10 -c “This is rumenz” -u 555 -aG deploy rumenz</p>
<p>然后检查 UID 和主目录更改。</p>
<p>grep -E –color ‘rumenz’ &#x2F;etc&#x2F;passwd</p>
<p>帐户过期检查。</p>
<p>chage -l rumenz</p>
<p>检查所有 rumenz 都加入的组。</p>
<p>grep -E –color ‘rumenz’ &#x2F;etc&#x2F;group</p>
<p>对 usermod 使用多个选项</p>
<h3 id="15-更改用户的-UID-和-GID"><a href="#15-更改用户的-UID-和-GID" class="headerlink" title="15. 更改用户的 UID 和 GID"></a>15. 更改用户的 UID 和 GID</h3><hr>
<p>我们可以更改当前用户的 UID 和 GID。要更改为新 GID，我们需要一个现有组。这里已经有一个名为orange的帐户，其 GID 为777。</p>
<p>现在，我的 rumenz 用户帐户要分配给666 的UID和 Orange (777) 的GID。</p>
<p>在修改之前检查当前的 UID 和 GID。</p>
<p>id rumenz</p>
<p>修改 UID 和 GID。</p>
<p>usermod -u 666 -g 777 rumenz</p>
<p>检查更改。</p>
<p>id rumenz</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>用户</tag>
        <tag>usermod</tag>
        <tag>修改</tag>
      </tags>
  </entry>
  <entry>
    <title>linux创建大文件dd_yes_fallocate_truncate</title>
    <url>/2021/10/08/linux%E5%88%9B%E5%BB%BA%E5%A4%A7%E6%96%87%E4%BB%B6dd-yes-fallocate-truncate/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-4.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在我们日常工作中，为了验证开发的功能，比如：文件上传功能或者算法的处理效率等，经常需要一些大文件进行测试，有时在四处找了一顿之后，发现竟然没有一个合适的，虽然 Linux 中也有一些命令比如：vim、touch 等可以创建文件，但是如果需要一个 100G 或者 1T 的大文件，这些命令就显得力不从心，此时就需要能快速创建大文件命令，接下来将介绍这些命令的常见用法、命令之间的差异、以及使用时如何选择</p>
<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><hr>
<p>dd 命令的语法如下</p>
<p>dd if&#x3D;[source] of&#x3D;[destination] bs&#x3D;[block-size] count&#x3D;[counter]</p>
<p>从 source 读取并拷贝内容到 destination， source 和 destination 都是文件，前者是读取的文件，后者是写入的文件</p>
<p>bs 表示块的大小，单位是字节，后缀中带了字母 B的换算单位都是 1000, 比如: 1KB &#x3D; 1000 Bytes、 1MB &#x3D; 1000 * 1000 Bytes、1GB &#x3D; 1000 * 1000 * 1000 Bytes</p>
<p>后缀省略了字母 B的换算单位是 1024, 比如： 1K &#x3D; 1024 Bytes、 1M &#x3D; 1024 * 1024 Bytes、1G &#x3D; 1024 * 1024 * 1024 Bytes</p>
<p>count 表示块的数量，表示 dd 命令需要执行多少次读取并写入的操作</p>
<p>bs 乘以 count 其实就表示目标文件的大小，也即需要创建的文件的大小，比如：下面的命令可以创建一个 10G 大小的文件</p>
<p>[root@localhost dd_cmd]# dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;testfile bs&#x3D;1G count&#x3D;10<br>记录了10+0 的读入<br>记录了10+0 的写出<br>10737418240字节(11 GB)已复制，8.61643 秒，1.2 GB&#x2F;秒<br>[root@localhost dd_cmd]# du -h testfile<br>10G     testfile<br>[root@localhost dd_cmd]#</p>
<p>上面的命令表示从 &#x2F;dev&#x2F;zero文件每次读取 1G大小的数据并写入当前目录中的 testfile 文件， bs&#x3D;1G count&#x3D;10 表示块大小是1G，总共有10个块， 所以目标文件最终的大小是: 1G * 10 &#x3D; 10G</p>
<p>&#x2F;dev&#x2F;zero 是一个特殊的字符设备文件，当读取它的时候，它会返回空数据，这里表示从 &#x2F;dev&#x2F;zero读取空的数据写入 testfile 中</p>
<p>命令 du -h testfile 的结果也说明了 testfile 大小是 10G</p>
<p>从结果可以得知，用 dd 命令创建一个 10G 大小的文件花费了约 <strong>8.6</strong> 秒</p>
<h3 id="yes"><a href="#yes" class="headerlink" title="yes"></a>yes</h3><hr>
<p>前面的 dd 命令创建的是空字符的文件，如果想文件中包含自定义的字符，可以使用 yes 命令，它的作用是循环输出一行指定的字符串，直到进程结束，为了控制文件的大小并打破循环，我们借助 head 命令来实现，使用 yes 命令创建包含指定内容文件的语法如下</p>
<p>yes [string]  head -c [size of file] &gt; [name of file]</p>
<p>string 是写入文件每一行的字符串</p>
<p>head -c [size of file] 是接收指定大小的字符串，单位是字节，后面也可以接 K、KB、M、MB、G、GB等单位</p>
<p>下面的实例是往 yesfile 文件写入，每行的内容是: this is a test content , 一直到文件大小达到 10G</p>
<p>[root@localhost dd_cmd]# time yes “this is a test content”  head -c 10G &gt; yesfile</p>
<p>real    0m11.266s<br>user    0m8.898s<br>sys     0m13.217s<br>[root@localhost dd_cmd]# du -h yesfile<br>10G     yesfile</p>
<p>从结果可以看出，yes 命令创建一个 10G 的文件花费了 <strong>13.2</strong> 秒，比 dd 命令慢</p>
<h3 id="fallocate"><a href="#fallocate" class="headerlink" title="fallocate"></a>fallocate</h3><hr>
<p>fallocate 命令使用下面的语法 创建大文件</p>
<p>fallocate -l [size of file] [name of file]</p>
<p>-l 选项表示文件大小，单位是字节，后面可以接 K、KB、M、MB、G、GB等单位</p>
<p>下面的命令是创建一个 10G 大小的文件</p>
<p>[root@localhost dd_cmd]# time fallocate -l 10G allocatefile</p>
<p>real    0m0.002s<br>user    0m0.000s<br>sys     0m0.003s<br>[root@localhost dd_cmd]# du -h allocatefile<br>10G     allocatefile</p>
<p>上述的 time 命令只是为了统计创建文件的时间，从结果可以看出:fallocate命令创建一个 10G 大小的文件竟然只花费了 <strong>0.003</strong> 秒</p>
<p>命令 du -h allocatefile 是查看创建的文件大小，从结果可知，allocatefile 文件大小确实是 10G</p>
<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h3><hr>
<p>truncate 命令是缩小或者扩展文件至指定大小，它的语法如下：</p>
<p>truncate -s [file-size] [name of the file]</p>
<p>-s 选项表示文件大小，单位是字节，跟 fallocate 命令一样，后面可以接 K、KB、M、MB、G、GB等单位</p>
<p>下面是使用 truncate 命令创建一个 10G的文件的示例</p>
<p>[root@localhost dd_cmd]# time truncate -s 10G truncatefile</p>
<p>real    0m0.002s<br>user    0m0.000s<br>sys     0m0.002s<br>[root@localhost dd_cmd]# du -h truncatefile<br>0       truncatefile</p>
<p>从结果可以得到，truncate 命令 创建一个 10G的文件也只花费了 <strong>0.002</strong> 秒，和 fallocate 差不多</p>
<p>但是, du -h truncatefile 命令的结果表明 truncatefile 大小为 0</p>
<p><strong>原因是 truncate 命令 创建的是一个稀疏文件而不是实际的文件 ，稀疏文件不会占用磁盘空间<br>注意：fallocate 命令只支持 btrfs、ext4、 ocfs2、xfs 这几种文件系统，而 truncate 命令支持所有的现代文件系统</strong></p>
<h3 id="创建速度的差异"><a href="#创建速度的差异" class="headerlink" title="创建速度的差异"></a>创建速度的差异</h3><hr>
<p>从上面的几个实例可以看出，同样是创建一个 10G的文件， fallocate 和 truncate 命令只需要不到 0.1 秒的时间，但是 dd 命令需要 8.6 秒的时间，yes命令需要 13.2 秒，这中间相差了几百倍，为什么会有这么大的差别呢？</p>
<p>fallocate 将空间分配给文件，但是不会往文件中写入任何数据</p>
<p>truncate 创建的是稀疏文件，和 fallocate 一样，它也不会往文件中写入任何数据</p>
<p>dd 和 yes 都有写文件操作，而这需要大量的 IO 时间，所以同样创建 10G 的文件，它们比 fallocate 和 truncate 要慢很多</p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><hr>
<p>dd 、yes、fallocate、truncate 这几个命令都可以创建大文件, 在日常的使用中，我们该如何选择呢 ?</p>
<p>对速度没有很高的要求的情况下，一般首选 dd ，如果希望创建的文件中写入自定义的内容的话，使用 yes</p>
<p>如果想快速的创建大文件，比如 1 秒内创建一个 100G 的文件，选择 fallocate 和 truncate ，如果还需要确保文件是实际占用磁盘空间的话，就只剩下 fallocate 可选了</p>
<p>大部分情况下，fallocate 都能满足要求，所以不想仔细分析的话，使用 fallocate 就行了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>本文介绍了Linux下创建大文件的几种方法，并对所提供的方法进行了比较，最后提供了如何选择使用哪种方法的一些建议，文中只对 dd 、yes、fallocate、truncate 命令做了简要的说明，更多的介绍请参考 man 文档</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大文件</tag>
        <tag>dd</tag>
        <tag>fallocate</tag>
        <tag>truncate</tag>
        <tag>yes</tag>
        <tag>创建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux删除文件空间不释放问题解决</title>
    <url>/2021/06/18/linux%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4%E4%B8%8D%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-41.png"></p>
<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>某天，收到<code>Prometheus</code>报警，生产中某台机器出现磁盘空间不足报警，该台服务器是<code>mysql</code>其中一台从库，远程登录到该服务后，排查磁盘空间的原因，发现mysql日志文件过多，于是清空日志文件，但是日志清理后，发现磁盘空间并没有释放，下面分析处理过程和原因</p>
<h2 id="日志清理后，查看磁盘空间"><a href="#日志清理后，查看磁盘空间" class="headerlink" title="日志清理后，查看磁盘空间"></a>日志清理后，查看磁盘空间</h2><p>[root@hhjy3-21 ~]# df -Th<br>Filesystem     Type      Size  Used Avail Use% Mounted on<br>&#x2F;dev&#x2F;sda3      xfs        98G  65G   33G   73% &#x2F;<br>devtmpfs       devtmpfs  1.5G     0  1.5G   0% &#x2F;dev<br>tmpfs          tmpfs     1.5G     0  1.5G   0% &#x2F;dev&#x2F;shm<br>tmpfs          tmpfs     1.5G  8.9M  1.5G   1% &#x2F;run<br>tmpfs          tmpfs     1.5G     0  1.5G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup<br>&#x2F;dev&#x2F;sda1      xfs      1014M  120M  895M  12% &#x2F;boot<br>tmpfs          tmpfs     293M     0  293M   0% &#x2F;run&#x2F;user&#x2F;0</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在<code>Linux</code>或<code>Unix</code>系统中，通过使用rm删除文件的原理，rm命令只是从文件系统的目录结构上解除链接<code>(unlink)</code>，也就是说如果文件是被打开的(有一个进程正在使用该文件句柄)，那该进程还是可以读取已删除的文件，而我删除的正是在运行中的<code>MySQL</code>的<code>Logs</code>，删除的时候文件正在被使用中，所以并不释放磁盘空间。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><code>Linux</code>中使用<code>lsof grep deleted</code>命令可以获取一个已经被删除但是仍然被应用程序占用的文件列表</p>
<p>[root@hskj3-21 ~]# lsof  grep -i delete<br>mysqld_sa  1311          root    2u      CHR              136,0       0t0          3 &#x2F;dev&#x2F;pts&#x2F;0 (deleted)<br>mysqld     1607         mysql    1w      REG                8,3    312627    1700052 &#x2F;mysql&#x2F;3306&#x2F;logs&#x2F;mysql.log (deleted)<br>mysqld     1607         mysql    2w      REG                8,3    312627    1700052 &#x2F;mysql&#x2F;3306&#x2F;logs&#x2F;mysql.log (deleted)<br>mysqld     1607         mysql    5u      REG                8,3         0  134335687 &#x2F;mysql&#x2F;3306&#x2F;tmp&#x2F;ibz8LDOk (deleted)<br>mysqld     1607         mysql    6u      REG                8,3         0  134374089 &#x2F;mysql&#x2F;3306&#x2F;tmp&#x2F;ibprHY8C (deleted)<br>mysqld     1607         mysql    7u      REG                8,3         0  135173881 &#x2F;mysql&#x2F;3306&#x2F;tmp&#x2F;ibS7LjtV (deleted)<br>mysqld     1607         mysql    8u      REG                8,3         0  134429856 &#x2F;mysql&#x2F;3306&#x2F;tmp&#x2F;ibX2QZcx (deleted)<br>mysqld     1607         mysql   12u      REG                8,3         0  134429858 &#x2F;mysql&#x2F;3306&#x2F;tmp&#x2F;ibMxDsTQ (deleted)<br>mysqld     1607         mysql   21w      REG                8,3    153673    1700035 &#x2F;mysql&#x2F;3306&#x2F;logs&#x2F;slow.log (deleted)<br>mysqld     1607  1609   mysql    1w      REG                8,3    312627    1700052 &#x2F;mysql&#x2F;3306&#x2F;logs&#x2F;mysql.log (deleted)<br>……</p>
<p>用该命令后，我发现占用的文件列表非常多，我们需要将占用已删除文件的进程给一个一个的杀掉</p>
<p>[root@hskj3-21 ~]# kill -9 PID</p>
<h2 id="在线清空文件"><a href="#在线清空文件" class="headerlink" title="在线清空文件"></a>在线清空文件</h2><p>其实上面那种直接rm删除文件的方法非常危险，特别是针对<code>MySQL</code>，<code>Mongodb</code>，数据相关的服务，<code>rm</code>删除之后，没法释放空间，还得<code>手动重启</code>或者<code>kill</code>这些数据相关的服务进程，会影响到业务。</p>
<p>可以使用以下方法，磁盘空间不足可以马上释放，也可以保证进程继续向文件写入日志，这种方法适合在线清理。</p>
<p>$ echo &gt; xxx&#x2F;log</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>不释放空间</tag>
        <tag>删除</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux启动网卡时出现RTNETLINK answers: File exists错误解决</title>
    <url>/2021/12/25/linux%E5%90%AF%E5%8A%A8%E7%BD%91%E5%8D%A1%E6%97%B6%E5%87%BA%E7%8E%B0rtnetlink-answers-file-exists%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-18.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>新安装了一台CentOS服务器，IP地址是自动获取的，开始在系统启动时是否激活网卡也是no，系统启动后可以正常使用 ifup enp0s3 启动网卡，也可以正常访问</p>
<h3 id="配置静态IP地址"><a href="#配置静态IP地址" class="headerlink" title="配置静态IP地址"></a>配置静态IP地址</h3><hr>
<p>配置文件路径 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-enp0s3<br>在原有的配置上修改了 BOOTPROTO</p>
<p>BOOTPROTO&#x3D;static<br>ONBOOT&#x3D;no</p>
<p>添加了配置</p>
<p>ADDRESS&#x3D;192.168.55.101<br>NETMASK&#x3D;255.255.255.0<br>GATEWAY&#x3D;192.168.55.1</p>
<h3 id="没有配置ONBOOT"><a href="#没有配置ONBOOT" class="headerlink" title="没有配置ONBOOT"></a>没有配置ONBOOT</h3><hr>
<p>没有配置ONBOOT默认不会自动激活网卡<br>手动激活网卡报错 RTNETLINK answers: File exists</p>
<p>[root@localhost ~]#ifup enp0s3<br>RTNETLINK answers: File exists</p>
<h3 id="问题解决RTNETLINK-answers-File-exists"><a href="#问题解决RTNETLINK-answers-File-exists" class="headerlink" title="问题解决RTNETLINK answers: File exists"></a>问题解决RTNETLINK answers: File exists</h3><hr>
<p>仔细检查了一下配置发现问题<br>ADDRESS&#x3D;192.168.55.101<br>改成<br>IPADDR&#x3D;192.168.55.101</p>
<h3 id="下面附上网卡配置"><a href="#下面附上网卡配置" class="headerlink" title="下面附上网卡配置"></a>下面附上网卡配置</h3><hr>
<p>TYPE&#x3D;Ethernet<br>PROXY_METHOD&#x3D;none<br>BROWSER_ONLY&#x3D;no<br>BOOTPROTO&#x3D;static<br>DEFROUTE&#x3D;yes<br>IPV4_FAILURE_FATAL&#x3D;no<br>IPV6INIT&#x3D;yes<br>IPV6_AUTOCONF&#x3D;yes<br>IPV6_DEFROUTE&#x3D;yes<br>IPV6_FAILURE_FATAL&#x3D;no<br>IPV6_ADDR_GEN_MODE&#x3D;stable-privacy<br>NAME&#x3D;enp0s3<br>UUID&#x3D;50737ef1-2b52-41ea-9829-ee37a5dc19a0<br>DEVICE&#x3D;enp0s3<br>ONBOOT&#x3D;yes<br>IPADDR&#x3D;192.168.55.101<br>NETMASK&#x3D;255.255.255.0<br>GATEWAY&#x3D;192.168.55.1</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>RTNETLINK answers: File exists</tag>
        <tag>网卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux怎么设置密码过期时间_Linux 密码过期（WARNING:Your password has expired ）</title>
    <url>/2021/07/09/linux%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-linux-%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F%EF%BC%88warningyour-password-has-expired-%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-36.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>最近遇到两次这个问题，我们公司用的是开源的堡垒机Jumpserver<br>但是最近有两个同学遇到了 WARNING:Your password has expired<br>第一次遇到这个问题也没有往深了去查，当时去堡垒机后台修改用户密码，已经重新生成key都不行（这两步骤，我不记得我做没做），今天又遇到了一个同学遇到了这个问题，就去查了一下下</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><hr>
<p>我们当时为了过等保我们修改了所有服务器上的密码过期时间，修改成了三十天，我们一旦修改了这个，<br>后面新创建的用户的的密码过期时间就会是三十天（收到这个配置的影响）</p>
<p>这个主要是由 &#x2F;etc&#x2F;login.defs 参数文件中的一些参数控制的的。它主要用于用户账号限制</p>
<p>PASS_MAX_DAYS 60     #密码最大有效期，此处参数PASS_MAX_DAYS为60，表示60天后，密码会过期。99999表示永不过期。<br>PASS_MIN_DAYS 0      #两次修改密码的最小间隔时间，0表示可以随时修改账号密码<br>PASS_MIN_LEN  8      #密码最小长度，对于root无效<br>PASS_WARN_AGE 7      #密码过期前多少天开始提示</p>
<h3 id="命令记录"><a href="#命令记录" class="headerlink" title="命令记录"></a>命令记录</h3><hr>
<p>chage -l root<br>Last password change : Oct 23, 2013       【最近一次修改密码的时间】<br>Password expires : Jan 23, 2014              【密码过期时间】<br>Password inactive : never                       【密码失效时间】<br>Account expires : never                         【账户过期时间】<br>Minimum number of days between password change : 0    【两次改变密码之间相距最小天数】<br>Maximum number of days between password change : 92   【两次密码改变密码相距最大天数】<br>Number of days of warning before password expires : 7 【密码过期前开始警告的天数】</p>
<p>chage -M 36000 bigbao  修改用户的过期时间，修改过后就可以了。无需其他的操作</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>通过这个问题，我感觉这个策略还是需要的。应该设置一个普通用户的密码策略的过期时间</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Your password has expired</tag>
        <tag>密码过期</tag>
        <tag>设置密码</tag>
        <tag>过期时间</tag>
      </tags>
  </entry>
  <entry>
    <title>linux普通用户使用1024以下的端口（80）</title>
    <url>/2021/06/15/linux%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A81024%E4%BB%A5%E4%B8%8B%E7%9A%84%E7%AB%AF%E5%8F%A3%EF%BC%8880%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-38-1024x559.png"></p>
<p><code>linux</code>对于非<code>root</code>权限用户不能使用<code>1024</code>以下的端口，对于一些服务，过高的权限，会带来一定的风险。那么对于低权限的用户如何对外开放<code>1024</code>以下的端口。我这里找到几种办法并且亲测可行<br>首先搭建环境<code>centos7</code>账户<code>prod</code>没有<code>sudo</code>权限</p>
<h2 id="1-nginx-等软件做反向代理"><a href="#1-nginx-等软件做反向代理" class="headerlink" title="1. nginx 等软件做反向代理"></a>1. nginx 等软件做反向代理</h2><p>使用nginx启动80端口反向代理后台服务，后台服务可以写1024之后的端口</p>
<h2 id="2-iptables端口转发"><a href="#2-iptables端口转发" class="headerlink" title="2. iptables端口转发"></a>2. iptables端口转发</h2><p>首先程序绑定<code>1024</code>以上的端口，然后<code>root</code>权限下做转发注意有些系统需要手动开启<code>IP FORWARD</code>功能<br>临时修改<br><code>sysctl -w net.ipv4.ip_forward=1</code><br>或：修改文件<code>sysctl.conf</code></p>
<p>vi &#x2F;etc&#x2F;sysctl.conf<br>#修改<br>net.ipv4.ip_forward &#x3D; 1<br>#重新加载<br>sysctl -p &#x2F;etc&#x2F;sysctl.conf</p>
<p>使用root配置端口转发，把80端口转发到本机的后台服务6666端口上</p>
<p>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-port 6666</p>
<h2 id="3-setuid"><a href="#3-setuid" class="headerlink" title="3. setuid"></a>3. setuid</h2><p>root账户下执行</p>
<p>##正常情况下是不能监听80端口的<br>[test@test nginx]$ sbin&#x2F;nginx -c conf&#x2F;nginx.conf<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)<br>##下面给nginx授权suid权限<br>[root@test nginx]# chown root:root sbin&#x2F;nginx<br>[root@test nginx]# chmod 4755 sbin&#x2F;nginx<br>You have new mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root<br>[root@test nginx]# ll sbin&#x2F;nginx<br>-rwsr-xr-x. 1 root root 17675424 May 22 16:43 sbin&#x2F;nginx</p>
<h2 id="用普通用户运行nginx，监听80端口"><a href="#用普通用户运行nginx，监听80端口" class="headerlink" title="用普通用户运行nginx，监听80端口"></a>用普通用户运行nginx，监听80端口</h2><p>[test@test nginx]$ sbin&#x2F;nginx -c conf&#x2F;nginx.conf<br>[test@test nginx]$ ps -ef grep nginx<br>root     29988     1  0 13:15 ?        00:00:00 nginx: master process sbin&#x2F;nginx -c conf&#x2F;nginx.conf<br>nobody   29989 29988  0 13:15 ?        00:00:00 nginx: worker process<br>nobody   29990 29988  0 13:15 ?        00:00:00 nginx: worker process<br>nobody   29991 29988  0 13:15 ?        00:00:00 nginx: worker process<br>nobody   29992 29988  0 13:15 ?        00:00:00 nginx: worker process<br>test     30699 23722  0 13:16 pts&#x2F;1    00:00:00 grep –color&#x3D;auto nginx</p>
<p>从上面可以看出来nginx可以运行，<br>但是主进程仍然是以root权限运行,这样并不安全。</p>
<h2 id="4-CAP-NET-BIND-SERVICE"><a href="#4-CAP-NET-BIND-SERVICE" class="headerlink" title="4. CAP_NET_BIND_SERVICE"></a>4. CAP_NET_BIND_SERVICE</h2><p>从 <code>2.1</code> 版本开始，<code>Linux</code> 内核有了能力的概念，这使得普通用户也能够做只有超级用户才能完成的工作，这包括使用端口。</p>
<p>获取<code>CAP_NET_BIND_SERVICE</code>能力，即使服务程序运行在非root帐户下，也能够<code>binding</code>到低端口。使用的方法：<code>root</code>账户下执行<br><code>setcap cap_net_bind_service=+eip nginx/sbin/nginx</code></p>
<p>切换到test账户下<br>信息如下<br>[root@centos7 sbin]# setcap cap_net_bind_service&#x3D;+eip nginx<br>[root@centos7 sbin]# su test<br>[test@centos7 sbin]$ .&#x2F;nginx<br>[test@centos7 sbin]$ ps -aux grep nginx<br>test 18014  0.0  0.1  45500  1124 ?        Ss   18:49   0:00 nginx: master process .&#x2F;nginx<br>test 18015  0.0  0.1  45960  1596 ?        S    18:49   0:00 nginx: worker process<br>test 18017  0.0  0.0 112664   984 pts&#x2F;0    R+   18:49   0:00 grep –color&#x3D;auto nginx<br>[test@centos7 sbin]$<br>cap_net_bind_service</p>
<p>最后别忘记怎么清除这个能力</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>cap_net_bind_service</tag>
        <tag>Linux系统</tag>
        <tag>启动80端口</tag>
        <tag>普通用户</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器磁盘空间满了但是找不到占用文件怎么办？</title>
    <url>/2021/10/27/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E6%BB%A1%E4%BA%86%E4%BD%86%E6%98%AF%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8D%A0%E7%94%A8%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-23.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在服务器运维过程中，我们时常会遇到这样的情况，收到服务器磁盘空间告警<br><img src="https://img-blog.csdnimg.cn/70c806b2c561480fb4f6d440ce41d378.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>登录服务器，通过df -Hl查看<br><img src="https://img-blog.csdnimg.cn/e46959724c5e4cdebc941f43ed3c92c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>和告警信息一致，接着我们就是要找到导致磁盘空间满的目录或文件</p>
<h3 id="如何找到占用空间大的目录或文件？"><a href="#如何找到占用空间大的目录或文件？" class="headerlink" title="如何找到占用空间大的目录或文件？"></a>如何找到占用空间大的目录或文件？</h3><hr>
<p>一种比较笨的方法是，在根目录下，通过du -hs命令，列出各目录所占空间大小</p>
<p><img src="https://img-blog.csdnimg.cn/6ff471a18d5a480791a3b481fbe0c072.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>之后再用同样的方法继续到对应目录下去找</p>
<p>再相对高效一点的方法是通过du的-d参数，或–max-depth，设置查询的目录深度，目录深度增加，所查询的目录，展示出来会很多，这个时候可以通过grep进行过滤</p>
<p>du -h -d 2grep [GT] sort -nr<br>du -h –max-depth&#x3D;2grep [GT] sort -nr</p>
<p>通过这样的方式，可以搜出以G或者T为单位的占用磁盘空间的大目录，并排序</p>
<p>或者可以通过find来查询</p>
<p>find &#x2F; -type f -size +1G -exec du -h {} \;</p>
<p>从效率上来说，find要比du要更快速、灵活</p>
<p>通过这两种方法，我们可以快速找到占用磁盘空间的罪魁祸首</p>
<hr>
<p>你以为就这么简单？很多时候，你会发现，通过find或du查半天，发现所有加起来的占用空间，和df看到的磁盘空间占用，相差很大，就比如我上面的两张图</p>
<p>通过df查看，磁盘使用37G，但是在根目录下通过du -hs 查看，总共加起来差不多10G，没有隐藏目录，那空间被谁吃了？</p>
<p>很明显，有空间被已删除文件占用，文件删除了，但是资源没释放</p>
<p>之前介绍过一个很好用的命令：lsof，我们可以通过以下命令去查看</p>
<p>lsof +L1</p>
<p><img src="https://img-blog.csdnimg.cn/92bbb4a77977408d9003cdd8428b6c25.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>从结果可以看出，有一个28G左右的大日志文件，删除了，但是空间没释放，这是很常见的一种情况</p>
<p>对应的解决方法就是，重启tomcat应用，释放空间</p>
<h3 id="磁盘空间莫名被吃？"><a href="#磁盘空间莫名被吃？" class="headerlink" title="磁盘空间莫名被吃？"></a>磁盘空间莫名被吃？</h3><hr>
<p>还有一种经常有人问的问题，就是，通过df查看到的磁盘</p>
<p><img src="https://img-blog.csdnimg.cn/8f782054c51b4ad8b8d84856f68fa52f.png" alt="在这里插入图片描述"></p>
<p>会发现，Used和Avail加起来不够Size，莫名被吃掉一部分</p>
<p>其实这是Linux文件系统的一种安全策略，它默认会为root用户保留5%的磁盘空间，留作紧急情况使用。这样能保证有些关键应用（比如数据库）在硬盘满的时候有点余地，不致于马上就 crash</p>
<p>我们可以通过tune2fs修改预留空间的比例</p>
<p>tune2fs -m 1 &#x2F;dev&#x2F;vda1</p>
<p>通过下图可以看到前后对比</p>
<p><img src="https://img-blog.csdnimg.cn/480cb29e1c27439d937b863414ceae70.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这样被吃掉的空间，就吐出来了</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>占用</tag>
        <tag>磁盘空间</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用pm2来管理nodejs服务器进程</title>
    <url>/2021/04/17/linux%E7%94%A8pm2%E6%9D%A5%E7%AE%A1%E7%90%86nodejs%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/f23648fcfd6249eab5e5cf511dbd0ce8.png"></p>
<p><strong>pm2介绍</strong></p>
<p><em>pm2是一个管理Node.js进程process的工具，它可以让我们用简单的指令启动Node.js集群cluster并最大化使用我们的CPU，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</em></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm安装</p>
<p>npm install pm2 -g</p>
<h2 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h2><p>pm2安装好后，会自动创建下面目录。</p>
<p>$HOME&#x2F;.pm2 #将包含所有PM2相关文件<br>$HOME&#x2F;.pm2&#x2F;logs #将包含所有应用程序日志<br>$HOME&#x2F;.pm2&#x2F;pids #将包含所有应用程序pids<br>$HOME&#x2F;.pm2&#x2F;pm2.log #PM2日志记录<br>$HOME&#x2F;.pm2&#x2F;pm2.pid #PM2 pid<br>$HOME&#x2F;.pm2&#x2F;rpc.sock #远程命令的套接字文件<br>$HOME&#x2F;.pm2&#x2F;pub.sock #可发布事件的套接字文件<br>$HOME&#x2F;.pm2&#x2F;conf.js #PM2配置</p>
<h2 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h2><p>pm2 start后面加上node.js起始档案</p>
<p>pm2 startapp.js</p>
<p>使用集群（cluster）的方式来起始档案</p>
<p>pm2 start -i 4 –name serverapp.js</p>
<h2 id="删除Process"><a href="#删除Process" class="headerlink" title="删除Process"></a>删除Process</h2><p>根据<code>id,name</code>删除process</p>
<p>pm2 delete { id or name }</p>
<h2 id="停止进程Process"><a href="#停止进程Process" class="headerlink" title="停止进程Process"></a>停止进程Process</h2><p>根据<code>id,name</code>停止process</p>
<p>pm2 stop { id or name }</p>
<h2 id="重新启动进程Process"><a href="#重新启动进程Process" class="headerlink" title="重新启动进程Process"></a>重新启动进程Process</h2><p>根据<code>id,name</code>重新启动process</p>
<p>pm2 restart { id or name }</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>列出目前所有已启动的process并显示他们目前的状态，按下ctrl+c可以离开monitor</p>
<p>pm2 monit  </p>
<p><img src="https://code404.icu/img/moveypu/2021/04/1489159993-1186706966_n.png"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>进程</tag>
        <tag>nodejs</tag>
        <tag>pm2</tag>
        <tag>服务器</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统中查看历史操作操作记录_history这么强大</title>
    <url>/2021/08/07/linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%93%8D%E4%BD%9C%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95-history%E8%BF%99%E4%B9%88%E5%BC%BA%E5%A4%A7/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-5-1024x418.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>当我们频繁使用 Linux 命令行时，有效地使用历史记录，可以大大提高工作效率。</p>
<p>在平时 Linux 操作过程中，很多命令是重复的，你一定不希望大量输入重复的命令。如果你是系统管理员，你可能需要对用户操作进行审计，管理好 Linux 命令历史记录显得非常重要。</p>
<p>今天我们来介绍一下，在 Linux 使用 history 来减少重复命令的几个实用技巧。</p>
<h3 id="一、基本原理"><a href="#一、基本原理" class="headerlink" title="一、基本原理"></a>一、基本原理</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/c5d930763b4c443aad46c5d1f1fc9adf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Linux 命令的历史记录，会持久化存储，默认位置是当前用户家目录的 .bash_history 文件。</p>
<p>当 Linux 系统启动一个 Shell 时，Shell 会从 .bash_history 文件中，读取历史记录，存储在相应内存的缓冲区中。</p>
<p>我们平时所操作的 Linux 命令，都会记录在缓冲区中。包括 history 命令所执行的历史命令管理，都是在操作缓冲区，而不是直接操作 .bash_history 文件。</p>
<p>当我们退出 Shell，比如按下 Ctrl+D 时，Shell 进程会把历史记录缓冲区的内容，写回到 .bash_history 文件中去。</p>
<h3 id="二、使用详解"><a href="#二、使用详解" class="headerlink" title="二、使用详解"></a>二、使用详解</h3><hr>
<h4 id="1、基础用法"><a href="#1、基础用法" class="headerlink" title="1、基础用法"></a>1、基础用法</h4><hr>
<p>直接输入 history 命令，可以看到最近操作的所有命令都显示出来了</p>
<p>$ history<br>   1  bash<br>   2  ls<br>   3  vim .bash_history<br>   4  cat .bash_history<br>   5  history<br>   6  bash</p>
<p>有时候我不需要显示所有的历史命令，只显示最后的 10 条历史记录，可以在命令后加数字 N 即可</p>
<p>$ history 10</p>
<p>正常情况下，只有在 Shell 正常退出时，才会将缓冲区内容保存到文件。如果你想主动保存缓冲区的历史记录，执行 -w 选项即可</p>
<p>$ history -w</p>
<p>当然，如果你执行了一些敏感的命令操作，可以执行 -c 将缓冲区内容直接删除</p>
<p>$ history -c</p>
<h4 id="2、重复执行命令"><a href="#2、重复执行命令" class="headerlink" title="2、重复执行命令"></a>2、重复执行命令</h4><hr>
<p>如果要重复执行一些命令，可以使用 ! 来快速执行重复的命令。</p>
<p>举个例子，重复执行第 1024 历史命令，可以执行如下命令</p>
<p>$ !1024</p>
<p>1024 这个编号可以通过 history 查看哦</p>
<p>重复执行上一条命令</p>
<p>$ !!</p>
<p>重复执行倒数第 6 条历史命令，可以通过负数表示，-6 表示倒数第 6 条记录</p>
<p>$ !-6</p>
<h4 id="3、搜索历史命令"><a href="#3、搜索历史命令" class="headerlink" title="3、搜索历史命令"></a>3、搜索历史命令</h4><hr>
<p>有时候，需要重复执行某字符串开头的最后一个命令，同样可以通过 ! 来操作，然后按 Enter 执行即可</p>
<p>比如，刚才执行了一个很长命令，只记录命令开头是 curl，这时就可以通过 !curl 快速执行该命令</p>
<p>$ !curl</p>
<p>这个用法很高效，但存在不安全因素，因为有可能执行的命令不是你想要执行的，那就坏事了。可以通过 :p 来安全地执行。</p>
<p>$ !curl:p<br>curl <a href="http://www.sina.com.cn/">www.sina.com.cn</a></p>
<p>加上 :p 后，只是打印出了搜索到的命令，如果要执行，请按 Up 键，然后回车即可。</p>
<p>如果你只知道某条命令包含了 x 信息，不是以 x 开头，同样可以通过 ? 来执行包含字符串的命令</p>
<p>$ !?sina</p>
<h4 id="4、交互式搜索历史命令"><a href="#4、交互式搜索历史命令" class="headerlink" title="4、交互式搜索历史命令"></a>4、交互式搜索历史命令</h4><hr>
<p>在 Linux 搜索历史命令，还可以通过交互式的搜索方式，简直高效直接。在命令行输入 Ctrl+R 后，进入交互界面，键入需要搜索的关键字，如果匹配到多条命令，可以多次键入 Ctrl+R 来切换上一条匹配的命令。</p>
<p>(reverse-i-search)`sina’: echo sina</p>
<p>可以看到，我输入了 sina 后，就自动匹配到最近一次和 sina 匹配的命令，这时按下回车就可以执行该命令。</p>
<h4 id="5、重复执行上条命令"><a href="#5、重复执行上条命令" class="headerlink" title="5、重复执行上条命令"></a>5、重复执行上条命令</h4><hr>
<p>在这里总结下多种重复执行上条命令的方式，你可以选择一种自己喜欢的就可以啦</p>
<ul>
<li>!!</li>
<li>!-1</li>
<li>Ctrl+p</li>
<li>Up</li>
<li>Ctrl+R</li>
</ul>
<h4 id="6、显示时间戳"><a href="#6、显示时间戳" class="headerlink" title="6、显示时间戳"></a>6、显示时间戳</h4><hr>
<p>有时候需要对 Linux 系统做审计，那为历史记录添加时间戳，显示非常有用。</p>
<p>$ export HISTTIMEFORMAT&#x3D;’%F %T ‘<br>$ history 3<br>  46  2021-04-18 15:21:33 curl <a href="http://www.code404.icu/">www.code404.icu</a><br>  47  2021-04-18 15:21:35 pwd<br>  48  2021-04-18 15:21:39 history 3</p>
<p>可以看到，历史记录已经显示了时间戳。其实这些对于审计需求，还不够，可以加上更详细的信息：</p>
<p>$ export HISTTIMEFORMAT&#x3D;”%F %T `who -u am i 2&gt;&#x2F;dev&#x2F;null awk ‘{print $NF}’sed \-e ‘s&#x2F;[()]&#x2F;&#x2F;g’` `whoami` “<br>  6  2021-04-18 16:07:48 113.200.44.237 root ls<br>  7  2021-04-18 16:07:59 113.200.44.237 root pwd<br>  8  2021-04-18 16:08:14 113.200.44.237 root history</p>
<h4 id="7、控制历史记录总数"><a href="#7、控制历史记录总数" class="headerlink" title="7、控制历史记录总数"></a>7、控制历史记录总数</h4><hr>
<p>默认情况下，Linux 系统最多存储 1000 条历史记录，可以通过 HISTSIZE 环境变量查看</p>
<p>$ echo $HISTSIZE<br>1000</p>
<p>对于需要做审计的场景，1000 条历史记录可能会太少了，我们可以修改为合适的值</p>
<p>$ export HISTSIZE&#x3D;10000</p>
<p>注意，HISTSIZE 变量只能控制缓冲区中的历史记录数量，如果需要控制 .bash_history 文件存储的最大记录数，可以通过 HISTFILESIZE 进行控制</p>
<p>上述命令行修改只在当前 Shell 环境生效，如果需要永久生效，需要写入配置文件</p>
<p>$ echo “export HISTSIZE&#x3D;10000” &gt;&gt; ~&#x2F;.bash_profile<br>$ echo “export HISTFILESIZE&#x3D;200000” &gt;&gt; ~&#x2F;.bash_profile<br>$ source ~&#x2F;.bash_profile</p>
<h4 id="8、更改历史记录文件名"><a href="#8、更改历史记录文件名" class="headerlink" title="8、更改历史记录文件名"></a>8、更改历史记录文件名</h4><hr>
<p>有时，为了方便管理和备份，需要更改历史记录文件的路径和名称。简单，同样可以通过环境变量 HISTFILE 更改它的文件名称</p>
<p>$ echo “export HISTFILE&#x3D;&#x2F;data&#x2F;backup&#x2F;chopin.bash_history” &gt;&gt; ~&#x2F;.bash_profile<br>$ souce ~&#x2F;.bash_profile</p>
<h4 id="9、禁用历史记录"><a href="#9、禁用历史记录" class="headerlink" title="9、禁用历史记录"></a>9、禁用历史记录</h4><hr>
<p>处于某种特殊环境，我们需要禁用历史记录</p>
<p>$ echo “export HISTSIZE&#x3D;0” &gt;&gt; ~&#x2F;.bash_profile<br>$ echo “export HISTFILESIZE&#x3D;0” &gt;&gt; ~&#x2F;.bash_profile<br>$ source ~&#x2F;.bash_profile</p>
<p>哈哈，直接把上述两个变量的值设置为 0，就实现了禁用历史记录的功能</p>
<h4 id="10、黑客必知的一个小技巧"><a href="#10、黑客必知的一个小技巧" class="headerlink" title="10、黑客必知的一个小技巧"></a>10、黑客必知的一个小技巧</h4><hr>
<p>最后分享一个不为人知的，黑客必知的小技巧。</p>
<p>在命令前额外多加一个空格，这样的命令是不会被记录到历史记录的，感觉是不是很酷</p>
<p>这个技巧如果在你的系统不管用，请查看下环境变量 HISTCONTROL 是否包含 ignorespace，貌似 centos 系统默认没有设置这个值。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><hr>
<p>在 Linux 系统，history 命令可以非常方便，帮助我们管理历史命令，平时我们命令都会先记录在缓存区，在 Shell 退出时才会记录到文件中。</p>
<p>history 命令提供了很方便的管理功能，合理去配置和管理历史记录，可以让你的 Linux 系统更加健壮和安全。</p>
<p>好了，老规矩，贴心的肖哥还是来总结一下 history 命令常用方法</p>
<ul>
<li>history n：只显示最近的 n 条历史记录</li>
<li>history -c：清除缓存区中的历史记录</li>
<li>history -w：将缓存区的历史记录保存到文件</li>
<li>history -d N：删除第 N 条历史记录</li>
</ul>
<p>几种重复执行命令的方法：!!、!-1、!N、!string 等<br>交互式历史命令搜索，请使用 Ctrl+R 快捷键</p>
<p>合适使用几个相关的环境变量，让你的 Linux 系统更安全：</p>
<ul>
<li>HISTSIZE：控制缓冲区历史记录的最大个数</li>
<li>HISTFILESIZE：控制历史记录文件中的最大个数</li>
<li>HISTIGNORE：设置哪些命令不记录到历史记录</li>
<li>HISTTIMEFORMAT：设置历史命令显示的时间格式</li>
<li>HISTCONTROL：扩展的控制选项</li>
</ul>
<p>如果在生产环境，这些环境变量需要持久化到配置文件 ~&#x2F;.bash_profile</p>
<p>export HISTCONTROL&#x3D;ignoreboth</p>
<h1 id="ignorespace-忽略空格开头的命令"><a href="#ignorespace-忽略空格开头的命令" class="headerlink" title="ignorespace: 忽略空格开头的命令"></a>ignorespace: 忽略空格开头的命令</h1><h1 id="ignoredups-忽略连续重复命令"><a href="#ignoredups-忽略连续重复命令" class="headerlink" title="ignoredups: 忽略连续重复命令"></a>ignoredups: 忽略连续重复命令</h1><h1 id="ignoreboth-表示上述两个参数都设置"><a href="#ignoreboth-表示上述两个参数都设置" class="headerlink" title="ignoreboth: 表示上述两个参数都设置"></a>ignoreboth: 表示上述两个参数都设置</h1><h1 id="设置追加而不是覆盖"><a href="#设置追加而不是覆盖" class="headerlink" title="设置追加而不是覆盖"></a>设置追加而不是覆盖</h1><p>shopt -s histappend</p>
<p>export HISTSIZE&#x3D;1000<br>export HISTFILESIZE&#x3D;200000<br>export HISTTIMEFORMAT&#x3D;”%F %T “</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>history</tag>
        <tag>历史记录</tag>
      </tags>
  </entry>
  <entry>
    <title>linux运算符`反引号和$()怎么用？</title>
    <url>/2021/09/16/linux%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8D%E5%BC%95%E5%8F%B7%E5%92%8C%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-41.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>`反引号操作符可以在 shell 脚本中使用，因为它很容易与其他命令结合使用。但是，还有一种更“推荐”的方式来做同样的事情，使用$()运算符。本文将介绍在 shell 脚本中使用他们的优缺点。</p>
<h3 id="反引号的使用方式"><a href="#反引号的使用方式" class="headerlink" title="反引号的使用方式"></a>反引号的使用方式</h3><hr>
<p>下面是一个简单的实例：</p>
<p>[root@localhost ~]# echo “There are `ls  wc -l` files in this directory”<br>There are 10 files in this directory</p>
<p><code>ls wc -l</code>用于列出和计算当前目录的文件数，然后将它嵌入到 echo 命令中。</p>
<p>在 shell 脚本中，当然可以执行相同的操作，将<code>ls wc -l</code>命令的结果分配给一个变量，稍后使用该变量。</p>
<p>[root@localhost ~]# file_count&#x3D;`ls  wc -l`<br>[root@localhost ~]# echo “There are $file_count files in this directory”<br>There are 10 files in this directory</p>
<h3 id="的使用方式"><a href="#的使用方式" class="headerlink" title="$()的使用方式"></a>$()的使用方式</h3><hr>
<p>也可以通过使用$()代替`反引号来获得相同的结果，如下例所示：</p>
<p>[root@localhost ~]# echo “There are $(ls  wc -l) files in this directory”<br>There are 10 files in this directory</p>
<p>下面是一个例子，我需要对网络连接中的某些问题进行故障排除，因此我决定每分钟显示总连接数和等待连接数。</p>
<p>[root@localhost ~]# vim netinfo.sh</p>
<p>#!&#x2F;bin&#x2F;bash<br>while true<br>do<br>  ss -an &gt; netinfo.txt<br>  connections_total&#x3D;$(cat netinfo.txt  wc -l)<br>  connections_waiting&#x3D;$(grep WAIT netinfo.txt  wc -l)<br>  printf “$(date +%R) - Total&#x3D;%6d Waiting&#x3D;%6d\n” $connections_total $connections_waiting<br>  sleep 60<br>done</p>
<p>运行一下脚本：</p>
<p>[root@localhost ~]# .&#x2F;netinfo.sh<br>17:13 - Total&#x3D;   158 Waiting&#x3D;     4<br>17:14 - Total&#x3D;   162 Waiting&#x3D;     0<br>17:15 - Total&#x3D;   155 Waiting&#x3D;     0<br>17:16 - Total&#x3D;   155 Waiting&#x3D;     0<br>17:17 - Total&#x3D;   155 Waiting&#x3D;     0</p>
<h3 id="如何选择使用哪种方式"><a href="#如何选择使用哪种方式" class="headerlink" title="如何选择使用哪种方式"></a>如何选择使用哪种方式</h3><hr>
<p>这里更推荐使用$()方式。下面是原因：</p>
<ol>
<li>如果内部命令也使用 `，` 运算符可能会变得混乱。<br>将需要转义内部的 `，如果将单引号作为命令的一部分或结果的一部分，阅读和排除脚本故障可能会变得困难。<br>如果开始考虑在其他 ` 运算符中嵌套 ` 运算符，则事情将不会按预期工作或根本不起作用。</li>
<li>$()操作符更安全，更可预测。<br>在 $() 运算符中的内容被视为 shell 脚本。从语法上讲，这和把代码保存在文本文件中是一样的。<br>以下是`和 $()行为差异的一些示例：</li>
</ol>
<p>[root@localhost ~]# echo ‘\$x’<br>\$x<br>[root@localhost ~]# echo `echo ‘\$x’`<br>$x<br>[root@localhost ~]# echo $(echo ‘\$x’)<br>\$x</p>
<h3 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h3><hr>
<p>在较为复杂的命令语句中，推荐使用$()方式。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>`</tag>
        <tag>$()</tag>
        <tag>反引号</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>linux配置超时_自动退出登录TMOUT</title>
    <url>/2021/07/10/linux%E9%85%8D%E7%BD%AE%E8%B6%85%E6%97%B6-%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95tmout/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-37.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>系统为CentOS 7，一次无意操作在 &#x2F;etc&#x2F;profile 末尾增加了TMOUT&#x3D;90,然后系统就总是一会没操作就自动退出登录，不仅ssh自动退出，在本地使用也自动退出，很麻烦，查了一下，原来是启动了系统空闲等待时间，TMOUT&#x3D;90意思是90秒无操作就自动退出登录。</p>
<h3 id="取消系统空闲等待时间"><a href="#取消系统空闲等待时间" class="headerlink" title="取消系统空闲等待时间"></a>取消系统空闲等待时间</h3><hr>
<p>然后我需要取消这个设置，既然我是在&#x2F;etc&#x2F;profile中增加了TMOUT&#x3D;90，那么我把它删除掉不就行了？</p>
<p>删除了之后，使&#x2F;etc&#x2F;profile配置文件生效</p>
<p>source &#x2F;etc&#x2F;profile </p>
<p>退出登录</p>
<p>logout</p>
<p>重新登陆，然而，过了一会儿，还是会自动退出登录，查看set</p>
<p>set</p>
<p>发现结果中有一项：TMOUT&#x3D;90，然后我用unset命令取消TMOUT</p>
<p>unset TMOUT</p>
<p>重新登录后再次查看set结果，发现结果中还是有一项：TMOUT&#x3D;90，查看 &#x2F;etc&#x2F;profile 文件， &#x2F;etc&#x2F;profile 文件中没有TMOUT配置。但是系统还是会自动退出登录，烦烦烦，然后使用如下命令:</p>
<p>export TMOUT&#x3D;9999999<br>readonly TMOUT</p>
<p>然而并没有什么用，重新登录后查看set结果，还是TMOUT&#x3D;90，还是会自动退出登录！！！！<br>最终，我把上面的两行命令写到 &#x2F;etc&#x2F;profile 的末尾，</p>
<p>vi &#x2F;etc&#x2F;profile<br>#打开文件后，在末尾增加下面两行内容，然后保存退出。<br>export TMOUT&#x3D;0    #0代表永不自动退出<br>readonly TMOUT   # 将值设置为readonly 防止用户更改，在shell中无法修改TMOUT</p>
<p>然后退出登陆，再次登录，再次查看set结果，发现结果中有一项为</p>
<p>TMOUT&#x3D;0</p>
<p>终于成功了，再也没有自动退出的现象了。</p>
<h3 id="设置系统空闲等待时间"><a href="#设置系统空闲等待时间" class="headerlink" title="设置系统空闲等待时间"></a>设置系统空闲等待时间</h3><hr>
<p>反之，如果想让系统超时未操作自动退出登录，可以修改&#x3D;&#x3D;&#x2F;etc&#x2F;profile&#x3D;&#x3D;文件</p>
<p>vi &#x2F;etc&#x2F;profile<br>#打开文件后，在末尾增加下面两行内容，然后保存退出。<br>export TMOUT&#x3D;600   #600秒无操作自动退出登录<br>readonly TMOUT# 将值设置为readonly 防止用户更改，在shell中无法修改TMOUT</p>
<p>也可以通过命令的方式设置，在shell中输入如下代码即可实现600秒无操作自动退出登录：</p>
<p>export TMOUT&#x3D;600<br>readonly TMOUT </p>
<p>如果之前已经在 &#x2F;etc&#x2F;profile文件中设置了 readonly TMOUT，需要先将 &#x2F;etc&#x2F;profile 文件中的 readonly TMOUT 注释掉或删除掉，再输入上面的命令。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>TMOUT</tag>
        <tag>自动退出</tag>
      </tags>
  </entry>
  <entry>
    <title>logrotate 切割文件报错 SELinux is preventing logrotate from &#39;read, write&#39; accesses on the file</title>
    <url>/2021/09/19/logrotate-%E5%88%87%E5%89%B2%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99-selinux-is-preventing-logrotate-from-read-write-accesses-on-the-file/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-17-1024x635.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>一般来说，日志是任何故障排除过程中非常重要的一部分，但这些日志会随着时间增长。在这种情况下，我们需要手动执行日志清理以回收空间，这是一件繁琐的管理任务。为了解决这个问题，我们可以在 Linux 中配置 logrotate 程序，它可以自动执行日志文件的轮换、压缩、删除和用邮件发出。我们可以配置 logrotate 程序，以便每个日志文件可以在每天、每周、每月或当它变得太大时处理。</p>
<h3 id="logrotate配置"><a href="#logrotate配置" class="headerlink" title="logrotate配置"></a>logrotate配置</h3><hr>
<p>配置文件是对 &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt 进行日志切割</p>
<p>&#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt {<br>    daily<br>    size 100M<br>    rotate 3<br>    missingok<br>    copytruncate<br>    create 644 root root<br>    dateext<br>    notifempty<br>    compress<br>}</p>
<h3 id="报错日志"><a href="#报错日志" class="headerlink" title="报错日志"></a>报错日志</h3><hr>
<p>第二天早晨来了一看，日志并没有按时切割<br>报错内容<br>setroubleshoot: failed to retrieve rpm info for &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs<br>setroubleshoot: SELinux is preventing &#x2F;usr&#x2F;sbin&#x2F;logrotate from read access on the directory &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs<br>SELinux is preventing &#x2F;usr&#x2F;sbin&#x2F;logrotate from read access on the directory &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs.#012#012*****</p>
<p>Sep 18 03:30:01 bpm1 systemd: Started Session 274416 of user root.<br>Sep 18 03:30:02 bpm1 dbus[4380]: [system] Successfully activated service ‘org.fedoraproject.Setroubleshootd’<br>Sep 18 03:30:02 bpm1 setroubleshoot: failed to retrieve rpm info for &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs<br>Sep 18 03:30:02 bpm1 setroubleshoot: SELinux is preventing &#x2F;usr&#x2F;sbin&#x2F;logrotate from read access on the directory &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs. For complete SELinux messages run: sealert -l 22549acb-6393-4878-bf74-86df4389902e<br>Sep 18 03:30:02 bpm1 python: SELinux is preventing &#x2F;usr&#x2F;sbin&#x2F;logrotate from read access on the directory &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs.#012#012*****  Plugin restorecon (82.4 confidence) suggests   ************************#012#012If you want to fix the label. #012&#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs default label should be default_t.#012Then you can run restorecon. The access attempt may have been stopped due to insufficient permissions to access a parent directory in which case try to change the following command accordingly.#012Do#012# &#x2F;sbin&#x2F;restorecon -v &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs#012#012*****  Plugin file (7.05 confidence) suggests   ******************************#012#012If you think this is caused by a badly mislabeled machine.#012Then you need to fully relabel.#012Do#012touch &#x2F;.autorelabel; reboot#012#012*****  Plugin file (7.05 confidence) suggests   ******************************#012#012If you think this is caused by a badly mislabeled machine.#012Then you need to fully relabel.#012Do#012touch &#x2F;.autorelabel; reboot#012#012*****  Plugin catchall_labels (4.59 confidence) suggests   *******************#012#012If you want to allow logrotate to have read access on the logs directory#012Then you need to change the label on &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs#012Do#012# semanage fcontext -a -t FILE_TYPE ‘&#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs’#012where FILE_TYPE is one of the following: NetworkManager_log_t, NetworkManager_unit_file_t, NetworkManager_var_run_t, abrt_unit_file_t, abrt_var_cache_t, abrt_var_log_t, abrt_var_run_t, accountsd_unit_file_t, acct_data_t, admin_home_t, afs_logfile_t, aiccu_var_run_t, aide_log_t, ajaxterm_var_run_t, alsa_unit_file_t, alsa_var_run_t, amanda_log_t, amanda_unit_file_t, antivirus_log_t, antivirus_unit_file_t, antivirus_var_run_t, apcupsd_log_t, apcupsd_unit_file_t, apcupsd_var_run_t, apmd_log_t, apmd_unit_file_t, apmd_var_run_t, arpwatch_unit_file_t, arpwatch_var_run_t, asterisk_log_t, asterisk_var_run_t, audisp_var_run_t, auditd_unit_file_t, auditd_var_run_t, auth_cache_t, automount_unit_file_t, automount_var_run_t, avahi_unit_file_t, avahi_var_run_t, bacula_log_t, bacula_var_run_t, bcfg2_unit_file_t, bcfg2_var_run_t, bin_t, bitlbee_log_t, bitlbee_var_run_t, blkmapd_var_run_t, blktap_var_run_t, blueman_var_run_t, bluetooth_unit_file_t, bluetooth_var_run_t, boinc_log_t, boinc_unit_file_t, boot_t, bootloader_var_run_t, brltty_log_t, brltty_unit_file_t, brltty_var_run_t, bumblebee_unit_file_t, bumblebee_var_run_t, cachefilesd_var_run_t, calamaris_log_t, callweaver_log_t, callweaver_var_run_t, canna_log_t, canna_var_run_t, cardmgr_var_run_t, ccs_var_lib_t, ccs_var_log_t, ccs_var_run_t, cert_t, certmaster_var_log_t, certmaster_var_run_t, certmonger_unit_file_t, certmonger_var_run_t, cfengine_log_t, cgdcbxd_unit_file_t, cgdcbxd_var_run_t, cgred_log_t, cgred_var_run_t, cgroup_t, checkpc_log_t, chronyd_unit_file_t, chronyd_var_log_t, chronyd_var_run_t, cinder_api_unit_file_t, cinder_backup_unit_file_t, cinder_log_t, cinder_scheduler_unit_file_t, cinder_var_run_t, cinder_volume_unit_file_t, clogd_var_run_t, cloud_init_unit_file_t, cloud_log_t, cluster_unit_file_t, cluster_var_log_t, cluster_var_run_t, clvmd_var_run_t, cmirrord_var_run_t, cobbler_var_log_t, cockpit_unit_file_t, cockpit_var_run_t, collectd_unit_file_t, collectd_var_run_t, colord_unit_file_t, comsat_var_run_t, condor_log_t, condor_unit_file_t, condor_var_run_t, conman_log_t, conman_unit_file_t, conman_var_run_t, consolekit_log_t, consolekit_unit_file_t, consolekit_var_run_t, container_log_t, container_plugin_var_run_t, container_unit_file_t, container_var_run_t, couchdb_log_t, couchdb_unit_file_t, couchdb_var_run_t, courier_var_run_t, cpuplug_var_run_t, cpuspeed_var_run_t, cron_log_t, cron_var_run_t, crond_unit_file_t, crond_var_run_t, ctdbd_log_t, ctdbd_var_run_t, cupsd_config_var_run_t, cupsd_log_t, cupsd_lpd_var_run_t, cupsd_unit_file_t, cupsd_var_run_t, cvs_var_run_t, cyphesis_log_t, cyphesis_var_run_t, cyrus_var_run_t, dbskkd_var_run_t, dbusd_etc_t, dcc_var_run_t, dccd_var_run_t, dccifd_var_run_t, dccm_var_run_t, dcerpcd_var_run_t, ddclient_log_t, ddclient_var_run_t, deltacloudd_log_t, deltacloudd_var_run_t, denyhosts_var_log_t, device_t, devicekit_var_log_t, devicekit_var_run_t, dhcpc_var_run_t, dhcpd_unit_file_t, dhcpd_var_run_t, dictd_var_run_t, dirsrv_snmp_var_log_t, dirsrv_snmp_var_run_t, dirsrv_var_log_t, dirsrv_var_run_t, dirsrvadmin_unit_file_t, dkim_milter_data_t, dlm_controld_var_log_t, dlm_controld_var_run_t, dnsmasq_unit_file_t, dnsmasq_var_log_t, dnsmasq_var_run_t, dnssec_trigger_unit_file_t, dnssec_trigger_var_run_t, dovecot_var_log_t, dovecot_var_run_t, drbd_var_run_t, dspam_log_t, dspam_var_run_t, entropyd_var_run_t, etc_runtime_t, etc_t, eventlogd_var_run_t, evtchnd_var_log_t, evtchnd_var_run_t, exim_log_t, exim_var_run_t, fail2ban_log_t, fail2ban_var_run_t, faillog_t, fcoemon_var_run_t, fenced_var_log_t, fenced_var_run_t, fetchmail_log_t, fetchmail_var_run_t, file_context_t, fingerd_log_t, fingerd_var_run_t, firewalld_unit_file_t, firewalld_var_log_t, firewalld_var_run_t, foghorn_var_log_t, foghorn_var_run_t, fonts_cache_t, fonts_t, freeipmi_bmc_watchdog_unit_file_t, freeipmi_bmc_watchdog_var_run_t, freeipmi_ipmidetectd_unit_file_t, freeipmi_ipmidetectd_var_run_t, freeipmi_ipmiseld_unit_file_t, freeipmi_ipmiseld_var_run_t, fsadm_log_t, fsadm_var_run_t, fsdaemon_var_run_t, ftpd_unit_file_t, ftpd_var_run_t, games_srv_var_run_t, gdomap_var_run_t, getty_log_t, getty_unit_file_t, getty_var_run_t, gfs_controld_var_log_t, gfs_controld_var_run_t, glance_api_unit_file_t, glance_log_t, glance_registry_unit_file_t, glance_scrubber_unit_file_t, glance_var_run_t, glusterd_log_t, glusterd_var_run_t, gpm_var_run_t, gpsd_var_run_t, greylist_milter_data_t, groupd_var_log_t, groupd_var_run_t, gssproxy_unit_file_t, gssproxy_var_run_t, haproxy_unit_file_t, haproxy_var_log_t, haproxy_var_run_t, hsqldb_unit_file_t, httpd_config_t, httpd_log_t, httpd_sys_rw_content_t, httpd_unit_file_t, httpd_var_run_t, hwdata_t, hwloc_dhwd_unit_t, hwloc_var_run_t, hypervkvp_unit_file_t, hypervvssd_unit_file_t, icecast_log_t, icecast_var_run_t, ifconfig_var_run_t, inetd_child_var_run_t, inetd_log_t, inetd_var_run_t, init_var_run_t, initrc_var_log_t, initrc_var_run_t, innd_log_t, innd_unit_file_t, innd_var_run_t, insmod_var_run_t, iodined_unit_file_t, ipa_dnskey_unit_file_t, ipa_log_t, ipa_otpd_unit_file_t, ipa_var_run_t, ipmievd_unit_file_t, ipmievd_var_run_t, ipsec_log_t, ipsec_mgmt_unit_file_t, ipsec_mgmt_var_run_t, ipsec_var_run_t, iptables_unit_file_t, iptables_var_lib_t, iptables_var_run_t, irqbalance_var_run_t, iscsi_log_t, iscsi_unit_file_t, iscsi_var_run_t, isnsd_var_run_t, iwhd_log_t, iwhd_var_run_t, jetty_log_t, jetty_var_run_t, jockey_var_log_t, kadmind_log_t, kadmind_var_run_t, kdump_unit_file_t, keepalived_unit_file_t, keepalived_var_run_t, keystone_log_t, keystone_unit_file_t, keystone_var_run_t, kismet_log_t, kismet_var_run_t, klogd_var_run_t, kmscon_unit_file_t, krb5_conf_t, krb5kdc_log_t, krb5kdc_var_run_t, ksmtuned_log_t, ksmtuned_unit_file_t, ksmtuned_var_run_t, ktalkd_log_t, ktalkd_unit_file_t, l2tpd_var_run_t, lastlog_t, lib_t, lircd_var_run_t, lldpad_var_run_t, locale_t, locate_var_run_t, logrotate_tmp_t, logrotate_var_lib_t, logwatch_var_run_t, lpd_var_run_t, lsassd_var_run_t, lsmd_unit_file_t, lsmd_var_run_t, lttng_sessiond_unit_file_t, lttng_sessiond_var_run_t, lvm_unit_file_t, lvm_var_run_t, lwiod_var_run_t, lwregd_var_run_t, lwsmd_var_run_t, mailman_log_t, mailman_var_run_t, man_cache_t, man_t, mcelog_log_t, mcelog_var_run_t, mdadm_log_t, mdadm_unit_file_t, mdadm_var_run_t, memcached_var_run_t, minidlna_log_t, minidlna_var_run_t, minissdpd_var_run_t, mip6d_unit_file_t, mirrormanager_log_t, mirrormanager_var_run_t, mock_var_run_t, modemmanager_unit_file_t, mon_statd_var_run_t, mongod_log_t, mongod_unit_file_t, mongod_var_run_t, motion_log_t, motion_unit_file_t, motion_var_run_t, mount_var_run_t, mpd_log_t, mpd_var_run_t, mrtg_log_t, mrtg_var_run_t, mscan_var_run_t, munin_etc_t, munin_log_t, munin_var_run_t, mysqld_etc_t, mysqld_log_t, mysqld_unit_file_t, mysqld_var_run_t, mysqlmanagerd_var_run_t, mythtv_var_log_t, nagios_log<br>Sep 18 03:30:02 bpm1 setroubleshoot: failed to retrieve rpm info for &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt<br>Sep 18 03:30:02 bpm1 setroubleshoot: SELinux is preventing logrotate from ‘read, write’ accesses on the file &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt. For complete SELinux messages run: sealert -l 5fa91a89-8748-49ec-8a9a-d4f25d7c8078</p>
<p>Sep 18 03:30:02 bpm1 python: SELinux is preventing logrotate from ‘read, write’ accesses on the file &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt.#012#012*****  Plugin restorecon (82.4 confidence) suggests   ************************#012#012If you want to fix the label. #012&#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt default label should be default_t.#012Then you can run restorecon. The access attempt may have been stopped due to insufficient permissions to access a parent directory in which case try to change the following command accordingly.#012Do#012# &#x2F;sbin&#x2F;restorecon -v &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt#012#012*****  Plugin file (7.05 confidence) suggests   ******************************#012#012If you think this is caused by a badly mislabeled machine.#012Then you need to fully relabel.#012Do#012touch &#x2F;.autorelabel; reboot#012#012*****  Plugin file (7.05 confidence) suggests   ******************************#012#012If you think this is caused by a badly mislabeled machine.#012Then you need to fully relabel.#012Do#012touch &#x2F;.autorelabel; reboot#012#012*****  Plugin catchall_labels (4.59 confidence) suggests   *******************#012#012If you want to allow logrotate to have read write access on the logs.txt file#012Then you need to change the label on &#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt#012Do#012# semanage fcontext -a -t FILE_TYPE ‘&#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt’#012where FILE_TYPE is one of the following: NetworkManager_log_t, abrt_var_cache_t, abrt_var_log_t, acct_data_t, afs_cache_t, afs_logfile_t, aide_log_t, amanda_log_t, antivirus_log_t, apcupsd_log_t, apmd_log_t, asterisk_log_t, auth_cache_t, bacula_log_t, bitlbee_log_t, boinc_log_t, brltty_log_t, calamaris_log_t, callweaver_log_t, canna_log_t, ccs_var_lib_t, ccs_var_log_t, certmaster_var_log_t, cfengine_log_t, cgred_log_t, checkpc_log_t, chronyd_var_log_t, cinder_log_t, cloud_log_t, cluster_var_log_t, cobbler_var_log_t, condor_log_t, conman_log_t, consolekit_log_t, container_log_t, couchdb_log_t, cron_log_t, ctdbd_log_t, cupsd_log_t, cyphesis_log_t, ddclient_log_t, deltacloudd_log_t, denyhosts_var_log_t, devicekit_var_log_t, dirsrv_snmp_var_log_t, dirsrv_var_log_t, dlm_controld_var_log_t, dnsmasq_var_log_t, dovecot_var_log_t, dspam_log_t, evtchnd_var_log_t, exim_log_t, fail2ban_log_t, faillog_t, fenced_var_log_t, fetchmail_log_t, fingerd_log_t, firewalld_var_log_t, foghorn_var_log_t, fsadm_log_t, getty_log_t, gfs_controld_var_log_t, glance_log_t, glusterd_log_t, groupd_var_log_t, haproxy_var_log_t, httpd_log_t, icecast_log_t, inetd_log_t, initrc_var_log_t, innd_log_t, ipa_log_t, ipsec_log_t, iscsi_log_t, iwhd_log_t, jetty_log_t, jockey_var_log_t, kadmind_log_t, keystone_log_t, kismet_log_t, krb5kdc_log_t, ksmtuned_log_t, ktalkd_log_t, lastlog_t, logrotate_lock_t, logrotate_tmp_t, logrotate_var_lib_t, mailman_log_t, mcelog_log_t, mdadm_log_t, minidlna_log_t, mirrormanager_log_t, mongod_log_t, motion_log_t, mpd_log_t, mrtg_log_t, munin_log_t, mysqld_log_t, mythtv_var_log_t, nagios_log_t, named_cache_t, named_log_t, neutron_log_t, nova_log_t, nscd_log_t, nsd_log_t, ntpd_log_t, numad_var_log_t, openhpid_log_t, openshift_log_t, openshift_var_lib_t, opensm_log_t, openvpn_status_t, openvpn_var_log_t, openvswitch_log_t, openwsman_log_t, osad_log_t, passenger_log_t, pcp_log_t, piranha_log_t, pkcs_slotd_log_t, pki_log_t, pki_ra_log_t, pki_tomcat_log_t, pki_tps_log_t, plymouthd_var_log_t, polipo_log_t, postgresql_log_t, pppd_log_t, pptp_log_t, prelink_log_t, prelude_log_t, privoxy_log_t, procmail_log_t, prosody_log_t, psad_var_log_t, puppet_log_t, puppet_tmp_t, pyicqt_log_t, qdiskd_var_log_t, rabbitmq_var_log_t, radiusd_log_t, redis_log_t, rhev_agentd_log_t, rhsmcertd_log_t, ricci_modcluster_var_log_t, ricci_var_log_t, rpm_log_t, rsync_log_t, rtas_errd_log_t, samba_log_t, sanlock_log_t, sectool_var_log_t, sendmail_log_t, sensord_log_t, setroubleshoot_var_log_t, shorewall_log_t, slapd_log_t, slpd_log_t, smsd_log_t, snapperd_log_t, snmpd_log_t, snort_log_t, spamd_log_t, speech-dispatcher_log_t, squid_log_t, sssd_var_log_t, stapserver_log_t, stunnel_log_t, sudo_log_t, svnserve_log_t, sysstat_log_t, systemd_passwd_var_run_t, thin_aeolus_configserver_log_t, thin_log_t, tomcat_log_t, tor_var_log_t, tuned_log_t, ulogd_var_log_t, uucpd_log_t, var_log_t, var_spool_t, varnishlog_log_t, vdagent_log_t, virt_cache_t, virt_log_t, virt_qemu_ga_log_t, vmware_log_t, watchdog_log_t, winbind_log_t, wtmp_t, xdm_log_t, xend_var_log_t, xenstored_var_log_t, xferlog_t, xserver_log_t, zabbix_log_t, zarafa_deliver_log_t, zarafa_gateway_log_t, zarafa_ical_log_t, zarafa_indexer_log_t, zarafa_monitor_log_t, zarafa_server_log_t, zarafa_spooler_log_t, zebra_log_t, zoneminder_log_t.#012Then execute:#012restorecon -v ‘&#x2F;data&#x2F;bpm&#x2F;engine&#x2F;logs&#x2F;logs.txt’#012#012#012*****  Plugin catchall (1.31 confidence) suggests   **************************#012#012If you believe that logrotate should be allowed read write access on the logs.txt file by default.#012Then you should report this as a bug.#012You can generate a local policy module to allow this access.#012Do#012allow this access for now by executing:#012# ausearch -c ‘logrotate’ –raw  audit2allow -M my-logrotate#012# semodule -i my-logrotate.pp#012<br>Sep 18 03:31:01 bpm1 systemd: Started Session 274417 of user root.<br>Sep 18 03:32:01 bpm1 systemd: Started Session 274418 of user root.<br>Sep 18 03:33:01 bpm1 systemd: Started Session 274419 of user root.<br>Sep 18 03:34:01 bpm1 systemd: Started Session 274420 of user root.<br>Sep 18 03:35:01 bpm1 systemd: Started Session 274421 of user root.<br>Sep 18 03:36:01 bpm1 systemd: Started Session 274422 of user root.<br>Sep 18 03:37:01 bpm1 systemd: Started Session 274423 of user root.<br>Sep 18 03:38:01 bpm1 systemd: Started Session 274424 of user root.</p>
<h3 id="分析报错内容是selinux"><a href="#分析报错内容是selinux" class="headerlink" title="分析报错内容是selinux"></a>分析报错内容是selinux</h3><hr>
<p>查看selinux状态，发现selinux是开开启的</p>
<p>[<a href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#x63;&#111;&#x64;&#x65;&#x34;&#48;&#52;&#46;&#x69;&#99;&#x75;">&#x72;&#x6f;&#111;&#116;&#x40;&#x63;&#111;&#x64;&#x65;&#x34;&#48;&#52;&#46;&#x69;&#99;&#x75;</a> ~]# sestatus<br>SELinux status:                 enabled<br>SELinuxfs mount:                &#x2F;sys&#x2F;fs&#x2F;selinux<br>SELinux root directory:         &#x2F;etc&#x2F;selinux<br>Loaded policy name:             targeted<br>Current mode:                   enforcing<br>Mode from config file:          enforcing<br>Policy MLS status:              enabled<br>Policy deny_unknown status:     allowed<br>Max kernel policy version:      31</p>
<h3 id="调整selinux配置"><a href="#调整selinux配置" class="headerlink" title="调整selinux配置"></a>调整selinux配置</h3><hr>
<p>把selinux 调整为 permissive<br>临时修改</p>
<p>setenforce 0</p>
<p>永久修改</p>
<p>vim &#x2F;etc&#x2F;selinux&#x2F;config<br>SELINUX&#x3D;permissive</p>
<p>查看当前状态</p>
<p>[<a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#99;&#x6f;&#x64;&#101;&#x34;&#x30;&#52;&#46;&#105;&#99;&#x75;">&#114;&#111;&#x6f;&#x74;&#64;&#99;&#x6f;&#x64;&#101;&#x34;&#x30;&#52;&#46;&#105;&#99;&#x75;</a> ~]# sestatus<br>SELinux status:                 enabled<br>SELinuxfs mount:                &#x2F;sys&#x2F;fs&#x2F;selinux<br>SELinux root directory:         &#x2F;etc&#x2F;selinux<br>Loaded policy name:             targeted<br>Current mode:                   permissive<br>Mode from config file:          permissive<br>Policy MLS status:              enabled<br>Policy deny_unknown status:     allowed<br>Max kernel policy version:      31</p>
<p>此时，可以调整crontab 让logrotate 触发，就正常切割了</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>日志切割</tag>
        <tag>crontab</tag>
        <tag>logrotate</tag>
        <tag>preventing</tag>
        <tag>retrieve</tag>
        <tag>selinux</tag>
        <tag>sestatus</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven仓库配置163源</title>
    <url>/2021/04/16/maven%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE163%E6%BA%90/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/2021041600263985.png"></p>
<h2 id="一、在maven软件中使用"><a href="#一、在maven软件中使用" class="headerlink" title="一、在maven软件中使用"></a>一、在maven软件中使用</h2><h6 id="以apache-maven-3-8-1-为例："><a href="#以apache-maven-3-8-1-为例：" class="headerlink" title="以apache-maven-3.8.1 为例："></a>以apache-maven-3.8.1 为例：</h6><p>打开maven配置文件</p>
<p>.&#x2F;apache-maven-3.8.1&#x2F;conf&#x2F;settings.xml</p>
<p>找到<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签节点</p>
<p>添加一个的mirror子节点：</p>
<mirror>
    <id>nexus-163</id>
    <mirrorOf>\*</mirrorOf>
    <name>Nexus 163</name>
    <url>http://mirrors.163.com/maven/repository/maven-public/</url>
</mirror>

<h1 id="二、在maven项目pom中使用"><a href="#二、在maven项目pom中使用" class="headerlink" title="二、在maven项目pom中使用"></a>二、在maven项目pom中使用</h1><p>打开项目配置文件<code>pom.xml</code><br>添加或修改</p>
<repositories>
    <repository>
        <id>nexus-163</id>
        <name>Nexus 163</name>
        <url>http://mirrors.163.com/maven/repository/maven-public/</url>
        <layout>default</layout>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
        <releases>
            <enabled>true</enabled>
        </releases>
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
        <id>nexus-163</id>
        <name>Nexus 163</name>
        <url>http://mirrors.163.com/maven/repository/maven-public/</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
        <releases>
            <enabled>true</enabled>
        </releases>
    </pluginRepository>
</pluginRepositories>

<p>执行更新一下即可。</p>
<p>mvn update</p>
<p>已上就是Maven仓库配置163源配置过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>仓库</tag>
        <tag>163</tag>
        <tag>Maven</tag>
        <tag>源</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>mount 挂载 nfs 报错 mount: wrong fs type, bad option, bad superblock on</title>
    <url>/2021/12/29/mount-%E6%8C%82%E8%BD%BD-nfs-%E6%8A%A5%E9%94%99-mount-wrong-fs-type-bad-option-bad-superblock-on/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-21.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>NFS就是Network File System的缩写，它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。<br>NFS服务器可以让PC将网络中的NFS服务器共享的目录挂载到本地端的文件系统中，而在本地端的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样，在使用上相当便利</p>
<h3 id="远程挂载时发生错误"><a href="#远程挂载时发生错误" class="headerlink" title="远程挂载时发生错误"></a>远程挂载时发生错误</h3><hr>
<p>在远程服务器上挂载时报错</p>
<p>mount: wrong fs type, bad option, bad superblock on 192.168.55.102:&#x2F;data,<br>missing codepage or helper program, or other error<br>(for several filesystems (e.g. nfs, cifs) you might<br>need a &#x2F;sbin&#x2F;mount. helper program)<br>In some cases useful info is found in syslog - try<br>dmesg tail or so</p>
<h3 id="问题解决方法"><a href="#问题解决方法" class="headerlink" title="问题解决方法"></a>问题解决方法</h3><hr>
<p>这个问题是由于远程客户端没有安装 nfs 工具<br>在客户端安装nfs-utils</p>
<p>#centos<br>yum install nfs-utils<br>#ubuntu<br>apt-get install nfs-common</p>
<h3 id="验证-mount-挂载"><a href="#验证-mount-挂载" class="headerlink" title="验证 mount 挂载"></a>验证 mount 挂载</h3><hr>
<p>这回就不报错了</p>
<p>mount -t nfs 192.168.55.102:&#x2F;data &#x2F;data</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>bad superblock</tag>
        <tag>nfs</tag>
        <tag>NFS挂载</tag>
        <tag>远程挂载</tag>
      </tags>
  </entry>
  <entry>
    <title>mvcc: cannot unmarshal event: proto: wrong wireType = 0 for field Key</title>
    <url>/2021/10/14/mvcc-cannot-unmarshal-event-proto-wrong-wiretype-0-for-field-key/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-10.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>查看etcd的启动日志，发现报错mvcc: cannot unmarshal event: proto: wrong wireType &#x3D; 0 for field Key。经查询资料，此报错是由于服务器非正常关机（意外掉电，强制拔电)后 etcd数据损坏导致的，这个节点之前确实是出现异常关机，etcd无法启动，那么解决此问题就行了</p>
<h3 id="对-etcd-db-进行数据校验，发现数据被损坏："><a href="#对-etcd-db-进行数据校验，发现数据被损坏：" class="headerlink" title="对 etcd db 进行数据校验，发现数据被损坏："></a>对 etcd db 进行数据校验，发现数据被损坏：</h3><hr>
<p>[root@node-1 ~]# bolt check &#x2F;var&#x2F;lib&#x2F;etcd&#x2F;member&#x2F;snap&#x2F;db<br>page 1143: multiple references<br>page 1072: multiple references<br>page 1122: multiple references<br>page 1138: multiple references<br>page 1088: multiple references<br>page 630: unreachable unfreed<br>page 999: unreachable unfreed<br>page 1021: unreachable unfreed<br>page 1029: unreachable unfreed<br>page 1098: unreachable unfreed<br>10 errors found<br>invalid value</p>
<h3 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h3><hr>
<p>通过如下方式可以把损坏的 etcd 节点（例子中node-1上的 etcd1 <a href="https://10.60.1.3:2380）先移除再重新加入集群：">https://10.60.1.3:2380）先移除再重新加入集群：</a></p>
<h4 id="1、在故障节点停止-etcd服务并删除损坏的-etcd-数据"><a href="#1、在故障节点停止-etcd服务并删除损坏的-etcd-数据" class="headerlink" title="1、在故障节点停止 etcd服务并删除损坏的 etcd 数据"></a>1、在故障节点停止 etcd服务并删除损坏的 etcd 数据</h4><hr>
<p>[root@node-1 ~] systemctl stop etcd; mv &#x2F;var&#x2F;lib&#x2F;etcd&#x2F;member&#x2F;* ~&#x2F;etcd-backup</p>
<h4 id="2、在其它节点找到故障etcd-的-member-id-并从-从集群中移除"><a href="#2、在其它节点找到故障etcd-的-member-id-并从-从集群中移除" class="headerlink" title="2、在其它节点找到故障etcd 的 member id 并从 从集群中移除"></a>2、在其它节点找到故障etcd 的 member id 并从 从集群中移除</h4><hr>
<p>[root@node-2 ~]# etcdctl member list<br>39872ad0e5987746, started, etcd3, <a href="https://10.60.1.5:2380/">https://10.60.1.5:2380</a>, <a href="https://10.60.1.5:2379/">https://10.60.1.5:2379</a><br>72af99a4c899158b, unstarted, etcd1, <a href="https://10.60.1.3:2380/">https://10.60.1.3:2380</a>, <a href="https://10.60.1.3:2379/">https://10.60.1.3:2379</a><br>cd39f3691f506c2b, started, etcd2, <a href="https://10.60.1.4:2380/">https://10.60.1.4:2380</a>, <a href="https://10.60.1.4:2379/">https://10.60.1.4:2379</a><br>[root@node-2 ~]# etcdctl member remove 72af99a4c899158b</p>
<h4 id="3、重新把-etcd1添加回集群"><a href="#3、重新把-etcd1添加回集群" class="headerlink" title="3、重新把 etcd1添加回集群"></a>3、重新把 etcd1添加回集群</h4><hr>
<p>[root@node-2 ~]# etcdctl member add etcd1 –peer-urls&#x3D;<a href="https://10.60.1.3:2380/">https://10.60.1.3:2380</a><br>Member a431fc3546d257c4 added to cluster 9a63314b15ba7312<br>ETCD_NAME&#x3D;”etcd1”<br>ETCD_INITIAL_CLUSTER&#x3D;”etcd3&#x3D;<a href="https://10.60.1.5:2380,etcd1=https://10.60.1.3:2380,etcd2=https://10.60.1.4:2380&quot;">https://10.60.1.5:2380,etcd1=https://10.60.1.3:2380,etcd2=https://10.60.1.4:2380&quot;</a><br>ETCD_INITIAL_CLUSTER_STATE&#x3D;”existing”</p>
<h4 id="4、在故障节点重启-etcd-服务"><a href="#4、在故障节点重启-etcd-服务" class="headerlink" title="4、在故障节点重启 etcd 服务"></a>4、在故障节点重启 etcd 服务</h4><hr>
<p>[root@node-1 ~] systemctl start etcd</p>
<h4 id="5、查看确认etcd-和-Kubernetes集群恢复正常"><a href="#5、查看确认etcd-和-Kubernetes集群恢复正常" class="headerlink" title="5、查看确认etcd 和 Kubernetes集群恢复正常"></a>5、查看确认etcd 和 Kubernetes集群恢复正常</h4><hr>
<p>1）etcdctl member list确认etcd集群恢复正常<br>2）kubectl get pod –namespace kube-systemgrep apiservergrep node-1确认 apiserver 恢复正常<br>3）kubectl get node grep node-1确认节点处于 Ready 状态</p>
<p>在故障节点上停止etcd服务并删除损坏的 etcd 数据，现在etcd服务本来就没有启动，删除前先备份数据，最后启动etcd服务</p>
<p>注意事项：如果在3个控制节点的集群，出现2个节点 etcd 数据损坏，可能造成整个集群无法恢复的风险。请确保不对服务器进行非正常关机操作。</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>kubernets</tag>
        <tag>0 for field Key</tag>
        <tag>cannot unmarshal event</tag>
        <tag>etcd</tag>
        <tag>mvcc</tag>
        <tag>proto</tag>
        <tag>wrong wireType</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 报错 错误码 1045 - Unknow error 1045</title>
    <url>/2021/04/06/mysql-%E6%8A%A5%E9%94%99-%E9%94%99%E8%AF%AF%E7%A0%81-1045-unknow-error-1045/</url>
    <content><![CDATA[<h4 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h4><h6 id="密码错误"><a href="#密码错误" class="headerlink" title="密码错误"></a><strong>密码错误</strong></h6><hr>
<p><img src="https://code404.icu/img/moveypu/2021/04/2021040601454729.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名：root</span><br><span class="line">密码：r123</span><br><span class="line"></span><br><span class="line">修改密码为：ROOT123</span><br><span class="line"></span><br><span class="line">[root@host-192-168-1-1 ~]# mysqladmin -uroot -proot123 password &#x27;ROOT123&#x27;</span><br><span class="line">mysqladmin: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">mysqladmin: connect to server at &#x27;localhost&#x27; failed</span><br><span class="line">error: &#x27;Unknown error 1045&#x27;</span><br><span class="line"></span><br><span class="line">[root@host-192-168-1-1 ~]# mysqladmin -uroot -pr123 password &#x27;ROOT123&#x27;</span><br><span class="line">mysqladmin: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="error-‘Unknown-error-1045’"><a href="#error-‘Unknown-error-1045’" class="headerlink" title="error: ‘Unknown error 1045’"></a>error: ‘Unknown error 1045’</h3><p>登录用户或密码错误，重置密码就可以解决</p>
<p>mysql重置密码 <a href="http://#">请移步</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>1045</tag>
        <tag>Unknow error 1045</tag>
        <tag>登录报错</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 时间类型 datetime、bigint、timestamp，应该选哪个？日期时间数据类型对比</title>
    <url>/2021/09/13/mysql-%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B-datetime%E3%80%81bigint%E3%80%81timestamp%EF%BC%8C%E5%BA%94%E8%AF%A5%E9%80%89%E5%93%AA%E4%B8%AA%EF%BC%9F%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%95%B0/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-11.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>数据库中可以用datetime、bigint、timestamp来表示时间，那么选择什么类型来存储时间比较合适呢？</p>
<h3 id="前期数据准备"><a href="#前期数据准备" class="headerlink" title="前期数据准备"></a>前期数据准备</h3><hr>
<p>通过程序往数据库插入50w数据</p>
<ul>
<li>数据表：</li>
</ul>
<p>CREATE TABLE `users` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `time_date` datetime NOT NULL,<br>  `time_timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,<br>  `time_long` bigint(20) NOT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `time_long` (`time_long`),<br>  KEY `time_timestamp` (`time_timestamp`),<br>  KEY `time_date` (`time_date`)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;500003 DEFAULT CHARSET&#x3D;latin1</p>
<p>其中time_long、time_timestamp、time_date为同一时间的不同存储格式</p>
<ul>
<li>实体类users</li>
</ul>
<p>&#x2F;**<br> * @author hetiantian<br> * @date 2018&#x2F;10&#x2F;21<br> * *&#x2F;<br>@Builder<br>@Data<br>public class Users {<br>    &#x2F;**<br>     * 自增唯一id<br>     * *&#x2F;<br>    private Long id;</p>
<pre><code>/\*\*
 \* date类型的时间
 \* \*/
private Date timeDate;

/\*\*
 \* timestamp类型的时间
 \* \*/
private Timestamp timeTimestamp;

/\*\*
 \* long类型的时间
 \* \*/
private long timeLong;
</code></pre>
<p>}</p>
<ul>
<li>dao层接口</li>
</ul>
<p>&#x2F;**<br> * @author hetiantian<br> * @date 2018&#x2F;10&#x2F;21<br> * *&#x2F;<br>@Mapper<br>public interface UsersMapper {<br>    @Insert(“insert into users(time_date, time_timestamp, time_long) value(#{timeDate}, #{timeTimestamp}, #{timeLong})”)<br>    @Options(useGeneratedKeys &#x3D; true,keyProperty &#x3D; “id”,keyColumn &#x3D; “id”)<br>    int saveUsers(Users users);<br>}</p>
<ul>
<li>测试类往数据库插入数据</li>
</ul>
<p>public class UsersMapperTest extends BaseTest {<br>    @Resource<br>    private UsersMapper usersMapper;</p>
<pre><code>@Test
public void test() &#123;
    for (int i = 0; i &lt; 500000; i++) &#123;
        long time = System.currentTimeMillis();
        usersMapper.saveUsers(Users.builder().timeDate(new Date(time)).timeLong(time).timeTimestamp(new Timestamp(time)).build());
    &#125;
&#125;
</code></pre>
<p>}</p>
<h3 id="sql查询速率测试"><a href="#sql查询速率测试" class="headerlink" title="sql查询速率测试"></a>sql查询速率测试</h3><hr>
<ul>
<li>通过datetime类型查询：</li>
</ul>
<p>select count(*) from users where time_date &gt;&#x3D;”2018-10-21 23:32:44” and time_date &lt;&#x3D;”2018-10-21 23:41:22”</p>
<p>耗时：0.171</p>
<ul>
<li>通过timestamp类型查询</li>
</ul>
<p>select count(*) from users where time_timestamp &gt;&#x3D; “2018-10-21 23:32:44” and time_timestamp &lt;&#x3D;”2018-10-21 23:41:22”</p>
<p>耗时：0.351</p>
<ul>
<li>通过bigint类型查询</li>
</ul>
<p>select count(*) from users where time_long &gt;&#x3D;1540135964091 and time_long &lt;&#x3D;1540136482372</p>
<p>耗时：0.130s</p>
<ul>
<li>结论 在InnoDB存储引擎下，通过时间范围查找，性能bigint &gt; datetime &gt; timestamp</li>
</ul>
<h3 id="sql分组速率测试"><a href="#sql分组速率测试" class="headerlink" title="sql分组速率测试"></a>sql分组速率测试</h3><hr>
<p>使用bigint 进行分组会每条数据进行一个分组，如果将bigint做一个转化在去分组就没有比较的意义了，转化也是需要时间的</p>
<ul>
<li>通过datetime类型分组：</li>
</ul>
<p>select time_date, count(*) from users group by time_date</p>
<p>耗时：0.176s</p>
<ul>
<li>通过timestamp类型分组：</li>
</ul>
<p>select time_timestamp, count(*) from users group by time_timestamp</p>
<p>耗时：0.173s</p>
<ul>
<li>结论 在InnoDB存储引擎下，通过时间分组，性能timestamp &gt; datetime，但是相差不大</li>
</ul>
<h3 id="sql排序速率测试"><a href="#sql排序速率测试" class="headerlink" title="sql排序速率测试"></a>sql排序速率测试</h3><hr>
<ul>
<li>通过datetime类型排序：</li>
</ul>
<p>select * from users order by time_date</p>
<p>耗时：1.038s</p>
<ul>
<li>通过timestamp类型排序</li>
</ul>
<p>select * from users order by time_timestamp</p>
<p>耗时：0.933s</p>
<ul>
<li>通过bigint类型排序</li>
</ul>
<p>select * from users order by time_long</p>
<p>耗时：0.775s</p>
<ul>
<li>结论 在InnoDB存储引擎下，通过时间排序，性能bigint &gt; timestamp &gt; datetime</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>如果需要对时间字段进行操作(如通过时间范围查找或者排序等)，推荐使用bigint，如果时间字段不需要进行任何操作，推荐使用timestamp，使用4个字节保存比较节省空间，但是只能记录到2038年记录的时间有限。</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>bigint</tag>
        <tag>datetime</tag>
        <tag>timestamp</tag>
        <tag>日期数据类型比较</tag>
        <tag>时间类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql忘记密码_如何重置Mysql密码重置mariadb密码</title>
    <url>/2021/04/11/mysql%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81-%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEmysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AEmariadb%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1-先将MySQL停止"><a href="#1-先将MySQL停止" class="headerlink" title="1.先将MySQL停止"></a>1.先将MySQL停止</h2><h5 id="查看-Mariadb-状态"><a href="#查看-Mariadb-状态" class="headerlink" title="查看 Mariadb 状态"></a>查看 Mariadb 状态</h5><p>命令：systemctl status mariadb #查看状态</p>
<p>[root@localhost ~]# systemctl status mariadb<br>● mariadb.service - MariaDB database server<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;mariadb.service; enabled; vendor preset: disabled)<br>   Active: active (running) since 四 2021-04-08 14:14:27 CST; 7min ago<br>  Process: 1131 ExecStartPost&#x3D;&#x2F;usr&#x2F;libexec&#x2F;mariadb-wait-ready $MAINPID (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br>  Process: 1066 ExecStartPre&#x3D;&#x2F;usr&#x2F;libexec&#x2F;mariadb-prepare-db-dir %n (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br> Main PID: 1130 (mysqld_safe)<br>   CGroup: &#x2F;system.slice&#x2F;mariadb.service<br>           ├─1130 &#x2F;bin&#x2F;sh &#x2F;usr&#x2F;bin&#x2F;mysqld_safe –basedir&#x3D;&#x2F;usr<br>           └─1360 &#x2F;usr&#x2F;libexec&#x2F;mysqld –basedir&#x3D;&#x2F;usr –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql –plugin-dir&#x3D;&#x2F;usr&#x2F;lib64&#x2F;mysql&#x2F;plugin –log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mari…</p>
<p>4月 08 14:14:21 localhost.localdomain systemd[1]: Starting MariaDB database server…<br>4月 08 14:14:23 localhost.localdomain mariadb-prepare-db-dir[1066]: Database MariaDB is probably initialized in &#x2F;var&#x2F;lib&#x2F;mysql already, nothing is done.<br>4月 08 14:14:23 localhost.localdomain mariadb-prepare-db-dir[1066]: If this is not the case, make sure the &#x2F;var&#x2F;lib&#x2F;mysql is empty before running mariadb-prepare-db-dir.<br>4月 08 14:14:23 localhost.localdomain mysqld_safe[1130]: 210408 14:14:23 mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>4月 08 14:14:24 localhost.localdomain mysqld_safe[1130]: 210408 14:14:24 mysqld_safe Starting mysqld daemon with databases from &#x2F;var&#x2F;lib&#x2F;mysql<br>4月 08 14:14:27 localhost.localdomain systemd[1]: Started MariaDB database server.</p>
<h5 id="停止-mariadb-服务"><a href="#停止-mariadb-服务" class="headerlink" title="停止 mariadb 服务"></a>停止 mariadb 服务</h5><p>[root@localhost ~]# systemctl stop mariadb</p>
<h2 id="2-然后跳过授权表启动MySQL服务程序"><a href="#2-然后跳过授权表启动MySQL服务程序" class="headerlink" title="2.然后跳过授权表启动MySQL服务程序"></a>2.然后跳过授权表启动MySQL服务程序</h2><h5 id="启动mysql跳过授权表"><a href="#启动mysql跳过授权表" class="headerlink" title="启动mysql跳过授权表"></a>启动mysql跳过授权表</h5><p>[root@localhost ~]# &#x2F;usr&#x2F;bin&#x2F;mysqld_safe<br>210408 14:23:16 mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>210408 14:23:16 mysqld_safe Starting mysqld daemon with databases from &#x2F;var&#x2F;lib&#x2F;mysql</p>
<h5 id="开启一个新终端执行mysql进入mysql命令行"><a href="#开启一个新终端执行mysql进入mysql命令行" class="headerlink" title="开启一个新终端执行mysql进入mysql命令行"></a>开启一个新终端执行mysql进入mysql命令行</h5><p>[root@localhost ~]# mysql<br>Welcome to the MariaDB monitor.  Commands end with ; or \g.<br>Your MariaDB connection id is 2<br>Server version: 5.5.68-MariaDB MariaDB Server</p>
<p>Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</p>
<p>Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.</p>
<p>MariaDB [(none)]&gt; </p>
<h5 id="查看mysql用户列表"><a href="#查看mysql用户列表" class="headerlink" title="查看mysql用户列表"></a>查看mysql用户列表</h5><p>MariaDB [(none)]&gt; select user,password,host from mysql.user;<br>+——+——————————————-+———–+<br> user  password                                   host<br>+——+——————————————-+———–+<br> root  *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9  127.0.0.1<br> root                                             ::1<br>+——+——————————————-+———–+</p>
<h5 id="忘记root用户密码，修改root用户的密码为rootPwd1234"><a href="#忘记root用户密码，修改root用户的密码为rootPwd1234" class="headerlink" title="忘记root用户密码，修改root用户的密码为rootPwd1234"></a>忘记root用户密码，修改root用户的密码为rootPwd1234</h5><p>MariaDB [(none)]&gt; update mysql.user set password&#x3D;password(‘rootPwd1234’) where User&#x3D;”root” and Host&#x3D;”127.0.0.1”;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0</p>
<p>MariaDB [(none)]&gt; select user,password,host from mysql.user;<br>+——+——————————————-+———–+<br> user  password                                   host<br>+——+——————————————-+———–+<br> root  *9A8DADA52F3C4C5613A4074064974949033E3C62  127.0.0.1<br> root                                             ::1<br>+——+——————————————-+———–+<br>2 rows in set (0.00 sec)<br>MariaDB [(none)]&gt; flush privileges;<br>Query OK, 0 rows affected (0.00 sec)</p>
<h2 id="3-重新启动mysql"><a href="#3-重新启动mysql" class="headerlink" title="3.重新启动mysql"></a>3.重新启动mysql</h2><h5 id="ctrl-C-结束上面启动的mysqld-safe进行"><a href="#ctrl-C-结束上面启动的mysqld-safe进行" class="headerlink" title="ctrl-C 结束上面启动的mysqld_safe进行"></a>ctrl-C 结束上面启动的mysqld_safe进行</h5><p>Ctrl-c 结束不了进程，可以Ctrl-z退出，再执行kill</p>
<p>[root@localhost ~]# &#x2F;usr&#x2F;bin&#x2F;mysqld_safe<br>210409 12:09:58 mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>210409 12:09:58 mysqld_safe Starting mysqld daemon with databases from &#x2F;var&#x2F;lib&#x2F;mysql<br>^C^C^Z<br>[1]+  已停止               &#x2F;usr&#x2F;bin&#x2F;mysqld_safe<br>[root@localhost ~]# ps -ef grep mysql<br>root       2586   2069  0 12:09 pts&#x2F;0    00:00:00 &#x2F;bin&#x2F;sh &#x2F;usr&#x2F;bin&#x2F;mysqld_safe<br>mysql      2722   2586  0 12:09 pts&#x2F;0    00:00:00 &#x2F;usr&#x2F;libexec&#x2F;mysqld –basedir&#x3D;&#x2F;usr –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql –plugin-dir&#x3D;&#x2F;usr&#x2F;lib64&#x2F;mysql&#x2F;plugin –user&#x3D;mysql –log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid –socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock<br>root       2746   2069  0 12:10 pts&#x2F;0    00:00:00 grep –color&#x3D;auto mysql<br>[root@localhost ~]# kill -9 2586 2722<br>[root@localhost ~]#<br>[1]+  已杀死               &#x2F;usr&#x2F;bin&#x2F;mysqld_safe<br>[root@localhost ~]# ps -ef grep mysql<br>root       2748   2069  0 12:10 pts&#x2F;0    00:00:00 grep –color&#x3D;auto mysql<br>[root@localhost ~]# </p>
<h5 id="启动mariadb服务"><a href="#启动mariadb服务" class="headerlink" title="启动mariadb服务"></a>启动mariadb服务</h5><p>[root@localhost ~]# systemctl start mariadb<br>[root@localhost ~]# systemctl status mariadb<br>● mariadb.service - MariaDB database server<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;mariadb.service; enabled; vendor preset: disabled)<br>   Active: active (running) since 五 2021-04-09 12:12:22 CST; 4s ago<br>  Process: 2790 ExecStartPost&#x3D;&#x2F;usr&#x2F;libexec&#x2F;mariadb-wait-ready $MAINPID (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br>  Process: 2755 ExecStartPre&#x3D;&#x2F;usr&#x2F;libexec&#x2F;mariadb-prepare-db-dir %n (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)<br> Main PID: 2789 (mysqld_safe)<br>   CGroup: &#x2F;system.slice&#x2F;mariadb.service<br>           ├─2789 &#x2F;bin&#x2F;sh &#x2F;usr&#x2F;bin&#x2F;mysqld_safe –basedir&#x3D;&#x2F;usr<br>           └─2959 &#x2F;usr&#x2F;libexec&#x2F;mysqld –basedir&#x3D;&#x2F;usr –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql –plugin-dir&#x3D;&#x2F;usr&#x2F;lib64&#x2F;mysql&#x2F;plugin –log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mari…</p>
<p>4月 09 12:12:20 localhost.localdomain systemd[1]: Starting MariaDB database server…<br>4月 09 12:12:20 localhost.localdomain mariadb-prepare-db-dir[2755]: Database MariaDB is probably initialized in &#x2F;var&#x2F;lib&#x2F;mysql already, nothing is done.<br>4月 09 12:12:20 localhost.localdomain mysqld_safe[2789]: 210409 12:12:20 mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>4月 09 12:12:20 localhost.localdomain mysqld_safe[2789]: 210409 12:12:20 mysqld_safe Starting mysqld daemon with databases from &#x2F;var&#x2F;lib&#x2F;mysql<br>4月 09 12:12:22 localhost.localdomain systemd[1]: Started MariaDB database server.<br>[root@localhost ~]# </p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>[root@localhost ~]# mysql -h127.0.0.1 -prootPwd1234<br>Welcome to the MariaDB monitor.  Commands end with ; or \g.<br>Your MariaDB connection id is 5<br>Server version: 5.5.68-MariaDB MariaDB Server</p>
<p>Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</p>
<p>Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.</p>
<p>MariaDB [(none)]&gt; show databases;<br>+——————–+<br> Database<br>+——————–+<br> information_schema<br> mysql<br> performance_schema<br> test<br>+——————–+<br>5 rows in set (0.00 sec)</p>
<p>MariaDB [(none)]&gt; </p>
<p><strong>已上就是mysql重置密码过程，觉得有用就给个赞吧</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>centos</tag>
        <tag>重置密码</tag>
        <tag>mariadb</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据定时备份mysqldump</title>
    <url>/2021/06/22/mysql%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDmysqldump/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-51.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常工作中，总会有因手抖、写错条件、写错表名、错连生产库造成的误删库表和数据的事情发生。但是，如果每次删库都跑路的话，怕是再也不好找工作了吧！所以，删库跑路不是上上策。</p>
<p>数据恢复的前提的做好备份，且开启 binlog，格式为 row。如果没有备份文件，那么删掉库表后就真的删掉了，lsof 中还有记录的话，有可能恢复一部分文件。但若刚好数据库没有打开这个表文件，那就只能跑路了。如果没有开启 binlog，那么恢复数据后，从备份时间点开始的数据都没了。如果 binlog 格式不为 row，那么在误操作数据后就没有办法做闪回操作，只能老老实实地走备份恢复流程。</p>
<h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p>计划任务：</p>
<p>crontab -e<br>0 1 * * * &#x2F;bin&#x2F;bash &#x2F;data&#x2F;backup.sh #每天晚上1点备份</p>
<h2 id="备份脚本：-x2F-data-x2F-backup-sh"><a href="#备份脚本：-x2F-data-x2F-backup-sh" class="headerlink" title="备份脚本：&#x2F;data&#x2F;backup.sh"></a>备份脚本：&#x2F;data&#x2F;backup.sh</h2><p>#!&#x2F;bin&#x2F;sh<br>#description : dump mysql 10.64.35.118 databases to 10.64.35.144:&#x2F;extArray1&#x2F;OTS_DB_BACKUP&#x2F;</p>
<p>myuser&#x3D;’root’ # 用户名<br>mypass&#x3D;’123456’ # 密码<br>socket&#x3D;’&#x2F;data&#x2F;public&#x2F;mysql&#x2F;sock&#x2F;118.sock’ # sock文件<br>mycmd&#x3D;”&#x2F;data&#x2F;public&#x2F;mysql&#x2F;bin&#x2F;mysql -u$myuser -p$mypass -S $socket” # mysql登录命令<br>mydump&#x3D;”&#x2F;data&#x2F;public&#x2F;mysql&#x2F;bin&#x2F;mysqldump -u$myuser -p$mypass -S $socket” #mysqldump 备份命令<br>destDir&#x3D;”&#x2F;data&#x2F;backup&#x2F;database&#x2F;$(date +%F)” # 备份目录<br>mkdir -p $destDir</p>
<p>for database in `$mycmd -e “show databases;”sed ‘1,2d’egrep -v “mysqlschemasys”`<br>do<br>echo $database<br>for table in `$mycmd -e “show tables from $database;”sed ‘1d’`<br>do<br>echo $table</p>
<h1 id="按表备份-所有表"><a href="#按表备份-所有表" class="headerlink" title="按表备份 所有表"></a>按表备份 所有表</h1><p>$mydump $database $table &gt; $destDir&#x2F;mysqlbak_“$database”_“$table”_$(date +%F).sql<br>done</p>
<h1 id="按库备份-所有库"><a href="#按库备份-所有库" class="headerlink" title="按库备份 所有库"></a>按库备份 所有库</h1><p>$mydump -B $database  gzip &gt; $destDir&#x2F;mysqlbak_“$database”_$(date +%F).sql.gz<br>done<br>#备份到远程服务器<br>cp -r $destDir  &#x2F;backup&#x2F;database&#x2F;idaas&#x2F;<br>#gzip &#x2F;backup&#x2F;database&#x2F;idaas&#x2F;</p>
<p>#清理7天前的数据<br>#clearFileDate&#x3D;’date -d ‘8 day ago’  +%F’<br>#rm -f &#x2F;backup&#x2F;database&#x2F;idaas&#x2F;mysqlbak_*$clearFileDate*.sql</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>Mysqldump</tag>
        <tag>数据备份</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库备份_mysqldump定时备份</title>
    <url>/2021/09/09/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD-mysqldump%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-7-1024x538.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在操作数据过程中，可能会导致数据错误，甚至数据库奔溃，而有效的定时备份能很好地保护数据库。本篇文章主要讲述了几种方法进行 MySQL 定时备份数据库。</p>
<h3 id="一、mysqldump命令备份数据"><a href="#一、mysqldump命令备份数据" class="headerlink" title="一、mysqldump命令备份数据"></a>一、mysqldump命令备份数据</h3><hr>
<p>在MySQL中提供了命令行导出数据库数据以及文件的一种方便的工具mysqldump,我们可以通过命令行直接实现数据库内容的导出dump,首先我们简单了解一下mysqldump命令用法:</p>
<p>#MySQLdump常用<br>mysqldump -u root -p –databases 数据库1 数据库2 &gt; xxx.sql</p>
<h3 id="二、mysqldump常用操作示例"><a href="#二、mysqldump常用操作示例" class="headerlink" title="二、mysqldump常用操作示例"></a>二、mysqldump常用操作示例</h3><hr>
<h4 id="1-备份全部数据库的数据和结构"><a href="#1-备份全部数据库的数据和结构" class="headerlink" title="1.备份全部数据库的数据和结构"></a>1.备份全部数据库的数据和结构</h4><p>mysqldump -uroot -p123456 -A &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="2-备份全部数据库的结构（加-d-参数）"><a href="#2-备份全部数据库的结构（加-d-参数）" class="headerlink" title="2.备份全部数据库的结构（加 -d 参数）"></a>2.备份全部数据库的结构（加 -d 参数）</h4><p>mysqldump -uroot -p123456 -A -d &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="3-备份全部数据库的数据-加-t-参数"><a href="#3-备份全部数据库的数据-加-t-参数" class="headerlink" title="3.备份全部数据库的数据(加 -t 参数)"></a>3.备份全部数据库的数据(加 -t 参数)</h4><p>mysqldump -uroot -p123456 -A -t &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="4-备份单个数据库的数据和结构-数据库名mydb"><a href="#4-备份单个数据库的数据和结构-数据库名mydb" class="headerlink" title="4.备份单个数据库的数据和结构(,数据库名mydb)"></a>4.备份单个数据库的数据和结构(,数据库名mydb)</h4><p>mysqldump -uroot-p123456 mydb &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="5-备份单个数据库的结构"><a href="#5-备份单个数据库的结构" class="headerlink" title="5. 备份单个数据库的结构"></a>5. 备份单个数据库的结构</h4><p>mysqldump -uroot -p123456 mydb -d &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="6-备份单个数据库的数据"><a href="#6-备份单个数据库的数据" class="headerlink" title="6. 备份单个数据库的数据"></a>6. 备份单个数据库的数据</h4><p>mysqldump -uroot -p123456 mydb -t &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="7-备份多个表的数据和结构（数据，结构的单独备份方法与上同）"><a href="#7-备份多个表的数据和结构（数据，结构的单独备份方法与上同）" class="headerlink" title="7. 备份多个表的数据和结构（数据，结构的单独备份方法与上同）"></a>7. 备份多个表的数据和结构（数据，结构的单独备份方法与上同）</h4><p>mysqldump -uroot -p123456 mydb t1 t2 &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="8-一次备份多个数据库"><a href="#8-一次备份多个数据库" class="headerlink" title="8. 一次备份多个数据库"></a>8. 一次备份多个数据库</h4><p>mysqldump -uroot -p123456 –databases db1 db2 &gt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h3 id="三、还原-MySQL-备份内容"><a href="#三、还原-MySQL-备份内容" class="headerlink" title="三、还原 MySQL 备份内容"></a>三、还原 MySQL 备份内容</h3><hr>
<p>有两种方式还原，第一种是在 MySQL 命令行中，第二种是使用 SHELL 行完成还原</p>
<h4 id="1-在系统命令行中，输入如下实现还原："><a href="#1-在系统命令行中，输入如下实现还原：" class="headerlink" title="1.在系统命令行中，输入如下实现还原："></a>1.在系统命令行中，输入如下实现还原：</h4><p>mysql -uroot -p123456 &lt; &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<h4 id="2-在登录进入mysql系统中-通过source指令找到对应系统中的文件进行还原："><a href="#2-在登录进入mysql系统中-通过source指令找到对应系统中的文件进行还原：" class="headerlink" title="2.在登录进入mysql系统中,通过source指令找到对应系统中的文件进行还原："></a>2.在登录进入mysql系统中,通过source指令找到对应系统中的文件进行还原：</h4><p>mysql&gt; source &#x2F;data&#x2F;mysqlDump&#x2F;mydb.sql</p>
<p>在 Linux中，通常使用BASH脚本对需要执行的内容进行编写，加上定时执行命令crontab实现日志自动化生成。</p>
<p>以下代码功能就是针对mysql进行备份，配合crontab，实现备份的内容为近一个月（31天）内的每天的mysql数据库记录。</p>
<h3 id="四、编写BASH维护固定数量备份文件"><a href="#四、编写BASH维护固定数量备份文件" class="headerlink" title="四、编写BASH维护固定数量备份文件"></a>四、编写BASH维护固定数量备份文件</h3><hr>
<p>在Linux中，使用vi或者vim编写脚本内容并命名为：mysql_dump_script.sh</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#保存备份个数，备份31天数据<br>number&#x3D;31<br>#备份保存路径<br>backup_dir&#x3D;&#x2F;root&#x2F;mysqlbackup<br>#日期<br>dd&#x3D;`date +%Y-%m-%d-%H-%M-%S`<br>#备份工具<br>tool&#x3D;mysqldump<br>#用户名<br>username&#x3D;root<br>#密码<br>password&#x3D;TankB214<br>#将要备份的数据库<br>database_name&#x3D;edoctor</p>
<p>#如果文件夹不存在则创建<br>if [ ! -d $backup_dir ];<br>then<br>    mkdir -p $backup_dir;<br>fi</p>
<p>#简单写法 mysqldump -u root -p123456 users &gt; &#x2F;root&#x2F;mysqlbackup&#x2F;users-$filename.sql<br>$tool -u $username -p$password $database_name &gt; $backup_dir&#x2F;$database_name-$dd.sql</p>
<p>#写创建备份日志<br>echo “create $backup_dir&#x2F;$database_name-$dd.dupm” &gt;&gt; $backup_dir&#x2F;log.txt</p>
<p>#找出需要删除的备份<br>delfile&#x3D;`ls -l -crt $backup_dir&#x2F;*.sql  awk ‘{print $9 }’  head -1`</p>
<p>#判断现在的备份数量是否大于$number<br>count&#x3D;`ls -l -crt $backup_dir&#x2F;*.sql  awk ‘{print $9 }’  wc -l`</p>
<p>if [ $count -gt $number ]<br>then<br>  #删除最早生成的备份，只保留number数量的备份<br>  rm $delfile<br>  #写删除文件日志<br>  echo “delete $delfile” &gt;&gt; $backup_dir&#x2F;log.txt<br>fi</p>
<p>如上代码主要含义如下：</p>
<ol>
<li>首先设置各项参数，例如number最多需要备份的数目，备份路径，用户名，密码等。</li>
<li>执行mysqldump命令保存备份文件，并将操作打印至同目录下的log.txt中标记操作日志。</li>
<li>定义需要删除的文件：通过ls命令获取第九列，即文件名列，再通过实现定义操作时间最晚的那个需要删除的文件。</li>
<li>定义备份数量：通过ls命令加上wc -l统计以sql结尾的文件的行数。</li>
<li>如果文件超出限制大小，就删除最早创建的sql文件</li>
</ol>
<h3 id="五、使用crontab定期执行备份脚本"><a href="#五、使用crontab定期执行备份脚本" class="headerlink" title="五、使用crontab定期执行备份脚本"></a>五、使用crontab定期执行备份脚本</h3><hr>
<p>在 Linux 中，周期执行的任务一般由cron这个守护进程来处理[<strong>ps -efgrep cron</strong>]。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。<br>cron的配置文件称为“crontab”，是“cron table”的简写。</p>
<h4 id="cron服务"><a href="#cron服务" class="headerlink" title="cron服务"></a>cron服务</h4><p>cron是一个 Liunx 下 的定时执行工具，可以在无需人工干预的情况下运行作业。</p>
<p>service crond start    &#x2F;&#x2F;启动服务<br>service crond stop     &#x2F;&#x2F;关闭服务<br>service crond restart  &#x2F;&#x2F;重启服务<br>service crond reload   &#x2F;&#x2F;重新载入配置<br>service crond status   &#x2F;&#x2F;查看服务状态</p>
<h4 id="crontab语法"><a href="#crontab语法" class="headerlink" title="crontab语法"></a>crontab语法</h4><p>crontab命令用于安装、删除或者列出用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行。每个用户都可以有自己的crontab文件。&#x2F;var&#x2F;spool&#x2F;cron下的crontab文件不可以直接创建或者直接修改。该crontab文件是通过crontab命令创建的。</p>
<p>在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。<br>每个域之间使用空格或者制表符分隔。</p>
<p>格式如下：</p>
<p>minute hour day-of-month month-of-year day-of-week commands<br>合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday) </p>
<p>除了数字还有几个个特殊的符号就是”*“、”&#x2F;“和”-“、”,”，*代表所有的取值范围内的数字，”&#x2F;“代表每的意思,”&#x2F;5”表示每5个单位，”-“代表从某个数字到某个数字,”,”分开几个离散的数字。</p>
<p>-l 在标准输出上显示当前的crontab。<br>-r 删除当前的crontab文件。<br>-e 使用VISUAL或者EDITOR环境变量所指的编辑器编辑当前的crontab文件。当结束编辑离开时，编辑后的文件将自动安装。</p>
<p>创建cron脚本</p>
<ul>
<li>第一步：写cron脚本文件,命名为mysqlRollBack.cron。<br>15,30,45,59 echo “xgmtest…” &gt;&gt; xgmtest.txt 表示，每隔15分钟，执行打印一次命令</li>
<li>第二步：添加定时任务。执行命令 “crontab crontest.cron”。搞定</li>
<li>第三步：“crontab -l” 查看定时任务是否成功或者检测&#x2F;var&#x2F;spool&#x2F;cron下是否生成对应cron脚本</li>
</ul>
<p>注意：这操作是直接替换该用户下的crontab，而不是新增<br>定期执行编写的定时任务脚本（记得先给shell脚本执行权限）</p>
<p>0 2 * * * &#x2F;root&#x2F;mysql_backup_script.sh</p>
<p>随后使用crontab命令定期指令编写的定时脚本</p>
<p>crontab mysqlRollback.cron</p>
<p>再通过命令检查定时任务是否已创建：</p>
<h4 id="附-crontab-的使用示例："><a href="#附-crontab-的使用示例：" class="headerlink" title="附 crontab 的使用示例："></a>附 crontab 的使用示例：</h4><ol>
<li>每天早上6点</li>
</ol>
<p>0 6 * * * echo “Good morning.” &gt;&gt; &#x2F;tmp&#x2F;test.txt &#x2F;&#x2F;注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。</p>
<ol start="2">
<li>每两个小时</li>
</ol>
<p>0 *&#x2F;2 * * * echo “Have a break now.” &gt;&gt; &#x2F;tmp&#x2F;test.txt</p>
<ol start="3">
<li>晚上11点到早上8点之间每两个小时和早上八点</li>
</ol>
<p>0 23-7&#x2F;2，8 * * * echo “Have a good dream” &gt;&gt; &#x2F;tmp&#x2F;test.txt</p>
<ol start="4">
<li>每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点</li>
</ol>
<p>0 11 4 * 1-3 command line</p>
<ol start="5">
<li>1月1日早上4点</li>
</ol>
<p>0 4 1 1 * command line SHELL&#x3D;&#x2F;bin&#x2F;bash PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin MAILTO&#x3D;root &#x2F;&#x2F;如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME&#x3D;&#x2F;</p>
<ol start="6">
<li>每小时执行&#x2F;etc&#x2F;cron.hourly内的脚本</li>
</ol>
<p>01 * * * * root run-parts &#x2F;etc&#x2F;cron.hourly</p>
<ol start="7">
<li>每天执行&#x2F;etc&#x2F;cron.daily内的脚本</li>
</ol>
<p>02 4 * * * root run-parts &#x2F;etc&#x2F;cron.daily</p>
<ol start="8">
<li>每星期执行&#x2F;etc&#x2F;cron.weekly内的脚本</li>
</ol>
<p>22 4 * * 0 root run-parts &#x2F;etc&#x2F;cron.weekly</p>
<ol start="9">
<li>每月去执行&#x2F;etc&#x2F;cron.monthly内的脚本</li>
</ol>
<p>42 4 1 * * root run-parts &#x2F;etc&#x2F;cron.monthly</p>
<p>注意: “run-parts” 这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。</p>
<ol start="10">
<li>每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。</li>
</ol>
<p>5，15，25，35，45，55 16，17，18 * * * command</p>
<ol start="11">
<li>每周一，三，五的下午3：00系统进入维护状态，重新启动系统。</li>
</ol>
<p>00 15 * * 1，3，5 shutdown -r +5</p>
<ol start="12">
<li>每小时的10分，40分执行用户目录下的innd&#x2F;bbslin这个指令：</li>
</ol>
<p>10，40 * * * * innd&#x2F;bbslink</p>
<ol start="13">
<li>每小时的1分执行用户目录下的bin&#x2F;account这个指令：</li>
</ol>
<p>1 * * * * bin&#x2F;account</p>
<p>以下是我的测试每分钟的截图效果，其对应代码如下：</p>
<p>* * * * * &#x2F;root&#x2F;mysql_backup_script.sh</p>
<p>效果截图：<br><img src="https://img-blog.csdnimg.cn/d9b6ef85c9ee49818ed690c7287e9480.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>Mysqldump</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos启动报错java.lang.RuntimeException: [db-load-error]load jdbc.properties error</title>
    <url>/2021/12/02/nacos%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99java-lang-runtimeexception-db-load-errorload-jdbc-properties-error/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>下载了最新的nacos2.0.3，并通过脚本启动，出现如下异常</p>
<p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘externalStoragePersistServiceImpl’: Invocation of init method failed; nested exception is java.lang.RuntimeException: java.lang.RuntimeException: [db-load-error]load jdbc.properties error<br>at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:139)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:413)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1761)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:592)<br>at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:514)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:321)<br>at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:319)<br>at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)<br>at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1276)<br>at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1196)<br>at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:595)<br>… 146 common frames omitted<br>Caused by: java.lang.RuntimeException: java.lang.RuntimeException: [db-load-error]load jdbc.properties error<br>at com.alibaba.nacos.config.server.service.datasource.DynamicDataSource.getDataSource(DynamicDataSource.java:60)<br>at com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePersistServiceImpl.init(ExternalStoragePersistServiceImpl.java:133)<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>at java.lang.reflect.Method.invoke(Method.java:498)<br>at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363)<br>at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307)<br>at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)<br>… 158 common frames omitted<br>Caused by: java.lang.RuntimeException: [db-load-error]load jdbc.properties error<br>at com.alibaba.nacos.config.server.service.datasource.ExternalDataSourceServiceImpl.init(ExternalDataSourceServiceImpl.java:109)<br>at com.alibaba.nacos.config.server.service.datasource.DynamicDataSource.getDataSource(DynamicDataSource.java:55)<br>… 166 common frames omitted</p>
<h3 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h3><hr>
<p>报错内容汇总</p>
<p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name<br>‘externalStoragePersistServiceImpl’: Invocation of init method failed; nested exception is<br>java.lang.RuntimeException: java.lang.RuntimeException: [db-load-error]load jdbc.properties error<br>Caused by: java.lang.RuntimeException: java.lang.RuntimeException: [db-load-error]load jdbc.properties<br>error<br>Caused by: java.lang.RuntimeException: [db-load-error]load jdbc.properties error</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr>
<p>进入conf目录，导入nacos-mysql.sql到数据库，再编辑application.properties，这是mysql的配置</p>
<p>spring.datasource.platform&#x3D;mysql</p>
<p>db.num&#x3D;1<br>db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;11.162.196.16:3306&#x2F;nacos_devtest?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true<br>db.user&#x3D;nacos_devtest<br>db.password&#x3D;youdontknow</p>
<h3 id="强调一下nacos-mysql-sql"><a href="#强调一下nacos-mysql-sql" class="headerlink" title="强调一下nacos-mysql.sql"></a>强调一下nacos-mysql.sql</h3><hr>
<p>要先把nacos-mysql.sql导入到数据库中，再启动就不报错了</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><hr>
<p>在nacos的解压目录nacos&#x2F;的conf目录下，有配置文件cluster.conf，请每行配置成ip:port。（请配置3个或3个以上节点）</p>
<p># ip:port<br>200.8.9.16:8848<br>200.8.9.17:8848<br>200.8.9.18:8848</p>
]]></content>
      <categories>
        <category>nacos</category>
        <category>配置中心</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
        <tag>nacos</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat Premium v15 中文最新破解版</title>
    <url>/2021/04/24/navicat-premium-v15-%E4%B8%AD%E6%96%87%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-17.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Navicat Premium 是MySQL，SQL Server，Oracle和PostgreSQL的一体化数据库管理工具，功能非常强大。</p>
<p>Navicat 15破解版可以让你通过 SSH 通道创建安全的 SSH 阶段作业，确保两台主机之间的连接受到强大验证和安全加密的保护，还提供了逆向工程功能，你可以从一个现有的数据库创建数据库模型，可视化地显现和编辑你的数据库结构或创建一个图形模型，并由模型生成一个数据库，总之这是一款专业且强大的在线数据库管理工具。</p>
<h3 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h3><p><strong>安全连接</strong></p>
<p>Navicat 可以让你通过 SSH 通道创建安全的 SSH 阶段作业，确保两台主机之间的连接受到强大验证和安全加密的保护。验证方式可使用密码或公钥和私钥对。Navicat 亦支持 HTTP 通道，让你灵活地绕过限制直接数据库服务器连接的互联网服务供应商。</p>
<p><strong>对象设计器</strong></p>
<p>使用专业的对象设计器创建、修改和设计所有数据库对象，例如：表、视图、函数、过程和事件。无需编写复杂的 SQL 来创建和编辑对象，你会知道你正使用什么选项。</p>
<p><strong>表查看器</strong></p>
<p>网格或表单查看</p>
<p>使用网格查看添加、修改和删除记录。用类似数据表的功能浏览网格查看，例如排序和隐藏数据组，使用我们的助理编辑器：备注、十六进制、图像或更多。</p>
<p>你也可以用表单查看操作记录。清楚显示记录的栏位名和其值，不必担心误解数据。</p>
<p><strong>外键数据选择</strong></p>
<p>在你的数据库使用外键关系锚定参考的查找表，并自动建立下拉列表。无需持续对照参考主表，你可以简化你的工作流程和提升效率。</p>
<p><strong>SQL 创建工具或编辑器</strong></p>
<p>SQL 创建工具</p>
<p>视觉化 SQL 创建工具让你创建和编辑查询或视图，而不必担心语法和正确命令的用法。选择你想在表中执行的操作，它会为你编写 SQL 语句。</p>
<p><strong>自动完成代码</strong></p>
<p>使用我们的自动完成代码功能，能快速地在 SQL 编辑器中创建 SQL 语句。无论你想选择的是数据库对象的属性或 SQL 关键字，你只需从下拉列表中选择。</p>
<p><strong>逆向工程</strong></p>
<p>使用 Navicat 的逆向工程，你可以从一个现有的数据库创建数据库模型，可视化地显现和编辑你的数据库结构或创建一个图形模型，并由模型生成一个数据库。</p>
<p><strong>正向工程和脚本生成</strong></p>
<p>同步到数据库功能给你充分了解所有数据库的差异。生成必要的同步脚本来更新目标数据库，并使其与模型相同。</p>
<p>导出 SQL 让你有机会全面控制最终的 SQL 脚本，生成参照完整性规则，生成模型的独立部份、注释、字符集等。它可以节省你的工作时间</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>github地址：<a href="https://github.com/leenhem/software.git">https://github.com/leenhem/software.git</a></p>
<p>仓库内有软件下载说明</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 navicat150_premium_cs_x64.exe，配置如下</p>
<p>两个注意</p>
<p>注：安装激活时不要联网，不要联网，不要联网</p>
<p>注：安装完成后不要打开软件，安装完成后不要打开软件，安装完成后不要打开软件</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-5.png"></p>
<h3 id="激活过程"><a href="#激活过程" class="headerlink" title="激活过程"></a>激活过程</h3><p>打开激活工具</p>
<p>勾选Backup、Host和Navicat v15，如图所示。<strong>然后点击Patch按钮</strong>，找到Navicat Premium 15安装路径下的navicat.exe，选中并点击打开，此时会提示：navicat.exe - x64 -&gt; Cracked，提示已破解。</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-6.png"></p>
<p>点击下图的红色箭头所指的Generate，将自动生成Serial Keygen（即注册码），然后复制上。</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-7.png"></p>
<p><strong>现在</strong>打开Navicat Premium 15，点击注册（或菜单栏的帮助——》注册），输入上一步生成的注册码，然后点击激活，<strong>紧接着点手动激活</strong>。</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-8.png"></p>
<p>把白复制的激活码粘贴上来，点击<strong>激活</strong></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-11.png"></p>
<p>选择<strong>手动激活</strong>，复制<strong>请求码</strong></p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-12.png"></p>
<p>打开注册机，把请求码粘贴到 Request Code，点击 Activation Code 下面的 Generate 按钮，复制Activation Code</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-15.png"></p>
<p>把复制好的 Activation Code码粘贴到手动激活中的激活码框中</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-14.png"></p>
<p>好了，已经激活完成</p>
<p><img src="https://code404.icu/img/moveypu/2021/04/image-16.png"></p>
<p>已上就是Navicat Premium v15 中文最新破解版全过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>navicat</tag>
        <tag>navicat 中文最新破解版</tag>
        <tag>navicat 激活工具</tag>
        <tag>navicat 破解版</tag>
        <tag>navicat15</tag>
        <tag>最新破解版</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus 最新版破解教程_Nessus8.14安装教程_文未送插件</title>
    <url>/2021/05/30/nessus-%E6%9C%80%E6%96%B0%E7%89%88%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B-nessus8-14%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-%E6%96%87%E6%9C%AA%E9%80%81%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Nessus-简介"><a href="#Nessus-简介" class="headerlink" title="Nessus 简介"></a>Nessus 简介</h2><p>Nessus 是目前全世界最多人使用的系统漏洞扫描与分析软件。总共有超过75,000个机构使用 Nessus 作为扫描该机构电脑系统的软件。Nessus号称是世界上最流行的漏洞扫描程序,通常包括成千上万的最新的漏洞，各种各样的扫描选项，及易于使用的图形界面和有效的报告。</p>
<h2 id="Nessus-下载"><a href="#Nessus-下载" class="headerlink" title="Nessus 下载"></a>Nessus 下载</h2><p>首先进NESSUS官网(<a href="https://www.tenable.com/downloads/nessus)%EF%BC%8C%E4%B8%8B%E8%BD%BD8.14%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%A0%E6%98%AFWIN%E7%B3%BB%E7%BB%9F%E4%B9%9F%E5%A5%BD%EF%BC%8CIOSX%E7%B3%BB%E7%BB%9F%E4%B9%9F%E5%A5%BD%EF%BC%8CLINUX%E7%B3%BB%E7%BB%9F%E4%B9%9F%E5%A5%BD%EF%BC%8C%E7%88%B1%E8%A3%85%E9%82%A3%E4%B8%AA%E7%89%88%E6%9C%AC%E8%A3%85%E9%82%A3%E4%B8%AA%E7%89%88%E6%9C%AC%E3%80%82">https://www.tenable.com/downloads/nessus)，下载8.14版本的安装程序，你是WIN系统也好，IOSX系统也好，LINUX系统也好，爱装那个版本装那个版本。</a><br>进入官网下载地址，根据自己的操作操作系统选择下载的版本。本文以Centos7系列安装为例。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-51-1024x399.png"></p>
<h2 id="Nessus-安装"><a href="#Nessus-安装" class="headerlink" title="Nessus 安装"></a>Nessus 安装</h2><p>下载好安装包Nessus-8.14.0-es7.x86_64.rpm后，把下载好的安装包及所需插件等上传到要安装的机器上，然后安装</p>
<p>[root@ODSP-DB data]# rpm -ivh Nessus-8.14.0-es7.x86_64.rpm<br>警告：Nessus-8.14.0-es7.x86_64.rpm: 头V4 RSA&#x2F;SHA1 Signature, 密钥 ID 1c0c4a5d: NOKEY<br>准备中…                          ################################# [100%]<br>正在升级&#x2F;安装…<br>   1:Nessus-8.14.0-es7                ################################# [100%]<br>Unpacking Nessus Core Components…</p>
<ul>
<li>You can start Nessus by typing &#x2F;bin&#x2F;systemctl start nessusd.service</li>
<li>Then go to <a href="https://odsp-db:8834/">https://ODSP-DB:8834/</a> to configure your scanner</li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>[root@ODSP-DB data]# systemctl status nessusd</p>
<h2 id="Nessus-初始化"><a href="#Nessus-初始化" class="headerlink" title="Nessus 初始化"></a>Nessus 初始化</h2><p>非常重要的一步，安装完毕后，系统会要求打开浏览器初始化扫描器，请一定要选择<code>nessus manager by sc</code>（每个小版本可能不一样，但是核心就是选择管理扫描器的为安全中心SC），然后就要求你创建用户名和密码，根据自己爱好随意.</p>
<p>安装完成后进行系统设置，打开访问网址 <a href="https://127.0.0.1:8834，初始化扫描器。">https://127.0.0.1:8834，初始化扫描器。</a></p>
<p>根据提示步骤，选择 <code>Managed Scanner</code></p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-52.png"></p>
<p>再选择 <code>Tenable.sc</code></p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-53.png"></p>
<p>最后，点击继续，创建账号密码即可登录。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-54.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-55-1024x335.png"></p>
<h2 id="Nessus-破解"><a href="#Nessus-破解" class="headerlink" title="Nessus 破解"></a>Nessus 破解</h2><p>然后更新all-2.0.tar.gz 插件 然后到安装目录执行nessuscli update all-2.0.tar.gz更新插件和授权</p>
<p>[root@ODSP-DB data]# cd &#x2F;opt&#x2F;nessus&#x2F;sbin&#x2F;<br>[root@ODSP-DB sbin]# .&#x2F;nessuscli update &#x2F;data&#x2F;all-2.0.tar.gz </p>
<p>[info] Copying templates version 202105110858 to &#x2F;opt&#x2F;nessus&#x2F;var&#x2F;nessus&#x2F;templates&#x2F;tmp<br>[info] Finished copying templates.<br>[info] Moved new templates with version 202105110858 from plugins dir.<br> * Update successful.  The changes will be automatically processed by Nessus.</p>
<p>修改安装目录下的配置文件 plugin_feed_info.inc 然后在替换一共需要替换两处。</p>
<p>[root@ODSP-DB nessus]# vim plugin_feed_info.inc<br>PLUGIN_SET &#x3D; “202105110858”;<br>PLUGIN_FEED &#x3D; “ProfessionalFeed (Direct)”;<br>PLUGIN_FEED_TRANSPORT &#x3D; “Tenable Network Security Lightning”;<br>[root@ODSP-DB nessus]# cp plugin_feed_info.inc &#x2F;opt&#x2F;nessus&#x2F;lib&#x2F;nessus&#x2F;plugins&#x2F;<br>[root@ODSP-DB nessus]# cp plugin_feed_info.inc &#x2F;opt&#x2F;nessus&#x2F;var&#x2F;nessus&#x2F;</p>
<p>重新启动NESSUS服务，重新登陆控制台即可看到破解成功</p>
<p>systemctl restart nessusd</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-56-1024x330.png"></p>
<p>本文所涉及安装包：<a href="https://github.com/leenhem/software.git">https://github.com/leenhem/software.git</a></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>nfs 自动挂载</title>
    <url>/2021/12/30/nfs-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-22.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样</p>
<h3 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h3><hr>
<h4 id="开机自动挂载：-x2F-etc-x2F-fstab-里添加"><a href="#开机自动挂载：-x2F-etc-x2F-fstab-里添加" class="headerlink" title="开机自动挂载：&#x2F;etc&#x2F;fstab 里添加"></a>开机自动挂载：&#x2F;etc&#x2F;fstab 里添加</h4><hr>
<p>通过系统配置 &#x2F;etc&#x2F;fstab 自动挂载</p>
<p>server_IP:&#x2F;remote_dir  &#x2F;local_dir  nfs  defaults  1  1</p>
<p>例如：</p>
<p>192.168.56.101:&#x2F;home&#x2F;shareStoreDir &#x2F;home&#x2F;shareStoreDir nfs defaults 0 0</p>
<p>第1个1表示备份文件系统，第2个1表示从&#x2F;分区的顺序开始fsck磁盘检测，0表示不检测。</p>
<p>这种方法不推荐，尝试过程中发现开机很慢，而且开机后并没有挂载成功。<br>后查找原因是开机时,系统还没有完全完成所有服务的启动,包括网络服务:network。<br>在网络无法连入时试图mount NFS当然会失败</p>
<h4 id="开机自动挂载：在-x2F-etc-x2F-rc-d-x2F-rc-local文件中添加记录"><a href="#开机自动挂载：在-x2F-etc-x2F-rc-d-x2F-rc-local文件中添加记录" class="headerlink" title="开机自动挂载：在&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件中添加记录"></a>开机自动挂载：在&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件中添加记录</h4><hr>
<p>添加开机启动脚本</p>
<p>mount -t nfs -o nolock hostname(orIP):&#x2F;directory &#x2F;mnt</p>
<p>还是会遇到上面开机后并没有挂载成功的问题，供解决方法可以休眠几秒后尝试<br>命令修改为：</p>
<p>sleep 5;mount -t nfs xx.xx.xx.xx:&#x2F;home &#x2F;mnt&#x2F;nfs</p>
<h4 id="开机自动挂载-autofs（推荐）"><a href="#开机自动挂载-autofs（推荐）" class="headerlink" title="开机自动挂载 autofs（推荐）"></a>开机自动挂载 autofs（推荐）</h4><hr>
<p>没有安装autofs可以先进行安装</p>
<p>yum install autofs</p>
<h1 id="启动-autofs"><a href="#启动-autofs" class="headerlink" title="启动 autofs"></a>启动 autofs</h1><p>systemctl start autofs.service</p>
<h1 id="开机自启-autofs-service"><a href="#开机自启-autofs-service" class="headerlink" title="开机自启 autofs.service"></a>开机自启 autofs.service</h1><p>systemctl enable autofs.service</p>
<p>主要有两个配置文件：</p>
<p>&#x2F;etc&#x2F;auto.master<br>&#x2F;etc&#x2F;auto.xxx (这个文件可以自己指定，只要和auto.master中的配置文件名称对应即可)</p>
<h4 id="auto-master-文件"><a href="#auto-master-文件" class="headerlink" title="auto.master 文件"></a>auto.master 文件</h4><hr>
<p>示例：<br><img src="https://img-blog.csdnimg.cn/18d19740ebdc49e6bbc071330b37a7c2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>在auto.master文件中添加红框标注的内容<br>其中：</p>
<ul>
<li>&#x2F;data&#x2F;shareStoreDir：是要挂载的本地目录，我们在向NFS服务器发送请求信号时，一定要在这个目录下面进行操作，否则是无效的。</li>
<li>&#x2F;etc&#x2F;auto.nfs: 是一个配置 NFS服务器共享文件的路径，及本地在&#x2F;home&#x2F;shareStoreDir目录中要与远程共享文件挂载的目录及权限，在auto.nfs文件中还要详细说明。</li>
<li>–timeout&#x3D;60:指NFS客户端在多久没有向NFS服务器请求数据时断开挂载连接。</li>
</ul>
<p>如果一个NFS服务器上有许多的客户端一直连接的话，NFS服务器会承受很大的带宽压力，这对NFS服务器的正常使用会造成很大的影响，因此，为了解决这一弊端，我可以设定超时时间：让NFS客户端在获取数据时与NFS服务器进行连接，而在没有获取数据的时间内，自动的断开与NFS服务器之间的连接，这就是NFS的自动挂载技术</p>
<h4 id="auto-nfs文件"><a href="#auto-nfs文件" class="headerlink" title="auto.nfs文件"></a>auto.nfs文件</h4><hr>
<p>系统本身没有这个文件，我们新建一个就好，模板参考 auto.misc<br><img src="https://img-blog.csdnimg.cn/8ceadeb1b45b475c91b644eb54c561aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>红框标注的就是我们要添加的内容</p>
<p>grafana : 它是一个本地目录，我们不需要创建它，用于挂载远程共享文件172.25.42.242:&#x2F;home&#x2F;k8s-data&#x2F;grafana，在我们想要使用远程共享文件&#x2F;home&#x2F;k8s-data&#x2F;grafana时，只要在本地目录&#x2F;data&#x2F;shareStoreDir下键入 cd grafana 系统就会自动挂载到远程共享目录:172.25.42.242:&#x2F;home&#x2F;k8s-data&#x2F;grafana,我们就可以正常使用里面的共享文件了 ，在到达超时时间时就会自动卸载。</p>
<p>不好理解的话可以对两个文件做如下修改：<br>auto.master</p>
<p>vim &#x2F;etc&#x2F;auto.master<br>&#x2F;data&#x2F;shareStoreDir &#x2F;etc&#x2F;auto.nfs –timeout&#x3D;60</p>
<p>auto.nfs</p>
<p>vim &#x2F;etc&#x2F;auto.nfs<br>grafana         -fstype&#x3D;nfs,rw          172.25.42.242:&#x2F;home&#x2F;k8s-data&#x2F;grafana</p>
<p>这样执行cd &#x2F;data&#x2F;shareStoreDir&#x2F;grafana就可以自动挂载。</p>
<p>修改完配置文件后需重启autofs服务：</p>
<p>service autofs restart</p>
<h4 id="测试nfs-自动挂载"><a href="#测试nfs-自动挂载" class="headerlink" title="测试nfs 自动挂载"></a>测试nfs 自动挂载</h4><hr>
<p>自动挂载前 执行 cd grafana 目录<br><img src="https://img-blog.csdnimg.cn/380e79dcbf9a4da49175365329788e2b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>可以看到已成功挂载，退出目录1分钟后，再次观察挂载情况，如下图</p>
<p><img src="https://img-blog.csdnimg.cn/e951e8d14bcc4dc1b120fe57a5a5e40e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>nfs</tag>
        <tag>autofs</tag>
        <tag>自动挂载</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 之 location 匹配规则-史上最强讲解code404</title>
    <url>/2021/05/06/nginx-%E4%B9%8B-location-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99-%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E8%AE%B2%E8%A7%A3code404/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-1.png"></p>
<h2 id="location-匹配规则"><a href="#location-匹配规则" class="headerlink" title="location 匹配规则"></a>location 匹配规则</h2><hr>
<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><p>location [&#x3D;~~*^~] &#x2F;uri&#x2F; { … }</p>
<p>符号</p>
<p>含义</p>
<p>=</p>
<p>开头表示精确匹配</p>
<p>^~</p>
<p>开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为&#x2F;static&#x2F;20%&#x2F;aa，可以被规则^~ &#x2F;static&#x2F; &#x2F;aa匹配到（注意是空格）</p>
<p>~</p>
<p>开头表示区分大小写的正则匹配</p>
<p>~*</p>
<p>开头表示不区分大小写的正则匹配</p>
<p>!<del>和!</del>*</p>
<p>分别为区分大小写不匹配及不区分大小写不匹配 的正则</p>
<p>&#x2F;</p>
<p>通用匹配，任何请求都会匹配到。</p>
<p><em><strong>多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）:</strong></em></p>
<ul>
<li>首先匹配 &#x3D;</li>
<li>其次匹配 ^~</li>
<li>其次是按文件中顺序的正则匹配</li>
<li>最后是交给 &#x2F; 通用匹配</li>
<li>当有匹配成功时候，停止匹配，按当前匹配规则处理请求</li>
</ul>
<p>例子，有如下匹配规则：</p>
<p>location &#x3D; &#x2F; {<br>   #规则A<br>}<br>location &#x3D; &#x2F;login {<br>   #规则B<br>}<br>location ^~ &#x2F;static&#x2F; {<br>   #规则C<br>}<br>location ~ \.(gifjpgpngjscss)$ {<br>   #规则D<br>}<br>location <del>* \.png$ {<br>   #规则E<br>}<br>location !</del> \.xhtml$ {<br>   #规则F<br>}<br>location !~* \.xhtml$ {<br>   #规则G<br>}<br>location &#x2F; {<br>   #规则H<br>}</p>
<p><em><strong>那么产生的效果如下：</strong></em></p>
<ul>
<li>访问根目录&#x2F;， 比如<a href="http://localhost/">http://localhost/</a> 将匹配规则A</li>
<li>访问 <a href="http://localhost/login">http://localhost/login</a> 将匹配规则B，<a href="http://localhost/register">http://localhost/register</a> 则匹配规则H</li>
<li>访问 <a href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则C</li>
<li>访问 <a href="http://localhost/a.gif">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a href="http://localhost/static/c.png">http://localhost/static/c.png</a> 则优先匹配到规则C</li>
<li>访问 <a href="http://localhost/a.PNG">http://localhost/a.PNG</a> 则匹配规则E，而不会匹配规则D，因为规则E不区分大小写。</li>
<li>访问 <a href="http://localhost/a.xhtml">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a href="http://localhost/a.XHTML%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99G%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E3%80%82%E8%A7%84%E5%88%99F%EF%BC%8C%E8%A7%84%E5%88%99G%E5%B1%9E%E4%BA%8E%E6%8E%92%E9%99%A4%E6%B3%95%EF%BC%8C%E7%AC%A6%E5%90%88%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%83%B3%E6%83%B3%E7%9C%8B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E3%80%82">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a></li>
</ul>
<p>访问 <a href="http://localhost/category/id/1111">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</p>
<p><em><strong>所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</strong></em></p>
<p>#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。<br>#这里是直接转发给后端应用服务器了，也可以是一个静态首页</p>
<h1 id="第一个必选规则"><a href="#第一个必选规则" class="headerlink" title="第一个必选规则"></a>第一个必选规则</h1><p>location &#x3D; &#x2F; {<br>    proxy_pass <a href="http://tomcat:8080/index">http://tomcat:8080/index</a><br>}</p>
<h1 id="第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项"><a href="#第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项" class="headerlink" title="第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项"></a>第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</h1><h1 id="有两种配置模式，目录匹配或后缀匹配-任选其一或搭配使用"><a href="#有两种配置模式，目录匹配或后缀匹配-任选其一或搭配使用" class="headerlink" title="有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用"></a>有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</h1><p>location ^~ &#x2F;static&#x2F; {<br>    root &#x2F;webroot&#x2F;static&#x2F;;<br>}<br>location ~* \.(gifjpgjpegpngcssjsico)$ {<br>    root &#x2F;webroot&#x2F;res&#x2F;;<br>}<br>#第三个规则就是通用规则，用来转发动态请求到后端应用服务器<br>#非静态文件请求就默认是动态请求，自己根据实际把握<br>#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了<br>location &#x2F; {<br>    proxy_pass <a href="http://tomcat:8080/">http://tomcat:8080/</a><br>}</p>
<h2 id="ReWrite语法"><a href="#ReWrite语法" class="headerlink" title="ReWrite语法"></a>ReWrite语法</h2><hr>
<ul>
<li>last – 基本上都用这个Flag</li>
<li>break – 中止Rewirte，不在继续匹配</li>
<li>redirect – 返回临时重定向的HTTP状态302</li>
<li>permanent – 返回永久重定向的HTTP状态301</li>
</ul>
<p>1、下面是可以用来判断的表达式：</p>
<p>-f和!-f用来判断是否存在文件<br>-d和!-d用来判断是否存在目录<br>-e和!-e用来判断是否存在文件或目录<br>-x和!-x用来判断文件是否可执行</p>
<p>2、下面是可以用作判断的全局变量</p>
<p>例：<a href="http://localhost:88/test1/test2/test.php">http://localhost:88/test1/test2/test.php</a><br>$host：localhost<br>$server_port：88<br>$request_uri：<a href="http://localhost:88/test1/test2/test.php">http://localhost:88/test1/test2/test.php</a><br>$document_uri：&#x2F;test1&#x2F;test2&#x2F;test.php<br>$document_root：D:\nginx&#x2F;html<br>$request_filename：D:\nginx&#x2F;html&#x2F;test1&#x2F;test2&#x2F;test.php</p>
<h2 id="Redirect语法"><a href="#Redirect语法" class="headerlink" title="Redirect语法"></a>Redirect语法</h2><hr>
<p>server {<br>    listen 80;<br>    server_name start.igrow.cn;<br>    index index.html index.php;<br>    root html;<br>    if ($http_host !~ “^star\.igrow\.cn$&amp;quot {<br>        rewrite ^(.*) <a href="http://star.igrow.cn$1/">http://star.igrow.cn$1</a> redirect;<br>    }<br>}</p>
<h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><hr>
<p>location ~* .(gifjpgswf)$ {<br>valid_referers none blocked start.igrow.cn sta.igrow.cn;<br>if (KaTeX parse error: Expected ‘}’, got ‘EOF’ at end of input: …rite ^&#x2F; <a href="http://host/logo.png">http://host/logo.png</a>;<br>}<br>}</p>
<h2 id="根据文件类型设置过期时间"><a href="#根据文件类型设置过期时间" class="headerlink" title="根据文件类型设置过期时间"></a>根据文件类型设置过期时间</h2><hr>
<p>location ~* \.(jscssjpgjpeggifpngswf)$ {<br>    if (-f $request_filename) {<br>        expires 1h;<br>        break;<br>    }<br>}</p>
<h2 id="禁止访问某个目录"><a href="#禁止访问某个目录" class="headerlink" title="禁止访问某个目录"></a>禁止访问某个目录</h2><hr>
<p>location ~* \.(txtdoc)${<br>    root &#x2F;data&#x2F;www&#x2F;wwwroot&#x2F;linuxtone&#x2F;test;<br>    deny all;<br>}</p>
<p>一些可用的全局变量，可以参考获取Nginx内置绑定变量章节。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>规则</tag>
        <tag>nginx</tag>
        <tag>code404</tag>
        <tag>location</tag>
        <tag>匹配</tag>
        <tag>最强</tag>
        <tag>讲解</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 普通用户使用80端口启动nginx nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)</title>
    <url>/2021/12/13/nginx-%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A880%E7%AB%AF%E5%8F%A3%E5%90%AF%E5%8A%A8nginx-nginx-emerg-bind-to-0-0-0-080-failed-13-permission-denied/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-7.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>当我们用普通用户执行启动nginx时，无法启动成功，报错<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)</p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><hr>
<p>大家都知道默认情况下linux的1024以下端口是只有root用户才有权限占用，于是我们的tomcat，apache，nginx等等程序如果想要用普通用户来占用80端口的话就会抛出permission denied的异常。</p>
<p>nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)</p>
<h3 id="方法一、依次执行如下命令"><a href="#方法一、依次执行如下命令" class="headerlink" title="方法一、依次执行如下命令"></a>方法一、依次执行如下命令</h3><hr>
<p>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;<br>chown root nginx<br>chmod u+s nginx</p>
<ul>
<li>优点是，方便简单</li>
<li>缺点是，既然sudo权限都不给了，这个set uid 最后也是让nginx运行在root权限下。 ps -ef grep nginx 查看的时候，nginx的主进程是运行在root下的。 虽然是可以让普通用户运行nginx服务，但是不是所有nginx进程都在用户本身下运行</li>
</ul>
<h3 id="方法二、iptables端口转发"><a href="#方法二、iptables端口转发" class="headerlink" title="方法二、iptables端口转发"></a>方法二、iptables端口转发</h3><hr>
<p>使用非80端口启动程序，然后再用iptables做一个端口转发。</p>
<p>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-port 8080<br>#用root用户直接去执行就可以了！<br>(<br>sysctl -w net.ipv4.ip_forward&#x3D;1<br>iptables -F -t nat #清空nat表<br>iptables -t nat -A PREROUTING -p tcp –dport 80 -j DNAT –to:8088<br>)</p>
<ul>
<li>优点：可以用第三方用户直接启动，nginx的主进程就是用户本身来启动的</li>
<li>缺点，额外增加开销，负载低的情况可以，负载高了 就不太好了</li>
</ul>
<h3 id="方案三、赋予nginx监听80端口的能力"><a href="#方案三、赋予nginx监听80端口的能力" class="headerlink" title="方案三、赋予nginx监听80端口的能力"></a>方案三、赋予nginx监听80端口的能力</h3><hr>
<p>nginx内核 超过2.1版本以后 出现了能力的说法<br>我们可以给&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx 赋予监听80端口的权限能力</p>
<p>setcap cap_net_bind_service&#x3D;+ep &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</p>
<p>这样就可以直接用普通用户启用nginx了。并且可以在高负载的情况下，减少由于端口转发部分的负载开销。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>普通用户</tag>
        <tag>Permission denied</tag>
        <tag>监听80商品</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 访问权限管理_ HTTP Basic Authentication in Nginx</title>
    <url>/2021/07/24/nginx-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-http-basic-authentication-in-nginx/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-64-1024x528.png"></p>
<p>Nginx 访问权限管理_ HTTP Basic Authentication in Nginx</p>
<h3 id="1-安装-htpasswd-工具"><a href="#1-安装-htpasswd-工具" class="headerlink" title="1. 安装 htpasswd 工具"></a>1. 安装 htpasswd 工具</h3><hr>
<p>yum -y install httpd-tools  </p>
<h3 id="2-创建认证用户"><a href="#2-创建认证用户" class="headerlink" title="2. 创建认证用户"></a>2. 创建认证用户</h3><hr>
<p>htpasswd -c pass.db admin  &#x2F;&#x2F;admin 并输入密码</p>
<p>在次添加用户时输入时输入</p>
<p>htpasswd pass.db username</p>
<p>会在<code>/etx/nginx/passwd.db</code>文件中生成用户名和加密的密码：<code>admin:$apr1$AXiejsqQ$GxwQMF08odPgUg0k5H4Hq.</code></p>
<h3 id="3-nginx-增加两项配置"><a href="#3-nginx-增加两项配置" class="headerlink" title="3. nginx 增加两项配置"></a>3. nginx 增加两项配置</h3><hr>
<p>增加 authbasic 和 authbasicuserfile</p>
<p> vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</p>
<p>server {<br>    listen       80;<br>    server_name  local;<br>    location &#x2F; {<br>        root   &#x2F;data&#x2F;www;<br>        index  index.html;<br>        auth_basic “nginx auth_basic  认证”;<br>        auth_basic_user_file &#x2F;etc&#x2F;nginx&#x2F;pass.db;<br>    }<br>}</p>
<h3 id="4-重启nginx服务"><a href="#4-重启nginx服务" class="headerlink" title="4. 重启nginx服务"></a>4. 重启nginx服务</h3><hr>
<p>nginx -s reload</p>
<p>登录页面的时候就会显示输入用户名密码</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>Auth</tag>
        <tag>auth_basic</tag>
        <tag>Basic</tag>
        <tag>httpd-tools</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx,lua,shell执行服务器脚本问题connect() to unix:/tmp/shell.sock failed (2: No such file or directory)</title>
    <url>/2021/06/25/nginxluashell%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%84%9A%E6%9C%AC%E9%97%AE%E9%A2%98connect-to-unix-tmp-shell-sock-failed-2-no-such-file-or-directory/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-60.png"></p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a href="https://www.code404.icu/830.html">https://www.code404.icu/830.html</a></p>
<h3 id="shell-sock找不到的解决办法"><a href="#shell-sock找不到的解决办法" class="headerlink" title="shell.sock找不到的解决办法"></a>shell.sock找不到的解决办法</h3><p>connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory)<br>按照参考文档中的来做的话，shell.sock被放到了&#x2F;tmp目录下，但是使用过程中，一直报文件找不到。<br>解决办法是将shell.sock<strong>放到其他目录</strong>。</p>
<p>connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory)</p>
<p>例如：</p>
<p>.&#x2F;sockproc &#x2F;data&#x2F;shell.sock<br>chmod 0666 &#x2F;data&#x2F;shell.sock</p>
<p>在lua中使用的时候更换下地址即可。</p>
<p>2021&#x2F;06&#x2F;23 17:24:20 [crit] 32063#0: *3941462 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 172.25.42.35, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “192.168.65.94:19999”<br>2021&#x2F;06&#x2F;23 17:24:30 [crit] 32155#0: *3941508 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 172.25.42.35, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “192.168.65.94:19999”<br>2021&#x2F;06&#x2F;23 17:24:45 [crit] 32568#0: *3941567 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 172.25.42.35, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “192.168.65.94:19999”<br>2021&#x2F;06&#x2F;23 17:25:06 [crit] 32568#0: *3941567 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 172.25.42.35, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “192.168.65.94:19999”<br>2021&#x2F;06&#x2F;24 08:08:57 [crit] 32568#0: *4105349 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 127.0.0.1, server: , request: “HEAD &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “localhost:19999”<br>2021&#x2F;06&#x2F;24 08:08:59 [crit] 32568#0: *4105353 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 127.0.0.1, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “localhost:19999”<br>2021&#x2F;06&#x2F;24 08:10:30 [crit] 32569#0: *4105722 connect() to unix:&#x2F;tmp&#x2F;shell.sock failed (2: No such file or directory), client: 127.0.0.1, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “localhost:19999”</p>
<h3 id="服务器重启后shell-sock无法连接"><a href="#服务器重启后shell-sock无法连接" class="headerlink" title="服务器重启后shell.sock无法连接"></a>服务器重启后shell.sock无法连接</h3><p>connect() to unix:&#x2F;data&#x2F;shell&#x2F;shell.sock failed (111: Connection refused)</p>
<p>2021&#x2F;06&#x2F;24 08:08:57 [crit] 32568#0: *4105349 connect() to unix:&#x2F;data&#x2F;shell&#x2F;shell.sock failed (111: Connection refused), client: 127.0.0.1, server: , request: “HEAD &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “localhost:19999”<br>2021&#x2F;06&#x2F;24 08:08:59 [crit] 32568#0: *4105353 connect() to unix:&#x2F;data&#x2F;shell&#x2F;shell.sock failed (111: Connection refused), client: 127.0.0.1, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “localhost:19999”<br>2021&#x2F;06&#x2F;24 08:10:30 [crit] 32569#0: *4105722 connect() to unix:&#x2F;data&#x2F;shell&#x2F;shell.sock failed (111: Connection refused), client: 127.0.0.1, server: , request: “GET &#x2F;test&#x2F; HTTP&#x2F;1.1”, host: “localhost:19999”</p>
<p>服务器重启后，就会报错</p>
<p>connect() to unix:&#x2F;data&#x2F;shell&#x2F;shell.sock failed (111: Connection refused)</p>
<p>所以需要重新执行命令，给 &#x2F;data&#x2F;shell.sock 权限</p>
<p>.&#x2F;sockproc &#x2F;data&#x2F;shell.sock<br>chmod 0666 &#x2F;data&#x2F;shell.sock</p>
<p>我们可以把这两个命令放到开机启动时自动执行的脚本中。</p>
<p>vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local 内容如下：</p>
<p>touch &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;local<br>sudo &#x2F;usr&#x2F;local&#x2F;k8s&#x2F;lua&#x2F;sockproc&#x2F;sockproc &#x2F;data&#x2F;shell&#x2F;shell.sock<br>sudo chmod 0666 &#x2F;data&#x2F;shell&#x2F;shell.sock</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>lua</tag>
        <tag>shell.sock</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx代理WebSocket配置</title>
    <url>/2021/04/18/nginx%E4%BB%A3%E7%90%86websocket%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image.png"></p>
<p>WebSocket 协议提供了一种创建支持客户端和服务器之间实时双向通信的 Web 应用程序的方法。作为 HTML5 的一部分，WebSocket 使得开发这些类型的应用程序比以前的方法更容易。大多数现代浏览器都支持WebSocket，包括Chrome、Firefox、Internet Explorer、Opera和Safari，而且现在越来越多的服务器应用框架也支持WebSocket。</p>
<p>对于企业生产用途来说，如果需要多个WebSocket服务器以保证性能和高可用性，则需要一个了解WebSocket协议的负载平衡层，而NGINX从1.3版本开始就支持WebSocket，并且可以作为反向代理，对WebSocket应用进行负载平衡。所有版本的NGINX Plus也都支持WebSocket）。</p>
<p>WebSocket协议与HTTP协议不同，但WebSocket握手与HTTP兼容，使用HTTP升级设施可将连接从HTTP升级到WebSocket。这使得WebSocket应用可以更容易地融入现有的基础架构中。例如，WebSocket 应用程序可以使用标准 HTTP 端口 80 和 443，从而允许使用现有的防火墙规则。</p>
<p>WebSocket 应用程序可在客户端和服务器之间保持长期开放的连接，便于开发实时应用程序。HTTP Upgrade机制用于将连接从HTTP升级到WebSocket，使用升级和连接头。反向代理服务器在支持WebSocket时面临着一些挑战。其中之一是 WebSocket 是逐跳协议，因此当代理服务器从客户端截获升级请求时，它需要向后端服务器发送自己的升级请求，包括适当的头信息。此外，由于 WebSocket 连接是长期的，而不是 HTTP 使用的典型的短连接，因此反向代理需要允许这些连接保持开放，而不是因为它们似乎是空闲的而关闭它们。</p>
<p><strong>NGINX通过允许在客户端和后端服务器之间建立隧道来支持WebSocket。</strong></p>
<p>为了让NGINX将Upgrade请求从客户端发送到后端服务器，必须显式设置Upgrade和Connection头</p>
<p>设置如下：</p>
<p>location &#x2F;wsapp {    <br>    proxy_pass <a href="http://wsbackend/wsapp">http://wsbackend/wsapp</a>;    <br>    proxy_http_version 1.1;    <br>    proxy_set_header Upgrade $http_upgrade;    <br>    proxy_set_header Connection “Upgrade”;    <br>    proxy_set_header Host $host;<br>    }</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>WebSocket</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx做静态网页服务器</title>
    <url>/2021/07/29/nginx%E5%81%9A%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-40.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在公司中经常会遇到静态服务器，通常会提供一个上传的功能，其他应用如果需要静态资源就从该静态服务器中获取。</p>
<p>1、在&#x2F;usr&#x2F;local&#x2F;var&#x2F;www 下分别创建images和img目录，分别在每个目录下放一张test.jpg<br><img src="https://img-blog.csdnimg.cn/b6bea66132be48368576a55808b0c506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<p>http {<br>    server {<br>        listen       80;<br>        server_name  localhost;</p>
<pre><code>    set $doc\_root /usr/local/var/www;

    # 默认location
    location / &#123;
        root   /usr/local/var/www/html;
        index  index.html index.htm;
    &#125;

    location ^~ /images/ &#123;
        root $doc\_root;
   &#125;

   location ~\* \\.(gifjpgjpegpngbmpicoswfcssjs)$ &#123;
       root $doc\_root/img;
   &#125;
&#125;
</code></pre>
<p>}</p>
<p>自定义变量使用set指令，语法 set 变量名值;引用使用变量名值;引用使用变量名; 这里自定义了doc_root变量。</p>
<p>静态服务器location的映射一般有两种方式：</p>
<ul>
<li>使用路径，如 &#x2F;images&#x2F; 一般图片都会放在某个图片目录下，</li>
<li>使用后缀，如 .jpg、.png 等后缀匹配模式</li>
</ul>
<p>访问<code>http://localhost/test.jpg</code> 会映射到 <code>$doc_root/img</code></p>
<p>访问<code>http://localhost/images/test.jpg</code> 当同一个路径满足多个location时，优先匹配优先级高的location，由于<code>^~</code> 的优先级大于<code>~</code>, 所以会走<code>/images/</code>对应的location</p>
<p>常见的location路径映射路径有以下几种：</p>
<ul>
<li>= 进行普通字符精确匹配。也就是完全匹配。</li>
<li>^~ 前缀匹配。如果匹配成功，则不再匹配其他location。</li>
<li>~ 表示执行一个正则匹配，区分大小写</li>
<li>~* 表示执行一个正则匹配，不区分大小写</li>
<li>&#x2F;xxx&#x2F; 常规字符串路径匹配</li>
<li>&#x2F; 通用匹配，任何请求都会匹配到</li>
</ul>
<h3 id="location优先级"><a href="#location优先级" class="headerlink" title="location优先级"></a>location优先级</h3><hr>
<p>当一个路径匹配多个location时究竟哪个location能匹配到时有优先级顺序的，而优先级的顺序于location值的表达式类型有关，和在配置文件中的先后顺序无关。相同类型的表达式，字符串长的会优先匹配。推荐：Java面试题大全</p>
<p>以下是按优先级排列说明：</p>
<ul>
<li>等号类型（&#x3D;）的优先级最高。一旦匹配成功，则不再查找其他匹配项，停止搜索。</li>
<li>^~类型表达式，不属于正则表达式。一旦匹配成功，则不再查找其他匹配项，停止搜索。</li>
<li>正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。</li>
<li>常规字符串匹配类型。按前缀匹配。</li>
<li>&#x2F; 通用匹配，如果没有匹配到，就匹配通用的<br>优先级搜索问题：不同类型的location映射决定是否继续向下搜索</li>
<li>等号类型、^~类型：一旦匹配上就停止搜索了，不会再匹配其他location了</li>
<li>正则表达式类型(~ ~*）,常规字符串匹配类型&#x2F;xxx&#x2F; : 匹配到之后，还会继续搜索其他其它location，直到找到优先级最高的，或者找到第一种情况而停止搜索</li>
</ul>
<p>location优先级从高到底：</p>
<p>(location &#x3D;) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ,* 正则顺序) &gt; (location 部分起始路径) &gt; (&#x2F;)</p>
<p>location &#x3D; &#x2F; {<br>    # 精确匹配&#x2F;，主机名后面不能带任何字符串 &#x2F;<br>    [ configuration A ]<br>}<br>location &#x2F; {<br>    # 匹配所有以 &#x2F; 开头的请求。<br>    # 但是如果有更长的同类型的表达式，则选择更长的表达式。<br>    # 如果有正则表达式可以匹配，则优先匹配正则表达式。<br>    [ configuration B ]<br>}<br>location &#x2F;documents&#x2F; {<br>    # 匹配所有以 &#x2F;documents&#x2F; 开头的请求，匹配符合以后，还要继续往下搜索。<br>    # 但是如果有更长的同类型的表达式，则选择更长的表达式。<br>    # 如果有正则表达式可以匹配，则优先匹配正则表达式。<br>    [ configuration C ]<br>}<br>location ^~ &#x2F;images&#x2F; {<br>    # 匹配所有以 &#x2F;images&#x2F; 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。<br>    # 所以，即便有符合的正则表达式location，也不会被使用<br>    [ configuration D ]<br>}</p>
<p>location ~* \.(gifjpgjpeg)$ {<br>    # 匹配所有以 gif jpg jpeg结尾的请求。<br>    # 但是 以 &#x2F;images&#x2F;开头的请求，将使用 Configuration D，D具有更高的优先级<br>    [ configuration E ]<br>}</p>
<p>location &#x2F;images&#x2F; {<br>    # 字符匹配到 &#x2F;images&#x2F;，还会继续往下搜索<br>    [ configuration F ]<br>}</p>
<p>location &#x3D; &#x2F;test.htm {<br>    root   &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;htm;<br>    index  index.htm;<br>}</p>
<p>注意：location的优先级与location配置的位置无关</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>location优先级</tag>
        <tag>前缀匹配</tag>
        <tag>正则匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理 tomcat 出现大量 established 太多_netstat监控大量ESTABLISHED连接数</title>
    <url>/2021/04/07/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-tomcat-%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-established-%E5%A4%AA%E5%A4%9A-netstat%E7%9B%91%E6%8E%A7%E5%A4%A7%E9%87%8Festablished%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h4 id="查看网络连接数"><a href="#查看网络连接数" class="headerlink" title="查看网络连接数"></a>查看网络连接数</h4><blockquote>
<p>本文将讲述 ESTABLISHED 过多的优化方法</p>
</blockquote>
<p>#命令说明<br>netstat -an wc -l<br>netstat -an grep xx wc -l         #查看某个&#x2F;特定ip的连接数<br>netstat -an grep TIME_WAITwc -l   #查看连接数等待time_wait状态连接数<br>netstat -an grep ESTABLISHED wc -l    #查看建立稳定连接数量</p>
<h4 id="排错步骤-一"><a href="#排错步骤-一" class="headerlink" title="排错步骤(一)"></a>排错步骤(一)</h4><p>#查看稳定连接数TOP10<br>[root@web-gateway1 ~]# netstat -ntaawk ‘{print $5}’awk -F ‘:’ ‘{print $1}’sort uniq -csort -rnhead -n 10<br>    440 10.68.39.130<br>    423 10.68.39.131<br>    112 10.68.39.108<br>    101 10.68.39.109<br>     88 10.68.39.107<br>     55 10.67.20.37<br>     47 10.78.120.40<br>     42 10.78.46.22<br>     41 10.80.152.158<br>     41 10.78.114.101<br>#由此可见10.68.39.130&#x2F;131 连接库最多440&#x2F;423个</p>
<p>10.68.39.130 10.68.39.131 是两台tomcat服务器</p>
<h4 id="排错步骤-二"><a href="#排错步骤-二" class="headerlink" title="排错步骤(二)"></a>排错步骤(二)</h4><p>10.68.39.130 上执行</p>
<p>[root@quartz-push1 data]# netstat -ntagrep ESTABLISHED<br>tcp6       0      0 10.68.39.130:8068       10.68.39.120:60748      ESTABLISHED<br>tcp6       0      0 10.68.39.130:8068       10.68.39.120:52276      ESTABLISHED<br>tcp6       0      0 10.68.39.130:8068       10.68.39.120:53004      ESTABLISHED<br>tcp6       0      0 10.68.39.130:8068       10.68.39.120:58402      ESTABLISHED<br>tcp6       0      0 10.68.39.130:8068       10.68.39.120:57302      ESTABLISHED<br>tcp6       0      0 10.68.39.130:8068       10.68.39.120:37846      ESTABLISHED</p>
<h1 id="看到全部是到10-68-39-130服务器的链接"><a href="#看到全部是到10-68-39-130服务器的链接" class="headerlink" title="看到全部是到10.68.39.130服务器的链接"></a>看到全部是到10.68.39.130服务器的链接</h1><h1 id="统计一下有多少连接"><a href="#统计一下有多少连接" class="headerlink" title="统计一下有多少连接"></a>统计一下有多少连接</h1><p>[root@quartz-push1 data]# netstat -ntagrep 10.68.39.130:8068grep ESwc -l<br>    440    </p>
<h1 id="请求结束后依然存在大量ESTABLISHED没有被释放"><a href="#请求结束后依然存在大量ESTABLISHED没有被释放" class="headerlink" title="请求结束后依然存在大量ESTABLISHED没有被释放"></a>请求结束后依然存在大量ESTABLISHED没有被释放</h1><h4 id="排错步骤-三"><a href="#排错步骤-三" class="headerlink" title="排错步骤(三)"></a>排错步骤(三)</h4><p><strong>10.68.39.130 8068端口连接数</strong></p>
<p><strong>8068端口所启动的服务是tomcat</strong></p>
<p><strong>查看tomcat配置文件,初步推断是tomcat服务器回收session时出了问题，这个一般都跟服务器的Timeout设置有联系。</strong></p>
<h6 id="查看tomcat的配置文件server-xml"><a href="#查看tomcat的配置文件server-xml" class="headerlink" title="查看tomcat的配置文件server.xml"></a>查看tomcat的配置文件server.xml</h6><pre><code>&lt;Connector executor=&quot;tomcatThreadPool&quot;
           port=&quot;8068&quot; protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;
           connectionTimeout=&quot;20000&quot;
           enableLookups=&quot;false&quot;
           acceptCount=&quot;1000&quot;
           maxPostSize=&quot;-1&quot;
           maxHttpHeaderSize=&quot;8192&quot;
           compression=&quot;on&quot;
           disableUploadTimeout=&quot;true&quot;
           compressionMinSize=&quot;2048&quot;
           acceptorThreadCount=&quot;2&quot;
           compressableMimeType=&quot;text/html,text/xml,text/plain,text/css,text/javascript,application/javascript&quot;
           server=&quot;head S1&quot;
           URIEncoding=&quot;UTF-8&quot; 
/&gt;
</code></pre>
<blockquote>
<p>connectionTimeout&#x3D;”20000” 改为 connectionTimeout&#x3D;”2000” <br>acceptCount&#x3D;”100” 改为 acceptCount&#x3D;”5000”</p>
</blockquote>
<hr>
<h6 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h6><p>connectionTimeout&#x3D;2000 Connector接受一个连接后等待的时间(milliseconds)，默认值是60000。 连接超时2s,没数据了之后2秒就断，别等这么久<br>acceptCount 等待队列的长度，默认值是100。<br>keepAliveTimeout 在Connector关闭连接前，Connector为另外一个请求Keep Alive所等待的微妙数，默认值和 connectionTimeout 一样。</p>
<p>优化完毕，这样设置之后，问题得到完美解决。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ESTABLISHED</tag>
        <tag>tomcat连接数</tag>
        <tag>系统优化</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理Upstream名字返回到Swagger的base url中了</title>
    <url>/2021/09/11/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86upstream%E5%90%8D%E5%AD%97%E8%BF%94%E5%9B%9E%E5%88%B0swagger%E7%9A%84base-url%E4%B8%AD%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-9.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在用Nginx转发请求到sprint boot上游服务的时候，有一个配置项，如果处理不好，会导致在swagger里面无法访问API。下面来看一下实例</p>
<h3 id="首先来看问题的现象，通过nginx能够访问到swagger-ui的页面"><a href="#首先来看问题的现象，通过nginx能够访问到swagger-ui的页面" class="headerlink" title="首先来看问题的现象，通过nginx能够访问到swagger-ui的页面"></a>首先来看问题的现象，通过nginx能够访问到swagger-ui的页面</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/b633cd5df7ba46598f6fcedaebcee56d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="并且，直接url-访问API也正常，如下"><a href="#并且，直接url-访问API也正常，如下" class="headerlink" title="并且，直接url 访问API也正常，如下"></a>并且，直接url 访问API也正常，如下</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/c67799f0578a4102aef707ec8de5bcb9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="但是，在swagger-ui界面通过输入参数去请求API，就会得不到响应结果，如下"><a href="#但是，在swagger-ui界面通过输入参数去请求API，就会得不到响应结果，如下" class="headerlink" title="但是，在swagger-ui界面通过输入参数去请求API，就会得不到响应结果，如下"></a>但是，在swagger-ui界面通过输入参数去请求API，就会得不到响应结果，如下</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/549d3f07327d44c18b4de5afff84627d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们在这里观察到request url里面的地址里面的Base URL地址都是“code404_icu”，这并不是nginx的地址也不是上游服务的地址，而是nginx.conf配置中upstream定义的变量名，下面是nginx.conf的部分内容：</p>
<p>server<br>     {<br>        listen   18067;<br>        location &#x2F; {<br>                proxy_pass <a href="http://code404/_icu">http://code404\_icu</a>;<br>                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>                proxy_set_header        X-Real-IP       $remote_addr;<br>                proxy_redirect off ;<br>                proxy_http_version 1.1;<br>                proxy_set_header Upgrade $http_upgrade;<br>                proxy_set_header Connection “upgrade”;<br>                fastcgi_param  SCRIPT_NAME        “”;<br>                client_max_body_size    10m;<br>                more_clear_headers “Access-Control-Allow-Origin”;<br>                more_clear_headers “Access-Control-Allow-Credentials”;<br>                more_clear_headers “Access-Control-Allow-Headers”;<br>                more_clear_headers “Access-Control-Allow-Methods”;<br>        }<br>    access_log  logs&#x2F;dfs_access.log  main;<br>    error_log  logs&#x2F;dfs_error.log crit;<br>  }</p>
<p>也就是说swagger将nginx转发的upstream的名字作为base url来处理请求，显然这是得不到结果的。</p>
<h3 id="办法就是告诉swagger正确的请求地址"><a href="#办法就是告诉swagger正确的请求地址" class="headerlink" title="办法就是告诉swagger正确的请求地址"></a>办法就是告诉swagger正确的请求地址</h3><hr>
<p>这需要在nginx.conf中设置请求头，将原始的请求地址和端口传递到转发的服务去，具体设置如下：<br>添加<code>proxy_set_header Host $host:$server_port;</code></p>
<p>server<br>     {<br>        listen   18067;<br>        location &#x2F; {<br>                proxy_pass <a href="http://code404/_icu">http://code404\_icu</a>;<br>                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>                proxy_set_header    X-Real-IP       $remote_addr;<br>                proxy_set_headerHost$host:$server_port;<br>                proxy_redirect off ;<br>                proxy_http_version 1.1;<br>                proxy_set_header Upgrade $http_upgrade;<br>                proxy_set_header Connection “upgrade”;<br>                fastcgi_param  SCRIPT_NAME        “”;<br>                client_max_body_size    10m;<br>                more_clear_headers “Access-Control-Allow-Origin”;<br>                more_clear_headers “Access-Control-Allow-Credentials”;<br>                more_clear_headers “Access-Control-Allow-Headers”;<br>                more_clear_headers “Access-Control-Allow-Methods”;<br>        }<br>    access_log  logs&#x2F;dfs_access.log  main;<br>    error_log  logs&#x2F;dfs_error.log crit;<br>  }</p>
<p>重启nginx，再从swagger-ui访问一下API，这次返回正常，地址也是nginx的地址了。</p>
<p><img src="https://img-blog.csdnimg.cn/19012e005e014b8ba611a99c7ceda591.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
        <category>Nginx</category>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
        <tag>Swagger</tag>
        <tag>upstream</tag>
        <tag>url</tag>
        <tag>地址不对</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx启动报错 error while loading shared libraries: libfdfsclient.so: cannot open shared object file: No such file or directory</title>
    <url>/2021/11/02/nginx%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99-error-while-loading-shared-libraries-libfdfsclient-so-cannot-open-shared-object-file-no-such-file-or-directory/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-17.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>乍看这个报错就是缺失库文件</p>
<h3 id="nginx命令启动报错"><a href="#nginx命令启动报错" class="headerlink" title="nginx命令启动报错"></a>nginx命令启动报错</h3><hr>
<p>error while loading shared libraries: libfdfsclient.so:<br>cannot open shared object file: No such file or directory</p>
<h3 id="查看nginx使用的库"><a href="#查看nginx使用的库" class="headerlink" title="查看nginx使用的库"></a>查看nginx使用的库</h3><hr>
<p>从错误提示信息可以得知是因为缺少lib文件导致，$ ldd $(which &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx)进一步查看具体内容：</p>
<p>ldd &#x2F;data&#x2F;fastdfsnginx&#x2F;sbin&#x2F;nginx<br>linux-vdso.so.1 &#x3D;&gt;  (0x00007fffb55c6000)<br>libdl.so.2 &#x3D;&gt; &#x2F;lib64&#x2F;libdl.so.2 (0x00007fca5318b000)<br>libpthread.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libpthread.so.0 (0x00007fca52f6f000)<br>libcrypt.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libcrypt.so.1 (0x00007fca52d38000)<br>libfastcommon.so &#x3D;&gt; &#x2F;lib64&#x2F;libfastcommon.so (0x00007fca52aeb000)<br>libfdfsclient.so &#x3D;&gt; not found<br>libpcre.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libpcre.so.1 (0x00007fca52889000)<br>libcrypto.so.10 &#x3D;&gt; &#x2F;lib64&#x2F;libcrypto.so.10 (0x00007fca52426000)<br>libz.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libz.so.1 (0x00007fca52210000)<br>libc.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libc.so.6 (0x00007fca51e42000)<br>&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007fca5338f000)<br>libfreebl3.so &#x3D;&gt; &#x2F;lib64&#x2F;libfreebl3.so (0x00007fca51c3f000)<br>libm.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libm.so.6 (0x00007fca5193d000)</p>
<p>可以看到 libfdfsclient.so &#x3D;&gt; not found</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>像这样的问题，有以下 3 种原因：</p>
<ul>
<li>未安装 fdfsclient</li>
<li>libfdfsclient.so 名字不对</li>
<li>未设置 LD_LIBRARY_PATH</li>
</ul>
<p>我这里可以确定 fastdfsclient 已经安装</p>
<p>如果是文件名字不对，只需要把库名做个软链接就可以了</p>
<h3 id="设置-LD-LIBRARY-PATH"><a href="#设置-LD-LIBRARY-PATH" class="headerlink" title="设置 LD_LIBRARY_PATH"></a>设置 LD_LIBRARY_PATH</h3><hr>
<p>export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib:$LD_LIBRARY_PATH</p>
<h3 id="查看ldd-x2F-data-x2F-fastdfsnginx-x2F-sbin-x2F-nginx"><a href="#查看ldd-x2F-data-x2F-fastdfsnginx-x2F-sbin-x2F-nginx" class="headerlink" title="查看ldd &#x2F;data&#x2F;fastdfsnginx&#x2F;sbin&#x2F;nginx"></a>查看ldd &#x2F;data&#x2F;fastdfsnginx&#x2F;sbin&#x2F;nginx</h3><hr>
<p>linux-vdso.so.1 &#x3D;&gt;  (0x00007ffc3e1fc000)<br>libdl.so.2 &#x3D;&gt; &#x2F;lib64&#x2F;libdl.so.2 (0x00007f4a8d48a000)<br>libpthread.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libpthread.so.0 (0x00007f4a8d26e000)<br>libcrypt.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libcrypt.so.1 (0x00007f4a8d037000)<br>libfastcommon.so &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;libfastcommon.so (0x00007f4a8cdea000)<br>libfdfsclient.so &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;libfdfsclient.so (0x00007f4a8cbd0000)<br>libpcre.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libpcre.so.1 (0x00007f4a8c96e000)<br>libcrypto.so.10 &#x3D;&gt; &#x2F;lib64&#x2F;libcrypto.so.10 (0x00007f4a8c50b000)<br>libz.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libz.so.1 (0x00007f4a8c2f5000)<br>libc.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libc.so.6 (0x00007f4a8bf27000)<br>&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f4a8d68e000)<br>libfreebl3.so &#x3D;&gt; &#x2F;lib64&#x2F;libfreebl3.so (0x00007f4a8bd24000)<br>libm.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libm.so.6 (0x00007f4a8ba22000)</p>
<h3 id="再次测试启动nginx"><a href="#再次测试启动nginx" class="headerlink" title="再次测试启动nginx"></a>再次测试启动nginx</h3><hr>
<p>&#x2F;data&#x2F;fastdfsnginx&#x2F;sbin&#x2F;nginx -c &#x2F;data&#x2F;fastdfsnginx&#x2F;conf&#x2F;nginx.conf -t<br>ngx_http_fastdfs_set pid&#x3D;25946<br>nginx: the configuration file &#x2F;data&#x2F;fastdfsnginx&#x2F;conf&#x2F;nginx.conf syntax is ok</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>cannot open shared</tag>
        <tag>shared libraries</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx性能优化配置大全_完整版</title>
    <url>/2021/08/26/nginx%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8-%E5%AE%8C%E6%95%B4%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-23.png"></p>
<h3 id="调整worker-processes"><a href="#调整worker-processes" class="headerlink" title="调整worker_processes"></a>调整worker_processes</h3><hr>
<p>指Nginx要生成的worker数量,最佳实践是每个CPU运行1个工作进程。<br>了解系统中的CPU核心数，输入</p>
<p>$ grep processor &#x2F;proc&#x2F;cpuinfo  wc -l</p>
<h3 id="最大化worker-connections"><a href="#最大化worker-connections" class="headerlink" title="最大化worker_connections"></a>最大化worker_connections</h3><hr>
<p>Nginx Web服务器可以同时提供服务的客户端数。与worker_processes结合使用时，获得每秒可以服务的最大客户端数</p>
<p>最大客户端数&#x2F;秒&#x3D;工作进程*工作者连接数</p>
<p>为了最大化Nginx的全部潜力，应将工作者连接设置为核心一次可以运行的允许的最大进程数1024。</p>
<h3 id="启用Gzip压缩"><a href="#启用Gzip压缩" class="headerlink" title="启用Gzip压缩"></a>启用Gzip压缩</h3><hr>
<p>压缩文件大小，减少了客户端http的传输带宽，因此提高了页面加载速度<br>建议的gzip配置示例如下:( 在http部分内）</p>
<p>gzip on;  #打开或关闭gzip<br>gzip_vary on; #增加响应头”Vary: Accept-Encoding”<br>gzip_min_length    1k;  #当返回内容大于此值时才会使用gzip进行压缩,以K为单位,当值为0时，所有页面都进行压缩。<br>gzip_buffers 16 8k; #设置用于处理请求压缩的缓冲区数量和大小。比如32 4K表示按照内存页（one memory page）大小以4K为单位（即一个系统中内存页为4K），申请32倍的内存空间。建议此项不设置，使用默认值。<br>gzip_http_version 1.0;  #用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在http&#x2F;1.0的协议下不开启gzip压缩。<br>gzip_comp_level    1;  #设置gzip压缩级别，级别越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大<br>gzip_types text&#x2F;plain      application&#x2F;x-javascript text&#x2F;css application&#x2F;xml;  #设置需要压缩的MIME类型,如果不在设置类型范围内的请求不进行压缩<br>gzip_disable “MSIE [1-6]\.(?!.*SV1)”; #通过表达式，表明哪些UA头不使用gzip压缩</p>
<h3 id="为静态文件启用缓存"><a href="#为静态文件启用缓存" class="headerlink" title="为静态文件启用缓存"></a>为静态文件启用缓存</h3><hr>
<p>为静态文件启用缓存，以减少带宽并提高性能，可以添加下面的命令，限定计算机缓存网页的静态文件：</p>
<p>location ~* .(jpgjpegpnggificocssjs)$ {</p>
<p>expires 365d;</p>
<p>}</p>
<h3 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h3><hr>
<p>keepalive连接减少了打开和关闭连接所需的CPU和网络开销，获得最佳性能需要调整的变量可参考：</p>
<p>client_body_timeout 12;<br>client_header_timeout 12;<br>keepalive_timeout 15;<br>send_timeout 10;</p>
<h3 id="禁用access-logs"><a href="#禁用access-logs" class="headerlink" title="禁用access_logs"></a>禁用access_logs</h3><hr>
<p>访问日志记录，它记录每个nginx请求，因此消耗了大量CPU资源，从而降低了nginx性能。<br>完全禁用访问日志记录</p>
<p>access_log off;</p>
<p>如果必须具有访问日志记录，则启用访问日志缓冲</p>
<p>当系统处于负载状态时，启用日志缓冲区以降低 nginx worker 进程阻塞。大量的磁盘读写和 cpu 资源使用对于服务器资源也是一种巨大消耗。将日志数据缓冲到内存中可能是很小的一个优化手段， buffer 参数意义是缓冲区的大小，功能是当缓冲区已经写满时，日志会被写入文件中； flush 参数意义是缓冲区内日志在缓冲区内存中保存的最长时间，功能即当缓存中的日志超过最大缓存时间，也会被写入到文件中， 不足的地方即写入到日志文件的日志有些许延迟，即时调试中应当关闭日志缓冲。 。配置如下：</p>
<p>access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main buffer&#x3D;32k flush&#x3D;1m;</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>性能</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx报错500_502_503_504状态码详解</title>
    <url>/2021/08/27/nginx%E6%8A%A5%E9%94%99500-502-503-504%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-24.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>先来看一下一个http请求处理流程：<br><img src="https://img-blog.csdnimg.cn/c80cea809d264b2082c7c22452a2b89c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAbGVlbmhlbQ==,size_31,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>一个普通的http请求处理流程，如上图所示： A -&gt; client端发起请求给nginx B -&gt; nginx处理后，将请求转发到uwsgi，并等待结果 C -&gt; uwsgi处理完请求后，返回数据给nginx D -&gt; nginx将处理结果返回给客户端 每个阶段都会有一个预设的超时时间，由于网络、机器负载、代码异常等等各种原因，如果某个阶段没有在预期的时间内正常返回，就会导致这次请求异常，进而产生不同的状态码。</p>
<h3 id="1）504"><a href="#1）504" class="headerlink" title="1）504"></a>1）504</h3><hr>
<p>504主要是针对B、C阶段。一般nginx配置中会有：</p>
<p>location &#x2F; {<br>    …<br>    uwsgi_connect_timeout 6s;<br>    uwsgi_send_timeout 6s;<br>    uwsgi_read_timeout 10s;<br>    uwsgi_buffering on;<br>    uwsgi_buffers 80 16k;<br>    …<br>}</p>
<p>这个代表nginx与上游服务器（uwsgi）通信的超时时间，也就是说，如果在这个时间内，uwsgi没有响应，则认为这次请求超时，返回504状态码。</p>
<p>具体的日志如下：<br>access_log</p>
<p>[16&#x2F;May&#x2F;2016:22:11:38 +0800] 10.4.31.56 201605162211280100040310561523 15231401463407888908 10.*.*.* 127.0.0.1:8500 “GET &#x2F;api&#x2F;media_article_list&#x2F;?count&#x3D;10&amp;source_type&#x3D;0&amp;status&#x3D;all&amp;from_time&#x3D;0&amp;item_id&#x3D;0&amp;flag&#x3D;2&amp;_&#x3D;1463407896337 HTTP&#x2F;1.1” 504 **.***.com **.**.**.39, **.**.**.60 10.000 10.000 “Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;46.0.2490.71 Safari&#x2F;537.36” …</p>
<p>error_log</p>
<p>2016&#x2F;05&#x2F;16 22:11:38 [error] 90674#0: *947302032 upstream timed out (110: Connection timed out) while reading response header from upstream, client: 10.6.19.81, server: **.***.com, request: “GET &#x2F;api&#x2F;media_article_list&#x2F;?count&#x3D;10&amp;source_type&#x3D;0&amp;status&#x3D;all&amp;from_time&#x3D;0&amp;item_id&#x3D;0&amp;flag&#x3D;2&amp;_&#x3D;1463407896337 HTTP&#x2F;1.1”, upstream: “<a href="http://127.0.0.1:8500//*/*//*/*/api/media/_article/_list/?count=10&amp;source%5C_type=0&amp;status=all&amp;from%5C_time=0&amp;item%5C_id=0&amp;flag=2&amp;%5C_=1463407896337&quot;">http://127.0.0.1:8500/\*\*/\*\*/api/media\_article\_list/?count=10&amp;source\_type=0&amp;status=all&amp;from\_time=0&amp;item\_id=0&amp;flag=2&amp;\_=1463407896337&quot;</a>, host: “mp.toutiao.com”, referrer: “https:&#x2F;&#x2F;**.***.com&#x2F;articles&#x2F;?source_type&#x3D;0”error_log中upstream timed out (110: Connection timed out) while reading response header from upstream，</p>
<p>意思是说，在规定的时间内，没有从header中拿到数据，即uwsgi没有返回任何数据。</p>
<h3 id="2）502"><a href="#2）502" class="headerlink" title="2）502"></a>2）502</h3><hr>
<p>502主要针对B 、C阶段。产生502的时候，对应的error_log中的内容会有好几种：</p>
<p>access_log</p>
<p>error_log</p>
<p>2016&#x2F;05&#x2F;16 16:39:49 [error] 90693#0: *944980723 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.6.19.80, server: **.***.com, request: “GET &#x2F;articles&#x2F; HTTP&#x2F;1.1”, upstream: “<a href="http://127.0.0.1:8500//*/*//*/*/articles/&quot;">http://127.0.0.1:8500/\*\*/\*\*/articles/&quot;</a>, host: “**.***.com”, referrer: “http:&#x2F;&#x2F;**.***.com&#x2F;new_article&#x2F;“</p>
<p>列一下常见的几种502对应的 error_log：</p>
<ul>
<li>recv() failed (104: Connection reset by peer) while reading response header from upstream</li>
<li>upstream prematurely closed connection while reading response header from upstream</li>
<li>connect() failed (111: Connection refused) while connecting to upstream</li>
<li>…<br>这些都代表，在nginx设置的超时时间内，上游uwsgi没有给正确的响应（但是是有响应的，不然如果一直没响应，就会变成504超时了），因此nginx这边的状态码为502。</li>
</ul>
<p>如上，access_log中出现503，为什么？</p>
<p>这个是因为nginx upstream的容灾机制。如果nginx有如下配置：</p>
<p>upstream app_backup {<br>    server 127.0.0.1:8500 max_fails&#x3D;3 fail_timeout&#x3D;5s;<br>    server 127.0.0.1:88 backup;<br>}</p>
<ul>
<li>max_fails&#x3D;3 说明尝试3次后，会认为“ server 127.0.0.1:8500” 失效，于是进入 “server 127.0.0.1:88 backup”，即访问本机的88端口;<br>nginx upstream的容灾机制，默认情况下，Nginx 默认判断失败节点状态以connect refuse和time out状态为准，不过location里加了这个配置：</li>
</ul>
<p> proxy_next_upstream error http_502;<br> proxy_connect_timeout 1s;<br> proxy_send_timeout    6s;<br> proxy_read_timeout    10s;<br> proxy_set_header Host $host;</p>
<ul>
<li>这个配置是说，对于http状态是502的情况，也会走upstream的容灾机制；</li>
<li>概括一下就是，如果连续有3次(max_fails&#x3D;3)状态为502的请求，则会任务这个后端server 127.0.0.1:8500 挂掉了，在接下来的5s(fail_timeout&#x3D;5s)内，就会访问backup，即server 127.0.0.1:88 ，看下88端口对应的是什么：</li>
</ul>
<p>server {<br>listen 88;<br>access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;failover.log;<br>expires 1m;<br>error_page  500 502 503 504 &#x2F;500.html;<br>location &#x2F; {<br>return 503;<br>}<br>location &#x3D; &#x2F;500.html {<br>root &#x2F;**&#x2F;**&#x2F;**&#x2F;nginx&#x2F;5xx&#x2F;;<br>}<br>}</p>
<p>这个的意思就是，对于访问88端口的请求，nginx会返回503状态码，同时返回&#x2F;opt&#x2F;tiger&#x2F;ss_conf&#x2F;nginx&#x2F;5xx&#x2F;这个路径下的500.html文件。 因此，access_log中看到的是503</p>
<h3 id="3）499"><a href="#3）499" class="headerlink" title="3）499"></a>3）499</h3><hr>
<p>client发送请求后，如果在规定的时间内（假设超时时间为500ms）没有拿到nginx给的响应，则认为这次请求超时，会主动结束，这个时候nginx的access_log就会打印499状态码。 A+B+C+D &gt; 500ms 其实这个时候，server端有可能还在处理请求，只不过client断掉了连接，因此处理结果也无法返回给客户端。 499如果比较多的话，可能会引起服务雪崩。 比如说，client一直在发起请求，客户端因为某些原因处理慢了，没有在规定时间内返回数据，client认为请求失败，中断这次请求，然后再重新发起请求。这样不断的重复，服务端的请求越来越多，机器负载变大，请求处理越来越慢，没有办法响应任何请求</p>
<p>官网总结nginx返回499的情况，是由于：</p>
<p>client has closed connection    #客户端主动关闭了连接。</p>
<p>client has closed connection #客户端主动关闭了连接。</p>
<p>解决的话，可以添加</p>
<p>proxy_ignore_client_abort    on;</p>
<p>还有一种原因，确实是客户端关闭了连接，或者连接超时。主要是因为PHP进程数太少，或php进程占用，资源不能很快释放，请求堆积。这种情况要解决的话，需要在程序上做优化。</p>
<h3 id="4）500"><a href="#4）500" class="headerlink" title="4）500"></a>4）500</h3><hr>
<p>服务器内部错误，也就是服务器遇到意外情况，而无法执行请求。发生错误，一般的几种情况：</p>
<ul>
<li>web脚本错误，如php语法错误，lua语法错误等。</li>
<li>访问量大的时候，由于系统资源限制，而不能打开过多的文件句柄<br>分析错误的原因</li>
<li>查看nginx，php的错误日志</li>
<li>如果是too many open files，修改nginx的worker_rlimit_nofile参数，使用ulimit查看系统打开文件限制，修改&#x2F;etc&#x2F;security&#x2F;limits.conf</li>
<li>如果脚本存在问题，则需要修复脚本错误，并优化代码</li>
<li>各种优化都做好，还是出现too many open files，那就需要考虑做负载均衡，把流量分散到不同服务器上去</li>
</ul>
<h3 id="5）503"><a href="#5）503" class="headerlink" title="5）503"></a>5）503</h3><hr>
<p>503是服务不可用的返回状态。 由于在nginx配置中，设置了limit_req的流量限制，导致许多请求返回503错误代码，在限流的条件下，为提高用户体验，希望返回正常Code 200，且返回操作频繁的信息：</p>
<p>…Nginx Code Status…</p>
<p>200：服务器成功返回网页<br>403：服务器拒绝请求。404：请求的网页不存在<br>499：客户端主动断开了连接。500：服务器遇到错误，无法完成请求。502：服务器作为网关或代理，从上游服务器收到无效响应。503 - 服务不可用<br>504：服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>这些状态码被分为五大类：<br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。 （自己电脑这边的问题） 自己电脑这边的问题）<br>500-599 用于支持服务器错误。 （对方的问题） 对方的问题）———————————————————————————————200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。<br>———————————————————————————————300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>———————————————————————————————400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。<br>———————————————————————————————500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。<br>proxy_intercept_errors 当上游服务器响应头回来后，可以根据响应状态码的值进行拦截错误处理，与error_page 指令相互结合。用在访问上游服务器出现错误的情况下。</p>
<p>如下的一个配置实例：</p>
<p>[root@dev ~]# cat ssl-zp.code404.icu.conf<br>upstream mianshi1 {<br>    server 192.168.1.33:8080 max_fails&#x3D;3 fail_timeout&#x3D;10s;<br>    #server 192.168.1.32:8080 max_fails&#x3D;3 fail_timeout&#x3D;10s;<br>}<br> server {<br>    listen 443;<br>    server_name zp.wangshibo.com;ssl on;<br>    ### SSL log files ###<br>    access_log logs&#x2F;zrx_access.log;<br>    error_log logs&#x2F;zrx_error.log;<br>    ### SSL cert files ###<br>    ssl_certificate ssl&#x2F;wangshibo.cer;<br>    ssl_certificate_key ssl&#x2F;wangshibo.key;ssl_session_timeout 5m;<br>    error_page 404 301 <a href="https://zp.code404.com/code404.icu-web/">https://zp.code404.com/code404.icu-web/</a>;<br>    location &#x2F;zrx-web&#x2F; {<br>        proxy_pass <a href="http://mianshi1/">http://mianshi1</a>;<br>        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        # proxy_set_header X-Forwarded-Proto https;<br>        #proxy_set_header X-Forwarded-Proto https;proxy_redirect off;<br>        proxy_intercept_errors on;<br>    }<br>}</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>502</tag>
        <tag>状态码</tag>
        <tag>499</tag>
        <tag>500</tag>
        <tag>503</tag>
        <tag>504</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx挂维护页面，优雅地进行网站升级维护</title>
    <url>/2021/03/31/nginx%E6%8C%82%E7%BB%B4%E6%8A%A4%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<p><strong>通过Nginx实现一个简单的网站维护通知页面,优雅地进行网站升级维护</strong></p>
<p><code>发布项目时，发布的时间内，我们的域名访问时，跳到了维护通知页面，当时我觉得，这个体验好，这样用户就知道网站为啥不可用了，升级维护期间无法一一告知用户的，这么做真的很专业，用户一看就知道，原来这段时间在维护啊，那我等维护好了继续访问，都说用户体验，这就是用户体验呢。</code></p>
<h2 id="1、简单重写一个网站维护功能"><a href="#1、简单重写一个网站维护功能" class="headerlink" title="1、简单重写一个网站维护功能"></a>1、简单重写一个网站维护功能</h2><hr>
<h3 id="在nginx的配置文件中server模块下添加下面配置"><a href="#在nginx的配置文件中server模块下添加下面配置" class="headerlink" title="在nginx的配置文件中server模块下添加下面配置"></a>在nginx的配置文件中server模块下添加下面配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rewrite ^ /weihu break; #表示匹配所有请求,跳转到 weihu location</span><br><span class="line">location /weihu &#123;</span><br><span class="line">default_type text/html ;</span><br><span class="line">return 200  &quot;&lt;h1&gt;网站维护中，请稍后再试!&lt;/h1&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、新建一个网站维护页面实现网站维护功能"><a href="#2、新建一个网站维护页面实现网站维护功能" class="headerlink" title="2、新建一个网站维护页面实现网站维护功能"></a>2、新建一个网站维护页面实现网站维护功能</h2><hr>
<h3 id="新建一个网站维护页面"><a href="#新建一个网站维护页面" class="headerlink" title="新建一个网站维护页面"></a>新建一个网站维护页面</h3><p><code>nginx 将请求全部指向到一个页面</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建一个目录 存放网站维护页面</span><br><span class="line">mkdir /data/weihu</span><br><span class="line">cd /data/weihu</span><br><span class="line">vim index.html</span><br><span class="line">#把下列网站维护页面内容放到 index.html里</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;网站维护通知&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div  align=&quot;center&quot;&gt;</span><br><span class="line">&lt;h1&gt;网站维护中，请稍后再试......&lt;/h1&gt;</span><br><span class="line">    &lt;img src=&quot;./weihu.png&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>在nginx的配置文件中server模块下添加下面配置</code></p>
<p><code>新添加一个nginx配置文件 weihu_nginx.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim conf.d/weihu_nginx.conf</span><br><span class="line">#nginx 配置文件内添加内容：</span><br><span class="line">server</span><br><span class="line">     &#123;</span><br><span class="line">        listen   80;</span><br><span class="line">        server_name    www.xxx.com xxx.com;</span><br><span class="line">        root     /data/weihu;</span><br><span class="line">        index    index.html ;</span><br><span class="line">        access_log /data/logs/access/www.xxx.com_access.log access;</span><br><span class="line">        error_log /data/logs/error/www.xxx.com_error.log crit;</span><br><span class="line">  &#125;</span><br><span class="line">server</span><br><span class="line">     &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name app.xxx.com;</span><br><span class="line">        root /data/weihu;</span><br><span class="line">        index app.html;</span><br><span class="line">        access_log /data/logs/access/www.xxx.com_access.log access;</span><br><span class="line">        error_log /data/logs/error/www.xxx.com_error.log crit;</span><br><span class="line">        location /  &#123;</span><br><span class="line">                default_type &#x27;application/json; charset=utf-8&#x27;;</span><br><span class="line">                return 200  &#x27;&#123;&quot;sign&quot;:&quot;xxx&quot;,&quot;codeDesc&quot;:&quot;系统升级维护中&quot;,&quot;nonceStr&quot;:&quot;xxx&quot;,&quot;code&quot;:&quot;xxx&quot;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        ssl     on;</span><br><span class="line">        server_name  www.xxx.com;</span><br><span class="line">        ssl_certificate  /home/www/xxx/key/www.xxx.com.crt;</span><br><span class="line">        ssl_certificate_key  /home/www/xxx/key/www.xx.com.key;</span><br><span class="line">        ssl_session_cache       shared:SSL:10m;</span><br><span class="line">        ssl_session_timeout     10m;</span><br><span class="line">        ssl_protocols   SSLv3   TLSv1   TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers     HIGH:!aNULL:!MD5:!EXPORT56:!EXP;</span><br><span class="line">        ssl_prefer_server_ciphers       on;</span><br><span class="line">        keepalive_timeout       70;</span><br><span class="line">        root /data/www;</span><br><span class="line">        index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>nginx主配置文件 http模块下面添加配置</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#网站维护配置,网站维护时去掉注释,重启nginx</span><br><span class="line">#include /data/openresty/nginx/conf/conf.d/weihu_nginx.conf;</span><br></pre></td></tr></table></figure>

<h4 id="网站维护页面"><a href="#网站维护页面" class="headerlink" title="网站维护页面"></a>网站维护页面</h4><p><img src="https://code404.icu/img/moveypu/2021/03/2021033012284195.png"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>nginx配置</tag>
        <tag>维护</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx搭建负载均衡</title>
    <url>/2021/08/02/nginx%E6%90%AD%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-1.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>
<p>负载均衡通过upstream指令来实现</p>
<h3 id="1-RR-round-robin-轮询-默认"><a href="#1-RR-round-robin-轮询-默认" class="headerlink" title="1. RR(round robin :轮询 默认)"></a>1. RR(round robin :轮询 默认)</h3><hr>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器down掉，能自动剔除。轮询是默认配置，不需要太多的配置</p>
<p>同一个项目分别使用8081和8082端口启动项目</p>
<p>upstream web_servers {<br>   server localhost:8081;<br>   server localhost:8082;<br>}</p>
<p>server {<br>    listen       80;<br>    server_name  localhost;<br>    #access_log  logs&#x2F;host.access.log  main;</p>
<pre><code>location / &#123;
    proxy\_pass http://web\_servers;
    # 必须指定Header Host
    proxy\_set\_header Host $host:$server\_port;
&#125;
</code></pre>
<p> }</p>
<p>访问地址仍然可以获得响应 <a href="http://localhost/api/user/login?username=zhangsan&amp;password=111111">http://localhost/api/user/login?username=zhangsan&amp;password=111111</a> ，这种方式是轮询的</p>
<h3 id="2-权重"><a href="#2-权重" class="headerlink" title="2. 权重"></a>2. 权重</h3><hr>
<p>指定轮询几率，weight和访问比率成正比, 也就是服务器接收请求的比例就是各自配置的weight的比例，用于后端服务器性能不均的情况,比如服务器性能差点就少接收点请求，服务器性能好点就多处理点请求。</p>
<p>upstream test {<br>    server localhost:8081 weight&#x3D;1;<br>    server localhost:8082 weight&#x3D;3;<br>    server localhost:8083 weight&#x3D;4 backup;<br>}</p>
<p>示例是4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083</p>
<h3 id="3-ip-hash"><a href="#3-ip-hash" class="headerlink" title="3. ip_hash"></a>3. ip_hash</h3><hr>
<p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候(采用了session保存数据)，这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<p>upstream test {<br>    ip_hash;<br>    server localhost:8080;<br>    server localhost:8081;<br>}</p>
<h3 id="4-fair-第三方"><a href="#4-fair-第三方" class="headerlink" title="4. fair(第三方)"></a>4. fair(第三方)</h3><hr>
<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应</p>
<p>upstream backend {<br>    fair;<br>    server localhost:8080;<br>    server localhost:8081;<br>}</p>
<h3 id="5-url-hash-第三方"><a href="#5-url-hash-第三方" class="headerlink" title="5. url_hash(第三方)"></a>5. url_hash(第三方)</h3><hr>
<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p>
<p>upstream backend {<br>    hash $request_uri;<br>    hash_method crc32;<br>    server localhost:8080;<br>    server localhost:8081;<br>}</p>
<p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>策略</tag>
        <tag>nginx</tag>
        <tag>upstream</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx最小配置Root_Location_try_files指令</title>
    <url>/2021/09/12/nginx%E6%9C%80%E5%B0%8F%E9%85%8D%E7%BD%AEroot-location-try-files%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-10.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>安全服务器是只允许所需数量的服务器。理想情况下，我们将通过单独启用其他功能来基于最小系统构建服务器。进行最少的配置也有助于调试。如果该错误在最小系统中不可用，则分别添加功能，然后继续搜索错误。</p>
<h3 id="这是运行nginx所需的最低配置"><a href="#这是运行nginx所需的最低配置" class="headerlink" title="这是运行nginx所需的最低配置"></a>这是运行nginx所需的最低配置</h3><hr>
<p># &#x2F;etc&#x2F;nginx&#x2F;nginx.confevents {}</p>
<h1 id="event-context-have-to-be-defined-to-consider-config-validhttp"><a href="#event-context-have-to-be-defined-to-consider-config-validhttp" class="headerlink" title="event context have to be defined to consider config validhttp {"></a>event context have to be defined to consider config validhttp {</h1><p> server {<br>    listen 80;<br>    server_name  code404.icu  <a href="http://www.code404.icu/">www.code404.icu</a>  *.code404.icu;</p>
<pre><code>return 200 &quot;Hello&quot;;
</code></pre>
<p>  }</p>
<h3 id="Root-Location和try-files指令"><a href="#Root-Location和try-files指令" class="headerlink" title="Root Location和try_files指令"></a>Root Location和try_files指令</h3><hr>
<h4 id="Root-指令"><a href="#Root-指令" class="headerlink" title="Root 指令"></a>Root 指令</h4><p>root指令用于设置请求的根目录，从而允许nginx将传入的请求映射到文件系统上。</p>
<p>server {<br>  listen 80;<br>  server_name code404.icu;<br>  root &#x2F;var&#x2F;www&#x2F;code404.icu;<br>}</p>
<p>它允许nginx根据请求返回服务器内容:</p>
<p>code404.icu:80&#x2F;index.html     # returns &#x2F;var&#x2F;www&#x2F;code404.icu&#x2F;index.html<br>code404.icu:80&#x2F;foo&#x2F;index.html # returns &#x2F;var&#x2F;www&#x2F;code404.icu&#x2F;foo&#x2F;index.html</p>
<h4 id="Location指令"><a href="#Location指令" class="headerlink" title="Location指令"></a>Location指令</h4><p>location指令用于根据请求的URI(统一资源标识符)来设置配置。</p>
<p>语法为:</p>
<p>location [modifier] path</p>
<p>示例:</p>
<p>location &#x2F;foo {</p>
<h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><p>}</p>
<p>如果未指定修饰符，则将路径视为前缀，之后可以跟随任何内容。上面的示例将匹配:</p>
<p>&#x2F;foo<br>&#x2F;fooo<br>&#x2F;foo123<br>&#x2F;foo&#x2F;bar&#x2F;index.html<br>…</p>
<p>我们还可以在给定的上下文中使用多个location指令:</p>
<p>server {<br>  listen 80;<br>  server_name code404.icu;<br>  root &#x2F;var&#x2F;www&#x2F;code404.icu;</p>
<p>  location&#x2F;{<br>    return 200 “root”;<br>  }</p>
<p>  location &#x2F;foo {<br>    return 200 “foo”;<br>  }<br>}<br>code404.icu:80  &#x2F;      # &#x3D;&gt; “root”<br>code404.icu:80   &#x2F;foo    # &#x3D;&gt; “foo”<br>code404.icu:80   &#x2F;foo123 # &#x3D;&gt; “foo”<br>code404.icu:80   &#x2F;bar    # &#x3D;&gt; “root”</p>
<p>Nginx还提供了一些可以与 location 指令结合使用的修饰符。</p>
<p>修饰符已分配优先级:</p>
<p>=           - Exact match<br>^~          - Preferential match<br>~ &amp;&amp; ~*     - Regex match<br>no modifier - Prefix match</p>
<p>首先，nginx将检查所有精确匹配项。如果不存在，它将寻找优先选项。如果此匹配也失败，则将按其出现顺序测试正则表达式匹配。如果其他所有操作均失败，则将使用最后一个前缀匹配。</p>
<p>location &#x2F;match {<br>  return 200 ‘Prefix match: will match everything that starting with &#x2F;match’;<br>}</p>
<p>location ~* &#x2F;match[0-9] {<br>  return 200 ‘Case insensitive regex match’;<br>}</p>
<p>location ~ &#x2F;MATCH[0-9] {<br>  return 200 ‘Case sensitive regex match’;<br>}</p>
<p>location ^~ &#x2F;match0 {<br>  return 200 ‘Preferential match’;<br>}</p>
<p>location &#x3D; &#x2F;match {<br>  return 200 ‘Exact match’;<br>}<br>&#x2F;match     # &#x3D;&gt; ‘Exact match’<br>&#x2F;match0    # &#x3D;&gt; ‘Preferential match’<br>&#x2F;match1    # &#x3D;&gt; ‘Case insensitive regex match’<br>&#x2F;MATCH1    # &#x3D;&gt; ‘Case sensitive regex match’<br>&#x2F;match-abc # &#x3D;&gt; ‘Prefix match: matches everything that starting with &#x2F;match’</p>
<h4 id="try-files指令"><a href="#try-files指令" class="headerlink" title="try_files指令"></a>try_files指令</h4><p>该指令尝试不同的路径，并返回找到的任何路径。</p>
<p>try_files $uri index.html &#x3D;404;</p>
<p>因此，&#x2F;foo.html将尝试按以下顺序返回文件:</p>
<p>$uri(&#x2F;foo.html);</p>
<p>index.html</p>
<p>如果未找到:404</p>
<p>如果我们在服务器上下文中定义try_files，然后定义查找所有请求的位置，则不会执行try_files。发生这种情况是因为服务器上下文中的try_files定义了其伪位置，该伪位置是可能的最低特定位置。因此，定义location&#x2F; 会比我们的伪位置更具体。</p>
<p>server {<br>  try_files $uri &#x2F;index.html &#x3D;404;</p>
<p>  location&#x2F;{<br>  }<br>}</p>
<p>因此，我们应该避免在服务器上下文中使用try_files:</p>
<p>server {<br>  location&#x2F;{<br>    try_files $uri &#x2F;index.html &#x3D;404;<br>  }<br>}</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>root</tag>
        <tag>location</tag>
        <tag>try_files</tag>
        <tag>基础配置</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx站点动态上下线之使用 ngx_dynamic_upstream 实现nginx动态负载</title>
    <url>/2021/04/05/nginx%E7%AB%99%E7%82%B9%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF%E4%B9%8B%E4%BD%BF%E7%94%A8-ngx-dynamic-upstream-%E5%AE%9E%E7%8E%B0nginx%E5%8A%A8%E6%80%81%E8%B4%9F%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>模块下载地址: <a href="https://github.com/cubicdaiya/ngx_dynamic_upstream">https://github.com/cubicdaiya/ngx_dynamic_upstream</a></p>
</blockquote>
<blockquote>
<p>主要功能 实现了修改upstream权重 可以不需要重载nginx配置 即不需要reload</p>
</blockquote>
<h4 id="首先安装nginx"><a href="#首先安装nginx" class="headerlink" title="首先安装nginx"></a>首先安装nginx</h4><p>nginx 安装文档请移驾 <a href="https://www.code404.icu/145.html">史上最全最详细Nginx源码编译安装的方法步骤</a></p>
<p>nginx 添加模块时一定要先 nginx -V 看一下原先安装的模块，不要覆盖原有模块</p>
<p>下面原有模块 –add-module&#x3D;&#x2F;opt&#x2F;nginx-module-vts 新增模块 –add-module&#x3D;&#x2F;opt&#x2F;ngx_dynamic_upstream</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.19.9]# ./configure --prefix=/opt/nginx/ --add-module=/opt/nginx-module-vts --add-module=/opt/ngx_dynamic_upstream-0.1.6</span><br><span class="line">[root@localhost nginx-1.19.9]# make -j 4 # -j 是多线程编译，4就是4个线程</span><br><span class="line">[root@localhost nginx-1.19.9]# make install </span><br><span class="line">[root@localhost nginx-1.19.9]# cd /opt/nginx/sbin/</span><br><span class="line">[root@localhost sbin]# ll</span><br><span class="line">总用量 8928</span><br><span class="line">-rwxr-xr-x. 1 root root 4612232 4月   1 21:43 nginx</span><br><span class="line">-rwxr-xr-x. 1 root root 4524024 4月   1 13:11 nginx.old</span><br><span class="line">[root@localhost sbin]# ./nginx -V</span><br><span class="line">nginx version: nginx/1.19.9</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span><br><span class="line">configure arguments: --prefix=/opt/nginx/ --add-module=/opt/nginx-module-vts --add-module=/opt/ngx_dynamic_upstream-0.1.6</span><br></pre></td></tr></table></figure>

<h5 id="模块添加完成"><a href="#模块添加完成" class="headerlink" title="模块添加完成"></a><em>模块添加完成</em></h5><hr>
<h4 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h4><p><strong><em>本次只讲dynamic_upstream相关配置，其它nginx配置请自行查找相关文档</em></strong></p>
<blockquote>
<p>主配置下添加(在任意server模块下都可以，我配置在80端口下面)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /dynamic &#123;</span><br><span class="line">        dynamic_upstream;</span><br><span class="line">        allow 192.168.80.80 #IP白名单</span><br><span class="line">        #allow 127.0.0.1;</span><br><span class="line">        #deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>upstream 下面配置（zone名字随意 1m即可）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream gateway &#123;</span><br><span class="line">        zone  zone_for_gateway_jgy_9527 1m;</span><br><span class="line">        server 192.168.80.176:9528; # max_fails=1 fail_timeout=30s;</span><br><span class="line">        server 192.168.65.94:9528; # max_fails=1 fail_timeout=30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#养成好习惯，启动/重启 前检查配置是否正常</span><br><span class="line">[root@localhost conf.d]# /data/openresty/nginx/sbin/nginx -c /data/openresty/nginx/conf/nginx.conf -t  #检查配置文件</span><br><span class="line">nginx: the configuration file /data/openresty/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /data/openresty/nginx/conf/nginx.conf test is successful</span><br><span class="line">[root@localhost conf.d]# /data/openresty/nginx/sbin/nginx -c /data/openresty/nginx/conf/nginx.conf #启动nginx</span><br></pre></td></tr></table></figure>

<h4 id="验证动态剔除服务"><a href="#验证动态剔除服务" class="headerlink" title="验证动态剔除服务"></a>验证动态剔除服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@OIS-AS02 ~]# curl &quot;http://192.168.65.94/dynamic?upstream=zone_for_gateway_jgy_9527&amp;verbose=&quot; #查看zone_for_gateway_jgy_9527 下面服务列表</span><br><span class="line">server 192.168.80.176:9528 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 192.168.65.94:9528 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">[root@OIS-AS02 ~]# curl &quot;http://192.168.65.94/dynamic?upstream=zone_for_gateway_jgy_9527&amp;verbose=&amp;server=192.168.80.176:9528&amp;down=&quot;</span><br><span class="line">server 192.168.80.176:9528 weight=1 max_fails=1 fail_timeout=10 down;</span><br><span class="line">server 192.168.65.94:9528 weight=1 max_fails=1 fail_timeout=10;</span><br></pre></td></tr></table></figure>

<h4 id="HTTP-APIs（使用方法）"><a href="#HTTP-APIs（使用方法）" class="headerlink" title="HTTP APIs（使用方法）"></a>HTTP APIs（使用方法）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列表</span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&quot;</span><br><span class="line">server 127.0.0.1:6001;</span><br><span class="line">server 127.0.0.1:6002;</span><br><span class="line">server 127.0.0.1:6003;</span><br><span class="line"></span><br><span class="line"># 详细</span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;verbose=&quot;</span><br><span class="line">server 127.0.0.1:6001 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6002 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6003 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line"></span><br><span class="line"># 更新参数（临时，重启失效）</span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;server=127.0.0.1:6003&amp;weight=10&amp;max_fails=5&amp;fail_timeout=5&quot;</span><br><span class="line">server 127.0.0.1:6001 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6002 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6003 weight=10 max_fails=5 fail_timeout=5;</span><br><span class="line"></span><br><span class="line"># 下线服务</span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;server=127.0.0.1:6003&amp;down=&quot;</span><br><span class="line">server 127.0.0.1:6001 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6002 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6003 weight=1 max_fails=1 fail_timeout=10 down;</span><br><span class="line"></span><br><span class="line"># 上线服务 </span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;server=127.0.0.1:6003&amp;up=&quot;</span><br><span class="line">server 127.0.0.1:6001 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6002 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line">server 127.0.0.1:6003 weight=1 max_fails=1 fail_timeout=10;</span><br><span class="line"></span><br><span class="line"># 动态添加服务</span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;add=&amp;server=127.0.0.1:6004&quot;</span><br><span class="line">server 127.0.0.1:6001;</span><br><span class="line">server 127.0.0.1:6002;</span><br><span class="line">server 127.0.0.1:6003;</span><br><span class="line">server 127.0.0.1:6004;</span><br><span class="line"></span><br><span class="line"># 动态移除服务</span><br><span class="line">$ curl &quot;http://127.0.0.1:6000/dynamic?upstream=zone_for_backends&amp;remove=&amp;server=127.0.0.1:6003&quot;</span><br><span class="line">server 127.0.0.1:6001;</span><br><span class="line">server 127.0.0.1:6002;</span><br><span class="line">server 127.0.0.1:6004;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>upstream</tag>
        <tag>负载均衡</tag>
        <tag>动态upstream</tag>
        <tag>动态下线</tag>
        <tag>动态升级</tag>
        <tag>动态更新</tag>
        <tag>无感升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置_location目录匹配详解_中一个不起眼字符\&quot;/\&quot;的巨大作用</title>
    <url>/2021/10/25/nginx%E9%85%8D%E7%BD%AE-location%E7%9B%AE%E5%BD%95%E5%8C%B9%E9%85%8D%E8%AF%A6%E8%A7%A3-%E4%B8%AD%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B5%B7%E7%9C%BC%E5%AD%97%E7%AC%A6-%E7%9A%84%E5%B7%A8%E5%A4%A7%E4%BD%9C/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-21.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Nginx作为一个轻量级的，高性能的web服务软件，因其占有内存少，并发能力强的特点，而广受欢迎和使用。国内很多大型互联网公司也对Nginx很是青睐。像BAT（百度，阿里和腾讯），TMD(头条，美团和滴滴)等等。使用过Nginx的同学都知道，你只需要按需求准确的更改好配置启动，那么就可以优雅的访问它了。所以说Nginx对配置文件的很是看中呢，这就要求我们更改配置文件时一定要再三确认，要不然可能因为疏忽而引发惨案呢？真实案例，就因为在配置时，少些了一个字符“&#x2F;”，就造成访问不通报错，因而接到投诉。那么是怎么引起的呢？原因就是：Nginx在配置proxy_pass代理转接时，少些“&#x2F;”字符造成的。有同学就有疑问，加不加“&#x2F;”,区别真的那么大吗？我们带着这个疑问，来探究下这个问题。</p>
<h3 id="location目录匹配详解"><a href="#location目录匹配详解" class="headerlink" title="location目录匹配详解"></a>location目录匹配详解</h3><hr>
<p>nginx每个location都是一个匹配目录，nginx的策略是：访问请求来时，会对访问地址进行解析，从上到下逐个匹配，匹配上就执行对应location大括号中的策略，并根据策略对请求作出相应。<br>依访问地址：<a href="http://www.code404.icu/code404/index.html%E4%B8%BA%E4%BE%8B%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A">http://www.code404.icu/code404/index.html为例，nginx配置如下：</a></p>
<p>location &#x2F;code404&#x2F; {<br>    proxy_connect_timeout 18000; ##修改成半个小时<br>    proxy_send_timeout 18000;<br>    proxy_read_timeout 18000;<br>    proxy_pass <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>;<br>}</p>
<p>那访问时就会匹配这个location,从而把请求代理转发到本机的8080 Tomcat服务中，Tomcat相应后，信息原路返回。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>location如果没有“&#x2F;”时，请求就可以模糊匹配以字符串开头的所有字符串，而有“&#x2F;”时，只能精确匹配字符本身。<br>下面举个例子说明：<br>配置location &#x2F;code404可以匹配&#x2F;code404asdfasdf请求，也可以匹配&#x2F;code404*&#x2F;asdfasfd等等，只要以code404开头的目录都可以匹配到。而location &#x2F;code404&#x2F; 必须精确匹配 &#x2F;code404&#x2F; 这个目录的请求,不能匹配 &#x2F;code404asdfasdf 或&#x2F;code404*&#x2F;asdfasfd等请求。<br>proxy_pass有无“&#x2F;”的四种区别探究<br>访问地址都是以：<a href="http://www.code404.com/code404/index.html">http://www.code404.com/code404/index.html</a> 为例。请求都匹配目录&#x2F;code404&#x2F;</p>
<h3 id="第一种：加”-x2F-“"><a href="#第一种：加”-x2F-“" class="headerlink" title="第一种：加”&#x2F;“"></a>第一种：加”&#x2F;“</h3><hr>
<p>   location  &#x2F;code404&#x2F; {<br>    proxy_pass  <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a>;<br>   }</p>
<p>测试结果，请求被代理跳转到：<a href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a></p>
<h3 id="第二种-不加”-x2F-“"><a href="#第二种-不加”-x2F-“" class="headerlink" title="第二种: 不加”&#x2F;“"></a>第二种: 不加”&#x2F;“</h3><hr>
<p>location &#x2F;code404&#x2F; {<br>proxy_pass <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>;<br>}</p>
<p>测试结果，请求被代理跳转到：<a href="http://127.0.0.1:8080/code404/index.html">http://127.0.0.1:8080/code404/index.html</a></p>
<h3 id="第三种-增加目录加”-x2F-“"><a href="#第三种-增加目录加”-x2F-“" class="headerlink" title="第三种: 增加目录加”&#x2F;“"></a>第三种: 增加目录加”&#x2F;“</h3><hr>
<p>location  &#x2F;code404&#x2F; {<br>    proxy_pass <a href="http://127.0.0.1:8080/sun/">http://127.0.0.1:8080/sun/</a>;<br>   }</p>
<p>测试结果，请求被代理跳转到：<a href="http://127.0.0.1:8080/sun/index.html">http://127.0.0.1:8080/sun/index.html</a></p>
<h3 id="第四种：增加目录不加”-x2F-“"><a href="#第四种：增加目录不加”-x2F-“" class="headerlink" title="第四种：增加目录不加”&#x2F;“"></a>第四种：增加目录不加”&#x2F;“</h3><hr>
<p>location  &#x2F;code404&#x2F; {<br>    proxy_pass <a href="http://127.0.0.1:8080/sun">http://127.0.0.1:8080/sun</a>;<br>   }</p>
<p>测试结果，请求被代理跳转到：<a href="http://127.0.0.1:8080/sunindex.html">http://127.0.0.1:8080/sunindex.html</a></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><hr>
<p>location目录后加”&#x2F;“,只能匹配目录，不加“&#x2F;”不仅可以匹配目录还对目录进行模糊匹配。而proxy_pass无论加不加“&#x2F;”,代理跳转地址都直接拼接。<br>为了加深大家印象可以用下面的配置实验测试下：</p>
<p>server {<br>  listen 80;<br>  server_name localhost;</p>
<h1 id="http-localhost-wddd01-xxx-gt-http-localhost-8080-wddd01-xxx"><a href="#http-localhost-wddd01-xxx-gt-http-localhost-8080-wddd01-xxx" class="headerlink" title="http://localhost/wddd01/xxx -&gt; http://localhost:8080/wddd01/xxx"></a><a href="http://localhost/wddd01/xxx">http://localhost/wddd01/xxx</a> -&gt; <a href="http://localhost:8080/wddd01/xxx">http://localhost:8080/wddd01/xxx</a></h1><p>  location &#x2F;wddd01&#x2F; {<br>    proxy_pass <a href="http://localhost:8080/">http://localhost:8080</a>;<br>  }</p>
<h1 id="http-localhost-wddd02-xxx-gt-http-localhost-8080-xxx"><a href="#http-localhost-wddd02-xxx-gt-http-localhost-8080-xxx" class="headerlink" title="http://localhost/wddd02/xxx -&gt; http://localhost:8080/xxx"></a><a href="http://localhost/wddd02/xxx">http://localhost/wddd02/xxx</a> -&gt; <a href="http://localhost:8080/xxx">http://localhost:8080/xxx</a></h1><p>  location &#x2F;wddd02&#x2F; {<br>    proxy_pass <a href="http://localhost:8080/">http://localhost:8080/</a>;<br>  }</p>
<h1 id="http-localhost-wddd03-xxx-gt-http-localhost-8080-wddd03-xxx"><a href="#http-localhost-wddd03-xxx-gt-http-localhost-8080-wddd03-xxx" class="headerlink" title="http://localhost/wddd03/xxx -&gt; http://localhost:8080/wddd03\*/xxx"></a><a href="http://localhost/wddd03/xxx">http://localhost/wddd03/xxx</a> -&gt; <a href="http://localhost:8080/wddd03/*/xxx">http://localhost:8080/wddd03\*/xxx</a></h1><p>  location &#x2F;wddd03 {<br>    proxy_pass <a href="http://localhost:8080/">http://localhost:8080</a>;<br>  }</p>
<h1 id="http-localhost-wddd04-xxx-gt-http-localhost-8080-xxx，请注意这里的双斜线，好好分析一下。"><a href="#http-localhost-wddd04-xxx-gt-http-localhost-8080-xxx，请注意这里的双斜线，好好分析一下。" class="headerlink" title="http://localhost/wddd04/xxx -&gt; http://localhost:8080//xxx，请注意这里的双斜线，好好分析一下。"></a><a href="http://localhost/wddd04/xxx">http://localhost/wddd04/xxx</a> -&gt; <a href="http://localhost:8080//xxx%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E7%9A%84%E5%8F%8C%E6%96%9C%E7%BA%BF%EF%BC%8C%E5%A5%BD%E5%A5%BD%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E3%80%82">http://localhost:8080//xxx，请注意这里的双斜线，好好分析一下。</a></h1><p>  location &#x2F;wddd04 {<br>    proxy_pass <a href="http://localhost:8080/">http://localhost:8080/</a>;<br>  }</p>
<h1 id="http-localhost-wddd05-xxx-gt-http-localhost-8080-hahaxxx，请注意这里的haha和xxx之间没有斜杠，分析一下原因。"><a href="#http-localhost-wddd05-xxx-gt-http-localhost-8080-hahaxxx，请注意这里的haha和xxx之间没有斜杠，分析一下原因。" class="headerlink" title="http://localhost/wddd05/xxx -&gt; http://localhost:8080/hahaxxx，请注意这里的haha和xxx之间没有斜杠，分析一下原因。"></a><a href="http://localhost/wddd05/xxx">http://localhost/wddd05/xxx</a> -&gt; <a href="http://localhost:8080/hahaxxx%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E7%9A%84haha%E5%92%8Cxxx%E4%B9%8B%E9%97%B4%E6%B2%A1%E6%9C%89%E6%96%9C%E6%9D%A0%EF%BC%8C%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9B%A0%E3%80%82">http://localhost:8080/hahaxxx，请注意这里的haha和xxx之间没有斜杠，分析一下原因。</a></h1><p>  location &#x2F;wddd05&#x2F; {<br>    proxy_pass <a href="http://localhost:8080/haha">http://localhost:8080/haha</a>;<br>  }</p>
<h1 id="http-localhost-api6-xxx-gt-http-localhost-8080-haha-xxx"><a href="#http-localhost-api6-xxx-gt-http-localhost-8080-haha-xxx" class="headerlink" title="http://localhost/api6/xxx -&gt; http://localhost:8080/haha/xxx"></a><a href="http://localhost/api6/xxx">http://localhost/api6/xxx</a> -&gt; <a href="http://localhost:8080/haha/xxx">http://localhost:8080/haha/xxx</a></h1><p>  location &#x2F;wddd06&#x2F; {<br>    proxy_pass <a href="http://localhost:8080/haha/">http://localhost:8080/haha/</a>;<br>  }</p>
<h1 id="http-localhost-wddd07-xxx-gt-http-localhost-8080-haha-xxx"><a href="#http-localhost-wddd07-xxx-gt-http-localhost-8080-haha-xxx" class="headerlink" title="http://localhost/wddd07/xxx -&gt; http://localhost:8080/haha/xxx"></a><a href="http://localhost/wddd07/xxx">http://localhost/wddd07/xxx</a> -&gt; <a href="http://localhost:8080/haha/xxx">http://localhost:8080/haha/xxx</a></h1><p>  location &#x2F;wddd07 {<br>    proxy_pass <a href="http://localhost:8080/haha">http://localhost:8080/haha</a>;<br>  }</p>
<h1 id="http-localhost-wddd08-xxx-gt-http-localhost-8080-haha-xxx，请注意这里的双斜杠。"><a href="#http-localhost-wddd08-xxx-gt-http-localhost-8080-haha-xxx，请注意这里的双斜杠。" class="headerlink" title="http://localhost/wddd08/xxx -&gt; http://localhost:8080/haha//xxx，请注意这里的双斜杠。"></a><a href="http://localhost/wddd08/xxx">http://localhost/wddd08/xxx</a> -&gt; <a href="http://localhost:8080/haha//xxx%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E7%9A%84%E5%8F%8C%E6%96%9C%E6%9D%A0%E3%80%82">http://localhost:8080/haha//xxx，请注意这里的双斜杠。</a></h1><p>  location &#x2F;wddd08 {<br>    proxy_pass <a href="http://localhost:8080/haha/">http://localhost:8080/haha/</a>;<br>  }<br>}</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>location</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置HTTP服务器</title>
    <url>/2021/07/26/nginx%E9%85%8D%E7%BD%AEhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>
<h3 id="Nginx-网页目录"><a href="#Nginx-网页目录" class="headerlink" title="Nginx 网页目录"></a>Nginx 网页目录</h3><hr>
<p>首先在文档根目录Docroot（&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html）中放一个test.html;<br><img src="https://img-blog.csdnimg.cn/43fa8b6f03ec4b65b9a0e6e8e586886d.png" alt="在这里插入图片描述"></p>
<h3 id="配置nginx-conf中的server"><a href="#配置nginx-conf中的server" class="headerlink" title="配置nginx.conf中的server"></a>配置nginx.conf中的server</h3><hr>
<p>user code404.icu;<br>http {<br>    server {<br>        listen       80;<br>        server_name  localhost;<br>        client_max_body_size 1024M;</p>
<pre><code>    # 默认location
    location / &#123;
        root /usr/local/nginx/html;
        index  index.html index.htm;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><hr>
<p><a href="http://localhost/">http://localhost/</a> 指向&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html, index.html是安装nginx自带的html<br><a href="http://localhost/test.html">http://localhost/test.html</a> 指向&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;test.html</p>
<p>注意：如果访问图片出现403 Forbidden错误，可能是因为nginx.conf 的第一行user配置不对，默认是#user nobody;是注释的，linux下改成user root; macos下改成user 用户名 所在组; 然后重新加载配置文件或者重启，再试一下就可以了， 用户名可以通过who am i 命令来查看。</p>
<h3 id="指令简介"><a href="#指令简介" class="headerlink" title="指令简介"></a>指令简介</h3><hr>
<ul>
<li>server : 用于定义服务，http中可以有多个server块</li>
<li>listen : 指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口</li>
<li>server_name : 服务名称，用于配置域名</li>
<li>location : 用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式, &#x2F; 表示匹配任意路径, 当客户端访问的路径满足这个uri时就会执行location块里面的代码</li>
<li>root : 根路径，当访问<a href="http://localhost/test.html%EF%BC%8C%E2%80%9C/test.html%E2%80%9D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%E2%80%9D/%E2%80%9Duri">http://localhost/test.html，“/test.html”会匹配到”/”uri</a>, 找到root为&#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;html，用户访问的资源物理地址&#x3D;root + uri &#x3D; &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;html + &#x2F;test.html&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;html&#x2F;test.html</li>
<li>index : 设置首页，当只访问server_name时后面不跟任何路径是不走root直接走index指令的；如果访问路径中没有指定具体的文件，则返回index设置的资源，如果访问<a href="http://localhost/html/">http://localhost/html/</a> 则默认返回index.html</li>
</ul>
<h3 id="location-uri正则表达式"><a href="#location-uri正则表达式" class="headerlink" title="location uri正则表达式"></a>location uri正则表达式</h3><hr>
<ul>
<li><p>. ：匹配除换行符以外的任意字符</p>
</li>
<li><p>? ：重复0次或1次</p>
<ul>
<li><p>：重复1次或更多次</p>
</li>
<li><p>：重复0次或更多次</p>
</li>
</ul>
</li>
<li><p>\d ：匹配数字</p>
</li>
<li><p>^ ：匹配字符串的开始</p>
</li>
<li><p>$ ：匹配字符串的结束</p>
</li>
<li><p>{n} ：重复n次</p>
</li>
<li><p>{n,} ：重复n次或更多次</p>
</li>
<li><p>[c] ：匹配单个字符c</p>
</li>
<li><p>[a-z] ：匹配a-z小写字母的任意一个</p>
</li>
<li><p>(abc) : 属线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括括住，匹配符合a字符 或是b字符 或是c字符的字符串</p>
</li>
<li><p>\ 反斜杠：用于转义特殊字符</p>
</li>
</ul>
<p>小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\转义特殊字符。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>HTTP服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Nmap使用手册【全】扫描绕过防火墙</title>
    <url>/2021/07/28/nmap%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E3%80%90%E5%85%A8%E3%80%91%E6%89%AB%E6%8F%8F%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-67.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>Nmap是一个非常实用的网络连接端扫描软件，适用于Linux、Windows、Mac三大主流平台。用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。</p>
<h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><hr>
<p>1.全面扫描&#x2F;综合扫描</p>
<p>nmap -A 192.168.242.1 </p>
<p>2.Ping扫描</p>
<p>nmap -sP 192.168.242.1&#x2F;24</p>
<p>3.免ping扫描，穿透防火墙，避免被防火墙发现</p>
<p>nmap -P0 192.168.242.1</p>
<p>4.TCP SYN Ping扫描</p>
<p>nmap -PS -v 192.168.242.135<br>nmap -PS80()端口，10-100  -v 192.168.242.135 (针对防火墙丢弃RST包)<br>```![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/ea18b6bb8ecb455f92e12bdf585bc6b5.png?x-oss-process=image/watermark,type%5C_ZmFuZ3poZW5naGVpdGk,shadow%5C_10,text%5C_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size%5C_16,color%5C_FFFFFF,t%5C_70">https://img-blog.csdnimg.cn/ea18b6bb8ecb455f92e12bdf585bc6b5.png?x-oss-process=image/watermark,type\_ZmFuZ3poZW5naGVpdGk,shadow\_10,text\_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size\_16,color\_FFFFFF,t\_70</a>)</p>
<p>5.TCP ACK Ping 扫描<br>```shell<br>nmap -PA -v 192.168.242.135</p>
<ol start="6">
<li>UDP Ping 扫描</li>
</ol>
<p>nmap -PU -v 192.168.242.135</p>
<ol start="7">
<li>ICMP Ping Types 扫描</li>
</ol>
<p>nmap -PU -v 192.168.242.135 (ICMP ECHO)<br>nmap -PP -v 192.168.242.135 (ICMP 时间戳)<br>nmap -PM -v 192.168.242.135 (ICMP 地址掩码)</p>
<ol start="8">
<li>ARP Ping 扫描</li>
</ol>
<p>nmap -PR -v 192.168.242.1</p>
<ol start="9">
<li>列表扫描</li>
</ol>
<p>nmap -sL -v 192.168.242.1</p>
<ol start="10">
<li>禁止方向域名解析</li>
</ol>
<p>nmap -n -sL -v 192.168.242.1</p>
<ol start="11">
<li>方向域名解析</li>
</ol>
<p>nmap -R -sL -v 192.168.242.1</p>
<ol start="12">
<li>使用系统域名解析系统</li>
</ol>
<p>nmap –system-dns 192.168.242.1 192.168.242.135</p>
<ol start="13">
<li>扫描IPV6 地址</li>
</ol>
<p>nmap -6 IPv6</p>
<ol start="14">
<li>路由跟踪</li>
</ol>
<p>nmap –traceroute -v <a href="http://www.sunbridgegroup.com/">www.sunbridgegroup.com</a></p>
<ol start="15">
<li>SCTP INIT Ping 扫描</li>
</ol>
<p>nmap -PY -v 192.168.1.103</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><hr>
<ol>
<li>时序扫描</li>
</ol>
<p>nmap -T(0-5) 192.168.242.1</p>
<ol start="2">
<li>常用扫描方式</li>
</ol>
<p>nmap -P 80 192.168.242.1<br>nmap -P 80-100 192.168.242.1<br>nmap -P T:80,U:445 192.168.242.135<br>nmap -F 192.168.242.135 (快速扫描)<br>nmap –top-ports 200 192.168.242.1 (扫描最有用的前200 个端口)</p>
<ol start="3">
<li>TCP SYN 扫描（高效的扫描方式）</li>
</ol>
<p>nmap -sS -v 192.168.242.135</p>
<ol start="4">
<li>TCP 连接扫描</li>
</ol>
<p>nmap -sT -v 192.168.242.1</p>
<ol start="5">
<li>UDP 连接扫描</li>
</ol>
<p>nmap -sU -p 80-100 192.168.242.135</p>
<ol start="6">
<li>隐蔽扫描</li>
</ol>
<p>nmap -sN 61.241.194.153(NULL 扫描)<br>nmap -sF 61.241.194.153(FIN 扫描)<br>nmap -sX 61.241.194.153(Xmas 扫描)</p>
<ol start="7">
<li>TCP ACK 扫描</li>
</ol>
<p>nmap -sA 192.168.242.1</p>
<ol start="8">
<li>TCP 窗口扫描</li>
</ol>
<p>nmap -sW -v -F 192.168.242.1</p>
<ol start="9">
<li>TCP Maimon 扫描</li>
</ol>
<p>nmap -sM -T4 192.168.242.135</p>
<ol start="10">
<li>自定义扫描</li>
</ol>
<p>nmap -sT –scanflags SYNURG 192.168.242.1</p>
<ol start="11">
<li>空闲扫描( 隐藏IP )</li>
</ol>
<p>nmap -sI <a href="http://www.0day.co/">www.0day.co:80</a> 192.168.242.1</p>
<ol start="12">
<li>IP 协议扫描</li>
</ol>
<p>nmap -sO -T4 192.168.242.1</p>
<h3 id="指纹识别与探测"><a href="#指纹识别与探测" class="headerlink" title="指纹识别与探测"></a>指纹识别与探测</h3><hr>
<ol>
<li>版本探测</li>
</ol>
<p>nmap -sV 192.168.242.135nmap -sV -A 192.168.241.135</p>
<ol start="2">
<li>全端口版本探测</li>
</ol>
<p>nmap -sV –allports 192.168.242.135</p>
<p><img src="https://img-blog.csdnimg.cn/dcec68700d0b49b087b356ff854b6919.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li>设置扫描强度</li>
</ol>
<p>nmap -sV –version-intensity (0-9) 192.168.242.135</p>
<ol start="4">
<li>轻量级扫描</li>
</ol>
<p>nmap -sV –version-light 2 192.168.242.135</p>
<ol start="5">
<li>重量级扫描</li>
</ol>
<p>nmap -sV –version-all 192.168.242.135</p>
<ol start="6">
<li>获取详细版本信息</li>
</ol>
<p>nmap -sV –version-trace 192.168.242.135</p>
<ol start="7">
<li>RPC 扫描</li>
</ol>
<p>nmap -sS -sR 192.168.242.135</p>
<ol start="8">
<li>对指定的目标进行操作系统监测</li>
</ol>
<p>nmap -O –osscan-limit 192.168.242.1</p>
<p><img src="https://img-blog.csdnimg.cn/0d2e42f818824cb99bf798bf3f7316b8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="9">
<li>推测系统并识别</li>
</ol>
<p>nmap -O –osscan-guess 192.168.242.1</p>
<h3 id="伺机而动"><a href="#伺机而动" class="headerlink" title="伺机而动"></a>伺机而动</h3><hr>
<ol>
<li>调整并行扫描组的大小</li>
</ol>
<p>nmap –min-hostgroup 30 192.168.242.1&#x2F;24<br>nmap –max-hostgroup 30 902 192.168.242.1</p>
<ol start="2">
<li>调整探测报文的并行度</li>
</ol>
<p>nmap –min-parallelism 100 192.168.242.1<br>nmap –max-parallelism 100 192.168.242.1</p>
<ol start="3">
<li>调整探测报文超时</li>
</ol>
<p>nmap –initial-rtt-timeout 100ms 192.168.242.1<br>nmap –max-rtt-timeout 100ms 192.168.242.1<br>nmap –min-rtt-timeout 100ms 192.168.242.1</p>
<ol start="4">
<li>放弃缓慢的目标主机</li>
</ol>
<p>nmap –host-timeout 1800000ms 192.168.242.1</p>
<ol start="5">
<li>调整报文适合时间间隔</li>
</ol>
<p>nmap –scan-delay 1s 192.168.242.1<br>nmap –max-scan-delay 1s 192.168.242.1</p>
<h3 id="防火墙-x2F-IDS-逃逸"><a href="#防火墙-x2F-IDS-逃逸" class="headerlink" title="防火墙&#x2F;IDS 逃逸"></a>防火墙&#x2F;IDS 逃逸</h3><hr>
<ol>
<li>报文分段</li>
</ol>
<p>nmap -f -v 61.241.194.153</p>
<ol start="2">
<li>指定偏移大小</li>
</ol>
<p>nmap –mtu 16 192.168.242.1</p>
<ol start="3">
<li>IP 欺骗</li>
</ol>
<p>nmap -D RND:11 192.168.1.104<br>nmap -D 192.168.1.104,192.168.1.103,192.168.1.101 192.168.1.104</p>
<ol start="4">
<li>源地址欺骗</li>
</ol>
<p>nmap -sI <a href="http://www.0day.cn/">www.0day.cn:80</a> 192.168.1.104</p>
<ol start="5">
<li>源端口欺骗</li>
</ol>
<p>nmap –source-port 902 192.168.1.104</p>
<ol start="6">
<li>指定发包长度</li>
</ol>
<p>nmap –data-length 30 192.168.1.104</p>
<ol start="7">
<li>目标主机随机排序</li>
</ol>
<p>nmap –randomize-hosts 192.168.1.104</p>
<ol start="8">
<li>MAX 地址欺骗</li>
</ol>
<p>nmap -sT -Pn –spoof-mac 0 192.168.1.104</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><hr>
<ol>
<li>IP 信息收集</li>
</ol>
<p>nmap –script ip-geolocation-* <a href="http://www.code404.icu/">www.code404.icu</a></p>
<ol start="2">
<li>WHOIS 查询</li>
</ol>
<p>nmap –script whois-domain <a href="http://www.code404.icu/">www.code404.icu</a><br>nmap –script whois-domain –script-args whois.whodb&#x3D;nofollow<br><a href="http://www.code404.icu/">www.code404.icu</a><br>nmap -sn –script whois-domain -v -iL host.txt</p>
<ol start="3">
<li>IP 反查</li>
</ol>
<p>nmap -sn –script hostmap-ip2hosts <a href="http://www.code404.icu/">www.code404.icu</a></p>
<ol start="4">
<li>DNS 信息收集</li>
</ol>
<p>nmap –script dns-brute <a href="http://www.code404.icu/">www.code404.icu</a><br>nmap –script dns-brute dns-brute.threads&#x3D;10 <a href="http://www.code404.icu/">www.code404.icu</a><br>nmap –script dns-brute dns-brute.threads&#x3D;10,dns-brute.hostlis<br><a href="http://www.code404.icu/">www.code404.icu</a></p>
<ol start="5">
<li>检索系统信息</li>
</ol>
<p>nmap -p 445 445 192.168.1.104 –script membase-http-info</p>
<ol start="6">
<li>后台打印机服务漏洞</li>
</ol>
<p>nmap –script smb-security-mode.nse -p 445 119.29.155.45</p>
<ol start="7">
<li>系统漏洞扫描</li>
</ol>
<p>nmap –script smb-check-vulns.nse -p 445 119.29.155.45</p>
<ol start="9">
<li>扫描Web 漏洞</li>
</ol>
<p>nmap -p80 –script http-stored-xss.nse&#x2F;http-sql-injection.nse 119.29.155.45</p>
<ol start="10">
<li>通过Snmp 列举Windows 服务&#x2F;账户</li>
</ol>
<p>nmap -sU -p 161 –script&#x3D;snmp-win32-services 192.168.1.104<br>nmap -sU -f -p 161 –script&#x3D;snmp-win32-users 192.168.1.110</p>
<ol start="11">
<li>枚举DNS 服务器的主机名</li>
</ol>
<p>nmap –script dns-brute –script-args dns-brute.domain&#x3D;code404.icu</p>
<ol start="12">
<li>HTTP 信息收集</li>
</ol>
<p>nmap -sV -p 80 <a href="http://www.code404.icu/">www.code404.icu</a> (HTTP 版本探测)<br>nmap -p 80 –script&#x3D;http-headers <a href="http://www.code404.icu/">www.code404.icu</a> (HTTP 信息头探测)<br>nmap -p 80 –script&#x3D;http-sitemap-generator <a href="http://www.code404.icu/">www.code404.icu</a> (爬行Web 目录结构)</p>
<ol start="13">
<li>枚举SSL 密钥</li>
</ol>
<p>nmap -p 443 –script&#x3D;ssl-enum-ciphers <a href="http://www.code404.icu/">www.code404.icu</a></p>
<ol start="14">
<li>SSH 服务密钥信息探测</li>
</ol>
<p>nmap -p 22 –script ssh-hostkey –script-args ssh_hostkey&#x3D;full 127.0.0.1</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nmap</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Nmap</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>npm run asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).</title>
    <url>/2021/11/13/npm-run-asset-size-limit-the-following-assets-exceed-the-recommended-size-limit-244-kib/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021111207353243.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>使用webpack4打包时，运行npm run build:结果报错，提示<br>npm run build: WARNING in asset size limit: The following asset(s) exceed the recommended size limit。提示入口文件过大，webpack打包后的生成文件和入口文件体积过大，超过了默认值。</p>
<h3 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h3><hr>
<p>asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).<br>This can impact web performance.</p>
<p>leenhem@leenhem-Thinkpad-T440P:~&#x2F;code&#x2F;vue-element-admin$ npm run prod</p>
<blockquote>
<p><a href="mailto:&#x76;&#117;&#x65;&#45;&#x65;&#x6c;&#101;&#109;&#101;&#110;&#x74;&#45;&#x61;&#100;&#x6d;&#x69;&#110;&#64;&#52;&#46;&#52;&#46;&#x30;">&#x76;&#117;&#x65;&#45;&#x65;&#x6c;&#101;&#109;&#101;&#110;&#x74;&#45;&#x61;&#100;&#x6d;&#x69;&#110;&#64;&#52;&#46;&#52;&#46;&#x30;</a> prod<br>vue-cli-service serve –mode production</p>
</blockquote>
<p> INFO  Starting development server…</p>
<p> WARNING  Compiled with 2 warnings                                                                                                                          上午10:37:26</p>
<p> warning  </p>
<p>asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).<br>This can impact web performance.<br>Assets:<br>  static&#x2F;css&#x2F;app.e44a11ae.css (248 KiB)<br>  static&#x2F;js&#x2F;chunk-3d48ca62.afc066a9.js (1.33 MiB)<br>  static&#x2F;js&#x2F;chunk-5164a781.b8c02a89.js (890 KiB)<br>  static&#x2F;js&#x2F;chunk-7801aabc.8490b9cb.js (794 KiB)<br>  static&#x2F;js&#x2F;chunk-elementUI.611e9551.js (659 KiB)<br>  static&#x2F;js&#x2F;chunk-libs.824d12a4.js (396 KiB)</p>
<p> warning  </p>
<p>entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.<br>Entrypoints:<br>  app (1.4 MiB)<br>      static&#x2F;js&#x2F;chunk-elementUI.611e9551.js<br>      static&#x2F;css&#x2F;chunk-libs.3dfb7769.css<br>      static&#x2F;js&#x2F;chunk-libs.824d12a4.js<br>      static&#x2F;css&#x2F;app.e44a11ae.css<br>      static&#x2F;js&#x2F;app.1e6fd036.js</p>
<p>  App running at:</p>
<ul>
<li>Local:   <a href="http://localhost:9527/">http://localhost:9527/</a> </li>
<li>Network: <a href="http://172.25.42.35:9527/">http://172.25.42.35:9527/</a></li>
</ul>
<p>  App is served in production mode.<br>  Note this is for preview or E2E testing only.</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>在vue.config.js下配置 configureWebpack<br>将入口文件和资源文件最大值调大就不会报错了</p>
<p>  configureWebpack: {<br>    &#x2F;&#x2F; provide the app’s title in webpack’s name field, so that<br>    &#x2F;&#x2F; it can be accessed in index.html to inject the correct title.<br>    performance: {<br>    &#x2F;&#x2F;入口起点的最大体积<br>      maxEntrypointSize: 50000000,<br>    &#x2F;&#x2F;生成文件的最大体积<br>      maxAssetSize: 30000000,<br>    }<br>}</p>
]]></content>
      <categories>
        <category>VUE</category>
        <category>网页开发</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>limit</tag>
        <tag>size</tag>
        <tag>vue.js</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>openresty,lua,shell执行服务器脚本</title>
    <url>/2021/06/24/openrestyluashell%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-59.png"></p>
<p>最近安装了openresty ,想做一个通过git各大代码托管平台提供的webhook实现自动部署的功能。以前的实现方式是服务器暴露一个接口（php写的）给托管平台，webhook访问后接口会做一个修改或更新文件的动作，同时服务器上部署一个监控该文件的脚本，一旦检测到文件更新就调用系统的命令，比如 git pull 及其他命令进行项目更新和构建。</p>
<h3 id="为什么不直接通过php来调用系统命令而单独写一个监控脚本呢？"><a href="#为什么不直接通过php来调用系统命令而单独写一个监控脚本呢？" class="headerlink" title="为什么不直接通过php来调用系统命令而单独写一个监控脚本呢？"></a>为什么不直接通过php来调用系统命令而单独写一个监控脚本呢？</h3><p>首先是权限的问题，php无论是以php-fpm还是apache模块，一般都会用单独的用户来运行，这是出于安全的考虑，这个用户对项目目录也没有写入的权限，除了部分特殊的目录，比如上传目录才有写权限。所以远程仓库的更新没有办法直接写入到本地。</p>
<p>其次也是因为安全的原因，线上服务器的php.ini的设定都会禁用危险的 exec 、system之类的用来调用shell 命令的函数。</p>
<h3 id="关于监控脚本"><a href="#关于监控脚本" class="headerlink" title="关于监控脚本"></a>关于监控脚本</h3><p>windows上可以写一个批处理并加入开机启动，linux上有inotify，后来我还发现了可以使用nodemon实现跨平台。很多人对nodemon的印象还是停留在 javascript上面，特别是前端开发和node.js用得比较多，其实它也可以执行非js文件，比如shell script，python 脚本等等，非常好用的一个工具。</p>
<h3 id="为什么用openresty-x2F-ngx-lua"><a href="#为什么用openresty-x2F-ngx-lua" class="headerlink" title="为什么用openresty&#x2F;ngx_lua"></a>为什么用openresty&#x2F;ngx_lua</h3><p>上面的解决方案的缺点很明显，又是php，又是nodemon，还要指定一个监控文件，要依赖的东西太多了，结构上非常松散，也不利于迁移和重用，但是如果用openresty, 只要集中在lua脚本就可以了，加上少量的nginx配置，如果简单粗暴一些，甚至可以直接写在nginx配置里。</p>
<h3 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h3><ol>
<li>下载安装麻省理工Juce版的 lua_resty_shell</li>
<li>下载安装 sockproc</li>
<li>编写lua脚本</li>
</ol>
<h3 id="1-下载安装麻省理工Juce版的-lua-resty-shell"><a href="#1-下载安装麻省理工Juce版的-lua-resty-shell" class="headerlink" title="1.下载安装麻省理工Juce版的 lua_resty_shell"></a>1.下载安装麻省理工Juce版的 lua_resty_shell</h3><p>openresty 有一个默认lualib目录，在 MacOS 上位于 &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openresty&#x2F;1.19.3.1_1&#x2F;lualib，这个目录的作用是如果脚本里要引用一个包，比如require “resty.shell” ，映射到磁盘的文件，点会被转化为 “&#x2F;”，lua会在此目录搜索搜索并实际匹配到这个文件：&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openresty&#x2F;1.19.3.1_1&#x2F;lualib&#x2F;resty&#x2F;shell.lua</p>
<p>你可以直接把 juce版lua_resty_shell 克隆下来并将 shell.lua文件放入默认的lualib目录，不过这样会替换掉openresty自带的 resty&#x2F;shell 模块，不建议这样做，可以建立一个单独的目录，这里是用 &#x2F;Users&#x2F;falcon&#x2F;projects&#x2F;lua&#x2F;lualib用来存放用户或者第三方的package ，把前面的shell.lua放在这个目录，同时修改nginx.conf,http 加入以下内容：</p>
<p>http {<br>    lua_code_cache off;  # 仅开发环境禁用<br>    lua_package_path “&#x2F;Users&#x2F;falcon&#x2F;projects&#x2F;lua&#x2F;lualib&#x2F;?.lua;;”;<br>…</p>
<p>lua_package_path 指令表示lua包搜索的路径，;; 表示默认路径。? 就是require里引用模块的名称，在上文指的是 resty&#x2F;shell。</p>
<h3 id="2-下载安装-sockproc"><a href="#2-下载安装-sockproc" class="headerlink" title="2.下载安装 sockproc"></a>2.下载安装 sockproc</h3><p>按照文档下载编译并启动，可以监听socket，也可以监听端口。btw，我看了文档才知道原来 Macos 上的 telnet 命令是可以按socket来连接的，比linux上的 telnet 可要多才多艺（versatile）😂, linux 上的只能通过端口连接，要连接socket可以通过socat 。</p>
<p>为了方便，我写了个几行小脚本启动：</p>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env bash<br>&#x2F;bin&#x2F;rm &#x2F;tmp&#x2F;shell.sock &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>&#x2F;Users&#x2F;falcon&#x2F;cmd&#x2F;sockproc&#x2F;sockproc &#x2F;tmp&#x2F;shell.sock</p>
<h3 id="3-编写lua脚本"><a href="#3-编写lua脚本" class="headerlink" title="3. 编写lua脚本"></a>3. 编写lua脚本</h3><p>建立项目路径：&#x2F;Users&#x2F;falcon&#x2F;projects&#x2F;lua&#x2F;ngx_script, 新增 test-shell.lua</p>
<p>local shell &#x3D; require “resty.shell”<br>local args &#x3D; {<br>    socket &#x3D; “unix:&#x2F;tmp&#x2F;shell.sock”,  – 这是第一步的 unxi socket<br>}<br>local status, out, err &#x3D; shell.execute(“uptime”, args)  – ls 是想调用的命令,<br>ngx.header.content_type &#x3D; “text&#x2F;plain”<br>ngx.say(“Result:\n” .. out)                    – 命令输出结果</p>
<p>修改nginx.conf，server块:</p>
<pre><code>server &#123;
    listen       80 default\_server;
    server\_name  localhost;
    location = /shell &#123;
        default\_type &#39;text/html&#39;;
        content\_by\_lua\_file /Users/falcon/projects/lua/ngx\_script/test-shell.lua;
    &#125;
 
&#125;
</code></pre>
<p>重启openresty, 访问 <a href="http://localhost/shell">http://localhost/shell</a> 会看到以下内容，跟在终端里调用 uptime 命令结果是一样的</p>
<p>Result:<br>19:28  up 19:57, 3 users, load averages: 2.50 2.98 3.30</p>
<p>说明调用 shell 的测试成功，下面开始编写构建项目自动更新的脚本。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>lua</tag>
        <tag>Openresty</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl生成SSL_https证书_nginx配置证书</title>
    <url>/2021/11/03/openssl%E7%94%9F%E6%88%90ssl-https%E8%AF%81%E4%B9%A6-nginx%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-3.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>SSL 证书（SSL Certificates）又称数字证书，SSL 证书将为您的网站、移动 App、Web API 等应用提供身份验证和数据加密传输等整套 HTTPS 解决方案。</p>
<h3 id="openssl语法"><a href="#openssl语法" class="headerlink" title="openssl语法"></a>openssl语法</h3><hr>
<p>openssl  genrsa [-out filename] [-passout arg] [-f4] [-3] [-rand file(s)] [-engine id] [numbits] [-des] [-des3] [-idea]</p>
<p>usage: genrsa [args] [numbits]<br> -des            encrypt the generated key with DES in cbc mode<br> -des3           encrypt the generated key with DES in ede cbc mode (168 bit key)<br> -idea           encrypt the generated key with IDEA in cbc mode<br> -seed<br>                 encrypt PEM output with cbc seed<br> -aes128, -aes192, -aes256<br>                 encrypt PEM output with cbc aes<br> -camellia128, -camellia192, -camellia256<br>                 encrypt PEM output with cbc camellia<br> -out file       output the key to ‘file<br> -passout arg    output file pass phrase source<br> -f4             use F4 (0x10001) for the E value<br> -3              use 3 for the E value<br> -engine e       use engine e, possibly a hardware device.<br> -rand file:file:…<br>                 load the file (or the files in the directory) into<br>                 the random number generator</p>
<h3 id="openssl-自己制作ssl证书：自己签发免费ssl证书，为nginx生成自签名ssl证书"><a href="#openssl-自己制作ssl证书：自己签发免费ssl证书，为nginx生成自签名ssl证书" class="headerlink" title="openssl 自己制作ssl证书：自己签发免费ssl证书，为nginx生成自签名ssl证书"></a>openssl 自己制作ssl证书：自己签发免费ssl证书，为nginx生成自签名ssl证书</h3><hr>
<h4 id="首先执行如下命令生成一个key，服务器证书密钥文件"><a href="#首先执行如下命令生成一个key，服务器证书密钥文件" class="headerlink" title="首先执行如下命令生成一个key，服务器证书密钥文件"></a>首先执行如下命令生成一个key，服务器证书密钥文件</h4><hr>
<p>openssl genrsa -des3 -out <a href="http://www.code404.icu.key/">www.code404.icu.key</a> 2048</p>
<p>这个时候会提示输入密码 这个密码要记住<br>不推荐输入。因为以后要给nginx使用。每次reload nginx配置时候都要你验证这个PAM密码的。</p>
<p>由于生成时候必须输入密码。你可以输入后 再删掉。</p>
<p>mv <a href="http://www.code404.icu.key/">www.code404.icu.key</a> xxx.key</p>
<p>openssl rsa -in xxx.key -out <a href="http://www.code404.icu.key/">www.code404.icu.key</a></p>
<p>rm xxx.key</p>
<h4 id="根据key文件生成服务器证书的申请文件-www-code404-icu-csr"><a href="#根据key文件生成服务器证书的申请文件-www-code404-icu-csr" class="headerlink" title="根据key文件生成服务器证书的申请文件 www.code404.icu.csr"></a>根据key文件生成服务器证书的申请文件 <a href="http://www.code404.icu.csr/">www.code404.icu.csr</a></h4><hr>
<p>openssl req -new -key <a href="http://www.code404.icu.key/">www.code404.icu.key</a> -out <a href="http://www.code404.icu.csr/">www.code404.icu.csr</a></p>
<p>会要求输入下面内容</p>
<p>输出内容为：</p>
<p>Enter pass phrase for root.key: 输入前面创建的密码<br>Country Name (2 letter code) [AU]:CN   国家代号，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing   省的全名，拼音<br>Locality Name (eg, city) []:BeiJing  市的全名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:Yvioo  公司英文名(可以随便输入)<br>Organizational Unit Name (eg, section) []:  单位名 可以不输入<br>Common Name (eg, YOUR name) []: 输入你的名子或域名 必填<br>Email Address []:<a href="mailto:&#97;&#x64;&#109;&#105;&#110;&#x40;&#109;&#x79;&#x63;&#x6f;&#109;&#x70;&#x61;&#110;&#x79;&#46;&#x63;&#x6f;&#109;">&#97;&#x64;&#109;&#105;&#110;&#x40;&#109;&#x79;&#x63;&#x6f;&#109;&#x70;&#x61;&#110;&#x79;&#46;&#x63;&#x6f;&#109;</a>  电子邮箱随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []:  可以不输入<br>An optional company name []:   可以不输入</p>
<h4 id="生成证书文件www-code404-icu-crt"><a href="#生成证书文件www-code404-icu-crt" class="headerlink" title="生成证书文件www.code404.icu.crt"></a>生成证书文件<a href="http://www.code404.icu.crt/">www.code404.icu.crt</a></h4><hr>
<p>openssl x509 -req -days 365 -in <a href="http://www.code404.icu.csr/">www.code404.icu.csr</a> -signkey <a href="http://www.code404.icu.key/">www.code404.icu.key</a> -out <a href="http://www.code404.icu.crt/">www.code404.icu.crt</a></p>
<h3 id="配置Nginx的证书"><a href="#配置Nginx的证书" class="headerlink" title="配置Nginx的证书"></a>配置Nginx的证书</h3><hr>
<p># HTTPS server<br>    #<br>    server {<br>        listen       443 ssl;<br>        server_name  localhost;</p>
<pre><code>    ssl\_certificate      ssl/www.code404.icu.crt;
    ssl\_certificate\_key  ssl/www.code404.icu.key;

    ssl\_session\_cache    shared:SSL:1m;
    ssl\_session\_timeout  5m;

    ssl\_ciphers  HIGH:!aNULL:!MD5;
    ssl\_prefer\_server\_ciphers  on;

    location / &#123;
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
        <category>OpenSSL</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>HTTPS</tag>
        <tag>证书</tag>
        <tag>code404</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracal官网账号共享</title>
    <url>/2021/06/30/oracal%E5%AE%98%E7%BD%91%E8%B4%A6%E5%8F%B7%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<p><strong>目前在官网下载 jdk以及其他oracle公司的产品的时候需要登陆，这边分享一个账号，方便下载</strong></p>
<hr>
<h3 id="Username-x74-x74-x61-x75-x65-114-x6e-64-116-114-x61-115-x68-x2d-109-97-105-x6c-x2e-x63-x6f-x6d"><a href="#Username-x74-x74-x61-x75-x65-114-x6e-64-116-114-x61-115-x68-x2d-109-97-105-x6c-x2e-x63-x6f-x6d" class="headerlink" title="Username: &#x74;&#x74;&#x61;&#x75;&#x65;&#114;&#x6e;&#64;&#116;&#114;&#x61;&#115;&#x68;&#x2d;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;"></a><strong>Username</strong>: <a href="mailto:&#x74;&#x74;&#x61;&#x75;&#x65;&#114;&#x6e;&#64;&#116;&#114;&#x61;&#115;&#x68;&#x2d;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x74;&#x74;&#x61;&#x75;&#x65;&#114;&#x6e;&#64;&#116;&#114;&#x61;&#115;&#x68;&#x2d;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></h3><h3 id="Password-nhXpiFpk3KztJ43"><a href="#Password-nhXpiFpk3KztJ43" class="headerlink" title="Password: nhXpiFpk3KztJ43"></a><strong>Password</strong>: nhXpiFpk3KztJ43</h3><p><em>挥一挥衣袖，提供一份方便</em></p>
<p><strong>如果无法访问请告知我更新blog</strong></p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>免注册</tag>
        <tag>公共账号</tag>
        <tag>账号</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle JDBC 连接卡死后 Connection Reset解决过程</title>
    <url>/2021/06/28/oracle-jdbc-%E8%BF%9E%E6%8E%A5%E5%8D%A1%E6%AD%BB%E5%90%8E-connection-reset%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-16.png"></p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>jstorm 项目新增一台linux 主机，程序运行的时候报错如下:</p>
<p>我把研发的源代码拿过来找到对应的LoadSysParam.init(); 单独写了一个测试程序，在新主机上连续运行几次后就会重现该问题报错如下:</p>
<p>Exception in thread “main” org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (IO 错误: Connection reset)<br>    at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80)<br>    at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:573)<br>    at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:637)<br>    at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:666)<br>    at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:674)<br>    at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:714)<br>    at com.tydic.common.db.DBManager.getSql(DBManager.java:507)<br>    at com.tydic.common.db.DBManager.getListBySqlCode(DBManager.java:87)<br>    at com.tydic.notice.work.load.LoadSysParam.LoadMsgStruct(LoadSysParam.java:239)<br>    at com.tydic.notice.work.load.LoadSysParam.load(LoadSysParam.java:151)<br>    at com.tydic.notice.work.load.LoadSysParam.init(LoadSysParam.java:142)<br>    at com.tydic.main.LoadMain.main(LoadMain.java:12)<br>Caused by: org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (IO 错误: Connection reset)<br>    at org.apache.commons.dbcp.BasicDataSource.createPoolableConnectionFactory(BasicDataSource.java:1549)<br>    at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1388)<br>    at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)<br>    at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:111)<br>    at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:77)<br>    … 11 more<br>Caused by: java.sql.SQLRecoverableException: IO 错误: Connection reset<br>    at oracle.jdbc.driver.T4CConnection.logon(T4CConnection.java:752)<br>    at oracle.jdbc.driver.PhysicalConnection.connect(PhysicalConnection.java:662)<br>    at oracle.jdbc.driver.T4CDriverExtension.getConnection(T4CDriverExtension.java:32)<br>    at oracle.jdbc.driver.OracleDriver.connect(OracleDriver.java:560)<br>    at org.apache.commons.dbcp.DriverConnectionFactory.createConnection(DriverConnectionFactory.java:38)<br>    at org.apache.commons.dbcp.PoolableConnectionFactory.makeObject(PoolableConnectionFactory.java:582)<br>    at org.apache.commons.dbcp.BasicDataSource.validateConnectionFactory(BasicDataSource.java:1556)<br>    at org.apache.commons.dbcp.BasicDataSource.createPoolableConnectionFactory(BasicDataSource.java:1545)<br>    … 15 more<br>Caused by: java.net.SocketException: Connection reset<br>    at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:115)<br>    at java.net.SocketOutputStream.write(SocketOutputStream.java:155)<br>    at oracle.net.ns.DataPacket.send(DataPacket.java:209)<br>    at oracle.net.ns.NetOutputStream.flush(NetOutputStream.java:215)<br>    at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:302)<br>    at oracle.net.ns.NetInputStream.read(NetInputStream.java:249)<br>    at oracle.net.ns.NetInputStream.read(NetInputStream.java:171)<br>    at oracle.net.ns.NetInputStream.read(NetInputStream.java:89)<br>    at oracle.jdbc.driver.T4CSocketInputStreamWrapper.readNextPacket(T4CSocketInputStreamWrapper.java:123)<br>    at oracle.jdbc.driver.T4CSocketInputStreamWrapper.read(T4CSocketInputStreamWrapper.java:79)<br>    at oracle.jdbc.driver.T4CMAREngineStream.unmarshalUB1(T4CMAREngineStream.java:429)<br>    at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:397)<br>    at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:257)<br>    at oracle.jdbc.driver.T4CTTIoauthenticate.doOAUTH(T4CTTIoauthenticate.java:433)<br>    at oracle.jdbc.driver.T4CTTIoauthenticate.doOAUTH(T4CTTIoauthenticate.java:950)<br>    at oracle.jdbc.driver.T4CConnection.logon(T4CConnection.java:639)<br>    … 22 more</p>
<p>网上搜索 “linux oracle connection reset” ,得到如下信息:<br>这绝对是我碰计算机以来遇到的第一大坑！</p>
<h3 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h3><p>在Linux主机上远程登录，执行一个简单的Oracle的JDBC连接程序（jar包），结果硬生生的卡在了连接建立验证阶段，然后等上几分钟后因为连接超时，连接被远端的Oracle服务器reset，于是报了connection reset exception</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>参考：<a href="http://www.usn-it.de/index.php/2009/02/20/oracle-11g-jdbc-driver-hangs-blocked-by-devrandom-entropy-pool-empty/">http://www.usn-it.de/index.php/2009/02/20/oracle-11g-jdbc-driver-hangs-blocked-by-devrandom-entropy-pool-empty/</a></p>
<p>如参考材料中所述，oracle JDBC在建立连接时需要一些随机数据用以加密session token之类的东西，而这个随机数据源默认用的是&#x2F;dev&#x2F;random，如果不是，反正也是一个能让人慢的抓狂的发生源。Linux有个内核熵池（感觉太装B了），通过搜集键盘，鼠标，中断，磁盘操作来产生随机数据，可以通过以下命令查看当前的熵值：</p>
<p>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;entropy_avail</p>
<p>由于执行程序的主机没有图形界面只是通过远程ssh进行连接，那么熵值来源就少了两个，如果机器比较空闲则后面两个来源也少了，结果就是等半天来不了一个随机数，可以通过一下命令体验一下，用&#x2F;dev&#x2F;random憋出个随机数是多难</p>
<p>dd if &#x3D;&#x2F;dev&#x2F;random of&#x3D;rnd_file bs&#x3D;1 count&#x3D;64</p>
<p>如果侥幸执行的很快，可以多试几次把积累起来的熵值用掉，可以通过前面所述的方法查看当前熵值数目</p>
<p>Linux中还有个随机数发生器，&#x2F;dev&#x2F;urandom，如其名字所述，不那么随机的随机发生器，就是伪随机的，当然会快很多。参考资料中给出的把随机源修改为&#x2F;dev&#x2F;urandom的方法，即在执行java程序加入命令行参数：</p>
<p>-Djava.security.egd&#x3D;file:&#x2F;&#x2F;&#x2F;dev&#x2F;urandom</p>
<p>可是似乎不起作用。那么手工来增大熵值吧，可以执行一下命令</p>
<p>for   i in {1..100000}; do   cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;entropy_avail;done;</p>
<p>就是反复打印当前熵值10万次，当然根据自己测试的结果当熵值到达240+时，可以按ctrl+c终止这个命令，此时再去执行Oracle JDBC程序，就可以连接成功了（保险一点可以等熵值更大时终止命令）。虽然不是实用的解决方案，但至少确定了问题所在。为了这个事，人都快奔溃了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>安装一个为提供提供熵的程序包</p>
<p>   sudo apt-get install haveged</p>
<p>安装后需要手动执行</p>
<p>   &#x2F;usr&#x2F;sbin&#x2F;haveged -w 1024 -v 1</p>
<p>来源： <a href="http://www.code404.icu/">http://www.code404.icu/</a><br>通过比对新老机器熵值cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;entropy_avail，发现新机器值很小，老机器之很大，感觉这个博客写的应该靠谱<br>同时又在启动参数上加入-Djava.security.egd&#x3D;file:&#x2F;&#x2F;&#x2F;dev&#x2F;urandom,发现程序不会报错。可以确定就是这个问题导致的。<br>ps：suse默认是有这个安装包的，rethad默认无此安装包，需要另外装</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>jdbc</tag>
        <tag>Connection Reset</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle数据库重启命令是什么</title>
    <url>/2021/05/12/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-16.png"></p>
<p>dba 连接 oracle（切到 oracle 用户）</p>
<p><code>**su - oracle**</code></p>
<p><strong><code>sqlplus /nolog</code><br><code>conn / as sysdba</code></strong></p>
<p>也可以<br><code>**sqlplus / as sysdba**</code></p>
<p>登录成功之后，关闭数据库服务<br><code>**shutdown immediate**</code></p>
<p>登录成功之后，开启数据库服务</p>
<p><code>**startup**</code></p>
<p>监听操作</p>
<p>启动监听</p>
<p><code>**lsnrctl start**</code></p>
<p>停止监听</p>
<p><code>**lsnrctl stop**</code></p>
<p>问题引出：<br>测试环境，进行oralce的<code>**shutdown immediate**</code>，等待时间很长，长的无法等待</p>
<p>ORACLE shutdown 过程：</p>
<p>1、<code>**shutdown normal**</code>（正常关闭方式）:阻止任何用户建立新的连接；等待当前所有正在连接的用户主动断开连接；当所有的用户都断开连接后，将立即关闭数据库</p>
<p>2、<code>**shutdown transactional**</code>（实务关闭方式）：阻止用户连接新的连接和开始新事务；等待所有活动事务提交后，再断开用户连接；当所有的活动实务提交完毕、所有的用户都断开连接后，将关闭数据库</p>
<p>3、<code>**shutdown immediate**</code>(立即关闭方式)：阻止用户连接新连接和开始新事务；将未提交的活动事务回退；关闭数据库</p>
<p>4、<code>**shutdown abort**</code>(终止关闭方式)：阻止用户建立新连接和开始新事务；取消未提交的活动事务，而不是回退；立即终止正在执行的任何SQL语句；立即关闭数据库</p>
<p>无疑，<code>**shutdown abort**</code>是最开速关闭数据库的方式，但是很可能会使数据库处于不一致状态，严重可能损坏数据库，导致数据库起不来，特别是生产环境。虽然现在是测试环境，但是也不建议这样做。推荐使用<code>**shutdown immediate**</code>方式关闭数据库。</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
        <tag>重启命令</tag>
      </tags>
  </entry>
  <entry>
    <title>org.I0Itec.zkclient.exception.ZkTimeoutException: Unable to connect to zookeeper server with timeout</title>
    <url>/2021/08/21/org-i0itec-zkclient-exception-zktimeoutexception-unable-to-connect-to-zookeeper-server-with-timeout/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-18-1024x512.png"></p>
<h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><hr>
<p>zookeeper客户端连接到zookeeper节点有20秒的延迟，而且每次都是20秒。自己编写客户端进行测试，通过日志看到在某个环节上会出现阻塞，导致延迟</p>
<h3 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h3><hr>
<p>org.I0Itec.zkclient.exception.ZkTimeoutException: Unable to connect to zookeeper server 10.3.139.117:2181 with timeout 5000ms</p>
<p>Opening socket connection to server 10.3.139.117&#x2F;10.3.139.117:2181. Will not attempt to authenticate using SASL (unknown error)</p>
<p>15:49:12.424 [main] INFO  org.apache.zookeeper.ZooKeeper - Initiating client connection, connectString&#x3D;x.x.x.x:2181 sessionTimeout&#x3D;5000 watcher&#x3D;zk.ZKTest$1@393671df<br>15:49:12.427 [main] INFO  org.apache.zookeeper.common.X509Util - Setting -D jdk.tls.rejectClientInitiatedRenegotiation&#x3D;true to disable client-initiated TLS renegotiation<br>15:49:12.431 [main] INFO  org.apache.zookeeper.ClientCnxnSocket - jute.maxbuffer value is 1048575 Bytes<br>15:49:12.436 [main] INFO  org.apache.zookeeper.ClientCnxn - zookeeper.request.timeout value is 0. feature enabled&#x3D;false</p>
<p>15:49:32.465 [main-SendThread(x.x.x.x:2181)] INFO  org.apache.zookeeper.ClientCnxn - Opening socket connection to server x.x.x.x&#x2F;x.x.x.x:2181.<br>15:49:32.465 [main-SendThread(x.x.x.x:2181)] INFO  org.apache.zookeeper.ClientCnxn - SASL config status: Will not attempt to authenticate using SASL (unknown error)<br>15:49:32.477 [main-SendThread(x.x.x.x:2181)] INFO  org.apache.zookeeper.ClientCnxn - Socket connection established, initiating session, client: &#x2F;172.20.140.23:56244, server: x.x.x.x&#x2F;x.x.x.x:2181<br>15:49:32.498 [main-SendThread(x.x.x.x:2181)] INFO  org.apache.zookeeper.ClientCnxn - Session establishment complete on server x.x.x.x&#x2F;x.x.x.x:2181, session id &#x3D; 0x201249468f70009, negotiated timeout &#x3D; 5000</p>
<h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><hr>
<p>在上报错内容中可以看到服务连接zookeeper超时</p>
<p>org.I0Itec.zkclient.exception.ZkTimeoutException: Unable to connect to zookeeper server 10.3.139.117:2181 with timeout 5000ms</p>
<p>通过上述过程，可以确定是zookeeper默认使用了ZooKeeperSaslClient，而这个过程中调用了getHostName方法，从而造成程序阻塞。</p>
<p>所以可以通过在hosts文件添加上zookeeper的ip地址，使得getHostName可以直接使用hosts里面的dns结果。</p>
<p>vim &#x2F;etc&#x2F;hosts</p>
<p>10.3.141.115zk1<br>10.3.141.116zk2<br>10.3.139.117zk3</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>以后一定谨慎使用InetSocketAddress的getHostName方法，这个方法会对传进去的字符串进行域名解析，即使是一个ip地址也会进行解析，而dns解析的快慢和服务器配置有关系</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>SASL</tag>
        <tag>socket</tag>
        <tag>timeout</tag>
        <tag>zookeeper</tag>
        <tag>连接慢</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman 如何调试加密接口？</title>
    <url>/2021/09/25/postman-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%8A%A0%E5%AF%86%E6%8E%A5%E5%8F%A3%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-22.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>众所周知，Postman 是一款非常流行且易用的 API 调试工具，在接口调试或测试时经常被使用<br>针对普通 API 接口，我们可以直接在 Postman 中输入 URL、Query String、Header、Data 来模拟发送一个 HTTP 请求<br>但是，针对「 <strong>加密接口</strong> 」的调试及测试，我们怎么来做呢？</p>
<h3 id="CryptoJS-及-Pre-request-Script"><a href="#CryptoJS-及-Pre-request-Script" class="headerlink" title="CryptoJS 及 Pre-request Script"></a>CryptoJS 及 Pre-request Script</h3><hr>
<p>CryptoJS 是一个使用 JavaScript 实现的加密算法库<br>它支持的算法包含：</p>
<ul>
<li>Base64</li>
<li>MD5</li>
<li>SHA-1 和 SHA-256</li>
<li>AES</li>
<li>Rabbit</li>
<li>MARC4</li>
<li>HMAC、HMAC-MD5、HMAC-SHA1、HMAC-SHA256</li>
<li>PBKDF2</li>
</ul>
<p>在 Postman 中有一个 Tab 「 <strong>Pre-request Script</strong> 」，它能在请求之前做一些预处理<br>比如，可以使用 CryptoJS 先对变量进行加密，然后设置到变量中，最后在真实请求时使用这个变量</p>
<h3 id="实战一下"><a href="#实战一下" class="headerlink" title="实战一下"></a>实战一下</h3><hr>
<p>假设现在有一个登录接口<br>请求方式为 POST，请求体中包含用户名 username、密码 password，并且 password 是通过 MD5 加密后设置到请求体内<br><img src="https://img-blog.csdnimg.cn/34d65f4c7b754c1597b55f82d4cee536.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>如此，我们只需要在 Pre-request Script Tab 下，使用 CryptoJS 编写 JS 脚本，对密码变量进行预处理</p>
<p># Pre-request Script </p>
<p>var password &#x3D; “hu123456”;</p>
<p>&#x2F;&#x2F;md5加密<br>&#x2F;&#x2F;使用JS模块CryptoJS中的md5去加密数据<br>var password_encry &#x3D; CryptoJS.MD5(“hu123456”).toString();<br>console.log(“加密后的数据为:”+password_encry);</p>
<p>&#x2F;&#x2F;设置到环境变量中<br>&#x2F;&#x2F;方式一：全局变量<br>&#x2F;&#x2F; pm.globals.set(“password_encry”, password_encry);</p>
<p>&#x2F;&#x2F;方式二：局部变量<br>pm.environment.set(“password_encry”, password_encry);</p>
<p>预处理设置变量有 2 种方式：全局变量、局部变量<br>需要注意的是，如果设置到局部环境，我们需要先新建一个环境，并创建一个变量才能在 JS 脚本中引用<br><img src="https://img-blog.csdnimg.cn/fe6ed68c7cb4446fa126679aadff9db2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>最后，在请求体中替换成上面设置的变量即可<br><img src="https://img-blog.csdnimg.cn/b923369f32e74bb1b63b6dfba63ba469.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><hr>
<p>Postman 可以借助 CryptoJS 完成大部分数据的加密，但是它并不支持 RSA 算法<br>这里可以使用另外一个算法库「 forgeJS 」来进行 RSA 的加解密</p>
]]></content>
      <categories>
        <category>测试</category>
        <category>Postman</category>
      </categories>
      <tags>
        <tag>CryptoJS</tag>
        <tag>Postman</tag>
        <tag>Pre-request</tag>
        <tag>script</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>postman使用教程1-安装与使用</title>
    <url>/2021/06/04/postman%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B1-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-19.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>postman用于测试http协议接口，无论是开发, 还是测试人员, 都有必要学习使用postman来测试接口, 用起来非常方便。</p>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>postman 可以直接在chrome 上安装插件，当然大部分的同学是没法连接到谷歌商店的，我们可以在电脑本地安装postman 客户端工具。<br>Postman 也可作为适用于Mac，Windows（32位&#x2F; 64位）和Linux（32位&#x2F; 64位）操作系统的本机桌面应用程序使用。</p>
<p>Postman官网下载地址 <a href="https://www.postman.com/downloads/%EF%BC%9A">https://www.postman.com/downloads/：</a></p>
<ul>
<li>Postman for MAC <a href="https://dl.pstmn.io/download/latest/osx">https://dl.pstmn.io/download/latest/osx</a></li>
<li>Postman for windows 64 <a href="https://dl.pstmn.io/download/latest/win64">https://dl.pstmn.io/download/latest/win64</a></li>
<li>Postman for windows X86 <a href="https://dl.pstmn.io/download/latest/win32">https://dl.pstmn.io/download/latest/win32</a></li>
<li>Postman for linux <a href="https://dl.pstmn.io/download/latest/linux64">https://dl.pstmn.io/download/latest/linux64</a></li>
</ul>
<p>以windows 10系统安装为例，下载安装包Postman-win64-7.1.1-Setup.exe，双击安装</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-9.png"></p>
<h2 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h2><h3 id="接口名称：获取今日天气"><a href="#接口名称：获取今日天气" class="headerlink" title="接口名称：获取今日天气"></a>接口名称：获取今日天气</h3><p>详细说明：<a href="https://www.nowapi.com/api/weather.today?url=www.code404.icu">https://www.nowapi.com/api/weather.today?url=www.code404.icu</a></p>
<p>请求示例(json): <a href="http://api.k780.com:88/?app=weather.today&amp;weaid=101020100&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json">http://api.k780.com:88/?app=weather.today&amp;weaid=101020100&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json</a></p>
<h4 id="请求参数说明："><a href="#请求参数说明：" class="headerlink" title="请求参数说明："></a>请求参数说明：</h4><p>app 是获取哪天的数据，weather.today是获取今天的，weather.future获取未来五天的<br>wedid 是城市气象编号，与中国天气网编号一致，如上海：101020100<br>key和sign是身份验证，注册一个可以换成自己的，上例中的10003是公众帐号，<br>formt是返回格式，支持 json，xml,除了formt不是必须的以外，其他参数都是必须提供的。</p>
<h4 id="接口返回格式："><a href="#接口返回格式：" class="headerlink" title="接口返回格式："></a>接口返回格式：</h4><p>{<br>    “success”: “1”,<br>    “result”: {<br>        “weaid”: “36”,<br>        “days”: “2021-05-06”,<br>        “week”: “星期四”,<br>        “cityno”: “shanghai”,<br>        “citynm”: “上海”,<br>        “cityid”: “101020100”,<br>        “temperature”: “24℃&#x2F;19℃”,<br>        “temperature_curr”: “22℃”,<br>        “humidity”: “31%”,<br>        “aqi”: “57”,<br>        “weather”: “小雨”,<br>        “weather_curr”: “多云”,<br>        “weather_icon”: “<a href="http://api.k780.com/upload/weather/d/1.gif&quot;">http://api.k780.com/upload/weather/d/1.gif&quot;</a>,<br>        “weather_icon1”: “”,<br>        “wind”: “东北风”,<br>        “winp”: “1级”,<br>        “temp_high”: “24”,<br>        “temp_low”: “19”,<br>        “temp_curr”: “22”,<br>        “humi_high”: “0”,<br>        “humi_low”: “0”,<br>        “weatid”: “2”,<br>        “weatid1”: “”,<br>        “windid”: “1”,<br>        “winpid”: “1”,<br>        “weather_iconid”: “1”<br>    }<br>}</p>
<h4 id="Collection下添加-request-请求"><a href="#Collection下添加-request-请求" class="headerlink" title="Collection下添加 request 请求"></a>Collection下添加 request 请求</h4><p>点左上角 New - 添加 Collection ，Collection是收集器，可以理解成一个测试项目，这个项目下添加需测试的接口</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-10.png"></p>
<p>添加收集器名称和描述</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-11.png"></p>
<p>create 添加成功后，添加一个请求</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-12.png"></p>
<p>添加需要测试的请求，保存到收集器里面</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-13.png"></p>
<p>展开之后就可以看到添加的get请求了</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-14.png"></p>
<h3 id="测试天气预报接口"><a href="#测试天气预报接口" class="headerlink" title="测试天气预报接口"></a>测试天气预报接口</h3><p>以测试天气接口为例：<a href="http://api.k780.com:88/?app=weather.today&amp;weaid=101020100&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json">http://api.k780.com:88/?app=weather.today&amp;weaid=101020100&amp;appkey=10003&amp;sign=b59bc3ef6191eb9f747dd4e83c99f2a4&amp;format=json</a></p>
<p>可以直接复制整个url地址到地址栏，会自动生成 QueryParams 键值对</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-15-1024x517.png"></p>
<p>点send按钮，就可以看到response内容了</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-16.png"></p>
<h4 id="Query-Params"><a href="#Query-Params" class="headerlink" title="Query Params"></a>Query Params</h4><p>Query Params参数有2种编辑方式，可以在表格填写键值对</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-17-1024x454.png"></p>
<p>也可以点开Bulk Edit写多个键值对，中间用冒号隔开，多个参数换行</p>
<p>app:weather.today<br>weaid:101020100<br>appkey:10003<br>sign:b59bc3ef6191eb9f747dd4e83c99f2a4<br>format:json</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-18-1024x406.png"></p>
]]></content>
      <categories>
        <category>Postman</category>
      </categories>
      <tags>
        <tag>Postman</tag>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 使用 PushGateway 进行数据上报采集</title>
    <url>/2021/05/07/prometheus-%E4%BD%BF%E7%94%A8-pushgateway-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%B8%8A%E6%8A%A5%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-5.png"></p>
<h2 id="PushGateway-介绍"><a href="#PushGateway-介绍" class="headerlink" title="PushGateway 介绍"></a>PushGateway 介绍</h2><hr>
<p>Prometheus 是一套开源的系统监控、报警、时间序列数据库的组合，最初有 SoundCloud 开发的，后来随着越来越多公司使用，于是便独立成开源项目。Prometheus 基本原理是通过 Http 协议周期性抓取被监控组件的状态，而输出这些被监控的组件的 Http 接口为 Exporter。PushGateway 作为 Prometheus 生态中的一个重要一员，它允许任何客户端向其 Push 符合规范的自定义监控指标，在结合 Prometheus 统一收集监控。</p>
<h2 id="PushGateway-安装配置"><a href="#PushGateway-安装配置" class="headerlink" title="PushGateway 安装配置"></a>PushGateway 安装配置</h2><hr>
<p>PushGateway 安装很简单，可以使用二进制包解压安装服务</p>
<h3 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h3><p>二进制包安装方式，直接从 <a href="https://github.com/prometheus/pushgateway/releases">官方 Github</a> 下载最新二进制安装包，解压即可。</p>
<p>[root@NEWCWS-AS03 data]# wget <a href="https://github.com/prometheus/pushgateway/releases/download/v1.4.0/pushgateway-1.4.0.linux-amd64.tar.gz">https://github.com/prometheus/pushgateway/releases/download/v1.4.0/pushgateway-1.4.0.linux-amd64.tar.gz</a><br>[root@NEWCWS-AS03 data]# tar -zxvf pushgateway-1.4.0.linux-amd64.tar.gz<br>pushgateway-1.4.0.linux-amd64&#x2F;<br>pushgateway-1.4.0.linux-amd64&#x2F;LICENSE<br>pushgateway-1.4.0.linux-amd64&#x2F;NOTICE<br>pushgateway-1.4.0.linux-amd64&#x2F;pushgateway<br>[root@NEWCWS-AS03 data]# cd pushgateway-1.4.0.linux-amd64&#x2F;<br>[root@NEWCWS-AS03 pushgateway-1.4.0.linux-amd64]# ls<br>LICENSE  NOTICE  pushgateway<br>[root@NEWCWS-AS03 pushgateway-1.4.0.linux-amd64]# ll<br>总用量 17172<br>-rw-r–r– 1 3434 3434    11357 1月  23 08:08 LICENSE<br>-rw-r–r– 1 3434 3434      487 1月  23 08:08 NOTICE<br>-rwxr-xr-x 1 3434 3434 17564162 1月  23 07:54 pushgateway<br>[root@NEWCWS-AS03 pushgateway-1.4.0.linux-amd64]# .&#x2F;pushgateway<br>level&#x3D;info ts&#x3D;2021-05-06T09:30:58.569Z caller&#x3D;main.go:85 msg&#x3D;”starting pushgateway” version&#x3D;”(version&#x3D;1.4.0, branch&#x3D;HEAD, revision&#x3D;007ba874bead1b9ad2253d89e3adeb16a73fd012)”<br>level&#x3D;info ts&#x3D;2021-05-06T09:30:58.569Z caller&#x3D;main.go:86 build_context&#x3D;”(go&#x3D;go1.15.7, user&#x3D;root@410bc05a48f6, date&#x3D;20210122-23:54:24)”<br>level&#x3D;info ts&#x3D;2021-05-06T09:30:58.572Z caller&#x3D;main.go:139 listen_address&#x3D;:9091<br>level&#x3D;info ts&#x3D;2021-05-06T09:30:58.572Z caller&#x3D;tls_config.go:191 msg&#x3D;”TLS is disabled.” http2&#x3D;false</p>
<p>使用命令 .&#x2F;pushgateway 命令即可启动服务，此时浏览器访问 http:&#x2F;&#x2F;:9091 即可访问 UI 页面，只不过默认 Metrics 上没有任何数据展示，那是因为我们还没有往 PushGateway 上推送任何数据。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-2-1024x250.png"></p>
<p>不过，PushGateway 服务本身是带了一些 Metrics 的，可以通过访问 http:&#x2F;&#x2F;:9091&#x2F;metrics 地址来获取，可以看到里边包含了 go、process 等相关的一些监控指标。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-3.png"></p>
<p>OK，现在 PushGateway 服务已经启动完毕，但是还没有跟 Prometheus 关联起来，我们需要的是通过 PushGateway 来上传自定义监控数据，然后通过 Prometheus 采集这些数据来进行监控。那么就需要将 PushGateway 添加到 Prometheus 目标任务中去，增加 prometheus.yml 配置如下：</p>
<h2 id="配置prometheus服务端"><a href="#配置prometheus服务端" class="headerlink" title="配置prometheus服务端"></a>配置prometheus服务端</h2><hr>
<p>-–</p>
<ul>
<li>job_name: ‘pushgateway’<br>  static_configs:<br>- targets: [‘172.30.12.167:9091’]<br>  labels:<br>    instance: pushgateway</li>
</ul>
<p>说明一下，这里采用 static_configs 静态配置方式，因为目前就一个 PushGateway，如果有多个可以考虑其他服务发现方式，来方便动态加载，具体可以参考 <a href="https://prometheus.io/docs/Prometheus/latest/configuration/configuration/#scrape_config">这里</a>。配置完毕后，重启 Prometheus 服务，此时可以通过 Prometheus UI 页面的 Targets 下查看是否配置成功。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-4-1024x600.png"></p>
]]></content>
      <categories>
        <category>运维监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>PushGateway</tag>
        <tag>数据上报</tag>
        <tag>采集</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 查询语法</title>
    <url>/2021/11/19/prometheus-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/IMG_0404-768x403-1.png"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>Prometheus是一套使用Go语言进行编写的监控工具，专注于基础监控，默认仅保留15天的监控数据，15天的监控数据，已经足够运维人员去排查和分析运维故障。Prometheus有专门的PQL语言，可以对采集上来的指标进行多维度、函数分析，具有高度的指标定制化能力。本文将同大家一起学习Prometheus的PQL语法，验证并记录下过程。</p>
<h3 id="PQL重要概念"><a href="#PQL重要概念" class="headerlink" title="PQL重要概念"></a>PQL重要概念</h3><hr>
<h4 id="即时向量"><a href="#即时向量" class="headerlink" title="即时向量"></a>即时向量</h4><hr>
<p>一个时间点某指标的值，如：</p>
<p>node_cpu_seconds_total{mode&#x3D;”idle”}</p>
<p><img src="https://img-blog.csdnimg.cn/295107a6353643a8a18efb37c483c69e.png" alt="在这里插入图片描述"></p>
<h4 id="区间向量"><a href="#区间向量" class="headerlink" title="区间向量"></a>区间向量</h4><hr>
<p>指的是在某段时间内metric的取值，每个时间点都包含一系列的值，如：</p>
<p>node_cpu_seconds_total{mode&#x3D;”idle”}[5m]</p>
<p><img src="https://img-blog.csdnimg.cn/68255ad6479446fa8a51db51112ce2fb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h4><hr>
<ul>
<li>Gauge，度量值，这个值是有变化的，如CPU使用率，有高有低</li>
<li>Counter，累计值，从程序开始，只增不减，如开机运行时长</li>
</ul>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><hr>
<p>一个指标，可以包括多个标签（label），用来指示这个指标的具体表示信息，起到对一个指标的修饰作用，标签可使用正则表达式进行匹配。</p>
<p>如node_cpu_seconds_total指标，直接查询该指标，会打印出该指标的全部标签数据。</p>
<p><img src="https://img-blog.csdnimg.cn/160ad5b641df4f26a5e9709b3d07a040.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>拿关系型数据比较，可以这么类似比喻，node_cpu_seconds_total为表，cpu，instance，job，mode，value为其字段，表数据总为最新的数据，数据量总数等于各个字段的枚举值相乘。</p>
<p>当我们给这个Metric指标做了标签过滤时，相当于执行了where限制性语句，如node_cpu_seconds_total{mode&#x3D;“idle”}，只过滤出包含mode字段，并且其值为idle，类似于SQL语句。</p>
<p>select * from node_cpu_seconds_total where mode &#x3D; ‘idle’</p>
<p>标签支持正则表达式，使用&#x3D;<del>(Rexp)，如node_cpu_seconds_total{mode&#x3D;</del>“idleiowait”}，类似于SQL语句。</p>
<p>select * from node_cpu_seconds_total where mode &#x3D; ‘idle’ or mode &#x3D; ‘iowait’</p>
<p>标签过滤器可以有多个，用逗号进行隔开，相当于执行了where … and … 语句，如node_cpu_seconds_total{mode&#x3D;“idle”,cpu&#x3D;‘0’}，类似于SQL语句。</p>
<p>select * from node_cpu_seconds_total where mode &#x3D; ‘idle’ and cpu &#x3D; ‘0’</p>
<p>配合标签，我们可以精确的找到我们需要用于展示或者计算的指标值。</p>
<h4 id="偏移量offset"><a href="#偏移量offset" class="headerlink" title="偏移量offset"></a>偏移量offset</h4><hr>
<p>指标通过偏移量offset关键字，可以查询相对于当前时间点之前的数据，默认获取当前最新数据，如node_cpu_seconds_total offset 5m，获取5分钟前该指标的数据。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><hr>
<p>PQL使用”#”对语法进行注释。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><hr>
<h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><hr>
<ul>
<li>sum函数可以对瞬时向量进行求和，如sum(node_cpu_seconds_total)，将统计所有值的总和。类似于select sum(value) from node_cpu_seconds_total</li>
<li>sum后面可以加 by 关键字，表示通过那个维度进行数据统计求和，如sum by (mode) (node_cpu_seconds_total) 类似于 select sum(vaule) from node_cpu_seconds_total group by mode</li>
</ul>
<h5 id="min"><a href="#min" class="headerlink" title="min"></a>min</h5><hr>
<ul>
<li>min函数可以对瞬时向量进行求最小值，min(node_cpu_seconds_total)。类似于select min(value) from node_cpu_seconds_total</li>
<li>同样，也支持by关键字，进行某个维度的求最小值</li>
</ul>
<h5 id="max"><a href="#max" class="headerlink" title="max"></a>max</h5><hr>
<ul>
<li>max函数可以对瞬时向量进行求最大值，max(node_cpu_seconds_total)。类似于select max(value) from node_cpu_seconds_total</li>
<li>同样，也支持by关键字，进行某个维度的求最大值</li>
</ul>
<h5 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h5><hr>
<ul>
<li>avg函数可以对瞬时向量进行求平均avg(node_cpu_seconds_total)。类似于select avg(value) from node_cpu_seconds_total</li>
<li>同样，也支持by关键字，进行某个维度的求最均值</li>
</ul>
<h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><hr>
<ul>
<li>count函数可以对瞬时向量个数求总数，如count(node_cpu_seconds_total)类似于select count(*) from node_cpu_seconds_total</li>
<li>同样，也支持by关键字，进行某个维度的求最总个数</li>
</ul>
<h5 id="topk"><a href="#topk" class="headerlink" title="topk"></a>topk</h5><hr>
<ul>
<li>topk函数可以对瞬时向量的值从大到小进行排列，并获取前N个值，需要传入两个参数，一个是N，一个是指标，如topk(5,node_cpu_seconds_total)，类似于select * from (select * from node_cpu_seconds_total order by value desc) where rownum&lt;&#x3D;5</li>
<li>同样，也支持by关键字，进行某个维度进行计算</li>
</ul>
<h5 id="bottomk"><a href="#bottomk" class="headerlink" title="bottomk"></a>bottomk</h5><hr>
<ul>
<li>同topk相反，这里不再赘述。</li>
</ul>
<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><hr>
<h5 id="加法运算"><a href="#加法运算" class="headerlink" title="+ 加法运算"></a>+ 加法运算</h5><hr>
<ul>
<li>指标支持加法运算，一个即时向量，由于标签值不一致，所以会有多个值，这些值可以跟另外一个即时向量进行相加，这里的相加要保持一个原则，那就是需要具有同一个标签值的才会相加。node_cpu_seconds_total + node_cpu_seconds_total，这相当于所有值都多加一个原来的值，总体的值的数量是保持不变的。</li>
<li>相加的两个瞬时向量个数不一致情况：node_cpu_seconds_total和node_cpu_seconds_total{mode&#x3D;“idle”}，后者经过过滤后，数量上明显比第一个少，此时输出的结果个数同过滤后数量少的个数一致。</li>
<li>两个即时向量都不具备有同样的标签值情况：如node_cpu_seconds_total + node_memory_Active_bytes，此时由于没有任何一个值具有相同的标签值，所以结果为nodata，此时我们可以用ignoring关键字，对标签值进行忽略，使他们可以进行相加。由于node_cpu_seconds_total比node_memory_Active_bytes多了cpu和mode标签，所以node_cpu_seconds_total数量个数一般大于node_memory_Active_bytes个数，所以需要使用group_left，node_cpu_seconds_total + ignoring(cpu,mode) group_left node_memory_Active_bytes，结果集以左边的node_cpu_seconds_total个数为准，如果加号两个即时向量位置相反，则可以使用group_right，如node_memory_Active_bytes + ignoring(cpu,mode) group_right node_cpu_seconds_total</li>
</ul>
<h5 id="减法运算"><a href="#减法运算" class="headerlink" title="- 减法运算"></a>- 减法运算</h5><hr>
<ul>
<li>类似加法运算</li>
</ul>
<h5 id="乘法运算"><a href="#乘法运算" class="headerlink" title="* 乘法运算"></a>* 乘法运算</h5><hr>
<ul>
<li>类似加法运算</li>
</ul>
<h5 id="x2F-除法运算"><a href="#x2F-除法运算" class="headerlink" title="&#x2F; 除法运算"></a>&#x2F; 除法运算</h5><hr>
<ul>
<li>类似加法运算</li>
</ul>
<h4 id="逻辑比较"><a href="#逻辑比较" class="headerlink" title="逻辑比较"></a>逻辑比较</h4><hr>
<h5 id="x3D-判断是否相等"><a href="#x3D-判断是否相等" class="headerlink" title="=&#x3D; 判断是否相等"></a>=&#x3D; 判断是否相等</h5><hr>
<ul>
<li>=&#x3D;用于判断左右两边的值是否相等，如果相等则为1（true），如果不等则为0（false），如node_cpu_seconds_total &#x3D;&#x3D;BOOL 0 判断是否有存在0值</li>
</ul>
<h5 id="x3D-判断是否不等"><a href="#x3D-判断是否不等" class="headerlink" title="!&#x3D; 判断是否不等"></a>!&#x3D; 判断是否不等</h5><hr>
<ul>
<li>类似&#x3D;&#x3D;</li>
</ul>
<h5 id="gt-x3D-大于等于"><a href="#gt-x3D-大于等于" class="headerlink" title="&gt;&#x3D; 大于等于"></a>&gt;&#x3D; 大于等于</h5><hr>
<ul>
<li>&gt;&#x3D;用于判断左边的值是否大于或等于右边的值，如果满足，则为1（true），如果不满足则为0（false）</li>
</ul>
<h5 id="lt-x3D-小于等于"><a href="#lt-x3D-小于等于" class="headerlink" title="&lt;&#x3D;小于等于"></a>&lt;&#x3D;小于等于</h5><hr>
<ul>
<li>类似大于等于</li>
</ul>
<h5 id="gt-大于"><a href="#gt-大于" class="headerlink" title="&gt; 大于"></a>&gt; 大于</h5><hr>
<ul>
<li>类似大于等于</li>
</ul>
<h5 id="lt-小于"><a href="#lt-小于" class="headerlink" title="&lt; 小于"></a>&lt; 小于</h5><hr>
<ul>
<li>类似大于等于</li>
</ul>
<h4 id="数据集操作"><a href="#数据集操作" class="headerlink" title="数据集操作"></a>数据集操作</h4><hr>
<h5 id="and"><a href="#and" class="headerlink" title="and"></a>and</h5><hr>
<ul>
<li>对多个指标的数据集进行标签判断，获取两个指标集具有共同的标签的值node_cpu_seconds_total and node_cpu_guest_seconds_total，类似sql select * from node_cpu_seconds_total a,node_cpu_guest_seconds_total b where a.cpu &#x3D; b.cpu and a.instance &#x3D; b.instance and a.job&#x3D;b.job and a.mode &#x3D; b.mode</li>
</ul>
<h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><hr>
<ul>
<li>对多个指标集数据进行展示，如果有标签重复，则仅显示其中一个标签的值。</li>
</ul>
<h5 id="unless"><a href="#unless" class="headerlink" title="unless"></a>unless</h5><hr>
<ul>
<li>对多个指标的数据集进行标签判断，获取两个指标集不具有共同的标签的值，结果集以最左边为准，如node_memory_Active_bytes unless node_cpu_seconds_total和node_cpu_seconds_total unless node_memory_Active_bytes结果是不一样的。</li>
</ul>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><hr>
<p>用于即时向量的函数</p>
<h4 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h4><hr>
<ul>
<li>abs返回即时向量的绝对值</li>
</ul>
<h4 id="absent"><a href="#absent" class="headerlink" title="absent"></a>absent</h4><hr>
<ul>
<li>absent用于检测即时向量中，某个标签是否存在，如果不存在，则value为1，如检查标签为node_arp_entries{instance&#x3D;“localhost:9100”}是否存在有元素，如果存在则返回nodata，如果不存在value则为1</li>
<li>常用于检测指标是否丢失。</li>
</ul>
<h4 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h4><hr>
<ul>
<li>用于将浮点数向上化为最接近的一个整数，如值为0.1，则为向上取整，成为1。</li>
</ul>
<h4 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h4><hr>
<ul>
<li>用于将浮点数向下化为最接近的一个整数，如值为0.1，则为向下取整，成为0。</li>
</ul>
<h4 id="clamp-max"><a href="#clamp-max" class="headerlink" title="clamp_max"></a>clamp_max</h4><hr>
<ul>
<li>该函数需要两个参数，一个是向量，另外一个是封顶值，如果一个向量的值超过该封顶值，该向量的值则为封顶值。</li>
</ul>
<h4 id="clamp-min"><a href="#clamp-min" class="headerlink" title="clamp_min"></a>clamp_min</h4><hr>
<ul>
<li>该函数需要两个参数，一个是向量，另外一个是触底值，如果一个向量的值超过该触底值，该向量的值则为触底值。</li>
</ul>
<p><strong>用于区间向量的函数</strong></p>
<p>区间向量的函数执行完成后，便成为了即时向量。</p>
<h4 id="absent-over-time"><a href="#absent-over-time" class="headerlink" title="absent_over_time"></a>absent_over_time</h4><hr>
<ul>
<li>absent_over_time用于检测在给定的区间向量中，是否存在有元素，如果没有则value为1。</li>
</ul>
<h4 id="changes"><a href="#changes" class="headerlink" title="changes"></a>changes</h4><hr>
<ul>
<li>返回给定的区间向量中，对比于当前值，发生变化的元素的数量。</li>
</ul>
<h4 id="delta"><a href="#delta" class="headerlink" title="delta"></a>delta</h4><hr>
<ul>
<li>返回区间向量中，第一个元素和最后一个元素之间的变化值，时间区间也参与算法计算，所以即时第一个元素和最后一个元素均为整数，该值也未必是整数。</li>
<li>须作用在gauge类型的指标</li>
</ul>
<h4 id="deriv"><a href="#deriv" class="headerlink" title="deriv"></a>deriv</h4><hr>
<ul>
<li>返回区间向量中，满足线性规律的每秒变化值</li>
<li>须作用在gauge类型的指标</li>
</ul>
<h4 id="idelta"><a href="#idelta" class="headerlink" title="idelta"></a>idelta</h4><hr>
<ul>
<li>该函数计算区间向量间，最后两个元素的差值，如果区间内没有两个元素，则返回nodata</li>
<li>须作用在gauge类型的指标</li>
</ul>
<h4 id="irate"><a href="#irate" class="headerlink" title="irate"></a>irate</h4><hr>
<ul>
<li>该函数计算区间向量间，最后两个元素的差值，并且除以区间的秒数，如果区间内没有两个元素，则返回nodata。</li>
</ul>
<h4 id="over-time"><a href="#over-time" class="headerlink" title="_over_time"></a>_over_time</h4><hr>
<ul>
<li>该函数技术按区间向量的最大（max）、最小（min）、平均（avg）、求和（sum）、求总数（）等汇聚值。</li>
</ul>
]]></content>
      <categories>
        <category>运维监控</category>
        <category>Prometheus</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>PromQL</tag>
        <tag>查询</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus 监控 主机存活 监控 blackbox_exporter</title>
    <url>/2021/06/19/prometheus-%E7%9B%91%E6%8E%A7-%E4%B8%BB%E6%9C%BA%E5%AD%98%E6%B4%BB-%E7%9B%91%E6%8E%A7-blackbox-exporter/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-44.png"></p>
<p>blackbox_exporter是Prometheus 官方提供的 exporter 之一，可以提供 http、dns、tcp、icmp 的监控数据采集。</p>
<h2 id="blackbox-exporter-应用场景"><a href="#blackbox-exporter-应用场景" class="headerlink" title="blackbox_exporter 应用场景"></a>blackbox_exporter 应用场景</h2><ol>
<li>ICMP 测试<br>主机探活机制</li>
<li>HTTP 测试<br>定义 Request Header 信息<br>判断 Http status &#x2F; Http Respones Header &#x2F; Http Body 内容</li>
<li>TCP 测试<br>业务组件端口状态监听<br>应用层协议定义与监听</li>
<li>POST 测试<br>接口联通性</li>
<li>SSL 证书过期时间</li>
<li>自定义测试（扩展）</li>
</ol>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>各个版本的blackbox_exporter <a href="https://github.com/prometheus/blackbox/_exporter/releases">https://github.com/prometheus/blackbox\_exporter/releases</a></p>
<p>$ tar -xvf blackbox_exporter-0.19.0.linux-amd64.tar.gz<br>$ cd blackbox_exporter-0.19.0.linux-amd64<br>$ .&#x2F;blackbox_exporter –version<br>blackbox_exporter, version 0.19.0 (branch: HEAD, revision: 5d575b88eb12c65720862e8ad2c5890ba33d1ed0)<br>  build user:       root@2b0258d5a55a<br>  build date:       20210510-12:56:44<br>  go version:       go1.16.4<br>  platform:         linux&#x2F;amd64</p>
<h2 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h2><p>cat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;blackbox_exporter.service<br>[Unit]<br>Description&#x3D;blackbox_exporter<br>After&#x3D;network.target</p>
<p>[Service]<br>User&#x3D;root<br>Type&#x3D;simple<br>ExecStart&#x3D;&#x2F;data&#x2F;blackbox_exporter-0.19.0.linux-amd64&#x2F;blackbox_exporter –config.file&#x3D;&#x2F;data&#x2F;blackbox_exporter-0.19.0.linux-amd64&#x2F;blackbox.yml<br>Restart&#x3D;on-failure</p>
<p>[Install]<br>WantedBy&#x3D;multi-user.target</p>
<h2 id="blackbox-exporter-配置文件"><a href="#blackbox-exporter-配置文件" class="headerlink" title="blackbox_exporter 配置文件"></a>blackbox_exporter 配置文件</h2><p>配置文件默认就可以，如果有特殊需求，再按需修改</p>
<p>cat blackbox.yml<br>modules:<br>  http_2xx:<br>    prober: http<br>  http_post_2xx:<br>    prober: http<br>    http:<br>      method: POST<br>  tcp_connect:<br>    prober: tcp<br>  pop3s_banner:<br>    prober: tcp<br>    tcp:<br>      query_response:<br>      - expect: “^+OK”<br>      tls: true<br>      tls_config:<br>        insecure_skip_verify: false<br>  ssh_banner:<br>    prober: tcp<br>    tcp:<br>      query_response:<br>      - expect: “^SSH-2.0-“<br>      - send: “SSH-2.0-blackbox-ssh-check”<br>  irc_banner:<br>    prober: tcp<br>    tcp:<br>      query_response:<br>      - send: “NICK prober”<br>      - send: “USER prober prober prober :prober”<br>      - expect: “PING :([^ ]+)”<br>        send: “PONG ${1}”<br>      - expect: “^:[^ ]+ 001”<br>  icmp:<br>    prober: icmp</p>
<h2 id="启动blackbox-exporter"><a href="#启动blackbox-exporter" class="headerlink" title="启动blackbox_exporter"></a>启动blackbox_exporter</h2><p>[root@NEWCWS-AS03 data]# systemctl start blackbox_exporter.service<br>[root@NEWCWS-AS03 data]# systemctl status blackbox_exporter.service<br>● blackbox_exporter.service - blackbox_exporter<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;blackbox_exporter.service; disabled; vendor preset: disabled)<br>   Active: active (running) since 四 2021-06-17 17:06:17 CST; 10s ago<br> Main PID: 35945 (blackbox_export)<br>    Tasks: 9<br>   Memory: 4.1M<br>   CGroup: &#x2F;system.slice&#x2F;blackbox_exporter.service<br>           └─35945 &#x2F;data&#x2F;blackbox_exporter-0.19.0.linux-amd64&#x2F;blackbox_exporter –config.file&#x3D;&#x2F;data&#x2F;blackbox_exporter-0.19.0.linux-amd64&#x2F;blackbox.yml</p>
<p>6月 17 17:06:17 NEWCWS-AS03 systemd[1]: Started blackbox_exporter.<br>6月 17 17:06:17 NEWCWS-AS03 blackbox_exporter[35945]: level&#x3D;info ts&#x3D;2021-06-17T09:06:17.475Z caller&#x3D;main.go:224 msg&#x3D;”Starting blackbox_exporter” version&#x3D;”(version&#x3D;0.19.0, branch&#x3D;HEAD, revision&#x3D;…90ba33d1ed0)”<br>6月 17 17:06:17 NEWCWS-AS03 blackbox_exporter[35945]: level&#x3D;info ts&#x3D;2021-06-17T09:06:17.475Z caller&#x3D;main.go:225 build_context&#x3D;”(go&#x3D;go1.16.4, user&#x3D;root@2b0258d5a55a, date&#x3D;20210510-12:56:44)”<br>6月 17 17:06:17 NEWCWS-AS03 blackbox_exporter[35945]: level&#x3D;info ts&#x3D;2021-06-17T09:06:17.476Z caller&#x3D;main.go:237 msg&#x3D;”Loaded config file”<br>6月 17 17:06:17 NEWCWS-AS03 blackbox_exporter[35945]: level&#x3D;info ts&#x3D;2021-06-17T09:06:17.476Z caller&#x3D;main.go:385 msg&#x3D;”Listening on address” address&#x3D;:9115<br>6月 17 17:06:17 NEWCWS-AS03 blackbox_exporter[35945]: level&#x3D;info ts&#x3D;2021-06-17T09:06:17.476Z caller&#x3D;tls_config.go:191 msg&#x3D;”TLS is disabled.” http2&#x3D;false<br>Hint: Some lines were ellipsized, use -l to show in full.</p>
<h2 id="在Prometheus上添加blackbox-exporter的配置"><a href="#在Prometheus上添加blackbox-exporter的配置" class="headerlink" title="在Prometheus上添加blackbox_exporter的配置"></a>在Prometheus上添加blackbox_exporter的配置</h2><ul>
<li>job_name: ‘主机网络监测’<br>metrics_path: &#x2F;probe<br>params:<br>  module: [icmp] #对应blackbox_exporter.yml的配置<br>file_sd_configs:<ul>
<li>refresh_interval: 10s<br>files:<ul>
<li>“&#x2F;data&#x2F;prometheus-2.22.1.linux-amd64&#x2F;conf.d&#x2F;icmp_status.yml”<br>relabel_configs:</li>
<li>source_labels: [__address__]<br>target_label: __param_target</li>
<li>target_label: __address__<br>replacement: 127.0.0.1:9115</li>
<li>source_labels: [__param_target]<br>target_label: instance</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>cat conf.d&#x2F;icmp_status.yml</p>
<ul>
<li>targets: [‘192.168.65.220’,’192.168.65.171’,’1.1.1.1’]<br>labels:<br>  group: ‘group1-网络PING监控’</li>
<li>targets: [‘192.168.80.198’,’192.168.80.199’]<br>labels:<br>  group: ‘group2-网络PING监控’</li>
<li>targets: [‘192.168.80.142’,’192.168.80.143’]<br>labels:<br>  group: ‘group3-网络PING监控’</li>
</ul>
<h2 id="重新加载prometheus配置"><a href="#重新加载prometheus配置" class="headerlink" title="重新加载prometheus配置"></a>重新加载prometheus配置</h2><h3 id="测试配置是否正确"><a href="#测试配置是否正确" class="headerlink" title="测试配置是否正确"></a>测试配置是否正确</h3><p>$.&#x2F;promtool check config prometheus.yml<br>Checking prometheus.yml<br>  SUCCESS: 0 rule files found</p>
<h3 id="重新加载Prometheus配置"><a href="#重新加载Prometheus配置" class="headerlink" title="重新加载Prometheus配置"></a>重新加载Prometheus配置</h3><p>$ curl -X POST <a href="http://127.0.0.1:9090/-/reload">http://127.0.0.1:9090/-/reload</a> (启用了–web.enable-lifecycle选项)</p>
<h2 id="查看加入的监控信息"><a href="#查看加入的监控信息" class="headerlink" title="查看加入的监控信息"></a>查看加入的监控信息</h2><p>访问 <a href="http://127.0.0.1:9090/targets">http://127.0.0.1:9090/targets</a></p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-42-1024x327.png"></p>
<h2 id="Grafana中加入-blackbox-exporter监控数据"><a href="#Grafana中加入-blackbox-exporter监控数据" class="headerlink" title="Grafana中加入 blackbox_exporter监控数据"></a>Grafana中加入 blackbox_exporter监控数据</h2><h3 id="导入blackbox-exporter模板"><a href="#导入blackbox-exporter模板" class="headerlink" title="导入blackbox_exporter模板"></a>导入blackbox_exporter模板</h3><p>此模板为9965号模板，数据源选择Prometheus 模板下载地址<br><a href="https://grafana.com/grafana/dashboards/9965">https://grafana.com/grafana/dashboards/9965</a></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>此模板需要安装饼状图插件 下载地址 <a href="https://grafana.com/grafana/plugins/grafana-piechart-panel">https://grafana.com/grafana/plugins/grafana-piechart-panel</a><br>安装插件，重启grafana生效。</p>
<p>$ grafana-cli plugins install grafana-piechart-panel<br>$ service grafana-server restart</p>
<h3 id="访问Grafana"><a href="#访问Grafana" class="headerlink" title="访问Grafana"></a>访问Grafana</h3><p><img src="https://code404.icu/img/moveypu/2021/06/image-43-1024x496.png"></p>
]]></content>
      <categories>
        <category>运维监控</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>监控</tag>
        <tag>blackbox_exporter</tag>
        <tag>主机存活</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus 监控 服务是否可用 可用性监控 blackbox_exporte</title>
    <url>/2021/06/20/prometheus-%E7%9B%91%E6%8E%A7-%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8-%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9B%91%E6%8E%A7-blackbox-exporte/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-44.png"></p>
<p>blackbox_exporter是Prometheus 官方提供的 exporter 之一，可以提供 http、dns、tcp、icmp 的监控数据采集。</p>
<h2 id="blackbox-exporter-应用场景"><a href="#blackbox-exporter-应用场景" class="headerlink" title="blackbox_exporter 应用场景"></a>blackbox_exporter 应用场景</h2><ol>
<li>ICMP 测试<br>主机探活机制</li>
<li>HTTP 测试<br>定义 Request Header 信息<br>判断 Http status &#x2F; Http Respones Header &#x2F; Http Body 内容</li>
<li>TCP 测试<br>业务组件端口状态监听<br>应用层协议定义与监听</li>
<li>POST 测试<br>接口联通性</li>
<li>SSL 证书过期时间</li>
<li>自定义测试（扩展）</li>
</ol>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>不说了，安装请看另外一篇：<a href="https://www.code404.icu/797.html">prometheus 监控 主机存活 监控 blackbox_exporter</a></p>
<h2 id="在Prometheus上添加blackbox-exporter的配置"><a href="#在Prometheus上添加blackbox-exporter的配置" class="headerlink" title="在Prometheus上添加blackbox_exporter的配置"></a>在Prometheus上添加blackbox_exporter的配置</h2><ul>
<li>job_name: 服务可用性监测<br>metrics_path: &#x2F;probe<br>params:<br>  module: [http_2xx]<br>file_sd_configs:<ul>
<li>refresh_interval: 10s<br>files:<ul>
<li>“&#x2F;data&#x2F;prometheus-2.22.1.linux-amd64&#x2F;conf.d&#x2F;http_status.yml”<br>relabel_configs:</li>
<li>source_labels: [__address__]<br>target_label: __param_target</li>
<li>target_label: __address__<br>replacement: 127.0.0.1:9115</li>
<li>source_labels: [__param_target]<br>target_label: instance</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="添加配置文件-conf-d-x2F-http-status-yml"><a href="#添加配置文件-conf-d-x2F-http-status-yml" class="headerlink" title="添加配置文件 conf.d&#x2F;http_status.yml"></a>添加配置文件 conf.d&#x2F;http_status.yml</h2><p>cat conf.d&#x2F;http_status.yml </p>
<ul>
<li>targets: [‘<a href="http://192.168.80.176:8061/carsoa-assembly/actuator/info&#39;,&#39;http://192.168.80.176:8005/carsoa-auth/actuator/info&#39;,&#39;http://192.168.80.176:8066/carsoa-bpm/actuator/info&#39;\]">http://192.168.80.176:8061/carsoa-assembly/actuator/info&#39;,&#39;http://192.168.80.176:8005/carsoa-auth/actuator/info&#39;,&#39;http://192.168.80.176:8066/carsoa-bpm/actuator/info&#39;\]</a><br>labels:<br>  group: ‘bjj’</li>
</ul>
<h2 id="重新加载prometheus配置"><a href="#重新加载prometheus配置" class="headerlink" title="重新加载prometheus配置"></a>重新加载prometheus配置</h2><h3 id="测试配置是否正确"><a href="#测试配置是否正确" class="headerlink" title="测试配置是否正确"></a>测试配置是否正确</h3><p>$.&#x2F;promtool check config prometheus.yml<br>Checking prometheus.yml<br>  SUCCESS: 0 rule files found</p>
<h3 id="重新加载Prometheus配置"><a href="#重新加载Prometheus配置" class="headerlink" title="重新加载Prometheus配置"></a>重新加载Prometheus配置</h3><p>$ curl -X POST <a href="http://127.0.0.1:9090/-/reload">http://127.0.0.1:9090/-/reload</a> (启用了–web.enable-lifecycle选项)</p>
<h2 id="查看加入的监控信息"><a href="#查看加入的监控信息" class="headerlink" title="查看加入的监控信息"></a>查看加入的监控信息</h2><p>访问 <a href="http://127.0.0.1:9090/targets">http://127.0.0.1:9090/targets</a></p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-45-1024x253.png"></p>
<h2 id="Grafana中加入-blackbox-exporter监控数据"><a href="#Grafana中加入-blackbox-exporter监控数据" class="headerlink" title="Grafana中加入 blackbox_exporter监控数据"></a>Grafana中加入 blackbox_exporter监控数据</h2><h3 id="导入blackbox-exporter模板"><a href="#导入blackbox-exporter模板" class="headerlink" title="导入blackbox_exporter模板"></a>导入blackbox_exporter模板</h3><p>此模板为9965号模板，数据源选择Prometheus 模板下载地址<br><a href="https://grafana.com/grafana/dashboards/9965">https://grafana.com/grafana/dashboards/9965</a></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>此模板需要安装饼状图插件 下载地址 <a href="https://grafana.com/grafana/plugins/grafana-piechart-panel">https://grafana.com/grafana/plugins/grafana-piechart-panel</a><br>安装插件，重启grafana生效。</p>
<p>$ grafana-cli plugins install grafana-piechart-panel<br>$ service grafana-server restart</p>
<h3 id="访问Grafana"><a href="#访问Grafana" class="headerlink" title="访问Grafana"></a>访问Grafana</h3><p><img src="https://code404.icu/img/moveypu/2021/06/image-46-1024x420.png"></p>
]]></content>
      <categories>
        <category>运维监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>blackbox_exporter</tag>
        <tag>可用性</tag>
        <tag>监控服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Python OTP实现多因子认证Google Authenticator及生成二维码</title>
    <url>/2021/09/17/python-otp%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81google-authenticator%E5%8F%8A%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-14.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>双因子认证（Two-factor authentication，也叫2FA），是一种通过组合两种不同的验证方式进行用户身份验证的机制。Google在2011年3月份，宣布在线上使用双因子认证，MSN和Yahoo紧随其后。</p>
<p>OTP 是 One-Time Password的简写，表示一次性密码。分为以下两种</p>
<p>HOTP 是HMAC-based One-Time Password的简写，表示基于HMAC算法加密的一次性密码。</p>
<p>HOTP 是事件同步，通过某一特定的事件次序及相同的种子值作为输入，通过HASH算法运算出一致的密码。RFC4226。</p>
<p>TOTP 是Time-based One-Time Password的简写，表示基于时间戳算法的一次性密码。</p>
<p>TOTP 是时间同步，基于客户端的动态口令和动态口令验证服务器的时间比对，一般每60秒产生一个新口令，要求客户端和服务器能够十分精确的保持正确的时钟，客户端和服务端基于时间计算的动态口令才能一致。　RFC6238。</p>
<p>双因子认证，除了需要验证用户名密码外，还要结合另外一种实物设备，如Rsa令牌，或者手机。<br>双因子认证的产品大致可以分成两类：</p>
<ul>
<li>可以产生token的硬件设备</li>
<li>智能手机的app</li>
</ul>
<p>手机短信验证码，登录微信公众号时的扫码确认都可以称为双因子认证。本文只介绍OTP一次性密码，也经常被称为token。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/a09343a68cd742fd9683dcb195b1222c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>动态密码的产生方式，主要是以时间差做为服务器与密码产生器的同步条件。在需要登录的时候，就利用密码产生器产生动态密码，OTP一般分为计次使用以及计时使用两种，计次使用的OTP产出后，可在不限时间内使用；计时使用的OTP则可设置密码有效时间，从30秒到两分钟不等，而OTP在进行认证之后即废弃不用，下次认证必须使用新的密码，增加了试图不经授权访问有限制资源的难度。</p>
<h3 id="使用Python实现OTP功能"><a href="#使用Python实现OTP功能" class="headerlink" title="使用Python实现OTP功能"></a>使用Python实现OTP功能</h3><hr>
<p>目前Python上有以下两大模块比较流行，以第一个pyotp为例介绍比较常用的TOTP</p>
<p>pyotp就是一个python模块，可以直接使用pip安装</p>
<p>pip install pyotp</p>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><hr>
<p>import base64<br>string&#x3D;’<a href="http://www.code404.icu&/#39;">www.code404.icu&#39;</a><br>secretKey &#x3D; base64.b32encode(string.encode(encoding&#x3D;”utf-8”))<br>print(secretKey)<br>b’O53XOLTDN5SGKNBQGQ&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;’</p>
<h3 id="生成口令"><a href="#生成口令" class="headerlink" title="生成口令"></a>生成口令</h3><hr>
<p>import pyotp<br>totp&#x3D;pyotp.TOTP(secretKey)<br>print(totp.now())<br>857020</p>
<h3 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h3><hr>
<p>使用 python 模块 qrcode</p>
<p>pip install qrcode</p>
<p>url&#x3D;pyotp.totp.TOTP(secretKey).provisioning_uri(“<a href="mailto:&#x6c;&#105;&#x68;&#x65;&#64;&#99;&#111;&#100;&#101;&#52;&#48;&#52;&#x2e;&#x69;&#99;&#117;">&#x6c;&#105;&#x68;&#x65;&#64;&#99;&#111;&#100;&#101;&#52;&#48;&#52;&#x2e;&#x69;&#99;&#117;</a>“,issuer_name&#x3D;’码404’)<br>img&#x3D;qrcode.make(url)<br>print(url)<br>with open(‘code404_qrcode.png’,’wb’) as f:<br>    img.save(f)</p>
<p>绑定手机APP Google身份验证器<br>使用APP扫 刚才生成的二维码<br><img src="https://img-blog.csdnimg.cn/60dd5fb1030f4ee28925cd09eaae461c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="验证口令"><a href="#验证口令" class="headerlink" title="验证口令"></a>验证口令</h3><hr>
<p>import base64<br>import pyotp<br>string&#x3D;’<a href="http://www.code404&/#39;">www.code404&#39;</a><br>secretKey&#x3D;base64.b32encode(string.encode(encoding&#x3D;’utf-8’))<br>print(secretKey)<br>totp&#x3D;pyotp.TOTP(secretKey)<br>print(totp.verify(276269))<br>True</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Google Authenticator</tag>
        <tag>OTP</tag>
        <tag>pyotp</tag>
        <tag>TOTP</tag>
        <tag>实现多因子认证</tag>
        <tag>生成二维码</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_pip使用手册_安装软件包_查询</title>
    <url>/2021/10/22/python-pip%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85-%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-18.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>所有的 Python 开发者都清楚，Python 之所以如此受欢迎，能够在众多高级语言中，脱颖而出，除了语法简单，上手容易之外，更多还要归功于 Python 生态的完备，有数以万计的 Python 爱好者愿意以 Python 为基础封装出各种有利于开发的第三方工具包。</p>
<p>这才使用我们能够以最快的速度开发出一个满足基本需要的项目，而不是每次都重复造轮子。</p>
<p>Python 从 1991 年诞生到现在，已经过去 28 个年头了，这其间产生了数以万计的第三方包，且每个包都会不断更新，会有越来越多的版本。</p>
<p>当你在一个复杂的项目环境中，如果没有一个有效的依赖包管理方案，项目的维护将会是一个大问题。</p>
<p>pip 是官方推荐的包管理工具，在大多数开发者眼里，pip 几乎是 Python 的标配。</p>
<p>说到 pip ，大家都不会陌生。但我相信不少人，只是熟悉几个常用的用法，而对于其他几个低频且实用的用法，却知之甚少，这两天，我查阅官方文档，把这些用法整理了一下，应该是网络上比较全的介绍。</p>
<h3 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h3><hr>
<p>查询当前环境安装的所有软件包</p>
<p>$ pip list</p>
<p>查询 pypi 上含有某名字的包</p>
<p>$ pip search pkg</p>
<p>查询当前环境中可升级的包</p>
<p>$ pip list –outdated</p>
<p>查询一个包的详细内容</p>
<p>$ pip show pkg</p>
<h3 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h3><hr>
<p>在不安装软件包的情况下下载软件包到本地</p>
<p>$ pip download –destination-directory &#x2F;local&#x2F;wheels -r requirements.txt</p>
<p>下载完，总归是要安装的，可以指定这个目录中安装软件包，而不从 pypi 上安装。</p>
<p>$ pip install –no-index –find-links&#x3D;&#x2F;local&#x2F;wheels -r requirements.txt</p>
<p>当然你也从你下载的包中，自己构建生成 wheel 文件</p>
<p>$ pip install wheel<br>$ pip wheel –wheel-dir&#x3D;&#x2F;local&#x2F;wheels -r requirements.txt</p>
<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><hr>
<p>使用 pip install 可以很方便地从 pypi 上搜索下载并安装 python 包。</p>
<p>如下所示</p>
<p>$ pip install requests</p>
<p>这是安装包的基本格式，我们也可以为其添加更多参数来实现不同的效果。</p>
<h4 id="1-只从本地安装，而不从-pypi-安装"><a href="#1-只从本地安装，而不从-pypi-安装" class="headerlink" title="1.只从本地安装，而不从 pypi 安装"></a>1.只从本地安装，而不从 pypi 安装</h4><hr>
<p># 前提你得保证你已经下载 pkg 包到 &#x2F;local&#x2F;wheels 目录下<br>$ pip install –no-index –find-links&#x3D;&#x2F;local&#x2F;wheels pkg</p>
<h4 id="2-限定版本进行软件包安装"><a href="#2-限定版本进行软件包安装" class="headerlink" title="2.限定版本进行软件包安装"></a>2.限定版本进行软件包安装</h4><hr>
<p>以下三种，对单个 python 包的版本进行了约束</p>
<p># 所安装的包的版本为 2.1.2<br>$ pip install pkg&#x3D;&#x3D;2.1.2</p>
<h1 id="所安装的包必须大于等于-2-1-2"><a href="#所安装的包必须大于等于-2-1-2" class="headerlink" title="所安装的包必须大于等于 2.1.2"></a>所安装的包必须大于等于 2.1.2</h1><p>$ pip install pkg&gt;&#x3D;2.1.2</p>
<h1 id="所安装的包必须小于等于-2-1-2"><a href="#所安装的包必须小于等于-2-1-2" class="headerlink" title="所安装的包必须小于等于 2.1.2"></a>所安装的包必须小于等于 2.1.2</h1><p>$ pip install pkg&lt;&#x3D;2.1.2</p>
<p>以下命令用于管理&#x2F;控制整个 python 环境的包版本</p>
<p># 导出依赖包列表<br>pip freeze &gt;requirements.txt</p>
<h1 id="从依赖包列表中安装"><a href="#从依赖包列表中安装" class="headerlink" title="从依赖包列表中安装"></a>从依赖包列表中安装</h1><p>pip install -r requirements.txt</p>
<h1 id="确保当前环境软件包的版本-并不确保安装"><a href="#确保当前环境软件包的版本-并不确保安装" class="headerlink" title="确保当前环境软件包的版本(并不确保安装)"></a>确保当前环境软件包的版本(并不确保安装)</h1><p>pip install -c constraints.txt</p>
<h4 id="3-限制不使用二进制包安装"><a href="#3-限制不使用二进制包安装" class="headerlink" title="3.限制不使用二进制包安装"></a>3.限制不使用二进制包安装</h4><hr>
<p>由于默认情况下，wheel 包的平台是运行 pip download 命令 的平台，所以可能出现平台不适配的情况。</p>
<p>比如在 MacOS 系统下得到的 pymongo-2.8-cp27-none-macosx_10_10_intel.whl 就不能在 linux_x86_64 安装。</p>
<p>使用下面这条命令下载的是 tar.gz 的包，可以直接使用 pip install 安装。</p>
<p>比 wheel 包，这种包在安装时会进行编译，所以花费的时间会长一些。</p>
<p># 下载非二进制的包<br>$ pip download –no-binary&#x3D;:all: pkg</p>
<h1 id="安装非二进制的包"><a href="#安装非二进制的包" class="headerlink" title="安装非二进制的包"></a>安装非二进制的包</h1><p>$ pip install pkg –no-binary</p>
<h4 id="4-指定代理服务器安装"><a href="#4-指定代理服务器安装" class="headerlink" title="4.指定代理服务器安装"></a>4.指定代理服务器安装</h4><hr>
<p>当你身处在一个内网环境中时，无法直接连接公网。这时候你使用pip install 安装包，就会失败。</p>
<p>面对这种情况，可以有两种方法：</p>
<ol>
<li>下载离线包拷贝到内网机器中安装</li>
<li>使用代理服务器转发请求</li>
</ol>
<p>第一种方法，虽说可行，但有相当多的弊端</p>
<ul>
<li>步骤繁杂，耗时耗力</li>
<li>无法处理包的依赖问题</li>
</ul>
<p>这里重点来介绍，第二种方法：</p>
<p>$ pip install –proxy [user:passwd@]http_server_ip:port pkg</p>
<p>每次安装包就发输入长长的参数，未免有些麻烦，为此你可以将其写入配置文件中：$HOME&#x2F;.config&#x2F;pip&#x2F;pip.conf</p>
<p>对于这个路径，说明几点</p>
<ul>
<li>不同的操作系统，路径各不相同</li>
</ul>
<p># Linux&#x2F;Unix:<br>&#x2F;etc&#x2F;pip.conf<br>~&#x2F;.pip&#x2F;pip.conf<br>~&#x2F;.config&#x2F;pip&#x2F;pip.conf</p>
<h1 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX:"></a>Mac OSX:</h1><p>~&#x2F;Library&#x2F;Application Support&#x2F;pip&#x2F;pip.conf<br>~&#x2F;.pip&#x2F;pip.conf<br>&#x2F;Library&#x2F;Application Support&#x2F;pip&#x2F;pip.conf</p>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows:"></a>Windows:</h1><p>%APPDATA%\pip\pip.ini<br>%HOME%\pip\pip.ini<br>C:\Documents and Settings\All Users\Application Data\PyPA\pip\pip.conf (Windows XP)<br>C:\ProgramData\PyPA\pip\pip.conf (Windows 7 及以后) </p>
<ul>
<li>若在你的机子上没有此文件，则自行创建即可<br>如何配置，这边给个样例：</li>
</ul>
<p>[global]<br>index-url &#x3D; <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a> </p>
<h1 id="替换出自己的代理地址，格式为-user-passwd-proxy-server-port"><a href="#替换出自己的代理地址，格式为-user-passwd-proxy-server-port" class="headerlink" title="替换出自己的代理地址，格式为[user:passwd@]proxy.server:port"></a>替换出自己的代理地址，格式为[user:passwd@]proxy.server:port</h1><p>proxy&#x3D;<a href="http://xxx.xxx.xxx.xxx:8080/">http://xxx.xxx.xxx.xxx:8080</a> </p>
<p>[install]</p>
<h1 id="信任阿里云的镜像源，否则会有警告"><a href="#信任阿里云的镜像源，否则会有警告" class="headerlink" title="信任阿里云的镜像源，否则会有警告"></a>信任阿里云的镜像源，否则会有警告</h1><p>trusted-host&#x3D;mirrors.aliyun.com </p>
<h4 id="5-安装用户私有软件包"><a href="#5-安装用户私有软件包" class="headerlink" title="5.安装用户私有软件包"></a>5.安装用户私有软件包</h4><hr>
<p>很多人可能还不清楚，python 的安装包是可以用户隔离的。</p>
<p>如果你拥有管理员权限，你可以将包安装在全局环境中。在全局环境中的这个包可被该机器上的所有拥有管理员权限的用户使用。</p>
<p>如果一台机器上的使用者不只一样，自私地将在全局环境中安装或者升级某个包，是不负责任且危险的做法。</p>
<p>面对这种情况，我们就想能否安装单独为我所用的包呢？</p>
<p>庆幸的是，还真有。</p>
<p>我能想到的有两种方法：</p>
<ol>
<li>使用虚拟环境</li>
<li>将包安装在用户的环境中</li>
</ol>
<p>今天的重点是第二种方法，教你如何安装用户私有的包？</p>
<p>命令也很简单，只要加上 –user 参数，pip 就会将其安装在当前用户的 ~&#x2F;.local&#x2F;lib&#x2F;python3.x&#x2F;site-packages 下，而其他用户的 python 则不会受影响。</p>
<p>pip install –user pkg</p>
<p>来举个例子</p>
<p># 在全局环境中未安装 requests<br>[root@localhost ~]# pip list  grep requests<br>[root@localhost ~]# su - wangbm<br>[root@localhost ~]# </p>
<h1 id="由于用户环境继承自全局环境，这里也未安装"><a href="#由于用户环境继承自全局环境，这里也未安装" class="headerlink" title="由于用户环境继承自全局环境，这里也未安装"></a>由于用户环境继承自全局环境，这里也未安装</h1><p>[wangbm@localhost ~]# pip list  grep requests<br>[wangbm@localhost ~]# pip install –user requests<br>[wangbm@localhost ~]# pip list  grep requests<br>requests (2.22.0)<br>[wangbm@localhost ~]# </p>
<h1 id="从-Location-属性可发现-requests-只安装在当前用户环境中"><a href="#从-Location-属性可发现-requests-只安装在当前用户环境中" class="headerlink" title="从 Location 属性可发现 requests 只安装在当前用户环境中"></a>从 Location 属性可发现 requests 只安装在当前用户环境中</h1><h2 id="wangbm-ws-compute01-pip-show-requests"><a href="#wangbm-ws-compute01-pip-show-requests" class="headerlink" title="[wangbm@ws_compute01 ~]$ pip show requests"></a>[wangbm@ws_compute01 ~]$ pip show requests</h2><p>Metadata-Version: 2.1<br>Name: requests<br>Version: 2.22.0<br>Summary: Python HTTP for Humans.<br>Home-page: <a href="http://python-requests.org/">http://python-requests.org</a><br>Author: Kenneth Reitz<br>Author-email: <a href="mailto:&#x6d;&#101;&#x40;&#x6b;&#101;&#x6e;&#x6e;&#x65;&#116;&#104;&#114;&#101;&#x69;&#x74;&#122;&#46;&#x6f;&#114;&#103;">&#x6d;&#101;&#x40;&#x6b;&#101;&#x6e;&#x6e;&#x65;&#116;&#104;&#114;&#101;&#x69;&#x74;&#122;&#46;&#x6f;&#114;&#103;</a><br>Installer: pip<br>License: Apache 2.0<br>Location: &#x2F;home&#x2F;wangbm&#x2F;.local&#x2F;lib&#x2F;python2.7&#x2F;site-packages<br>[wangbm@localhost ~]$ exit<br>logout</p>
<h1 id="退出-wangbm-用户，在-root-用户环境中发现-requests-未安装"><a href="#退出-wangbm-用户，在-root-用户环境中发现-requests-未安装" class="headerlink" title="退出 wangbm 用户，在 root 用户环境中发现 requests 未安装"></a>退出 wangbm 用户，在 root 用户环境中发现 requests 未安装</h1><p>[root@localhost ~]$ pip list  grep requests<br>[root@localhost ~]$ </p>
<p>当你身处个人用户环境中，python 导包时会先检索当前用户环境中是否已安装这个包，已安装则优先使用，未安装则使用全局环境中的包。</p>
<p>验证如下：</p>
<p>&gt;&gt;&gt; import sys</p>
<blockquote>
<blockquote>
<blockquote>
<p>from pprint import pprint<br>pprint(sys.path)<br>[‘’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python27.zip’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;plat-linux2’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;lib-tk’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;lib-old’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;lib-dynload’,<br> ‘&#x2F;home&#x2F;wangbm&#x2F;.local&#x2F;lib&#x2F;python2.7&#x2F;site-packages’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;site-packages’,<br> ‘&#x2F;usr&#x2F;lib64&#x2F;python2.7&#x2F;site-packages&#x2F;gtk-2.0’,<br> ‘&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages’,<br> ‘&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;pip-18.1-py2.7.egg’,<br> ‘&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;lockfile-0.12.2-py2.7.egg’]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="6-延长超时时间"><a href="#6-延长超时时间" class="headerlink" title="6.延长超时时间"></a>6.延长超时时间</h4><hr>
<p>若网络情况不是很好，在安装某些包时经常会因为 ReadTimeout 而失败。</p>
<p>对于这种情况，一般重试几次就好了。</p>
<p>但是这样难免有些麻烦，有没有更好的解决方法呢？</p>
<p>有的，可以通过延长超时时间。</p>
<p>$ pip install –default-timeout&#x3D;100 <packages></p>
<h3 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h3><hr>
<p>就一条命令，不再赘述</p>
<p>$ pip uninstall pkg</p>
<p>升级软件包<br>想要对现有的 python 进行升级，其本质上也是先从 pypi 上下载最新版本的包，再对其进行安装。所以升级也是使用 pip install，只不过要加一个参数 –upgrade。</p>
<p>$ pip install –upgrade pkg</p>
<p>在升级的时候，其实还有一个不怎么用到的选项 –upgrade-strategy，它是用来指定升级策略。</p>
<p>它的可选项只有两个：</p>
<ul>
<li>eager ：升级全部依赖包</li>
<li>only-if-need：只有当旧版本不能适配新的父依赖包时，才会升级。</li>
</ul>
<p>在 pip 10.0 版本之后，这个选项的默认值是 only-if-need，因此如下两种写法是一互致的。</p>
<p>pip install –upgrade pkg1<br>pip install –upgrade pkg1 –upgrade-strategy only-if-need</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><hr>
<p>由于在使用 pip 安装一些包时，默认会使用 pip 的官方源，所以经常会报网络超时失败。</p>
<p>常用的解决办法是，在安装包时，使用 -i 参数指定一个国内的镜像源。但是每次指定就很麻烦呀，还要打超长的一串字母。</p>
<p>这时候，其实可以将这个源写进 pip 的配置文件里。以后安装的时候，就默认从你配置的这个 源里安装了。</p>
<p>那怎么配置呢？文件文件在哪？</p>
<p>使用win+r 输入 %APPDATA% 进入用户资料文件夹，查看有没有一个 pip 的文件夹，若没有则创建之。</p>
<p>然后进入这个 文件夹，新建一个 pip.ini 的文件，内容如下</p>
<p>[global]<br>time-out&#x3D;60<br>index-url&#x3D;<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>[install]<br>trusted-host&#x3D;tsinghua.edu.cn</p>
<p>以上几乎包含了 pip 的所有使用场景，也许有不少用法你还没有用过，不过没关系，你只要收藏本文，等到要用的时候再来查阅即可。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>python url转码Python3中的urlencode和urldecode AttributeError: module urllib has no attribute parse</title>
    <url>/2021/04/12/python-url%E8%BD%AC%E7%A0%81python3%E4%B8%AD%E7%9A%84urlencode%E5%92%8Curldecode-attributeerror-module-urllib-has-no-attribute-parse/</url>
    <content><![CDATA[<p>Python3中的urlencode和urldecode</p>
<p>AttributeError: module ‘urllib’ has no attribute ‘parse’</p>
<p>代码目的是将“python url转码” 转换为urlcode</p>
<p>(venv) leenhem@DESKTOP-0ACGT17:~$ python<br>Python 3.8.5 (default, Jul 28 2020, 12:59:40)<br>[GCC 9.3.0] on linux<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import urllib<br>uri&#x3D;’<a href="https://www.baidu.com/s?ct=2097152&amp;si=www.code404.icu&amp;wd=&#39;">https://www.baidu.com/s?ct=2097152&amp;si=www.code404.icu&amp;wd=&#39;</a><br>keywords&#x3D;’python url转码’<br>encode_keywords&#x3D;urllib.parse.quote_plus(keywords)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>AttributeError: module ‘urllib’ has no attribute ‘parse’<br>报错： Traceback (most recent call last): File “<stdin>“, line 1, in <module> AttributeError: module ‘urllib’ has no attribute ‘parse’</p>
</blockquote>
</blockquote>
</blockquote>
<p>意思就是找不到parse类</p>
<p>解决方法：引入方式不对<br>正确引入方式：import urllib.parse</p>
<p>(venv) leenhem@DESKTOP-0ACGT17:~$ python<br>Python 3.8.5 (default, Jul 28 2020, 12:59:40)<br>[GCC 9.3.0] on linux<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import urllib.parse<br>uri&#x3D;’<a href="https://www.baidu.com/s?ct=2097152&amp;si=www.code404.icu&amp;wd=&#39;">https://www.baidu.com/s?ct=2097152&amp;si=www.code404.icu&amp;wd=&#39;</a><br>keywords&#x3D;’python url转码’<br>encode_keywords&#x3D;urllib.parse.quote_plus(keywords)<br>url&#x3D;uri+encode_keywords<br>print(url)<br><a href="https://www.baidu.com/s?ct=2097152&amp;si=www.code404.icu&amp;wd=python+url%E8%BD%AC%E7%A0%81">https://www.baidu.com/s?ct=2097152&amp;si=www.code404.icu&amp;wd=python+url%E8%BD%AC%E7%A0%81</a></p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>已上输出已转码为urlcode，觉得有用就给个赞吧</strong></p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>url</tag>
        <tag>parse</tag>
        <tag>UrlDecode</tag>
        <tag>UrlEncode</tag>
        <tag>urllib</tag>
        <tag>编码</tag>
        <tag>转码</tag>
      </tags>
  </entry>
  <entry>
    <title>python 代码如何打包成可执行文件.exe文件（Pyinstaller）</title>
    <url>/2021/07/06/python-%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6-exe%E6%96%87%E4%BB%B6%EF%BC%88pyinstaller%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-18.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>python写的代码如何打包成.exe可执行程序，让别人电脑上没安装过 python 的小伙伴也可以直接运行？<br>本篇讲如何用PyInstaller库一步步打包python代码。</p>
<h3 id="PyInstaller-环境准备"><a href="#PyInstaller-环境准备" class="headerlink" title="PyInstaller 环境准备"></a>PyInstaller 环境准备</h3><hr>
<p>我的电脑环境：</p>
<ol>
<li>系统ubuntu 20</li>
<li>python 3.6.5</li>
</ol>
<p>使用pip安装PyInstaller</p>
<p>pip install PyInstaller </p>
<p>安装完查看版本号</p>
<p>leenhem@DESKTOP-I6DTQAI:&#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong$ pip show PyInstaller<br>Name: pyinstaller<br>Version: 4.3<br>Summary: PyInstaller bundles a Python application and all its dependencies into a single package.<br>Home-page: <a href="http://www.pyinstaller.org/">http://www.pyinstaller.org/</a><br>Author: Hartmut Goebel, Giovanni Bajo, David Vierra, David Cortesi, Martin Zibricky<br>Author-email: None<br>License: GPLv2-or-later with a special exception which allows to use PyInstaller to build and distribute non-free programs (including commercial ones)<br>Location: &#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages<br>Requires: setuptools, altgraph, pyinstaller-hooks-contrib<br>Required-by: </p>
<h3 id="打包可执行文件"><a href="#打包可执行文件" class="headerlink" title="打包可执行文件"></a>打包可执行文件</h3><hr>
<p>我写了一段简单的 requests 代码code404.py</p>
<p>“””<br>使用requests库获取我的博客首页文章地址<br>cod404_码404 blog:<a href="https://www.code404.icu/">https://www.code404.icu/</a><br>“””<br>import requests<br>import re</p>
<p>r &#x3D; requests.get(“<a href="https://www.code404.icu/&quot;">https://www.code404.icu/&quot;</a>)</p>
<h1 id="匹配首页blog地址"><a href="#匹配首页blog地址" class="headerlink" title="匹配首页blog地址"></a>匹配首页blog地址</h1><p>res &#x3D; re.findall(r’&lt;a class&#x3D;”item-img-inner” href&#x3D;”(.+?)” title&#x3D;’, r.text)<br>for i in res:<br>    print(“blog:”, i)</p>
<p>命令行运行结果</p>
<p>leenhem@DESKTOP-I6DTQAI:&#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong$ python3 code404.py<br>blog: <a href="https://www.code404.icu/901.html">https://www.code404.icu/901.html</a><br>blog: <a href="https://www.code404.icu/898.html">https://www.code404.icu/898.html</a><br>blog: <a href="https://www.code404.icu/886.html">https://www.code404.icu/886.html</a><br>blog: <a href="https://www.code404.icu/876.html">https://www.code404.icu/876.html</a><br>blog: <a href="https://www.code404.icu/871.html">https://www.code404.icu/871.html</a><br>blog: <a href="https://www.code404.icu/862.html">https://www.code404.icu/862.html</a><br>blog: <a href="https://www.code404.icu/851.html">https://www.code404.icu/851.html</a><br>blog: <a href="https://www.code404.icu/849.html">https://www.code404.icu/849.html</a><br>blog: <a href="https://www.code404.icu/844.html">https://www.code404.icu/844.html</a><br>blog: <a href="https://www.code404.icu/838.html">https://www.code404.icu/838.html</a><br>blog: <a href="https://www.code404.icu/835.html">https://www.code404.icu/835.html</a><br>blog: <a href="https://www.code404.icu/830.html">https://www.code404.icu/830.html</a></p>
<p>这段代码依赖第三方库requests，需在python目录Lib\site-packages下找到requests</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-19.png"></p>
<p>找到后整个文件夹全部复制到代码根目录</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-20.png"></p>
<p>cd 到项目跟目录pachong下执行命令</p>
<p>pyinstaller -F yoyoblog.py</p>
<p>执行过程如下</p>
<p>leenhem@DESKTOP-I6DTQAI:&#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong$ pyinstaller -F code404.py<br>124 INFO: PyInstaller: 4.3<br>124 INFO: Python: 3.8.5<br>141 INFO: Platform: Linux-4.4.0-22000-Microsoft-x86_64-with-glibc2.29<br>143 INFO: wrote &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;code404.spec<br>174 INFO: UPX is not available.<br>180 INFO: Extending PYTHONPATH with paths<br>[‘&#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong’, ‘&#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong’]<br>274 INFO: checking Analysis<br>274 INFO: Building Analysis because Analysis-00.toc is non existent<br>275 INFO: Initializing module dependency graph…<br>285 INFO: Caching module graph hooks…<br>336 INFO: Analyzing base_library.zip …<br>3658 INFO: Processing pre-find module path hook distutils from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks&#x2F;pre_find_module_path&#x2F;hook-distutils.py’.<br>3664 INFO: distutils: retargeting to non-venv dir ‘&#x2F;usr&#x2F;lib&#x2F;python3.8’<br>7524 INFO: Caching module dependency graph…<br>7701 INFO: running Analysis Analysis-00.toc<br>8139 INFO: Analyzing &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;code404.py<br>8451 INFO: Processing pre-safe import module hook six.moves from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks&#x2F;pre_safe_import_module&#x2F;hook-six.moves.py’.<br>12641 INFO: Processing module hooks…<br>12641 INFO: Loading module hook ‘hook-certifi.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;_pyinstaller_hooks_contrib&#x2F;hooks&#x2F;stdhooks’…<br>12657 INFO: Loading module hook ‘hook-cryptography.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;_pyinstaller_hooks_contrib&#x2F;hooks&#x2F;stdhooks’…<br>13115 INFO: Loading module hook ‘hook-difflib.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13123 INFO: Loading module hook ‘hook-distutils.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13157 INFO: Loading module hook ‘hook-distutils.util.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13166 INFO: Loading module hook ‘hook-encodings.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13334 INFO: Loading module hook ‘hook-heapq.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13340 INFO: Loading module hook ‘hook-lib2to3.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13400 INFO: Loading module hook ‘hook-multiprocessing.util.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13404 INFO: Loading module hook ‘hook-pickle.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13410 INFO: Loading module hook ‘hook-sysconfig.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13414 INFO: Loading module hook ‘hook-xml.etree.cElementTree.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13421 INFO: Loading module hook ‘hook-xml.py’ from ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks’…<br>13649 INFO: Looking for ctypes DLLs<br>13688 INFO: Analyzing run-time hooks …<br>13696 INFO: Including run-time hook ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;hooks&#x2F;rthooks&#x2F;pyi_rth_multiprocessing.py’<br>13706 INFO: Including run-time hook ‘&#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;_pyinstaller_hooks_contrib&#x2F;hooks&#x2F;rthooks&#x2F;pyi_rth_certifi.py’<br>13727 INFO: Looking for dynamic libraries<br>22824 INFO: Looking for eggs<br>22829 INFO: Python library not in binary dependencies. Doing additional searching…<br>23392 INFO: Using Python library &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libpython3.8.so.1.0<br>23419 INFO: Warnings written to &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;build&#x2F;code404&#x2F;warn-code404.txt<br>23511 INFO: Graph cross-reference written to &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;build&#x2F;code404&#x2F;xref-code404.html<br>23585 INFO: checking PYZ<br>23586 INFO: Building PYZ because PYZ-00.toc is non existent<br>23586 INFO: Building PYZ (ZlibArchive) &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;build&#x2F;code404&#x2F;PYZ-00.pyz<br>24411 INFO: Building PYZ (ZlibArchive) &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;build&#x2F;code404&#x2F;PYZ-00.pyz completed successfully.<br>24429 INFO: checking PKG<br>24429 INFO: Building PKG because PKG-00.toc is non existent<br>24429 INFO: Building PKG (CArchive) PKG-00.pkg<br>27409 INFO: Building PKG (CArchive) PKG-00.pkg completed successfully.<br>27414 INFO: Bootloader &#x2F;home&#x2F;leenhem&#x2F;.local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;PyInstaller&#x2F;bootloader&#x2F;Linux-64bit&#x2F;run<br>27414 INFO: checking EXE<br>27415 INFO: Building EXE because EXE-00.toc is non existent<br>27415 INFO: Building EXE from EXE-00.toc<br>27421 INFO: Appending archive to ELF section in EXE &#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong&#x2F;dist&#x2F;code404<br>27524 INFO: Building EXE from EXE-00.toc completed successfully.</p>
<p>看到successfully 就是成功了</p>
<h3 id="pyinstaller-一些常用参数命令"><a href="#pyinstaller-一些常用参数命令" class="headerlink" title="pyinstaller 一些常用参数命令"></a>pyinstaller 一些常用参数命令</h3><hr>
<ul>
<li>-F 表示生成单个可执行文件</li>
<li>-w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！</li>
<li>-p 表示你自己自定义需要加载的类路径，一般情况下用不到</li>
<li>-i 表示可执行文件的图标</li>
</ul>
<p>更多参数可以通过 <code>pyinstaller -h</code> 查看</p>
<p>执行可执行文件文件<br>打包完成后会在 dist 目录看到一个 code404 文件</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-21.png"></p>
<h3 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h3><hr>
<p>可以在shell窗口执行linux 可执行 文件</p>
<p>leenhem@DESKTOP-I6DTQAI:&#x2F;mnt&#x2F;d&#x2F;workspace&#x2F;code&#x2F;pachong$ .&#x2F;dist&#x2F;code404<br>blog: <a href="https://www.code404.icu/901.html">https://www.code404.icu/901.html</a><br>blog: <a href="https://www.code404.icu/898.html">https://www.code404.icu/898.html</a><br>blog: <a href="https://www.code404.icu/886.html">https://www.code404.icu/886.html</a><br>blog: <a href="https://www.code404.icu/876.html">https://www.code404.icu/876.html</a><br>blog: <a href="https://www.code404.icu/871.html">https://www.code404.icu/871.html</a><br>blog: <a href="https://www.code404.icu/862.html">https://www.code404.icu/862.html</a><br>blog: <a href="https://www.code404.icu/851.html">https://www.code404.icu/851.html</a><br>blog: <a href="https://www.code404.icu/849.html">https://www.code404.icu/849.html</a><br>blog: <a href="https://www.code404.icu/844.html">https://www.code404.icu/844.html</a><br>blog: <a href="https://www.code404.icu/838.html">https://www.code404.icu/838.html</a><br>blog: <a href="https://www.code404.icu/835.html">https://www.code404.icu/835.html</a><br>blog: <a href="https://www.code404.icu/830.html">https://www.code404.icu/830.html</a></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr>
<ol>
<li>Pyinstaller只是将Python解释器和脚本打包成一个可执行文件，不同于编译成真正的机器码。所以代码的运行效率是降低的，只是解决了小白用户的操作难度。</li>
<li>打包时会分析项目的依赖，并将相关的依赖打包进来，并进行加密处理</li>
<li>不同的操作系统，需要在不同的操作系统进行打包。我们这次打包环境是ubuntu，所以打包出来的就是linux下的可执行文件，没有.exe后缀</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>打包</tag>
        <tag>.exe</tag>
        <tag>Pyinstaller</tag>
        <tag>可执行文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 如何字符串格式化使用_format格式化_详解码404</title>
    <url>/2021/08/15/python-%E5%A6%82%E4%BD%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BD%BF%E7%94%A8-format%E6%A0%BC%E5%BC%8F%E5%8C%96-%E8%AF%A6%E8%A7%A3%E7%A0%81404/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-12-1024x640.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>本文中介绍的字符串一个非常重要的知识点：字符串格式化输出。<br>格式化怎么理解？简答来说：就是让字符串按照我们设定的格式来输出，达到我们想要的结果。主要是有4种方式：</p>
<ul>
<li>%：基于占位符的格式化</li>
<li>format()函数的格式化：重点掌握</li>
<li>f-string格式化：重点掌握</li>
<li>字符串模板函数</li>
</ul>
<h4 id="format格式化"><a href="#format格式化" class="headerlink" title="format格式化"></a>format格式化</h4><hr>
<p>从python2.6+开始，新增了一种格式化字符串的函数str.format，可以说极大地增强了字符串格式化的功能，基本语法是通过{}和:来代替占位符%</p>
<ul>
<li>接收多个不限制的参数</li>
<li>位置可以不按照顺序</li>
</ul>
<h4 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h4><hr>
<p><code>&#123;&lt;参数序号&gt;:&lt;格式控制标记&gt;&#125;</code>，中间有一个冒号，不能省略！！！</p>
<p>name &#x3D; “Yule Cottage”  # 字符串类型<br>age &#x3D; 25  # 整数类型<br>height &#x3D; 1.76   # 浮点数类型<br>sex &#x3D; “男”</p>
<h3 id="多个参数连用"><a href="#多个参数连用" class="headerlink" title="多个参数连用"></a>多个参数连用</h3><hr>
<p># 1、不设置位置<br>print(“名字是：{}，年龄是：{}，身高是：{}，性别：{}”.format(name,age,height,sex))<br>名字是：Yule Cottage，年龄是：25，身高是：1.76，性别：男</p>
<h1 id="2、设置位置参数"><a href="#2、设置位置参数" class="headerlink" title="2、设置位置参数"></a>2、设置位置参数</h1><p>print(“名字是：{0}，年龄是：{1}，身高是：{2}，性别：{3}”.format(name,age,height,sex))<br>名字是：Yule Cottage，年龄是：25，身高是：1.76，性别：男</p>
<h1 id="设置位置参数"><a href="#设置位置参数" class="headerlink" title="设置位置参数"></a>设置位置参数</h1><h1 id="索引从0开始；2号位对应的height"><a href="#索引从0开始；2号位对应的height" class="headerlink" title="索引从0开始；2号位对应的height"></a>索引从0开始；2号位对应的height</h1><p>print(“名字是：{0}，身高是：{2}，年龄是：{1}，性别：{3}”.format(name,age,height,sex))<br>名字是：Yule Cottage，身高是：1.76，年龄是：25，性别：男<br>print(“性别：{3}，身高是：{2}，名字是：{0}，年龄是：{1}”.format(name,age,height,sex))<br>性别：男，身高是：1.76，名字是：Yule Cottage，年龄是：25</p>
<h1 id="3、元组形式"><a href="#3、元组形式" class="headerlink" title="3、元组形式"></a>3、元组形式</h1><h1 id="使用-进行解析"><a href="#使用-进行解析" class="headerlink" title="使用*进行解析"></a>使用*进行解析</h1><p>information &#x3D; (“Peter”,25)</p>
<p>print(“姓名是：{}，年龄是：{}”.format(*information))<br>姓名是：Peter，年龄是：25</p>
<h1 id="4、字典形式"><a href="#4、字典形式" class="headerlink" title="4、字典形式"></a>4、字典形式</h1><h1 id="参数为字典时候，通过-进行解析配对"><a href="#参数为字典时候，通过-进行解析配对" class="headerlink" title="参数为字典时候，通过**进行解析配对"></a>参数为字典时候，通过**进行解析配对</h1><p>print(“名字是：{name}，年龄是：{age}，身高是：{height}，性别：{sex}”.format(**{“name”:name,”age”:age,”height”:height,”sex”:sex}))<br>名字是：Yule Cottage，年龄是：25，身高是：1.76，性别：男</p>
<h1 id="5、直接变量赋值"><a href="#5、直接变量赋值" class="headerlink" title="5、直接变量赋值"></a>5、直接变量赋值</h1><p>print(“名字是：{name}，年龄是：{age}，身高是：{height}，性别：{sex}”.format(name&#x3D;”Yule Cottage”,age&#x3D;”2岁”,height&#x3D;”1.75m”,sex&#x3D;”男”))<br>名字是：Yule Cottage，年龄是：2岁，身高是：1.75m，性别：男</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><hr>
<p>宽度为20，我们实现居中、靠左、靠右对齐</p>
<p>name<br>‘Yule Cottage’<br>print(“{:^20s}”.format(name))  # 居中<br>print(“{:&gt;20s}”.format(name))  # 靠右<br>print(“{:&lt;20s}”.format(name))  # 靠左<br>    Yule Cottage<br>        Yule Cottage<br>Yule Cottage</p>
<h3 id="数值多种形式"><a href="#数值多种形式" class="headerlink" title="数值多种形式"></a>数值多种形式</h3><hr>
<p>首先我们还是看看对齐问题，浮点数的对齐只保留6位小数：</p>
<p>pi &#x3D; 3.1415926</p>
<p>print(“{:^20f}”.format(pi))  # 居中  # 默认只保留6位小数<br>print(“{:&gt;20f}”.format(pi))  # 靠右<br>print(“{:&lt;20f}”.format(pi))  # 靠左<br>      3.141593<br>            3.141593<br>3.141593</p>
<p>看看不同情况下的输出格式，浮点数需要带上小数点，默认全部是左对齐：</p>
<p># 不同的输出方式</p>
<p>print(“{}”.format(pi))  # 原数据<br>print(“{:.2f}”.format(pi))   # 2位小数<br>print(“{:&gt;.10f}”.format(pi))  # 位数不足，右侧补0<br>print(“{:.4%}”.format(pi))  # 百分比输出<br>print(“{:.2e}”.format(pi))<br>3.1415926<br>3.14<br>3.1415926000<br>314.1593%<br>3.14e+00</p>
<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><hr>
<p>sex<br>‘男’<br>print(“{0:30}”.format(sex))  # 字符串默认左对齐<br>print(“{:&gt;30}”.format(sex))  # 改成右对齐<br>print(“{0:30}”.format(age))  # 数值类型默认右对齐<br>print(“{:&lt;30}”.format(height)) # 改成左对齐<br>男<br>                             男<br>                            25<br>1.76</p>
<h1 id="指定填充的字符"><a href="#指定填充的字符" class="headerlink" title="指定填充的字符"></a>指定填充的字符</h1><p>print(“{:*&gt;30}”.format(sex))  # *<br>print(“{:+&gt;30}”.format(sex))  # +<br>print(“{:+^30}”.format(sex))  # 居中后填充+<br>print(“{:+&lt;30}”.format(height)) # +<br>*****************************男<br>+++++++++++++++++++++++++++++男<br>++++++++++++++男+++++++++++++++<br>1.76++++++++++++++++++++++++++</p>
<h3 id="千位分隔符"><a href="#千位分隔符" class="headerlink" title="千位分隔符"></a>千位分隔符</h3><hr>
<p>主要是用来显示数字的千位分隔符，在货币金额中使用的比较多：</p>
<p>b &#x3D; 1003005000600</p>
<p>print(“{:-^20}”.format(b))   # 不用逗号<br>print(“{:-^20,}”.format(b))  # 用逗号<br>—1003005000600—-<br>-1,003,005,000,600–</p>
<h1 id="小数的千位分隔符显示"><a href="#小数的千位分隔符显示" class="headerlink" title="小数的千位分隔符显示"></a>小数的千位分隔符显示</h1><p>print(“{0:-20,}”.format(12567.98760))  # 不填充<br>print(“{0:-^20,}”.format(12567.98760))  # 居中+填充<br>print(“{0:-&gt;20,}”.format(12567.98760))  # 右对齐+填充<br>print(“{0:-&lt;20,}”.format(12567.98760))  # 左对齐+填充<br>         12,567.9876<br>—-12,567.9876—–<br>———12,567.9876<br>12,567.9876———</p>
<h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><hr>
<p>精度输出的时候前面必须有一个小数点开头，具有两层含义：</p>
<ul>
<li>浮点数：表示输出小数位的有效位数</li>
<li>字符串：精度表示输出的最大长度</li>
</ul>
<p>pi<br>3.1415926<br>“{:.3f}”.format(pi)<br>‘3.142’<br>“{:30.5f}”.format(pi)  # 小数点后5位，整体宽度30<br>‘                       3.14159’<br>“{:*^30.5f}”.format(pi)  # 小数点后5位，宽度30,居中后补充*<br>‘***********3.14159************‘<br>name<br>‘Yule Cottage’<br>“{:.4}”.format(name)  # 最大长度为4<br>‘Yule’<br>“{:.6}”.format(name)  # 输出最大长度为6<br>‘Yule C’</p>
<h3 id="多种输出类型"><a href="#多种输出类型" class="headerlink" title="多种输出类型"></a>多种输出类型</h3><hr>
<p>表示输出整数和浮点数类型的格式规则。对于整数类型，输出格式包括6 种：</p>
<ul>
<li>c: 输出整数对应的 Unicode 字符；</li>
<li>b: 输出整数的二进制方式；</li>
<li>o: 输出整数的八进制方式；</li>
<li>d: 输出整数的十进制方式；</li>
<li>x: 输出整数的小写十六进制方式；</li>
<li>X: 输出整数的大写十六进制方式；</li>
</ul>
<p>下面的例子表示的是365的二进制、Unicode字符、十进制、小写16进制和大写的16进制的不同输出格式：</p>
<p>“{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}”.format(365)<br>‘101101101,ŭ,365,555,16d,16D’</p>
<p>如果是浮点数类型，那么输出格式包括4种：</p>
<ul>
<li>e: 输出浮点数对应的小写字母 e 的指数形式；</li>
<li>E: 输出浮点数对应的大写字母 E 的指数形式；</li>
<li>f: 输出浮点数的标准浮点形式；</li>
<li>%: 输出浮点数的百分形式。</li>
</ul>
<blockquote>
<p>浮点数输出时尽量使用&lt;.精度&gt;表示小数部分的宽度，有助于更好控制输出格式。</p>
</blockquote>
<p>“{0:e},{0:E}”.format(3.1415)<br>‘3.141500e+00,3.141500E+00’<br>“{0:f},{0:F}”.format(3.1415)<br>‘3.141500,3.141500’<br>“{0:%}”.format(3.1415)  # 保留6位小数，百分比输出<br>‘314.150000%’<br>“{0:.2%}”.format(3.1415)  # 2位小数，百分比输出<br>‘314.15%’</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>format格式化</tag>
        <tag>字符串格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 如何字符串格式化使用_占位符%_详解码404</title>
    <url>/2021/08/14/python-%E5%A6%82%E4%BD%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BD%BF%E7%94%A8-%E5%8D%A0%E4%BD%8D%E7%AC%A6-%E8%AF%A6%E8%A7%A3%E7%A0%81404/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-12-1024x640.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>本文中介绍的字符串一个非常重要的知识点：字符串格式化输出。<br>格式化怎么理解？简答来说：就是让字符串按照我们设定的格式来输出，达到我们想要的结果。主要是有4种方式：</p>
<ul>
<li>%：基于占位符的格式化</li>
<li>format()函数的格式化：重点掌握</li>
<li>f-string格式化：重点掌握</li>
<li>字符串模板函数</li>
</ul>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符%"></a>占位符%</h4><h3 id="常见格式符"><a href="#常见格式符" class="headerlink" title="常见格式符"></a>常见格式符</h3><hr>
<p>格式化符号其实是为真实的值预留出一个空位，而且还可以控制显示的格式。格式符包含一个类型码，用来显示不同的数据类型，比如字符串、二进制、指数等。常见的不同的占位符如下：</p>
<ul>
<li>%s： 字符串 (采用str()的显示)，常用</li>
<li>%r： 字符串 (采用repr()的显示)</li>
<li>%c： 单个字符，格式化字符及其ASCII码</li>
<li>%b： 二进制整数</li>
<li>%u： 格式化无符号整数，常用</li>
<li>%d： 格式化十进制整数，常用</li>
<li>%i： 十进制整数</li>
<li>%o： 八进制整数</li>
<li>%x： 十六进制整数</li>
<li>%g： 指数(e)或浮点数%f (根据显示长度)</li>
<li>%G： 指数(E)或浮点数%F (根据显示长度)</li>
<li>%e： 指数 (基底写为e)，用科学计数法格式化浮点数</li>
<li>%E： 指数 (基底写为E)，用法同%e</li>
<li>%f： 浮点数，格式化浮点数字，可以指定小数点后面的精度，常用</li>
<li>%F： 浮点数，与%f相同</li>
<li>%%： 字符“%”，用来显示百分号%</li>
</ul>
<h3 id="对齐问题"><a href="#对齐问题" class="headerlink" title="对齐问题"></a>对齐问题</h3><hr>
<p>关于对齐问题：</p>
<p>1. ^：居中对齐<br>2. &gt;：右对齐<br>3. &lt;：左对齐<br>4. +、-：显示正负号</p>
<h3 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h3><hr>
<p>常用的语法形式为：<code>%[(name)][flags][width].[precision] typecode</code></p>
<ul>
<li>(name)：参数的名称，可以省略；如果使用必须加上()</li>
<li>flags：对齐标志位；可以是+、-、“”、0；+右对齐，-左对齐，””填充一个空格；0表示左侧使用0填充</li>
<li>width：显示的宽度</li>
<li>precision：小数点后的精度</li>
</ul>
<h3 id="多种类型连用"><a href="#多种类型连用" class="headerlink" title="多种类型连用"></a>多种类型连用</h3><hr>
<p>print(“%9.3f” % 2.3)<br>2.300  #  前面4个空格</p>
<ul>
<li>第一个 % 后面的内容为显示的格式说明，9 为显示宽度，3 为小数点位数，f 表示输出为浮点数类型</li>
<li>第二个 % 后面为显示的内容来源，输出结果默认为右对齐，2.300 长度为 5，故前面有4个空格</li>
</ul>
<p>print(“%+9.3f” % 2.3)  # 带上+符号输出，9表示宽度，3表示小数位<br>   +2.300<br>print(“%-9.3f” % 2.3)  # -表示左对齐输出<br>2.300<br>print(“%-9.3f” % -2.3)<br>-2.300</p>
<h1 id="我们显示声明3个变量"><a href="#我们显示声明3个变量" class="headerlink" title="我们显示声明3个变量"></a>我们显示声明3个变量</h1><p>name &#x3D; “Yule Cottage”  # 字符串类型<br>age &#x3D; 25  # 整数类型<br>height &#x3D; 1.76   # 浮点数类型</p>
<h1 id="1、浮点数默认是6位小数"><a href="#1、浮点数默认是6位小数" class="headerlink" title="1、浮点数默认是6位小数"></a>1、浮点数默认是6位小数</h1><h1 id="2、-f和-F相同"><a href="#2、-f和-F相同" class="headerlink" title="2、%f和%F相同"></a>2、%f和%F相同</h1><p>print(“我是：%s，年龄: %d，身高是：%f” % (name,age,height))<br>我是：Yule Cottage，年龄: 25，身高是：1.760000</p>
<h1 id="指定浮点数的小数位"><a href="#指定浮点数的小数位" class="headerlink" title="指定浮点数的小数位"></a>指定浮点数的小数位</h1><p>print(“我是：%s，年龄: %d，身高是：%.3f” % (name,age,height))<br>我是：Yule Cottage，年龄: 25，身高是：1.760</p>
<p>下面的代码是通过字典对的形式来传入不同的数据类型，字典（后面会介绍python的字典）的值就是待格式的内容。</p>
<blockquote>
<p>需要注意的是name、age、height必须写在%号的后面</p>
</blockquote>
<p>print(“我是：%(name)s，年龄: %(age)d，身高是：%(height).3f” % {“name”:name,”age”:age,”height”:height})<br>我是：Yule Cottage，年龄: 25，身高是：1.760</p>
<h3 id="输出不同进制"><a href="#输出不同进制" class="headerlink" title="输出不同进制"></a>输出不同进制</h3><hr>
<p>print(“八进制：%o，十进制：%i，十六进制：%x” %(age,age,age))<br>八进制：31，十进制：25，十六进制：19</p>
<h1 id="print-“二进制：-b”-age-二进制不能使用"><a href="#print-“二进制：-b”-age-二进制不能使用" class="headerlink" title="print(“二进制：%b” %(age))   # 二进制不能使用"></a>print(“二进制：%b” %(age))   # 二进制不能使用</h1><p>bin(age)  # 通过bin函数查看<br>‘0b11001’</p>
<h3 id="输出的宽度、精度等设置"><a href="#输出的宽度、精度等设置" class="headerlink" title="输出的宽度、精度等设置"></a>输出的宽度、精度等设置</h3><hr>
<p>number &#x3D; 1.23456789</p>
<h1 id="宽度为10，保留小数点后4位，默认是右对齐"><a href="#宽度为10，保留小数点后4位，默认是右对齐" class="headerlink" title="宽度为10，保留小数点后4位，默认是右对齐"></a>宽度为10，保留小数点后4位，默认是右对齐</h1><p>print(“%10.4f” % number)<br>    1.2346<br>print(“%-10.4f” % number)  # -符号表示左对齐，显示4位小数<br>1.2346</p>
<h1 id="右对齐，保留10位小数，不足的用0补齐"><a href="#右对齐，保留10位小数，不足的用0补齐" class="headerlink" title="右对齐，保留10位小数，不足的用0补齐"></a>右对齐，保留10位小数，不足的用0补齐</h1><p>print(“%10.10f” % number)<br>1.2345678900<br>print(“%-10.8f” % number)  # 左对齐，保留8位小数<br>1.23456789</p>
<h1 id="左对齐，保留7位小数，会自动地进行四舍五入"><a href="#左对齐，保留7位小数，会自动地进行四舍五入" class="headerlink" title="左对齐，保留7位小数，会自动地进行四舍五入"></a>左对齐，保留7位小数，会自动地进行四舍五入</h1><p>print(“%-10.7f” % number)<br>1.2345679</p>
<p>下面是针对字符串的宽度等输出设置：</p>
<p>name<br>‘Yule Cottage’<br>print(“%.10s” % name) # 9个字母+一个空格：左对齐<br>Yule Cotta<br>print(“%.15s” % name) # 如果位数不够，直接全部输出<br>Yule Cottage<br>print(“%10.6s” % name) # 右对齐，取出6个字符<br>    Yule C</p>
<p>解释：总长度为10，前面4个空格，加上4+一个空格+C</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>占位符</tag>
        <tag>字符串</tag>
        <tag>格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 虚拟环境搭建之Virtualenv</title>
    <url>/2021/08/16/python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8Bvirtualenv/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-13.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<h3 id="什么是虚拟环境？"><a href="#什么是虚拟环境？" class="headerlink" title="什么是虚拟环境？"></a>什么是虚拟环境？</h3><p>从百度百科得知：以专利的实时动态程序行为修饰与模拟算法，直接利用本机的 OS，模拟出自带与本机相容 OS 的虚拟机（Vista 下可模拟 Vista、XP，Windows 7 下则可模拟 Windows 7、Vista、XP），也称为 “虚拟环境”。</p>
<p>功能：每一个环境都相当于一个新的 Python 环境。你可以在这个新的环境里安装库，运行代码等.。</p>
<h3 id="为什么需要使用虚拟环境？"><a href="#为什么需要使用虚拟环境？" class="headerlink" title="为什么需要使用虚拟环境？"></a>为什么需要使用虚拟环境？</h3><p>众所周知 Python 有强大的兼容性，粘附性强，同时却有些许库之间并不兼容。</p>
<h3 id="什么时候需要使用虚拟环境？"><a href="#什么时候需要使用虚拟环境？" class="headerlink" title="什么时候需要使用虚拟环境？"></a>什么时候需要使用虚拟环境？</h3><p>需要使用某库，但是和已安装的库存在兼容性问题，导致运行报错。</p>
<p>某些库迭代更新，旧项目使用旧库，更新成新库会导致项目无法正常运行。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr>
<p>各虚拟环境相当于不同的柜子，每个柜子存放物品不同都不会影响其他柜子，指定不同的虚拟环境完成不同的项目。</p>
<h3 id="搭建前"><a href="#搭建前" class="headerlink" title="搭建前"></a>搭建前</h3><hr>
<p>请确保 Python 已安装至使用的电脑中 (最好已经配置好了环境变量）</p>
<p>请确保 pip 命令能够正常使用，且能正常安装库</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr>
<h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>pip install virtualenv virtualenvwrapper -i <a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a></p>
<h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>pip install virtualenvwrapper-win -i <a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><hr>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>sed ‘$a export WORKON_HOME&#x3D;~&#x2F;Envs’ ~&#x2F;.bashrc<br>source &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh<br>source ~&#x2F;.bashrc</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>set PATH&#x3D;%PATH%;WORKON_HOME&#x3D;D:\Envs</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><hr>
<h3 id="创建Python虚拟环境，命名为venv"><a href="#创建Python虚拟环境，命名为venv" class="headerlink" title="创建Python虚拟环境，命名为venv"></a>创建Python虚拟环境，命名为venv</h3><p>Mac:code404.icu michael$ virtualenv –no-site-packages venv<br>Using base prefix ‘&#x2F;usr&#x2F;local&#x2F;…&#x2F;Python.framework&#x2F;Versions&#x2F;3.4’<br>New python executable in venv&#x2F;bin&#x2F;python3.4<br>Also creating executable in venv&#x2F;bin&#x2F;python<br>Installing setuptools, pip, wheel…done.</p>
<p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p>
<h3 id="进入虚拟环境"><a href="#进入虚拟环境" class="headerlink" title="进入虚拟环境"></a>进入虚拟环境</h3><p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境</p>
<p>Mac:code404.icu michael$ source venv&#x2F;bin&#x2F;activate<br>(venv)Mac:code404.icu michael$</p>
<p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。<br>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。</p>
<h3 id="退出当前虚拟环境，使用deactivate命令"><a href="#退出当前虚拟环境，使用deactivate命令" class="headerlink" title="退出当前虚拟环境，使用deactivate命令"></a>退出当前虚拟环境，使用deactivate命令</h3><p>(venv)Mac:code404.icu michael$ deactivate<br>Mac:code404.icu michael$ </p>
<p>此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Virtualenv</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title>PythonWEB框架之PyWebIO_不会前端也能写</title>
    <url>/2021/10/30/pythonweb%E6%A1%86%E6%9E%B6%E4%B9%8Bpywebio-%E4%B8%8D%E4%BC%9A%E5%89%8D%E7%AB%AF%E4%B9%9F%E8%83%BD%E5%86%99/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-26.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>PyWebIO提供了一系列命令式的交互函数来在浏览器上获取用户输入和进行输出，将浏览器变成了一个“富文本终端”，可以用于构建简单的Web应用或基于浏览器的GUI应用。 PyWebIO还可以方便地整合进现有的Web服务，让你不需要编写HTML和JS代码，就可以构建出具有良好可用性的应用。</p>
<p><img src="https://img-blog.csdnimg.cn/d2d4093275d94abcbb5a98d11e8015a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/f1cab5216f304584a763354bcc70d116.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><hr>
<ul>
<li>使用同步而不是基于回调的方式获取输入，代码编写逻辑更自然</li>
<li>非声明式布局，布局方式简单高效</li>
<li>代码侵入性小，旧脚本代码仅需修改输入输出逻辑便可改造为Web服务</li>
<li>支持整合到现有的Web服务，目前支持与Flask、Django、Tornado、aiohttp、FastAPI框架集成</li>
<li>同时支持基于线程的执行模型和基于协程的执行模型</li>
<li>支持结合第三方库实现数据可视化</li>
</ul>
<h3 id="稳定版安装"><a href="#稳定版安装" class="headerlink" title="稳定版安装"></a>稳定版安装</h3><hr>
<p>pip3 install -U pywebio</p>
<h3 id="开发版安装"><a href="#开发版安装" class="headerlink" title="开发版安装"></a>开发版安装</h3><p>pip3 install -U <a href="https://code.aliyun.com/wang0618/pywebio/repository/archive.zip">https://code.aliyun.com/wang0618/pywebio/repository/archive.zip</a></p>
<p><strong>系统要求</strong>: PyWebIO要求 Python 版本在 3.5.2 及以上</p>
<h3 id="开始写一个-Hello-world"><a href="#开始写一个-Hello-world" class="headerlink" title="开始写一个 Hello, world"></a>开始写一个 Hello, world</h3><hr>
<p>这是一个使用PyWebIO计算 BMI指数 的脚本:</p>
<p>from pywebio.input import input, FLOAT<br>from pywebio.output import put_text</p>
<p>def bmi():<br>    height &#x3D; input(“请输入你的身高(cm)：”, type&#x3D;FLOAT)<br>    weight &#x3D; input(“请输入你的体重(kg)：”, type&#x3D;FLOAT)</p>
<pre><code>BMI = weight / (height / 100) \*\* 2

top\_status = \[(14.9, &#39;极瘦&#39;), (18.4, &#39;偏瘦&#39;),
              (22.9, &#39;正常&#39;), (27.5, &#39;过重&#39;),
              (40.0, &#39;肥胖&#39;), (float(&#39;inf&#39;), &#39;非常肥胖&#39;)\]

for top, status in top\_status:
    if BMI &lt;= top:
        put\_text(&#39;你的 BMI 值: %.1f，身体状态：%s&#39; % (BMI, status))
        break
</code></pre>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:<br>    bmi()</p>
<p>如果没有使用PyWebIO，这只是一个非常简单的脚本，而通过使用PyWebIO提供的输入输出函数，你可以在浏览器中与代码进行交互 ：<br><img src="https://img-blog.csdnimg.cn/dc4e87ccb7f3474aa872e3338ac846cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="提供Web服务使用"><a href="#提供Web服务使用" class="headerlink" title="提供Web服务使用"></a>提供Web服务使用</h3><hr>
<p>上文BMI程序会在计算完毕后立刻退出，可以使用 pywebio.start_server() 将 bmi() 函数作为Web服务提供：</p>
<p>from pywebio import start_server<br>from pywebio.input import input, FLOAT<br>from pywebio.output import put_text</p>
<p>def bmi():  # bmi() 函数内容不变<br>    …  </p>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:<br>    start_server(bmi, port&#x3D;80)</p>
<h3 id="结合现有Web框架整合"><a href="#结合现有Web框架整合" class="headerlink" title="结合现有Web框架整合"></a>结合现有Web框架整合</h3><hr>
<p>Tornado应用整合：仅需在现有的Tornado应用中添加一个 RequestHandler ，就可以将PyWebIO应用整合进Tornado Web服务中</p>
<p>import tornado.ioloop<br>import tornado.web<br>from pywebio.platform.tornado import webio_handler</p>
<p>class MainHandler(tornado.web.RequestHandler):<br>    def get(self):<br>        self.write(“Hello, world”)</p>
<p>if __name__ &#x3D;&#x3D; “__main__“:<br>    application &#x3D; tornado.web.Application([<br>        (r”&#x2F;“, MainHandler),<br>        (r”&#x2F;bmi”, webio_handler(bmi)),  # bmi 即为上文计算BMI指数的函数<br>    ])<br>    application.listen(port&#x3D;80, address&#x3D;’localhost’)<br>    tornado.ioloop.IOLoop.current().start()</p>
<p>在 <a href="http://localhost/bmi">http://localhost/bmi</a> 页面上就可以计算BMI了。</p>
<p>与其他Web框架整合请见<a href="https://pywebio.readthedocs.io/zh_CN/latest/advanced.html#integration-with-web-framework">文档</a></p>
<h3 id="Demos"><a href="#Demos" class="headerlink" title="Demos"></a>Demos</h3><hr>
<ul>
<li><a href="http://pywebio-demos.pywebio.online/">基本demo</a> : 包含PyWebIO基本输入输出演示和使用PyWebIO编写的小应用</li>
<li><a href="http://pywebio-charts.pywebio.online/">数据可视化demo</a> : 使用 bokeh、plotly、pyecharts 等库进行数据可视化</li>
</ul>
<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><hr>
<p>使用手册和实现文档见 <a href="https://pywebio.readthedocs.io/">https://pywebio.readthedocs.io</a></p>
<h3 id="下面是我写的一个使用PyWebIO写的程序"><a href="#下面是我写的一个使用PyWebIO写的程序" class="headerlink" title="下面是我写的一个使用PyWebIO写的程序"></a>下面是我写的一个使用PyWebIO写的程序</h3><hr>
<p>import json<br>from pywebio.output import put_tabs,put_html,toast,put_code<br>from settings import options<br>def bmi():<br>    try:<br>        settings&#x3D;open(options.get(‘conf’) ,’r’,encoding&#x3D;’utf-8’).read()<br>    except Exception as e:<br>        toast(“解析配置文件出错\n”+str(e),position&#x3D;’center’,color&#x3D;’error’)<br>        return<br>    tabs&#x3D;[]<br>    put_code(options.get(‘env’)).style(‘text-align-last:right ;font-weight: 700’)<br>    try:<br>        Jsettings&#x3D;json.loads(settings)</p>
<pre><code>    for i in Jsettings:
        contents=\[\]
        for j in i\[&#39;links&#39;\]:
            contents.append(put\_html(&#39;&lt;button onclick=&quot;window.open(&#39;+&quot;&#39;&quot;+j\[&#39;links&#39;\]+&quot;&#39;&quot;+&#39;)&quot; class=&quot;btn btn-primary&quot;&gt;&#39;+j\[&#39;name&#39;\]+&#39;&lt;/button&gt;&#39;))
        tabs.append(&#123;&#39;title&#39;:i\[&#39;name&#39;\],&#39;content&#39;:contents&#125;)
    put\_tabs(tabs)

except Exception as e:
    toast(&quot;服务器错误，请联系管理员\\n&quot;+str(e), position=&#39;right&#39;, color=&#39;error&#39;, duration=2)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/874b405664d64a83b568d6a0468ced38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PyWebIO</tag>
        <tag>Tornado</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Python如何实现定时任务_多种方式实现定时任务</title>
    <url>/2021/08/31/python%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-28.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>实现定时任务是一项基本的功能，Python中有很多的实现方案，以定时监测电脑的性能信息（如cpu、内存、磁盘等）为例，比较下这些方案的特点以及适合场景。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><hr>
<p>使用pip下载 psutil 模块：</p>
<p>pip install psutil</p>
<p>实现监测性能的方法，代码如下：</p>
<p>import psutil<br>import datetime</p>
<p>def monitor_sys():<br>    # cpu、虚拟内存、disk等占比<br>    cpu_percent &#x3D; psutil.cpu_percent()<br>    v_mem_percent &#x3D; psutil.virtual_memory().percent<br>    c_disk_percent &#x3D; psutil.disk_usage(“C:\\“).percent<br>    now_time_str &#x3D; datetime.datetime.now().strftime(“%Y-%m-%d %H:%M:%S”)<br>    print(f”{now_time_str} cpu:{cpu_percent}, mem:{v_mem_percent}, disk:{c_disk_percent}”)</p>
<h3 id="定时任务实现方案"><a href="#定时任务实现方案" class="headerlink" title="定时任务实现方案"></a>定时任务实现方案</h3><h4 id="1、sleep-while"><a href="#1、sleep-while" class="headerlink" title="1、sleep + while"></a>1、sleep + while</h4><hr>
<p>通过 time 模块的sleep()和while循环，实现定时执行任务，<strong>代码如下：</strong></p>
<p>import time</p>
<p>def sleep2Schedule():<br>    while True:<br>        monitor_sys()<br>        # 5s调度一次<br>        time.sleep(5)<br>    # 递归调用<br>    sleep2Schedule()</p>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:<br>    sleep2Schedule()</p>
<p><strong>输出结果：</strong></p>
<p>2021-08-22 21:05:23 cpu:4.6, mem:75.9, disk:61.8<br>2021-08-22 21:05:29 cpu:5.8, mem:75.9, disk:61.8<br>2021-08-22 21:05:34 cpu:6.0, mem:75.8, disk:61.8<br>2021-08-22 21:05:39 cpu:4.4, mem:75.9, disk:61.8</p>
<p><strong>优缺点：</strong></p>
<p>优点是简单易实现，缺点也很明显，只能实现单一任务，不能异步执行。</p>
<h4 id="2、线程模块的Timer"><a href="#2、线程模块的Timer" class="headerlink" title="2、线程模块的Timer()"></a>2、线程模块的Timer()</h4><hr>
<p>通过 threading 模块的定时器Timer()，利用线程提供的start()启动多个线程，可以实现多个任务的定时执行，<strong>代码如下：</strong></p>
<p>from threading import Timer</p>
<p>def monitor_sys():<br>    ……  # 省略<br>    print(f”{now_time_str} cpu:{cpu_percent}, mem:{v_mem_percent}, disk:{c_disk_percent}”)<br>    Timer(5, monitor_sys).start()</p>
<p>def test_out():<br>    print(f”{datetime.datetime.now().strftime(‘%Y-%m-%d %H:%M:%S’)} 这该死的颜值啊！”)<br>    Timer(3, test_out).start()</p>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:<br>    monitor_sys()<br>    test_out()</p>
<p><strong>输出结果：</strong></p>
<p>2021-08-22 21:22:39 cpu:0.0, mem:75.4, disk:61.8<br>2021-08-22 21:22:39 这该死的颜值啊！<br>2021-08-22 21:22:42 这该死的颜值啊！<br>2021-08-22 21:22:44 cpu:4.7, mem:75.5, disk:61.8<br>2021-08-22 21:22:45 这该死的颜值啊！<br>2021-08-22 21:22:48 这该死的颜值啊！<br>2021-08-22 21:22:49 cpu:5.3, mem:75.3, disk:61.8<br>2021-08-22 21:22:51 这该死的颜值啊！</p>
<p><strong>优缺点：</strong><br>优点是可以异步的执行多个调度任务，缺点是只能指定时间间隔（执行频率），不能指定执行时间点或时间段，不能动态添加定时任务等。</p>
<h4 id="3、任务调度模块schedule"><a href="#3、任务调度模块schedule" class="headerlink" title="3、任务调度模块schedule"></a>3、任务调度模块schedule</h4><hr>
<p>先下载该模块：</p>
<p>pip install schedule</p>
<p>通过schedule模块创建需要周期或定时调度执行的Job，通过 run_pending 方式执行任务，<strong>实现代码如下：</strong></p>
<p>import schedule</p>
<p>def monitor_sys():<br>    ……  # 省略<br>    print(f”{now_time_str} cpu:{cpu_percent}, mem:{v_mem_percent}, disk:{c_disk_percent}”)</p>
<p>def test_out():<br>    print(f”{datetime.datetime.now().strftime(‘%Y-%m-%d %H:%M:%S’)} 这该死的颜值啊！”)</p>
<p>def schedule2Schedule():<br>    schedule.clear()<br>    # 创建Job1，5s执行一次 monitor_sys<br>    schedule.every(5).seconds.do(monitor_sys)<br>    # 创建Job2，3s执行一次 test_out<br>    schedule.every(3).seconds.do(test_out)<br>    # 开启调度任务<br>    while True:<br>        schedule.run_pending()</p>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:<br>    schedule2Schedule()</p>
<p><strong>输出结果：</strong></p>
<p>2021-08-22 21:38:49 这该死的颜值啊！<br>2021-08-22 21:38:51 cpu:15.5, mem:75.1, disk:61.8<br>2021-08-22 21:38:52 这该死的颜值啊！<br>2021-08-22 21:38:55 这该死的颜值啊！<br>2021-08-22 21:38:56 cpu:16.0, mem:75.2, disk:61.8<br>2021-08-22 21:38:58 这该死的颜值啊！<br>2021-08-22 21:39:01 cpu:18.1, mem:75.2, disk:61.8<br>2021-08-22 21:39:01 这该死的颜值啊！<br>2021-08-22 21:39:04 这该死的颜值啊！<br>2021-08-22 21:39:06 cpu:16.0, mem:75.1, disk:61.8</p>
<p><strong>优缺点：</strong></p>
<p>优点是可以异步执行多个定时任务，而且可以指定执行时间间隔（频率，如按分&#x2F;按天等），时间点（如从8:00开始）及时间段（如5~10分钟等），缺点是因为轻量级，无法动态添加任务，无法将任务的结果进行持久化等。</p>
<h4 id="4、任务框架APSchedule"><a href="#4、任务框架APSchedule" class="headerlink" title="4、任务框架APSchedule"></a>4、任务框架APSchedule</h4><hr>
<p>APSchedule模块用于执行周期或定时任务，可以动态的添加或删除定时任务，还可以将任务的结果持久化到数据库、内存、队列等保存，此外，该还提供了丰富的接口去实现定时任务。</p>
<p>通过pip引入APSchedule模块：</p>
<p>pip install APScheduler</p>
<p><strong>实现代码如下：</strong></p>
<p>from apscheduler.schedulers.blocking import BlockingScheduler</p>
<p>def APSchedule2Schedule():<br>    # 创建调度器<br>    schedule &#x3D; BlockingScheduler()<br>    # 动态添加任务: 触发器类型有``date``, ``interval`` or ``cron``,5s&#x2F;次的话选择interval类型<br>    schedule.add_job(monitor_sys, trigger&#x3D;’interval’, seconds&#x3D;5)<br>    # 指定22:13执行的话选择interval类型<br>    schedule.add_job(test_out, trigger&#x3D;’cron’, hour&#x3D;22, minute&#x3D;13)<br>    # 执行<br>    schedule.start()</p>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:<br>    APSchedule2Schedule()</p>
<p><strong>输出结果：</strong>（第二个任务按时间点，只执行了一次）</p>
<p>2021-08-22 22:12:55 cpu:4.7, mem:75.8, disk:61.8<br>2021-08-22 22:13:00 这该死的颜值啊！<br>2021-08-22 22:13:00 cpu:5.9, mem:75.6, disk:61.8<br>2021-08-22 22:13:05 cpu:3.8, mem:75.7, disk:61.8<br>2021-08-22 22:13:10 cpu:4.8, mem:75.6, disk:61.8<br>2021-08-22 22:13:15 cpu:5.1, mem:75.7, disk:61.8</p>
<h4 id="5、Celery实现调度任务"><a href="#5、Celery实现调度任务" class="headerlink" title="5、Celery实现调度任务"></a>5、Celery实现调度任务</h4><hr>
<p>最后，推荐一款可以比肩APSchedule的任务调度框架Celery，它具备APSchedule的优点，也支持动态增删Job，支持持久化等操作。Celery使用起来比APSchedule更复杂点，可以通过以下命令启动并监听定时任务：</p>
<p>python test_task.py celery worker –loglevel&#x3D;info –beat</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><hr>
<p>经过上面实现定时任务的多种方式梳理，不难看出APSchedule框架是最优的选择，它简单易用，而且功能丰富。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Celery</tag>
        <tag>python</tag>
        <tag>APSchedule</tag>
        <tag>schedule</tag>
        <tag>sleep</tag>
        <tag>Timer</tag>
        <tag>while</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>python开发celery异步任务调度与redis环境搭建</title>
    <url>/2021/10/20/python%E5%BC%80%E5%8F%91celery%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%8Eredis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-16-1024x428.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>Celery 是一个分布式队列的管理工具, 可以用 Celery 提供的接口快速实现并管理一个分布式的任务队列.<br>使用于生产环境的消息代理有 RabbitMQ 和 Redis,还可以使用数据库，本篇介绍redis使用</p>
<h3 id="Redis-环境搭建"><a href="#Redis-环境搭建" class="headerlink" title="Redis 环境搭建"></a>Redis 环境搭建</h3><hr>
<p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h3 id="使用-docker-安装Redis"><a href="#使用-docker-安装Redis" class="headerlink" title="使用 docker 安装Redis"></a>使用 docker 安装Redis</h3><hr>
<p>docker pull redis:latest</p>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><hr>
<p>docker run -itd –name redis-test -p 6379:6379 redis</p>
<p>映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</p>
<h3 id="django依赖包"><a href="#django依赖包" class="headerlink" title="django依赖包"></a>django依赖包</h3><hr>
<p>django使用的版本是v2.1.2</p>
<p>安装celery版本</p>
<p>pip install celery&#x3D;&#x3D;3.1.26.post2</p>
<p>安装django-celery包</p>
<p>pip install django-celery&#x3D;&#x3D;3.3.1</p>
<p>安装Redis</p>
<p>pip install redis&#x3D;&#x3D;2.10.6</p>
<h3 id="Django-中使用-Celery"><a href="#Django-中使用-Celery" class="headerlink" title="Django 中使用 Celery"></a>Django 中使用 Celery</h3><hr>
<p>要在 Django 项目中使用 Celery，您必须首先定义 Celery 库的一个实例（称为“应用程序”）</p>
<p>如果你有一个现代的 Django 项目布局，比如：</p>
<p>- proj&#x2F;</p>
<ul>
<li>manage.py</li>
<li>proj&#x2F;<ul>
<li>__init__.py</li>
<li>settings.py</li>
<li>urls.py</li>
</ul>
</li>
</ul>
<p>那么推荐的方法是创建一个新的proj&#x2F;proj&#x2F;celery.py模块来定义 Celery 实例：</p>
<p>import os</p>
<p>from celery import Celery</p>
<h1 id="Set-the-default-Django-settings-module-for-the-‘celery’-program"><a href="#Set-the-default-Django-settings-module-for-the-‘celery’-program" class="headerlink" title="Set the default Django settings module for the ‘celery’ program."></a>Set the default Django settings module for the ‘celery’ program.</h1><p>os.environ.setdefault(‘DJANGO_SETTINGS_MODULE’, ‘proj.settings’)</p>
<p>app &#x3D; Celery(‘proj’)</p>
<h1 id="Using-a-string-here-means-the-worker-doesn’t-have-to-serialize"><a href="#Using-a-string-here-means-the-worker-doesn’t-have-to-serialize" class="headerlink" title="Using a string here means the worker doesn’t have to serialize"></a>Using a string here means the worker doesn’t have to serialize</h1><h1 id="the-configuration-object-to-child-processes"><a href="#the-configuration-object-to-child-processes" class="headerlink" title="the configuration object to child processes."></a>the configuration object to child processes.</h1><h1 id="namespace-x3D-’CELERY’-means-all-celery-related-configuration-keys"><a href="#namespace-x3D-’CELERY’-means-all-celery-related-configuration-keys" class="headerlink" title="- namespace&#x3D;’CELERY’ means all celery-related configuration keys"></a>- namespace&#x3D;’CELERY’ means all celery-related configuration keys</h1><h1 id="should-have-a-CELERY-prefix"><a href="#should-have-a-CELERY-prefix" class="headerlink" title="should have a `CELERY_` prefix."></a>should have a `CELERY_` prefix.</h1><p>app.config_from_object(‘django.conf:settings’, namespace&#x3D;’CELERY’)</p>
<h1 id="Load-task-modules-from-all-registered-Django-apps"><a href="#Load-task-modules-from-all-registered-Django-apps" class="headerlink" title="Load task modules from all registered Django apps."></a>Load task modules from all registered Django apps.</h1><p>app.autodiscover_tasks()</p>
<p>@app.task(bind&#x3D;True)<br>def debug_task(self):<br>    print(f’Request: {self.request!r}’)</p>
<p>其中debug_task是测试的任务，可以注掉</p>
<p># @app.task(bind&#x3D;True)</p>
<h1 id="def-debug-task-self"><a href="#def-debug-task-self" class="headerlink" title="def debug_task(self):"></a>def debug_task(self):</h1><h1 id="print-‘Request-0-r-’-format-self-request"><a href="#print-‘Request-0-r-’-format-self-request" class="headerlink" title="print(‘Request: {0!r}’.format(self.request))"></a>print(‘Request: {0!r}’.format(self.request))</h1><p>上面一段只需改这句，’proj’是自己django项目的app名称</p>
<p>app &#x3D; Celery(‘proj’)</p>
<p>然后你需要在你的proj&#x2F;proj&#x2F;init.py 模块中导入这个应用程序。这确保在 Django 启动时加载应用程序，以便@shared_task装饰器（稍后提到）将使用它：</p>
<p>proj&#x2F;proj&#x2F;init.py:</p>
<p># This will make sure the app is always imported when</p>
<h1 id="Django-starts-so-that-shared-task-will-use-this-app"><a href="#Django-starts-so-that-shared-task-will-use-this-app" class="headerlink" title="Django starts so that shared_task will use this app."></a>Django starts so that shared_task will use this app.</h1><p>from .celery import app as celery_app</p>
<p>__all__ &#x3D; (‘celery_app’,)</p>
<p>上面这段固定的，不用改</p>
<h3 id="tasks任务"><a href="#tasks任务" class="headerlink" title="tasks任务"></a>tasks任务</h3><hr>
<p>在app下新建tasks.py,必须要是tasks.py文件名称，django会自动查找到app下的该文件</p>
<p>@shared_task<br>def add(x, y):<br>    print(“task———-1111111111111111111111”)<br>    return x + y</p>
<p>@shared_task<br>def mul(x, y):<br>    return x * y</p>
<p>tasks.py可以写任务函数add、mul，让它生效的最直接的方法就是添加app.task 或shared_task 这个装饰器</p>
<h3 id="添加setting配置"><a href="#添加setting配置" class="headerlink" title="添加setting配置"></a>添加setting配置</h3><hr>
<p>setting.py添加配置</p>
<p>#  celery 配置连接redis<br>BROKER_URL &#x3D; ‘redis:&#x2F;&#x2F;ip:6379’<br>CELERY_RESULT_BACKEND &#x3D; ‘redis:&#x2F;&#x2F;ip:6379’</p>
<p>CELERY_TASK_SERIALIZER &#x3D; ‘json’<br>CELERY_RESULT_SERIALIZER &#x3D; ‘json’<br>CELERY_ACCEPT_CONTENT&#x3D;[‘json’]<br>CELERY_TIMEZONE &#x3D; ‘Asia&#x2F;Shanghai’<br>CELERY_ENABLE_UTC &#x3D; True</p>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><hr>
<p>views.py创建视图</p>
<p>from .tasks import add, mul</p>
<p>def task_demo(request):<br>    res &#x3D; add.delay(10, 20)<br>    print(res.task_id)  # 返回task_id<br>    return JsonResponse({“code”: 0, “res”: res.task_id})</p>
<h3 id="启动worker"><a href="#启动worker" class="headerlink" title="启动worker"></a>启动worker</h3><hr>
<p>前面pip已经安装过celery应用了，celery是一个独立的应用，可以启动worker</p>
<p>celery -A MyDjango worker -l info</p>
<p>其中MyDjango是你自己的django项目名称</p>
<p>运行日志</p>
<p> ————– celery@DESKTOP-HJ487C8 v3.1.26.post2 (Cipater)<br>—- **** —–<br>— * ***  * – Windows-10-10.0.17134-SP0<br>– * - **** —</p>
<ul>
<li>** ———- [config]</li>
<li>** ———- .&gt; app:         yoyo:0x1ea1a96e9b0</li>
<li>** ———- .&gt; transport:   redis:&#x2F;&#x2F;localhost:6379&#x2F;&#x2F;</li>
<li>** ———- .&gt; results:     redis:&#x2F;&#x2F;localhost:6379&#x2F;</li>
<li>*** — * — .&gt; concurrency: 4 (prefork)</li>
</ul>
<p>– ******* —-<br>— ***** —– [queues]<br> ————– .&gt; celery           exchange&#x3D;celery(direct) key&#x3D;celery</p>
<p>[tasks]<br>  . yoyo.tasks.add<br>  . yoyo.tasks.mul</p>
<p>[2021-10-18 22:45:03,155: INFO&#x2F;MainProcess] Connected to redis:&#x2F;&#x2F;localhost:6379&#x2F;&#x2F;<br>[2021-10-18 22:45:03,347: INFO&#x2F;MainProcess] mingle: searching for neighbors<br>[2021-10-18 22:45:04,897: INFO&#x2F;MainProcess] mingle: all alone<br>[2021-10-18 22:45:05,406: WARNING&#x2F;MainProcess] e:\python36\lib\site-packages\celery\fixups\django.py:265:<br>UserWarning: Using settings.DEBUG leads to a memory leak, never use this setting in production environments!<br>  warnings.warn(‘Using settings.DEBUG leads to a memory leak, never ‘<br>[2021-10-18 22:45:05,407: WARNING&#x2F;MainProcess] celery@DESKTOP-HJ487C8 ready.</p>
<p>运行的时候，当我们看到”Connected to redis”说明已经连接成功了！</p>
<p>连接过程中如果出现报错：redis celery：AttributeError: str object has no attribute items</p>
<p>[2021-10-18 17:15:21,801: ERROR&#x2F;MainProcess] Unrecoverable error: AttributeError(“‘str’ object has no attribute ‘items’”,)<br>Traceback (most recent call last):<br>  File “e:\python36\lib\site-packages\celery\worker\__init__.py”, line 206, in start<br>    self.blueprint.start(self)<br>  File “e:\python36\lib\site-packages\celery\bootsteps.py”, line 123, in start<br>    step.start(parent)<br>  File “e:\python36\lib\site-packages\celery\bootsteps.py”, line 374, in start<br>    return self.obj.start()<br>  File “e:\python36\lib\site-packages\celery\worker\consumer.py”, line 280, in start<br>    blueprint.start(self)<br>  File “e:\python36\lib\site-packages\celery\bootsteps.py”, line 123, in start<br>    step.start(parent)<br>  File “e:\python36\lib\site-packages\celery\worker\consumer.py”, line 884, in start<br>    c.loop(*c.loop_args())<br>  File “e:\python36\lib\site-packages\celery\worker\loops.py”, line 103, in synloop<br>    connection.drain_events(timeout&#x3D;2.0)<br>  File “e:\python36\lib\site-packages\kombu\connection.py”, line 288, in drain_events<br>    return self.transport.drain_events(self.connection, **kwargs)<br>  File “e:\python36\lib\site-packages\kombu\transport\virtual\__init__.py”, line 847, in drain_events<br>    self._callbacks[queue](message)<br>  File “e:\python36\lib\site-packages\kombu\transport\virtual\__init__.py”, line 534, in _callback<br>    self.qos.append(message, message.delivery_tag)<br>  File “e:\python36\lib\site-packages\kombu\transport\redis.py”, line 146, in append<br>    pipe.zadd(self.unacked_index_key, delivery_tag, time()) \<br>  File “e:\python36\lib\site-packages\redis\client.py”, line 2320, in zadd<br>    for pair in iteritems(mapping):<br>  File “e:\python36\lib\site-packages\redis\_compat.py”, line 109, in iteritems<br>    return iter(x.items())<br>AttributeError: ‘str’ object has no attribute ‘items’</p>
<p>redis版本问题,报错版本redis&#x3D;3.2.1，降低版本redis&#x3D;2.10.6后，解决</p>
<h3 id="shell交互环境"><a href="#shell交互环境" class="headerlink" title="shell交互环境"></a>shell交互环境</h3><hr>
<p>在django shell交互环境调试运行任务</p>
<p>D:\202107django\MyDjango&gt;python manage.py shell<br>Python 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.<br>(InteractiveConsole)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from yoyo.tasks import add,mul<br>from celery.result import AsyncResult</p>
<p>res &#x3D; add.delay(11, 12)<br>res<br>&lt;AsyncResult: c5ff83a4-4840-4b36-8869-5ce6081904f1&gt;<br>res.status<br>‘SUCCESS’</p>
<p>res.backend<br>&lt;celery.backends.redis.RedisBackend object at 0x0000015E011C3128&gt;</p>
<p>res.task_id<br>‘c5ff83a4-4840-4b36-8869-5ce6081904f1’</p>
<p>get_task &#x3D; AsyncResult(id&#x3D;res.task_id)<br>get_task<br>&lt;AsyncResult: c5ff83a4-4840-4b36-8869-5ce6081904f1&gt;<br>get_task.get()<br>23</p>
</blockquote>
</blockquote>
</blockquote>
<p>res.status是查看任务状态<br>res.task_id 是获取任务的id<br>根据任务的id查询任务的执行结果AsyncResult(id&#x3D;res.task_id).get()获取</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Celery</tag>
        <tag>Django</tag>
        <tag>python</tag>
        <tag>任务调度</tag>
        <tag>异步</tag>
        <tag>Redis</tag>
        <tag>任务队列</tag>
      </tags>
  </entry>
  <entry>
    <title>python开发celery异步任务调度与定时触发_定时任务beat</title>
    <url>/2021/10/24/python%E5%BC%80%E5%8F%91celery%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%AE%9A%E6%97%B6%E8%A7%A6%E5%8F%91-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1beat/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-20.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Celery 可以异步执行，也可以通过定时任务触发</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><hr>
<p>这里用redis作为中间件，django使用的版本是v2.1.2<br>安装django需要用到的第三方包，注意版本号</p>
<p>pip install celery&#x3D;&#x3D;3.1.26.post2<br>pip install django-celery&#x3D;&#x3D;3.3.1<br>pip install redis&#x3D;&#x3D;2.10.6</p>
<p>详细的基础教程参考前面的<a href="https://www.code404.icu/1332.html%E3%80%82">https://www.code404.icu/1332.html。</a><br>本篇主要讲定时任务如何实现，下图中的Celery beat 定时任务<br><img src="https://img-blog.csdnimg.cn/0e6dde68bda341868e09c64aa49e5e66.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="celery-的5个角色"><a href="#celery-的5个角色" class="headerlink" title="celery 的5个角色"></a>celery 的5个角色</h3><hr>
<ul>
<li>Task 就是任务，有异步任务(Async Task)和定时任务(Celery Beat)</li>
<li>Broker 中间人，接收生产者发来的消息即Task，将任务存入队列。<br>任务的消费者是Worker。<br>Celery 本身不提供队列服务，推荐用Redis或RabbitMQ实现队列服务。</li>
<li>Worker 执行任务的单元，它实时监控消息队列，如果有任务就获取任务并执行它。</li>
<li>Beat 定时任务调度器，根据配置定时将任务发送给Broker。</li>
<li>Backend 用于存储任务的执行结果。</li>
</ul>
<h3 id="Django-中使用-Celery"><a href="#Django-中使用-Celery" class="headerlink" title="Django 中使用 Celery"></a>Django 中使用 Celery</h3><hr>
<p>要在 Django 项目中使用 Celery，您必须首先定义 Celery 库的一个实例（称为“应用程序”）</p>
<p>如果你有一个现代的 Django 项目布局，比如：</p>
<p>- proj&#x2F;</p>
<ul>
<li>manage.py</li>
<li>proj&#x2F;<ul>
<li>__init__.py</li>
<li>settings.py</li>
<li>urls.py</li>
</ul>
</li>
</ul>
<p>那么推荐的方法是创建一个新的proj&#x2F;proj&#x2F;celery.py模块来定义 Celery 实例：</p>
<p>import os</p>
<p>from celery import Celery</p>
<h1 id="Set-the-default-Django-settings-module-for-the-‘celery’-program"><a href="#Set-the-default-Django-settings-module-for-the-‘celery’-program" class="headerlink" title="Set the default Django settings module for the ‘celery’ program."></a>Set the default Django settings module for the ‘celery’ program.</h1><p>os.environ.setdefault(‘DJANGO_SETTINGS_MODULE’, ‘proj.settings’)</p>
<p>app &#x3D; Celery(‘proj’)</p>
<h1 id="Using-a-string-here-means-the-worker-doesn’t-have-to-serialize"><a href="#Using-a-string-here-means-the-worker-doesn’t-have-to-serialize" class="headerlink" title="Using a string here means the worker doesn’t have to serialize"></a>Using a string here means the worker doesn’t have to serialize</h1><h1 id="the-configuration-object-to-child-processes"><a href="#the-configuration-object-to-child-processes" class="headerlink" title="the configuration object to child processes."></a>the configuration object to child processes.</h1><h1 id="namespace-x3D-’CELERY’-means-all-celery-related-configuration-keys"><a href="#namespace-x3D-’CELERY’-means-all-celery-related-configuration-keys" class="headerlink" title="- namespace&#x3D;’CELERY’ means all celery-related configuration keys"></a>- namespace&#x3D;’CELERY’ means all celery-related configuration keys</h1><h1 id="should-have-a-CELERY-prefix"><a href="#should-have-a-CELERY-prefix" class="headerlink" title="should have a `CELERY_` prefix."></a>should have a `CELERY_` prefix.</h1><p>app.config_from_object(‘django.conf:settings’, namespace&#x3D;’CELERY’)</p>
<h1 id="Load-task-modules-from-all-registered-Django-apps"><a href="#Load-task-modules-from-all-registered-Django-apps" class="headerlink" title="Load task modules from all registered Django apps."></a>Load task modules from all registered Django apps.</h1><p>app.autodiscover_tasks()</p>
<p>@app.task(bind&#x3D;True)<br>def debug_task(self):<br>    print(f’Request: {self.request!r}’)</p>
<p>其中debug_task是测试的任务，可以注掉</p>
<p># @app.task(bind&#x3D;True)</p>
<h1 id="def-debug-task-self"><a href="#def-debug-task-self" class="headerlink" title="def debug_task(self):"></a>def debug_task(self):</h1><h1 id="print-‘Request-0-r-’-format-self-request"><a href="#print-‘Request-0-r-’-format-self-request" class="headerlink" title="print(‘Request: {0!r}’.format(self.request))"></a>print(‘Request: {0!r}’.format(self.request))</h1><p>上面一段只需改这句，’proj’是自己django项目的app名称</p>
<p>app &#x3D; Celery(‘proj’)</p>
<p>然后你需要在你的proj&#x2F;proj&#x2F;<strong>init</strong>.py 模块中导入这个应用程序。这确保在 Django 启动时加载应用程序，以便 @shared_task 装饰器（稍后提到）将使用它：</p>
<p>proj&#x2F;proj&#x2F;<strong>init</strong>.py:</p>
<p># This will make sure the app is always imported when</p>
<h1 id="Django-starts-so-that-shared-task-will-use-this-app"><a href="#Django-starts-so-that-shared-task-will-use-this-app" class="headerlink" title="Django starts so that shared_task will use this app."></a>Django starts so that shared_task will use this app.</h1><p>from .celery import app as celery_app</p>
<p>__all__ &#x3D; (‘celery_app’,)</p>
<p>上面这段固定的，不用改</p>
<h3 id="tasks任务"><a href="#tasks任务" class="headerlink" title="tasks任务"></a>tasks任务</h3><hr>
<p>在app下新建tasks.py,必须要是tasks.py文件名称，django会自动查找到app下的该文件</p>
<p>from __future__ import absolute_import<br>from celery import shared_task</p>
<p>@shared_task<br>def add(x, y):<br>    print(“task———-111111———-“)<br>    return x + y</p>
<p>@shared_task<br>def mul(x, y):<br>    print(“task———-22222———-“)<br>    return x * y</p>
<p>tasks.py可以写任务函数add、mul，让它生效的最直接的方法就是添加app.task 或shared_task 这个装饰器</p>
<h3 id="添加setting配置"><a href="#添加setting配置" class="headerlink" title="添加setting配置"></a>添加setting配置</h3><hr>
<p>setting.py添加配置</p>
<p>CELERY_TASK_SERIALIZER &#x3D; ‘json’<br>CELERY_RESULT_SERIALIZER &#x3D; ‘json’<br>CELERY_ACCEPT_CONTENT&#x3D;[‘json’]<br>CELERY_TIMEZONE &#x3D; ‘Asia&#x2F;Shanghai’<br>CELERY_ENABLE_UTC &#x3D; True</p>
<h1 id="celery-配置连接redis"><a href="#celery-配置连接redis" class="headerlink" title="celery 配置连接redis"></a>celery 配置连接redis</h1><p>BROKER_URL &#x3D; ‘redis:&#x2F;&#x2F;192.168.1.1:6379’<br>CELERY_RESULT_BACKEND &#x3D; ‘redis:&#x2F;&#x2F;192.168.1.1:6379’</p>
<h1 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h1><p>from celery.schedules import crontab<br>from datetime import timedelta</p>
<p>CELERYBEAT_SCHEDULE &#x3D; {<br>    ‘add’: {<br>        ‘task’: ‘yoyo(django app名称).tasks.add’,  # 任务<br>        ‘schedule’: timedelta(seconds&#x3D;5),  # 每5秒执行add函数<br>        ‘args’: (11, 12)  # 运行参数<br>    },<br>    ‘mul’: {<br>        ‘task’: ‘yoyo(django app名称).tasks.mul’,  # 任务<br>        ‘schedule’: timedelta(seconds&#x3D;10),  # 每10秒执行mul函数<br>        ‘args’: (11, 2)  # 运行参数<br>    }<br>}</p>
<p>CELERYBEAT_SCHEDULE 是配置定时任务，可以添加多个任务，任务名称可以与tasks中的函数名称保持一致,也可以自己定义一个任务名称。</p>
<ul>
<li>task 参数是对应app目录下的tasks文件中任务函数名称</li>
<li>schedule 运行周期，支持contrab表达式</li>
<li>args 运行任务时候带上的参数</li>
</ul>
<h3 id="启动worker-和beat服务"><a href="#启动worker-和beat服务" class="headerlink" title="启动worker 和beat服务"></a>启动worker 和beat服务</h3><hr>
<p>启动worker,执行任务</p>
<p>celery -A MyDjango(django 项目名称) worker -l info</p>
<p>运行日志</p>
<p>D:\202107django\MyDjango&gt;celery -A MyDjango worker -l info</p>
<p> ————– celery@DESKTOP-HJ487C8 v3.1.26.post2 (Cipater)<br>—- **** —–<br>— * ***  * – Windows-10-10.0.17134-SP0<br>– * - **** —</p>
<ul>
<li>** ———- [config]</li>
<li>** ———- .&gt; app:         yoyo:0x219342ff978</li>
<li>** ———- .&gt; transport:   redis:&#x2F;&#x2F;192.168.1.1:6379&#x2F;&#x2F;</li>
<li>** ———- .&gt; results:     redis:&#x2F;&#x2F;192.168.1.1:6379&#x2F;</li>
<li>*** — * — .&gt; concurrency: 4 (prefork)</li>
</ul>
<p>– ******* —-<br>— ***** —– [queues]<br> ————– .&gt; celery           exchange&#x3D;celery(direct) key&#x3D;celery</p>
<p>[tasks]<br>  . yoyo.tasks.add<br>  . yoyo.tasks.mul</p>
<p>[2021-10-21 12:20:32,079: INFO&#x2F;MainProcess] Connected to redis:&#x2F;&#x2F;192.168.1.1:6379&#x2F;&#x2F;<br>[2021-10-21 12:20:32,167: INFO&#x2F;MainProcess] mingle: searching for neighbors<br>[2021-10-21 12:20:33,700: INFO&#x2F;MainProcess] mingle: all alone</p>
<p>启动beat 定时任务监听</p>
<p>celery -A MyDjango(django 项目名称) beat -l info</p>
<p>启动日志</p>
<p>MyDjango&gt;celery -A MyDjango beat -l info<br>celery beat v3.1.26.post2 (Cipater) is starting.<br>__    -    … __   -        _<br>Configuration -&gt;<br>    . broker -&gt; redis:&#x2F;&#x2F;192.168.1.1:6379&#x2F;&#x2F;<br>    . loader -&gt; celery.loaders.app.AppLoader<br>    . scheduler -&gt; celery.beat.PersistentScheduler<br>    . db -&gt; celerybeat-schedule<br>    . logfile -&gt; [stderr]@%INFO<br>    . maxinterval -&gt; now (0s)<br>[2021-10-21 12:22:56,867: INFO&#x2F;MainProcess] beat: Starting…</p>
<p>启动完成后，会看到beat运行日志，定时任务已经推过去<br><img src="https://img-blog.csdnimg.cn/0851991c8310494cb95ce9d43b4dbc81.png" alt="在这里插入图片描述"></p>
<p>worker运行日志，执行任务<br><img src="https://img-blog.csdnimg.cn/e51a26b60bdc4540afda11125b5de1df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="crontab-周期任务"><a href="#crontab-周期任务" class="headerlink" title="crontab 周期任务"></a>crontab 周期任务</h3><hr>
<p>前面是设置每多少秒执行任务，这个只是测试下功能，任务很简单，我们一般用crontab 实现周期性任务，比如每周1-5早上执行一遍任务，用crontab 可以轻松实现</p>
<p># crontab任务</p>
<h1 id="每周一8-30调用task-add"><a href="#每周一8-30调用task-add" class="headerlink" title="每周一8:30调用task.add"></a>每周一8:30调用task.add</h1><p>from celery.schedules import crontab</p>
<p>CELERYBEAT_SCHEDULE &#x3D; {<br>    # Executes every Monday morning at 8:30 A.M<br>    ‘add’: {<br>        ‘task’: ‘yoyo(django app名称).tasks.add’,  # 任务<br>        ‘schedule’: crontab(hour&#x3D;8, minute&#x3D;30, day_of_week&#x3D;1),<br>        ‘args’: (11, 12)  # 运行参数<br>    }<br>}</p>
<p>crontab定时任务命令规则：</p>
<p>分</p>
<p>时</p>
<p>天</p>
<p>月</p>
<p>星期</p>
<p>命令</p>
<p>路径</p>
<p>minute</p>
<p>hour</p>
<p>day</p>
<p>month</p>
<p>week</p>
<p>command</p>
<p>path</p>
<p>*</p>
<p>*</p>
<p>*</p>
<p>*</p>
<p>*</p>
<p>command</p>
<p>path</p>
<ul>
<li>minute：<br>表示分钟，可以是从0到59之间的任何整数。</li>
<li>hour：<br>表示小时，可以是从0到23之间的任何整数。</li>
<li>day：<br>表示日期，可以是从1到31之间的任何整数。</li>
<li>month：<br>表示月份，可以是从1到12之间的任何整数。</li>
<li>week：<br>表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li>
<li>command：<br>要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li>
<li>path：<br>需执行的文件，用绝对路径</li>
</ul>
<p>crontab命令常用的特殊字符</p>
<p>符号</p>
<p>说明</p>
<p>*</p>
<p>表示任何时刻</p>
<p>,</p>
<p>表示分割</p>
<p>-</p>
<p>表示一个段，如第二段里：1-5，就表示1到5点</p>
<p>&#x2F;n</p>
<p>表示每个n的单位执行一次，如第二段里，*&#x2F;1, 就表示每隔1个小时执行一次命令。也可以写成1-23&#x2F;1</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Celery</tag>
        <tag>python</tag>
        <tag>定时任务</tag>
        <tag>beat</tag>
        <tag>cronta</tag>
      </tags>
  </entry>
  <entry>
    <title>python连接oracle数据库</title>
    <url>/2021/06/29/python%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-65.png"></p>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>使用第三方模块 <code>cx_Oracle</code>·</p>
<p>pip install cx_Oracle</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>import cx_Oracle as cx</p>
<p>#第一种</p>
<p>con &#x3D; cx.connect(‘root’, ‘123456’, ‘127.0.0.1:1521&#x2F;orcl’)</p>
<p>#第二种</p>
<p>con &#x3D; cx.connect(‘root&#x2F;<a href="mailto:&#x31;&#50;&#51;&#x34;&#x35;&#54;&#x40;&#49;&#x32;&#x37;&#46;&#x30;&#46;&#x30;&#x2e;&#x31;">&#x31;&#50;&#51;&#x34;&#x35;&#54;&#x40;&#49;&#x32;&#x37;&#46;&#x30;&#46;&#x30;&#x2e;&#x31;</a>:1521&#x2F;orcl’)</p>
<p>#第三种</p>
<p>dsn &#x3D; cx.makedsn(‘127.0.0.1’, ‘1521’, ‘orcl’)<br>connection &#x3D; cx.connect(‘root’, ‘123456’, dsn)</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p># -*- coding: utf-8 -*-<br>import cx_Oracle as cx      #导入模块<br>con &#x3D; cx.connect(‘root’, ‘123456’, ‘192.168.80.208&#x2F;orcl’)  #创建连接<br>cursor &#x3D; con.cursor()       #创建游标<br>cursor.execute(“select sysdate from dual”)  #执行sql语句<br>data &#x3D; cursor.fetchone()        #获取一条数据<br>print(data)     #打印数据<br>cursor.close()  #关闭游标<br>con.close()     #关闭数据库连接</p>
<p>oracle 数据库的操作和mysql 的pymysql 操作基本相同，可以参考pymysql使用</p>
<h3 id="启动python程序"><a href="#启动python程序" class="headerlink" title="启动python程序"></a>启动python程序</h3><p>python3 main.py<br>leenhem@DESKTOP-0ACGT17:&#x2F;mnt&#x2F;c&#x2F;workspace&#x2F;code&#x2F;tmp&#x2F;pyoracle$ python3 main.py<br>Traceback (most recent call last):<br>  File “main.py”, line 3, in <module><br>    con &#x3D; cx.connect(‘root’, ‘123456’, ‘192.168.80.208&#x2F;orcl’)  #创建连接<br>cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle Client library: “libclntsh.so: cannot open shared object file: No such file or directory”. See <a href="https://cx-oracle.readthedocs.io/en/latest/user/_guide/installation.html">https://cx-oracle.readthedocs.io/en/latest/user\_guide/installation.html</a> for help</p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle Client library: “libclntsh.so: cannot open shared object file: No such file or directory</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="下载Oracle服务器端对应的Client版本"><a href="#下载Oracle服务器端对应的Client版本" class="headerlink" title="下载Oracle服务器端对应的Client版本"></a>下载Oracle服务器端对应的Client版本</h4><p><a href="https://www.oracle.com/database/technologies/instant-client/downloads.html">https://www.oracle.com/database/technologies/instant-client/downloads.html</a></p>
<p>我用的是 instantclient_12_2</p>
<p>leenhem@DESKTOP-0ACGT17:&#x2F;mnt&#x2F;c&#x2F;workspace&#x2F;code&#x2F;tmp&#x2F;pyoracle$ ls &#x2F;mnt&#x2F;c&#x2F;instantclient_12_2&#x2F; -l<br>total 216684<br>-rwxrwxrwx 1 leenhem leenhem       363 Jan 26  2017 BASIC_README<br>-rwxrwxrwx 1 leenhem leenhem     44220 Jan 26  2017 adrci<br>-rwxrwxrwx 1 leenhem leenhem     57272 Jan 26  2017 genezi<br>-rwxrwxrwx 1 leenhem leenhem  71638263 Jan 26  2017 libclntsh.so.12.1<br>-rwxrwxrwx 1 leenhem leenhem   8033199 Jan 26  2017 libclntshcore.so.12.1<br>-rwxrwxrwx 1 leenhem leenhem   2981501 Jan 26  2017 libipc1.so<br>-rwxrwxrwx 1 leenhem leenhem    539065 Jan 26  2017 libmql1.so<br>-rwxrwxrwx 1 leenhem leenhem   6568149 Jan 26  2017 libnnz12.so<br>-rwxrwxrwx 1 leenhem leenhem   2218687 Jan 26  2017 libocci.so.12.1<br>-rwxrwxrwx 1 leenhem leenhem 124771800 Jan 26  2017 libociei.so<br>-rwxrwxrwx 1 leenhem leenhem    158543 Jan 26  2017 libocijdbc12.so<br>-rwxrwxrwx 1 leenhem leenhem    380996 Jan 26  2017 libons.so<br>-rwxrwxrwx 1 leenhem leenhem    116563 Jan 26  2017 liboramysql12.so<br>-rwxrwxrwx 1 leenhem leenhem   4036257 Jan 26  2017 ojdbc8.jar<br>-rwxrwxrwx 1 leenhem leenhem    240476 Jan 26  2017 uidrvci<br>-rwxrwxrwx 1 leenhem leenhem     74230 Jan 26  2017 xstreams.jar</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>添加 LD_LIBRARY_PATH&#x3D;&#x2F;mnt&#x2F;c&#x2F;instantclient_12_2&#x2F;</p>
<p>vim ~&#x2F;.bashrc<br>export LD_LIBRARY_PATH&#x3D;&#x2F;mnt&#x2F;c&#x2F;instantclient_12_2&#x2F;</p>
<h3 id="使环境变量生效"><a href="#使环境变量生效" class="headerlink" title="使环境变量生效"></a>使环境变量生效</h3><p>source ~&#x2F;.bashrc</p>
<h3 id="再次运行"><a href="#再次运行" class="headerlink" title="再次运行"></a>再次运行</h3><p>python 代码 连接数据库成功</p>
<p>9leenhem@DESKTOP-0ACGT17:&#x2F;mnt&#x2F;c&#x2F;workspace&#x2F;code&#x2F;tmp&#x2F;pyoracle$ python3 main.py<br>(datetime.datetime(2021, 6, 28, 11, 5, 16),)</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Oracle</tag>
        <tag>cx_Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ启动后没有绑定IP_报错SECURITY VIOLATION - scripts are being executed but script_security not enabled</title>
    <url>/2021/08/29/rabbitmq%E5%90%AF%E5%8A%A8%E5%90%8E%E6%B2%A1%E6%9C%89%E7%BB%91%E5%AE%9Aip-%E6%8A%A5%E9%94%99security-violation-scripts-are-being-executed-but-script-security-not-enabled/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-26.png"></p>
<h3 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h3><hr>
<p>RabbitMQ高可用架构图：<br><a href="https://www.processon.com/view/link/61289f8763768957962ee433">https://www.processon.com/view/link/61289f8763768957962ee433</a><br>启动Keepalived后VIP没有绑定到网卡上，报错</p>
<p>Keepalived_vrrp[12186]: WARNING - default user ‘keepalived_script’ for script execution does not exist - please create.<br>Keepalived_vrrp[12186]: Truncating auth_pass to 8 characters<br>Keepalived_vrrp[12186]: SECURITY VIOLATION - scripts are being executed but script_security not enabled.</p>
<h3 id="具体报错内容"><a href="#具体报错内容" class="headerlink" title="具体报错内容"></a>具体报错内容</h3><hr>
<p>Aug 27 15:48:06 BJOIS-AS systemd: Starting LVS and VRRP High Availability Monitor…<br>Aug 27 15:48:06 BJOIS-AS Keepalived[12183]: Starting Keepalived v1.3.5 (03&#x2F;19,2017), git commit v1.3.5-6-g6fa32f2<br>Aug 27 15:48:06 BJOIS-AS Keepalived[12183]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 15:48:06 BJOIS-AS systemd: Started LVS and VRRP High Availability Monitor.<br>Aug 27 15:48:06 BJOIS-AS Keepalived[12184]: Starting Healthcheck child process, pid&#x3D;12185<br>Aug 27 15:48:06 BJOIS-AS Keepalived_healthcheckers[12185]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 15:48:06 BJOIS-AS Keepalived[12184]: Starting VRRP child process, pid&#x3D;12186<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: Registering Kernel netlink reflector<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: Registering Kernel netlink command channel<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: Registering gratuitous ARP shared channel<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: WARNING - default user ‘keepalived_script’ for script execution does not exist - please create.<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: Truncating auth_pass to 8 characters<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: SECURITY VIOLATION - scripts are being executed but script_security not enabled.<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: VRRP_Instance(VI_1) removing protocol VIPs.<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: Using LinkWatch kernel netlink reflector…<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: VRRP_Instance(VI_1) Entering BACKUP STATE<br>Aug 27 15:48:06 BJOIS-AS Keepalived_vrrp[12186]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]<br>Aug 27 15:48:06 BJOIS-AS Keepalived[12184]: Stopping<br>Aug 27 15:48:06 BJOIS-AS systemd: Stopping LVS and VRRP High Availability Monitor…<br>Aug 27 15:48:06 BJOIS-AS Keepalived_healthcheckers[12185]: Stopped<br>Aug 27 15:48:07 BJOIS-AS Keepalived_vrrp[12186]: Stopped<br>Aug 27 15:48:07 BJOIS-AS Keepalived[12184]: Stopped Keepalived v1.3.5 (03&#x2F;19,2017), git commit v1.3.5-6-g6fa32f2<br>Aug 27 15:48:07 BJOIS-AS systemd: Stopped LVS and VRRP High Availability Monitor.</p>
<h3 id="第一个问题WARNING-default-user-‘keepalived-script’-for-script-execution-does-not-exist-please-create"><a href="#第一个问题WARNING-default-user-‘keepalived-script’-for-script-execution-does-not-exist-please-create" class="headerlink" title="第一个问题WARNING - default user ‘keepalived_script’ for script execution does not exist - please create."></a>第一个问题WARNING - default user ‘keepalived_script’ for script execution does not exist - please create.</h3><hr>
<p>WARNING - default user ‘keepalived_script’ for script execution does not exist - please create.</p>
<p>这个错误的原因在于配置文件的错误，在global_defs中加入如下两行即可。</p>
<p># 运行脚本的用户名和组。默认使用用户的默认组。如未指定，默认为keepalived_script 用户，如无此用户，则使用root<br>script_user root</p>
<p>重启服务</p>
<p>systemctl restart keepalived.service</p>
<p>查看日志</p>
<p>Aug 27 16:29:34 BJOIS-AS systemd: Starting LVS and VRRP High Availability Monitor…<br>Aug 27 16:29:34 BJOIS-AS Keepalived[23064]: Starting Keepalived v1.3.5 (03&#x2F;19,2017), git commit v1.3.5-6-g6fa32f2<br>Aug 27 16:29:34 BJOIS-AS Keepalived[23064]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 16:29:34 BJOIS-AS Keepalived[23065]: Starting Healthcheck child process, pid&#x3D;23066<br>Aug 27 16:29:34 BJOIS-AS systemd: Started LVS and VRRP High Availability Monitor.<br>Aug 27 16:29:34 BJOIS-AS Keepalived[23065]: Starting VRRP child process, pid&#x3D;23067<br>Aug 27 16:29:34 BJOIS-AS Keepalived_healthcheckers[23066]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: Registering Kernel netlink reflector<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: Registering Kernel netlink command channel<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: Registering gratuitous ARP shared channel<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: Truncating auth_pass to 8 characters<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: SECURITY VIOLATION - scripts are being executed but script_security not enabled.<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: VRRP_Instance(VI_1) removing protocol VIPs.<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: Using LinkWatch kernel netlink reflector…<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: VRRP_Instance(VI_1) Entering BACKUP STATE<br>Aug 27 16:29:34 BJOIS-AS Keepalived_vrrp[23067]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]<br>Aug 27 16:29:34 BJOIS-AS Keepalived[23065]: Stopping<br>Aug 27 16:29:34 BJOIS-AS systemd: Stopping LVS and VRRP High Availability Monitor…<br>Aug 27 16:29:34 BJOIS-AS Keepalived_healthcheckers[23066]: Stopped<br>Aug 27 16:29:35 BJOIS-AS Keepalived_vrrp[23067]: Stopped<br>Aug 27 16:29:35 BJOIS-AS Keepalived[23065]: Stopped Keepalived v1.3.5 (03&#x2F;19,2017), git commit v1.3.5-6-g6fa32f2<br>Aug 27 16:29:35 BJOIS-AS systemd: Stopped LVS and VRRP High Availability Monitor.</p>
<p>发现还是没有绑定IP</p>
<h3 id="第二个问题SECURITY-VIOLATION-scripts-are-being-executed-but-script-security-not-enabled"><a href="#第二个问题SECURITY-VIOLATION-scripts-are-being-executed-but-script-security-not-enabled" class="headerlink" title="第二个问题SECURITY VIOLATION - scripts are being executed but script_security not enabled."></a>第二个问题SECURITY VIOLATION - scripts are being executed but script_security not enabled.</h3><hr>
<p>SECURITY VIOLATION - scripts are being executed but script_security not enabled.</p>
<p>这个错误的原因在于配置文件的错误，在global_defs中加入如下两行即可。</p>
<p>#路径为非root可写，不要配置脚本为root用户执行。<br>enable_script_security</p>
<p>重启服务</p>
<p>systemctl restart keepalived.service</p>
<p>查看日志</p>
<p>Aug 27 16:34:04 BJOIS-AS systemd: Starting LVS and VRRP High Availability Monitor…<br>Aug 27 16:34:04 BJOIS-AS Keepalived[23137]: Starting Keepalived v1.3.5 (03&#x2F;19,2017), git commit v1.3.5-6-g6fa32f2<br>Aug 27 16:34:04 BJOIS-AS Keepalived[23137]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 16:34:04 BJOIS-AS Keepalived[23138]: Starting Healthcheck child process, pid&#x3D;23139<br>Aug 27 16:34:04 BJOIS-AS systemd: Started LVS and VRRP High Availability Monitor.<br>Aug 27 16:34:04 BJOIS-AS Keepalived[23138]: Starting VRRP child process, pid&#x3D;23140<br>Aug 27 16:34:04 BJOIS-AS keepalived_healthcheckers[23139]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: Registering Kernel netlink reflector<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: Registering Kernel netlink command channel<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: Registering gratuitous ARP shared channel<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: Opening file ‘&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf’.<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: Truncating auth_pass to 8 characters<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: VRRP_Instance(VI_1) removing protocol VIPs.<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: Using LinkWatch kernel netlink reflector…<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: VRRP_Instance(VI_1) Entering BACKUP STATE<br>Aug 27 16:34:04 BJOIS-AS Keepalived_vrrp[23140]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]<br>Aug 27 16:34:05 BJOIS-AS systemd: Stopping LVS and VRRP High Availability Monitor…<br>Aug 27 16:34:05 BJOIS-AS Keepalived[23138]: Stopping<br>Aug 27 16:34:05 BJOIS-AS Keepalived_healthcheckers[23139]: Stopped<br>Aug 27 16:34:06 BJOIS-AS Keepalived_vrrp[23140]: Stopped<br>Aug 27 16:34:06 BJOIS-AS Keepalived[23138]: Stopped Keepalived v1.3.5 (03&#x2F;19,2017), git commit v1.3.5-6-g6fa32f2<br>Aug 27 16:34:06 BJOIS-AS systemd: Stopped LVS and VRRP High Availability Monitor.</p>
<p>日志没有问题，但VIP还是没有绑定到服务器上<br>怎么办</p>
<h3 id="修改检测脚本"><a href="#修改检测脚本" class="headerlink" title="修改检测脚本"></a>修改检测脚本</h3><hr>
<p>haproxy_check2.sh</p>
<p>#!&#x2F;bin&#x2F;bash<br>COUNT&#x3D;`ps -C haproxy –no-header wc -l`<br>T&#x3D;`date ‘+%Y-%m-%d %H:%M:%S’`<br>LOGF&#x3D;’&#x2F;var&#x2F;log&#x2F;keepalived_healthcheckers.log’<br>echo “$T haproxy Number of processes :”$COUNT &gt;&gt; $LOGF<br>echo “$T haproxy processes :” `ps -ef grep haproxy`  &gt;&gt; $LOGF<br>if [ $COUNT -eq 0 ];then<br>echo “$T Stopping keepalived:” &gt;&gt; $LOGF<br>systemctl stop keepalived<br>echo “$T Stoped keepalived :” &gt;&gt; $LOGF<br>fi</p>
<p>我把检测脚本日志写到了&#x2F;var&#x2F;log&#x2F;keepalived_healthcheckers.log里</p>
<h3 id="看一下keepalived-healthcheckers检测日志"><a href="#看一下keepalived-healthcheckers检测日志" class="headerlink" title="看一下keepalived_healthcheckers检测日志"></a>看一下keepalived_healthcheckers检测日志</h3><hr>
<p>2021-08-27 16:47:59 haproxy Number of processes :0<br>2021-08-27 16:47:59 haproxy processes :<br>root 23463 23462 0 16:47 ? 00:00:00 &#x2F;bin&#x2F;bash &#x2F;etc&#x2F;keepalived&#x2F;haproxy_check2.sh<br>root 23468 23463 0 16:47 ? 00:00:00 &#x2F;bin&#x2F;bash &#x2F;etc&#x2F;keepalived&#x2F;haproxy_check2.sh<br>root 23470 23468 0 16:47 ? 00:00:00 grep haproxy<br>2021-08-27 16:47:59 Stopping keepalived:</p>
<p>发现是HAProxy没有启动，好了问题找到了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>keepalived+haproxy 架构时 要先启动haproxy才可以，也可以在检测脚本里面把haproxy拉起来</p>
<p>开机自启也无法保证haproxy启动顺序优先于keepalived，所以开机启动也需要自定义一下，写到rc.local里</p>
<p>附开机启动脚本，大概逻辑是先尝试启动haproxy，启动成功再启动keepalived，启动不成功则退出脚本</p>
<p>#!&#x2F;bin&#x2F;bash<br>T&#x3D;`date ‘+%Y-%m-%d %H:%M:%S’`<br>LOGF&#x3D;’&#x2F;var&#x2F;log&#x2F;autoup_haproxy_keepalived.log’<br>num&#x3D;10<br>#————</p>
<h1 id="start-haproxy"><a href="#start-haproxy" class="headerlink" title="start haproxy"></a>start haproxy</h1><p>#————<br>while true<br>do<br>haproxy_service&#x3D;`systemctl status haproxygrep running`<br>if [ -z “$haproxy_service” ];then<br>if [ $num -eq 60 ];then<br>echo “$T haproxy service start faild” &gt;&gt; $LOGF<br>exit<br>fi<br>echo “$T haproxy service start `expr $num &#x2F; 10`“ &gt;&gt; $LOGF<br>systemctl start haproxy<br>else<br>echo “$T haproxy service start success” &gt;&gt; $LOGF<br>break<br>fi<br>sleep 10<br>num&#x3D;$(($a+10))<br>done<br>#———–</p>
<h1 id="start-keepalived"><a href="#start-keepalived" class="headerlink" title="start keepalived"></a>start keepalived</h1><p>#———–<br>num&#x3D;10<br>while true<br>do<br>keepalived_service&#x3D;`systemctl status keepalivedgrep running`<br>if [ -z “$keepalived_service” ];then<br>if [ $num -eq 60 ];then<br>echo “$T keepalived service start faild” &gt;&gt; $LOGF<br>break<br>fi<br>echo “$T keepalived service start `expr $num &#x2F; 10`“ &gt;&gt; $LOGF<br>systemctl start keepalived<br>else<br>echo “$T keepalived service start success” &gt;&gt; $LOGF<br>break<br>fi<br>sleep 10<br>num&#x3D;$(($a+10))<br>done</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>haproxy</tag>
        <tag>keepalived</tag>
        <tag>keepalived_script</tag>
        <tag>script_security</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ消息队列服务高可用搭建手册</title>
    <url>/2021/06/05/rabbitmq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>注：本文搭建rabbitmq+haproxy+keepalived高可用集群，采用本地下载安装包的形式。</p>
<h2 id="1-帮助"><a href="#1-帮助" class="headerlink" title="1. 帮助"></a>1. 帮助</h2><h3 id="1-1-安装包下载"><a href="#1-1-安装包下载" class="headerlink" title="1.1 安装包下载"></a>1.1 安装包下载</h3><h3 id="1-2-集群运行前提"><a href="#1-2-集群运行前提" class="headerlink" title="1.2 集群运行前提"></a>1.2 集群运行前提</h3><p><strong>1)</strong> 集群所有节点必须运行相同的erlang及Rabbitmq版本。</p>
<p><strong>2)</strong> Hostname解析，节点之间通过域名互相访问，本文为3个节点，使用配置hosts方式。</p>
<h3 id="1-3-端口及协议"><a href="#1-3-端口及协议" class="headerlink" title="1.3 端口及协议"></a>1.3 端口及协议</h3><p><strong>1)</strong> Rabbitmq</p>
<p><strong>4369</strong>(tcp)：erlang进程epmd用来做node连接的</p>
<p><strong>5672</strong>(tcp)：与mq服务通信使用</p>
<p><strong>15672</strong>(tcp)：rabbitmq服务后台管理页面访问端（<a href="http://ip:15672）">http://ip:15672）</a></p>
<p><strong>25672</strong>(tcp)：集群之间访问使用</p>
<p><strong>2)</strong> haproxy</p>
<p><strong>8100</strong>：haproxy控制台访问端口，默认为8100</p>
<p><strong>3)</strong> keepalived</p>
<p>防火墙开启vrrp 协议</p>
<h2 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2. 集群搭建"></a>2. 集群搭建</h2><p>本文按照下图方案部署：</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-21.png"></p>
<h3 id="2-1-Erlang安装"><a href="#2-1-Erlang安装" class="headerlink" title="2.1 Erlang安装"></a>2.1 Erlang安装</h3><p><strong>1)</strong> 安装包 <code>erlang-21.2.5-1.el7.centos.x86_64.rpm</code></p>
<p><strong>2)</strong> 上传到指定目录，运行命令安装（本文安装路径为：&#x2F;usr&#x2F;local）</p>
<p>rpm -ivh erlang-21.2.5-1.el7.centos.x86_64.rpm</p>
<p><strong>3)</strong> 暂时不支持制定路径安装，如果想换路径，用which erl 查看erlang安装地址，erlang被安装到了<code>/usr/lib64/erlang</code> 此目录，此时便可将此目录转移到你想放置的目录。</p>
<p>mv &#x2F;usr&#x2F;lib64&#x2F;erlang&#x2F; &#x2F;usr&#x2F;local&#x2F;</p>
<p><strong>4)</strong> 此时运行命令报错</p>
<p>&#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin&#x2F;erl:行29: &#x2F;usr&#x2F;lib64&#x2F;erlang&#x2F;erts-8.0.3&#x2F;bin&#x2F;erlexe: 没有那个文件或目录</p>
<p>原因在于erl文件中配置了ROOTDIR，使用命令打开erl文件。</p>
<p>vim &#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin&#x2F;erl</p>
<p>#ROOTDIR改为如下，保存。</p>
<p>ROOTDIR&#x3D;”&#x2F;usr&#x2F;local&#x2F;erlang”</p>
<p><strong>5)</strong> 添加环境变量</p>
<p> export ERL_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang<br> export PATH&#x3D;$ERL_HOME&#x2F;bin:$PATH<br> #&#x2F;etc&#x2F;profile更新生效命令<br> source &#x2F;etc&#x2F;profile</p>
<p><strong>6)</strong> 运行erl成功</p>
<p>[root@mq1 ~]# erl<br>Erlang&#x2F;OTP 21 [erts-10.2.3] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]</p>
<p>Eshell V10.2.3  (abort with ^G)</p>
<h3 id="2-2-Rabbitmq单机安装"><a href="#2-2-Rabbitmq单机安装" class="headerlink" title="2.2 Rabbitmq单机安装"></a>2.2 Rabbitmq单机安装</h3><p><strong>1)</strong> rabbitmq-server-3.7.11-1.el7.noarch.rpm安装包。</p>
<p>rpm -ivh rabbitmq-server-3.7.11-1.el7.noarch.rpm</p>
<p><strong>2)</strong> 直接安装rabbitmq可能会报错找不到socat，下载socat-1.7.2.4-1.el7.rf.x86_64.rpm，安装成功后，继续安装rabbitmq便可成功。</p>
<p>rpm -ivh socat-1.7.2.4-1.el7.rf.x86_64.rpm</p>
<p><strong>3)</strong> 修改配置登录用户名，默认guest：guest不让登录了</p>
<p>我们创建管理员用户</p>
<p>rabbitmq设置用户名和密码<br>&#x2F;usr&#x2F;local&#x2F;rabbitmq_server-3.7.0&#x2F;sbin目录下输入</p>
<p>#新增用户<br>.&#x2F;rabbitmqctl add_user zhangsan admin123<br>#设置用户级别<br>#用户级别：<br>#1、administrator 可以登录控制台、查看所有信息、可以对rabbitmq进行管理<br>#2、monitoring  监控者 登录控制台，查看所有信息<br>#3、policymaker  策略制定者  登录控制台,指定策略<br>#4、managment 普通管理员 登录控制台<br>.&#x2F;rabbitmqctl set_user_tags zhangsan administrator</p>
<p><strong>4)</strong> 启动rabbitmq<br>执行命令：</p>
<p>#启动rabbitmq<br>systemctl start rabbitmq-server.service<br>#加入开机自启<br>systemctl enable rabbitmq-server.service</p>
<p><strong>5)</strong> 启用后台管理页面</p>
<p>[root@mq1 ~]# rabbitmq-plugins enable rabbitmq_management<br>Enabling plugins on node rabbit@mq1:<br>rabbitmq_management<br>The following plugins have been configured:<br>  rabbitmq_management<br>  rabbitmq_management_agent<br>  rabbitmq_tracing<br>  rabbitmq_web_dispatch<br>Applying plugin configuration to rabbit@mq1…<br>Plugin configuration unchanged.</p>
<p><strong>6)</strong> rabbitmq单机搭建完成</p>
<p>访问：<a href="http://ip:15672/">http://ip:15672</a></p>
<p><strong>7)</strong> 重复上面上步骤安装三台服务器</p>
<h3 id="2-3-集群搭建"><a href="#2-3-集群搭建" class="headerlink" title="2.3 集群搭建"></a>2.3 集群搭建</h3><p>本文搭建使用三台linux机器（假设：ip1,ip2,ip3）</p>
<h4 id="2-3-1-环境准备"><a href="#2-3-1-环境准备" class="headerlink" title="2.3.1 环境准备"></a>2.3.1 环境准备</h4><p><strong>1)</strong> erlang进程需要host来进行连接，所以它会检查你的hosts配置，而rabbitmq集群之间是通过erlang进程epmd用来做node连接的。三台服务需要修改其对应的hostname为mq1、mq2、mq3，并且每台机器hosts文件需要配置下面3行:</p>
<p>Ip1 mq1<br>Ip2 mq2<br>Ip3 mq3</p>
<p><strong>2)</strong> 寻找rabbitmq安装路径，修改.erlang.cookie 文件中的字符串，让每台服务器保持一致<br>尽量使用scp命令复制：</p>
<p>scp -r &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@ip2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;</p>
<p>复制前修改文件权限，复制完要恢复文件权限（修改权限命令：<code>chmod 400 .erlang.cookie</code>）</p>
<p><strong>3)</strong> 三台mq服务启动成功后，停止三台mq的服务</p>
<p>rabbitmqctl stop_app</p>
<p><strong>4)</strong> 加入集群命令（在其他两个几点mq2、ma3上运行）</p>
<p>rabbitmqctl stop_app（因为之前停止了，所以可能会报错，不用管。）</p>
<p>rabbitmqctl join_cluster rabbit@mq1 (这里的mq1，主节点的主机名)</p>
<p>rabbitmqctl start_app</p>
<p><strong>5)</strong> 访问控制台，搭建成功</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-20-1024x475.png"></p>
<h2 id="2-配置haproxy"><a href="#2-配置haproxy" class="headerlink" title="2. 配置haproxy"></a>2. 配置haproxy</h2><p>Haproxy是一款提供高可用性、负载均衡以及基于tcp和http应用的代理软件。</p>
<p>使用rpm安装包：haproxy-1.5.18-8.el7.x86_64.rpm</p>
<p><strong>1)</strong> 安装haproxy</p>
<p>rpm -ivh haproxy-1.5.18-8.el7.x86_64.rpm</p>
<p><strong>2)</strong> 配置文件放到&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</p>
<p>cat &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg<br>#logging options<br>global<br>log 127.0.0.1 local0 info<br>maxconn 5120<br>chroot &#x2F;usr&#x2F;local&#x2F;haproxy<br>uid 99<br>gid 99<br>daemon<br>quiet<br>nbproc 20<br>pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid</p>
<p>defaults<br>log global<br>#使用4层代理模式，”mode http”为7层代理模式<br>mode tcp<br>#if you set mode to tcp,then you nust change tcplog into httplog<br>option tcplog<br>option dontlognull<br>retries 3<br>option redispatch<br>maxconn 2000<br>contimeout 5s<br>     ##客户端空闲超时时间为 60秒 则HA 发起重连机制<br>     clitimeout 60s<br>     ##服务器端链接超时时间为 15秒 则HA 发起重连机制<br>     srvtimeout 15s<br>#front-end IP for consumers and producters</p>
<p>listen rabbitmq_cluster<br>bind 0.0.0.0:5672<br>#配置TCP模式<br>mode tcp<br>#balance url_param userid<br>#balance url_param session_id check_post 64<br>#balance hdr(User-Agent)<br>#balance hdr(host)<br>#balance hdr(Host) use_domain_only<br>#balance rdp-cookie<br>#balance leastconn<br>#balance source &#x2F;&#x2F;ip<br>#简单的轮询<br>balance roundrobin<br>        timeout client  3h<br>        timeout server  3h<br>#rabbitmq集群节点配置 #inter 每隔五秒对mq集群做健康检查， 2次正确证明服务器可用，2次失败证明服务器不可用，并且配置主备机制<br>        server mq1 ip1:5672 check inter 5000 rise 2 fall 2<br>        server mq2 ip2:5672 check inter 5000 rise 2 fall 2<br>        server mq3 ip3:5672 check inter 5000 rise 2 fall 2<br>#配置haproxy web监控，查看统计信息<br>listen stats<br>bind 0.0.0.0:8100<br>mode http<br>option httplog<br>stats enable<br>#设置haproxy监控地址为<a href="http://localhost:8100/rabbitmq-stats">http://localhost:8100/rabbitmq-stats</a><br>stats uri &#x2F;rabbitmq-stats<br>stats refresh 5s</p>
<p>haproxy.cfg需要注意haproxy安装目录，rpm安装位置为usr&#x2F;lib&#x2F;haproxy</p>
<p><strong>3)</strong> 启动服务</p>
<p>[root@haproxy2 ~]# systemctl start haproxy.service</p>
<p><strong>4)</strong> 搭建成功，访问以下地址可以对mq节点进行监控<br><a href="http://192.168.65.115:8100/rabbitmq-stats">http://192.168.65.115:8100/rabbitmq-stats</a></p>
<p><strong>5)</strong> 关闭haproxy</p>
<p>[root@haproxy2 ~]# systemctl stop haproxy.service</p>
<p><strong>6)</strong> 需要几台haproxy就安装几台，重复上面步骤就可以</p>
<h2 id="3-Keepalived安装"><a href="#3-Keepalived安装" class="headerlink" title="3. Keepalived安装"></a>3. Keepalived安装</h2><p>简介，它是一个高性能的服务器高可用或热备解决方案，主要作用是为了防止服务单点故障问题，可以通过和nginx、haproxy等反向代理的负载均衡来实现与web服务端的高可用。Keepalived以vrrp协议为主，vrrp协议将两台或多台路由设备虚拟为一个设备，对外提供虚拟路由ip。</p>
<p>使用安装包：keepalived-1.2.18.tar.gz</p>
<p><strong>1)</strong> yum安装环境依赖</p>
<p>yum install gcc -y<br>yum install -y openssl openssl-devel<br>yum install -y libnfnetlink-devel<br>yum -y install libnl libnl-devel</p>
<p><strong>2)</strong> 安装keepalived</p>
<p>tar -zxvf keepalived-1.2.18.tar.gz<br>cd keepalived-2.0.10&#x2F;<br>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;keepalived<br> make<br> make install<br> cp &#x2F;usr&#x2F;local&#x2F;keepalived&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf &#x2F;etc&#x2F;keepalived&#x2F;<br> cp &#x2F;usr&#x2F;local&#x2F;keepalived&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;keepalived &#x2F;etc&#x2F;init.d&#x2F;<br> cp &#x2F;usr&#x2F;local&#x2F;keepalived&#x2F;etc&#x2F;sysconfig&#x2F;keepalived &#x2F;etc&#x2F;sysconfig&#x2F;<br> ln -s &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;kee &#x2F;usr&#x2F;sbin&#x2F;<br> ln -s &#x2F;usr&#x2F;local&#x2F;keepalived&#x2F;sbin&#x2F;keepalived &#x2F;sbin&#x2F;</p>
<p><strong>3)</strong> 设置开机自启动</p>
<p>systemctl enable keepalived</p>
<p>**4) ** 添加keepalived_check.sh脚本文件至&#x2F;etc&#x2F;keepalived</p>
<p>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived_check.sh</p>
<p>#!&#x2F;bin&#x2F;bash<br>COUNT&#x3D;`ps -C haproxy –no-header wc -l`<br>if [ $COUNT -eq 0 ];then<br>   systemctl stop keepalived<br>fi</p>
<p>chmod +x &#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh</p>
<p><strong>5)</strong> 配置keepalived.conf文件，可根据注释修改配置</p>
<p>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf<br>! Configuration File for keepalived</p>
<p>global_defs {<br>   router_id KEEPMQ<br>}</p>
<p>vrrp_script chk_http_port {<br>    script “&#x2F;etc&#x2F;keepalived&#x2F;keepalived_check.sh”<br>    interval 1<br>    weight -2<br>}</p>
<p>vrrp_instance VI_1 {<br>    state MASTER<br>    interface eth0<br>    virtual_router_id 136<br>    priority 100<br>    advert_int 1<br>    authentication {<br>        auth_type PASS<br>        auth_pass 1111<br>    }<br>    unicast_src_ip 10.64.35.136 #本地IP地址<br>    unicast_peer {<br>    10.64.35.137 #对端IP地址,此地址一定不能忘记<br>    }<br>    virtual_ipaddress {<br>        10.64.35.156 #虚拟ip<br>    }<br>    track_script {<br>    chk_http_port<br>    }</p>
<p>}</p>
<p><strong>6)</strong> 可能遇见主备双机同时拥有vip的问题<br>第一种办法设置混杂模式</p>
<p>ifconfig eth0 promisc#设置混杂模式<br>ifconfig eth0 promisc #取消混杂模式</p>
<p>第二种：centos7 默认防火墙firewall<br>开启vrrp 协议，主备都运行下面的命令</p>
<p>firewall-cmd –direct –permanent –add-rule ipv4 filter INPUT 0 –protocol vrrp -j ACCEPT &amp;&amp; firewall-cmd –reload</p>
]]></content>
      <categories>
        <category>keepalived</category>
        <category>haproxy</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>haproxy</tag>
        <tag>keepalived</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ脑裂解决方案Mnesia reports that this RabbitMQ cluster has experienced a network partition.</title>
    <url>/2021/09/02/rabbitmq%E8%84%91%E8%A3%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88mnesia-reports-that-this-rabbitmq-cluster-has-experienced-a-network-partition/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>目前生产环境RabbitMQ集群分布在铜牛机房和马驹桥机房，其中铜牛机房两个节点，马驹桥机房两个节点；</p>
<p>当铜牛和马驹桥机房之间网络中断或者有较大波动时，RabbitMQ集群会发生网络分区（脑裂），分成两个分区，当网络恢复时，网络分区的状态还是会保持，除非采取一些措施去解决，造成消息消费异常等问题。</p>
<h3 id="网络分区处理方式"><a href="#网络分区处理方式" class="headerlink" title="网络分区处理方式"></a>网络分区处理方式</h3><hr>
<p>处理网络分区的方式有两种：</p>
<ol>
<li>手动处理网络分区：挑选一个信任的分区，重启其他分区的节点；</li>
<li>自动处理网络分区</li>
</ol>
<p>RabbitMQ提供了4种处理网络分区的方式，在rabbitmq.config中配置cluster_partition_handling参数即可，分别为：</p>
<ul>
<li>ignore</li>
<li>pause_minority</li>
<li>pause_if_all_down</li>
<li>autoheal</li>
</ul>
<ol>
<li><strong>ignore</strong>：默认是ignore，ignore的配置是当网络分区的时候，RabbitMQ不会自动做任何处理，即需要手动处理。</li>
<li><strong>pause_minority</strong>：当发生网络分区时，集群中的节点在观察到某些节点down掉时，会自动检测其自身是否处于少数派（小于或者等于集群中一半的节点数）。少数派中的节点在分区发生时会自动关闭（类似于执行了rabbitmqctl stop_app命令），当分区结束时又会启动。处于关闭的节点会每秒检测一次是否可连通到剩余集群中，如果可以则启动自身的应用，相当于执行rabbitmqctl start_app命令。这种处理方式适合集群节点数大于2个且最好为奇数的情况。</li>
<li><strong>pause_if_all_down</strong>：在pause_if_all_down模式下，RabbitMQ会自动关闭不能和list中节点通信的节点。语法为{pause_if_all_down, [nodes], ignoreautoheal}，其中[nodes]即为前面所说的list。如果一个节点与list中的所有节点都无法通信时，自关闭其自身。如果list中的所有节点都down时，其余节点如果是ok的话，也会根据这个规则去关闭其自身，此时集群中所有的节点会关闭。如果某节点能够与list中的节点恢复通信，那么会启动其自身的RabbitMQ应用，慢慢的集群可以恢复。为什么这里会有ignore和autoheal两种不同的配置，考虑这样一种情况：有两个节点node1和node2在机架A上，node3和node4在机架B上，此时机架A和机架B的通信出现异常，如果此时使用pause-minority的话会关闭所有的节点，如果此时采用pause-if-all-down，list中配置成[‘node1’,’node3’]的话，集群中的4个节点都不会关闭，但是会形成两个分区，此时就需要ignore或者autoheal来指引如何处理此种分区的情形。</li>
<li><strong>autoheal</strong>：在autoheal模式下，当认为发生网络分区时，RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。一个获胜的分区是指客户端连接最多的一个分区。如果产生一个平局，既有两个或者多个分区的客户端连接数一样多，那么节点数最多的一个分区就是获胜的分区。如果此时节点数也一样多，将会以参数输入的顺序来挑选获胜分区。</li>
</ol>
<h3 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h3><hr>
<ul>
<li><strong>ignore</strong>：适用于网络很可靠或者只有两个节点的集群；</li>
<li><strong>pause_minority</strong>：适用于三机房，每个机房有一个节点或一个以上的集群；</li>
<li><strong>pause_if_all_down</strong>：适用于三机房，每个机房节点数不一样的集群（比如四个节点）；</li>
<li><strong>autoheal</strong>：适用于网络不可靠，只关心服务的连续性而不是数据的完整性。适合有两个节点的集群；</li>
</ul>
<p>经过对比，采用pause_minority方式比较符合当前场景，以下使用这种方案进行测试。</p>
<h3 id="方案测试"><a href="#方案测试" class="headerlink" title="方案测试"></a>方案测试</h3><hr>
<h4 id="1-未加策略前，集群状态正常；"><a href="#1-未加策略前，集群状态正常；" class="headerlink" title="1. 未加策略前，集群状态正常；"></a>1. 未加策略前，集群状态正常；</h4><p><img src="https://img-blog.csdnimg.cn/b0401b90e0ee4eb9b3a182f0ec4379a7.png" alt="在这里插入图片描述"></p>
<h4 id="2-添加iptables策略，模拟网络中断；"><a href="#2-添加iptables策略，模拟网络中断；" class="headerlink" title="2. 添加iptables策略，模拟网络中断；"></a>2. 添加iptables策略，模拟网络中断；</h4><p>网络中断后RabbitMQ服务端口还存在（同机房还可以进行读写）；<br><img src="https://img-blog.csdnimg.cn/5dd35f187ed24e19bd69d67d3bdb24c7.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/78407b61bebe46ec9571a49bc2724dcc.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/def663a204c74f9e8e592d95c014a5b4.png" alt="在这里插入图片描述"></p>
<h4 id="3-关闭iptables策略，检查集群状态，发现集群已经分成两个分区；"><a href="#3-关闭iptables策略，检查集群状态，发现集群已经分成两个分区；" class="headerlink" title="3. 关闭iptables策略，检查集群状态，发现集群已经分成两个分区；"></a>3. 关闭iptables策略，检查集群状态，发现集群已经分成两个分区；</h4><p>重启节点rabbit@sz-145-centos178后集群状态恢复正常。<br><img src="https://img-blog.csdnimg.cn/fa5259930aa441fb88819f279cbc8adc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="4-修改-x2F-etc-x2F-rabbitmq-x2F-rabbitmq-config配置文件，添加pause-minority策略；"><a href="#4-修改-x2F-etc-x2F-rabbitmq-x2F-rabbitmq-config配置文件，添加pause-minority策略；" class="headerlink" title="4. 修改&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config配置文件，添加pause_minority策略；"></a>4. 修改&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config配置文件，添加pause_minority策略；</h4><p><img src="https://img-blog.csdnimg.cn/4af7153b3baa413d856b2130586ffe94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="5-逐一重启所有节点，重启过程中集群状态正常；"><a href="#5-逐一重启所有节点，重启过程中集群状态正常；" class="headerlink" title="5. 逐一重启所有节点，重启过程中集群状态正常；"></a>5. 逐一重启所有节点，重启过程中集群状态正常；</h4><p>重启完成后再次添加iptables策略，模拟网络中断；可以发现添加策略后网络中断时MQ节点检测到自身属于少数节点，所以关闭自身节点，不提供服务；<br><img src="https://img-blog.csdnimg.cn/72baa09fceb64c64bbd086ec976be528.png" alt="在这里插入图片描述"></p>
<h4 id="6-关闭iptables策略，可以看到该节点RabbitMQ服务自动启动，集群状态也正常；"><a href="#6-关闭iptables策略，可以看到该节点RabbitMQ服务自动启动，集群状态也正常；" class="headerlink" title="6. 关闭iptables策略，可以看到该节点RabbitMQ服务自动启动，集群状态也正常；"></a>6. 关闭iptables策略，可以看到该节点RabbitMQ服务自动启动，集群状态也正常；</h4><p><img src="https://img-blog.csdnimg.cn/a2db08ccbdc64c82982c0a43fc14c677.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/4fd8c67504474624b4cf0c2e9c836612.png" alt="在这里插入图片描述"></p>
<h3 id="变更步骤"><a href="#变更步骤" class="headerlink" title="变更步骤"></a>变更步骤</h3><hr>
<ol>
<li>太和桥机房新增一台虚拟机，安装RabbitMQ后将节点加入集群；</li>
<li>修改&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config配置文件，添加pause_minority策略；</li>
<li>逐一重启所有节点，同时将铜牛机房的一个节点剔除集群，保持每个机房一个节点。</li>
</ol>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>RabbitMQ</tag>
        <tag>autoheal</tag>
        <tag>ignore</tag>
        <tag>pause_if_all_down</tag>
        <tag>pause_minority</tag>
        <tag>网络分区</tag>
        <tag>脑裂</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-cluster集群创建异常及常用操作命令</title>
    <url>/2021/05/19/redis-cluster%E9%9B%86%E7%BE%A4%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-40.png"></p>
<h2 id="搭建Redis-cluster集群见问题"><a href="#搭建Redis-cluster集群见问题" class="headerlink" title="搭建Redis-cluster集群见问题"></a>搭建Redis-cluster集群见问题</h2><h3 id="redis-trib-rb-使用密码连接集群"><a href="#redis-trib-rb-使用密码连接集群" class="headerlink" title="redis-trib.rb 使用密码连接集群"></a>redis-trib.rb 使用密码连接集群</h3><p>前面的文档提到的配置，我们都设置的密码<br>如果Redis设定了密码，那么通过<code>redis-trib.rb</code>脚本创建集群时，是会类似这样的错误的：[ERR] Sorry, can’t connect to node <em>.</em>.<em>.</em>:7001<br>[ERR] Sorry, can’t connect to node 192.168.<em>.</em>:7001<br>原因：<br>这是因为redis-trib.rb脚本中连接Redis时，并未设定密码，这确实是个很大的坑。我的解决方法时，修改该脚本中连接Redis时的代码，修改内容如下：</p>
<p>大概是99行<br>把下面内容</p>
<p>@r &#x3D; Redis.new(:host &#x3D;&gt; @info[:host], :port &#x3D;&gt; @info[:port], :timeout &#x3D;&gt; 60)</p>
<p>修改为：</p>
<p>@r &#x3D; Redis.new(:host &#x3D;&gt; @info[:host], :port &#x3D;&gt; @info[:port], :timeout &#x3D;&gt; 60, :password &#x3D;&gt; “123456”)</p>
<p>redis5.0之后的版本就不会有这个问题了</p>
<h3 id="redis集群部署一直卡在Waiting-for-the-cluster-to-join-…"><a href="#redis集群部署一直卡在Waiting-for-the-cluster-to-join-…" class="headerlink" title="redis集群部署一直卡在Waiting for the cluster to join …"></a>redis集群部署一直卡在Waiting for the cluster to join …</h3><p>[root@localhost conf]# redis-trib.rb create –replicas 1 xxxxxxxxxxx</p>
<blockquote>
<blockquote>
<blockquote>
<p>Creating cluster<br>Performing hash slots allocation on 6 nodes…<br>Using 3 masters:<br>192.168.65.171:7001<br>192.168.65.175:7003<br>192.168.65.176:7005<br>Adding replica 192.168.65.175:7004 to 192.168.65.171:7001<br>Adding replica 192.168.65.176:7006 to 192.168.65.175:7003<br>Adding replica 192.168.65.171:7002 to 192.168.65.176:7005<br>M: 9808b9c852bc3e1dbbbd8f7c2e892217370c801d 192.168.65.171:7001<br>   slots:0-5460 (5461 slots) master<br>S: 8085e19aac1485f2804adb6b86f2cce2d045bf16 192.168.65.171:7002<br>   replicates 10b93027efc04877339a3030ecdf09c46fc86e7b<br>M: fd3874bc2ccf78a37dec0ec897650e9c3a0e93fd 192.168.65.175:7003<br>   slots:5461-10922 (5462 slots) master<br>S: 49fbb8e2cae0d9d899f3e3a8ceec474aee692283 192.168.65.175:7004<br>   replicates 9808b9c852bc3e1dbbbd8f7c2e892217370c801d<br>M: 10b93027efc04877339a3030ecdf09c46fc86e7b 192.168.65.176:7005<br>   slots:10923-16383 (5461 slots) master<br>S: 9c9a22f730882bff0b829755f26845e19fff1bee 192.168.65.176:7006<br>   replicates fd3874bc2ccf78a37dec0ec897650e9c3a0e93fd<br>Can I set the above configuration? (type ‘yes’ to accept): yes<br>Nodes configuration updated<br>Assign a different config epoch to each node<br>Sending CLUSTER MEET messages to join the cluster<br>Waiting for the cluster to join………….</p>
</blockquote>
</blockquote>
</blockquote>
<p>接下来 提示 Waiting for the cluster to join… 安装的时候在这里就一直等等等，没反应，傻傻等半天，看这句提示上面一句，Sending Cluster Meet Message to join the Cluster.</p>
<p>正常的解决方法：<br>在 <code>redis-cli -c -h xxx.xxx.xxx.xxx -p 700*</code> 分别进入redis各节点的客户端命令窗口， 依次输入 <code>cluster meet xxx.xxx.xxx.xxx 700* ......</code></p>
<p>回到Server1，已经创建完毕了。</p>
<h3 id="cluster-meet-ip-port命令无效"><a href="#cluster-meet-ip-port命令无效" class="headerlink" title="cluster meet ip port命令无效"></a>cluster meet ip port命令无效</h3><p>这个是困扰了我最久的问题，使用cluster meet ip port命令无效，同时，很少有博客提到redis集群总线的内容，都是叫你关闭防火墙，实际生产中谁会这么做？生产中一般不会关闭防火墙的</p>
<p>首先需要理清一个概念，就是redis集群总线：</p>
<p>redis集群总线端口为redis客户端端口加上10000，比如说你的redis 6379端口为客户端通讯端口，那么16379端口为集群总线端口<br>那么：<br>还有一个需要注意的问题是，iptables或者firewall需要添加对应集群总线端口，如果你把这两个都关了的话可以忽略以下内容：</p>
<p>iptables和firewall的配置参考博客 ：<a href="https://www.code404.icu/213.html">https://www.code404.icu/213.html</a></p>
<p>添加redis集群总线端口和每个redis实例的通信端口即可</p>
<h1 id="redis集群操作"><a href="#redis集群操作" class="headerlink" title="redis集群操作"></a>redis集群操作</h1><h3 id="登录redis集群"><a href="#登录redis集群" class="headerlink" title="登录redis集群"></a>登录redis集群</h3><p>root@localhost conf]# redis-cli -c -h 192.168.65.176 -p 7001 -a 123456<br>192.168.65.176:7001&gt;</p>
<h3 id="查看redis集群信息"><a href="#查看redis集群信息" class="headerlink" title="查看redis集群信息"></a>查看redis集群信息</h3><p>192.168.65.176:7001&gt; CLUSTER INFO<br>cluster_state:ok<br>cluster_slots_assigned:16384<br>cluster_slots_ok:16384<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:3<br>cluster_current_epoch:6<br>cluster_my_epoch:1<br>cluster_stats_messages_ping_sent:60631<br>cluster_stats_messages_pong_sent:60631<br>cluster_stats_messages_sent:121262<br>cluster_stats_messages_ping_received:60626<br>cluster_stats_messages_pong_received:60631<br>cluster_stats_messages_meet_received:5<br>cluster_stats_messages_received:121262<br>192.168.65.176:7001&gt; </p>
<h3 id="列出redis集群节点信息"><a href="#列出redis集群节点信息" class="headerlink" title="列出redis集群节点信息"></a>列出redis集群节点信息</h3><p>192.168.65.176:7001&gt; CLUSTER NODES<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621327172067 4 connected<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 myself,master - 0 1621327172000 1 connected 0-5460<br>13ca1d78a69771be772f9dc2c49bf72291de779e 192.168.65.176:7002@17002 master - 0 1621327172067 2 connected 5461-10922<br>bec54e69084ba31da7f9f64f362229c92458ced5 192.168.65.176:7006@17006 slave 13ca1d78a69771be772f9dc2c49bf72291de779e 0 1621327172067 6 connected<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621327172067 5 connected<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621327172067 3 connected 10923-16383</p>
<h3 id="新增redis集群节点"><a href="#新增redis集群节点" class="headerlink" title="新增redis集群节点"></a>新增redis集群节点</h3><h4 id="在服务器新增一个redis节点"><a href="#在服务器新增一个redis节点" class="headerlink" title="在服务器新增一个redis节点"></a>在服务器新增一个redis节点</h4><p>[root@localhost conf]# cp redis_7006.conf redis_7007.conf<br>[root@localhost conf]# vim redis_7007.conf </p>
<p>bind 192.168.65.176<br>port 7007<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7007.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7007.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7007”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7007.conf<br>cluster-node-timeout 60</p>
<p>[root@localhost conf]# mkdir &#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7007<br>[root@localhost conf]# redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7007.conf</p>
<h4 id="集群中增加redis节点"><a href="#集群中增加redis节点" class="headerlink" title="集群中增加redis节点"></a>集群中增加redis节点</h4><p>192.168.65.176:7001&gt; CLUSTER MEET 192.168.65.176 7007<br>OK<br>192.168.65.176:7001&gt; CLUSTER NODES<br>048083c0ffc5309c87994402b33db74537eb45e3 192.168.65.176:7007@17007 master - 0 1621327679230 0 connected<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621327679230 4 connected<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 myself,master - 0 1621327679000 1 connected 0-5460<br>13ca1d78a69771be772f9dc2c49bf72291de779e 192.168.65.176:7002@17002 master - 0 1621327679230 2 connected 5461-10922<br>bec54e69084ba31da7f9f64f362229c92458ced5 192.168.65.176:7006@17006 slave 13ca1d78a69771be772f9dc2c49bf72291de779e 0 1621327679230 6 connected<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621327679230 5 connected<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621327679230 3 connected 10923-16383</p>
<p>可以看到，新增的节点都是以master身份加入集群的</p>
<h3 id="更换节点身份："><a href="#更换节点身份：" class="headerlink" title="更换节点身份："></a>更换节点身份：</h3><p>将新增的192.168.65.176:7007节点身份改为192.168.65.176:7001的slave</p>
<p>[root@localhost conf]# redis-cli -c -h 192.168.65.176 -p 7007 -a 123456<br>192.168.65.176:7007&gt; CLUSTER REPLICATE 0a856e5007487002cfb70f6c6789223a4bfc05e7<br>OK<br>192.168.65.176:7007&gt; CLUSTER NODES<br>bec54e69084ba31da7f9f64f362229c92458ced5 192.168.65.176:7006@17006 slave 13ca1d78a69771be772f9dc2c49bf72291de779e 0 1621327910379 2 connected<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 master - 0 1621327910379 1 connected 0-5460<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621327910379 3 connected<br>13ca1d78a69771be772f9dc2c49bf72291de779e 192.168.65.176:7002@17002 master - 0 1621327910379 2 connected 5461-10922<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621327910379 3 connected 10923-16383<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621327910379 1 connected<br>048083c0ffc5309c87994402b33db74537eb45e3 192.168.65.176:7007@17007 myself,slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621327910000 0 connected<br>192.168.65.176:7007&gt; </p>
<h3 id="删除redis-cluster节点"><a href="#删除redis-cluster节点" class="headerlink" title="删除redis cluster节点"></a>删除redis cluster节点</h3><h4 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h4><p>无法删除已经登录的节点<br>无法删除自己所属的master节点</p>
<p>192.168.65.176:7007&gt; cluster nodes<br>bec54e69084ba31da7f9f64f362229c92458ced5 192.168.65.176:7006@17006 slave 13ca1d78a69771be772f9dc2c49bf72291de779e 0 1621328097777 2 connected<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 master - 0 1621328097777 1 connected 0-5460<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621328097777 3 connected<br>13ca1d78a69771be772f9dc2c49bf72291de779e 192.168.65.176:7002@17002 master - 0 1621328097777 2 connected 5461-10922<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621328097777 3 connected 10923-16383<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621328097777 1 connected<br>048083c0ffc5309c87994402b33db74537eb45e3 192.168.65.176:7007@17007 myself,slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621328097000 0 connected</p>
<p>192.168.65.176:7007&gt; CLUSTER FORGET 048083c0ffc5309c87994402b33db74537eb45e3<br>(error) ERR I tried hard but I can’t forget myself…<br>192.168.65.176:7007&gt; CLUSTER FORGET 0a856e5007487002cfb70f6c6789223a4bfc05e7<br>(error) ERR Can’t forget my master!<br>192.168.65.176:7007&gt; </p>
<p>192.168.65.176:7007&gt; CLUSTER FORGET bec54e69084ba31da7f9f64f362229c92458ced5<br>OK<br>192.168.65.176:7007&gt; CLUSTER FORGET 13ca1d78a69771be772f9dc2c49bf72291de779e<br>OK<br>192.168.65.176:7007&gt; CLUSTER NODES<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 master - 0 1621328660369 1 connected 0-5460<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621328660369 3 connected<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621328660369 3 connected 10923-16383<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621328660369 1 connected<br>048083c0ffc5309c87994402b33db74537eb45e3 192.168.65.176:7007@17007 myself,slave 0a856e5007487002cfb70f6c6789223a4bfc05e7 0 1621328660000 0 connected<br>192.168.65.176:7007&gt; </p>
<p>可以看到，之前删除的节点又恢复了，这是因为对应的配置文件没有删除</p>
<h2 id="模拟master节点挂掉"><a href="#模拟master节点挂掉" class="headerlink" title="模拟master节点挂掉"></a>模拟master节点挂掉</h2><p>[root@localhost conf]# netstat -nptlgrep 7001<br>tcp        0      0 192.168.65.176:7001     0.0.0.0:*               LISTEN      908&#x2F;redis-server 19<br>tcp        0      0 192.168.65.176:17001    0.0.0.0:*               LISTEN      908&#x2F;redis-server 19<br>[root@localhost conf]# kill -9 908<br>[root@localhost conf]# redis-cli -c -h 192.168.65.176 -p 7007 -a 123456<br>192.168.65.176:7007&gt;<br>192.168.65.176:7007&gt; CLUSTER NODES<br>bec54e69084ba31da7f9f64f362229c92458ced5 192.168.65.176:7006@17006 slave 13ca1d78a69771be772f9dc2c49bf72291de779e 0 1621329155995 2 connected<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 master,fail - 1621329083066 1621329082965 1 disconnected<br>13ca1d78a69771be772f9dc2c49bf72291de779e 192.168.65.176:7002@17002 master - 0 1621329155995 2 connected 5461-10922<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621329155995 3 connected<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621329155995 3 connected 10923-16383<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 master - 0 1621329155995 7 connected 0-5460<br>048083c0ffc5309c87994402b33db74537eb45e3 192.168.65.176:7007@17007 myself,slave 7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 0 1621329155000 0 connected</p>
<p>对应7001的一行可以看到，master fail，状态为disconnected；而对应7005的一行，slave已经变成master。</p>
<h3 id="重新启动-7001-端口节点"><a href="#重新启动-7001-端口节点" class="headerlink" title="重新启动 7001 端口节点"></a>重新启动 7001 端口节点</h3><p>[root@eureka176 conf]# redis-server redis_7001.conf<br>[root@eureka176 conf]# redis-cli -c -h 192.168.65.176 -p 7007 -a 123456<br>192.168.65.176:7007&gt; CLUSTER NODES<br>bec54e69084ba31da7f9f64f362229c92458ced5 192.168.65.176:7006@17006 slave 13ca1d78a69771be772f9dc2c49bf72291de779e 0 1621329255956 2 connected<br>0a856e5007487002cfb70f6c6789223a4bfc05e7 192.168.65.176:7001@17001 slave 7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 0 1621329255956 7 connected<br>13ca1d78a69771be772f9dc2c49bf72291de779e 192.168.65.176:7002@17002 master - 0 1621329255956 2 connected 5461-10922<br>2a4dddc7aa5c124adc0d62bd4ed55d7ce71679bf 192.168.65.176:7004@17004 slave 5cc4d8633f243f1cde83098e87a052f477c2d189 0 1621329255956 3 connected<br>5cc4d8633f243f1cde83098e87a052f477c2d189 192.168.65.176:7003@17003 master - 0 1621329255956 3 connected 10923-16383<br>7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 192.168.65.176:7005@17005 master - 0 1621329255956 7 connected 0-5460<br>048083c0ffc5309c87994402b33db74537eb45e3 192.168.65.176:7007@17007 myself,slave 7e8d7e7ab1d54b859709ff1b3850b624bfd9e9c4 0 1621329255000 0 connected<br>192.168.65.176:7007&gt; </p>
<p>可以看到，7001节点启动后为slave节点，并且是7005的slave节点。即master节点如果挂掉，它的slave节点变为新master节点继续对外提供服务，而原来的master节点如果重启，则变为新master节点的slave节点。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis-cli</tag>
        <tag>redis-cluster</tag>
        <tag>redis-server</tag>
        <tag>redis-trib</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Cluster集群模式部署</title>
    <url>/2021/05/18/redis-cluster%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-39.png"></p>
<h2 id="Cluster模式介绍"><a href="#Cluster模式介绍" class="headerlink" title="Cluster模式介绍"></a>Cluster模式介绍</h2><p>sentinel模式基本可以满足一般生产的需求，具备高可用性。但是当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。</p>
<p>cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。</p>
<p>使用集群，只需要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。</p>
<h2 id="cluster集群特点"><a href="#cluster集群特点" class="headerlink" title="cluster集群特点"></a>cluster集群特点</h2><ul>
<li>多个redis节点网络互联，数据共享</li>
<li>所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用</li>
<li>不支持同时处理多个key（如MSET&#x2F;MGET），因为redis需要把key均匀分布在各个节点上， 并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为</li>
<li>支持在线增加、删除节点</li>
<li>客户端可以连接任何一个主节点进行读写</li>
</ul>
<h2 id="Cluster模式搭建"><a href="#Cluster模式搭建" class="headerlink" title="Cluster模式搭建"></a>Cluster模式搭建</h2><p>环境准备：<br>三台机器，分别开启两个redis服务（端口）</p>
<p>192.168.30.128 端口：7001,7002</p>
<p>192.168.30.129 端口：7003,7004</p>
<p>192.168.30.130 端口：7005,7006</p>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h3 id="安装Redis软件"><a href="#安装Redis软件" class="headerlink" title="安装Redis软件"></a>安装Redis软件</h3><p>去官网找自己需要的版本 <a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a><br>说明：3.0.0之前的版不支持cluster集群模式，我用的版是4.0.8</p>
<h4 id="三台机器上分别执行"><a href="#三台机器上分别执行" class="headerlink" title="三台机器上分别执行"></a>三台机器上分别执行</h4><p>服务器上先安装好gcc环境<br><code>yum install gcc gcc-c++</code></p>
<p>[root@k8s-master01 ~]# wget <a href="https://download.redis.io/releases/redis-4.0.8.tar.gz">https://download.redis.io/releases/redis-4.0.8.tar.gz</a><br>–2021-05-18 09:19:02–  <a href="https://download.redis.io/releases/redis-4.0.8.tar.gz">https://download.redis.io/releases/redis-4.0.8.tar.gz</a><br>正在解析主机 download.redis.io (download.redis.io)… 45.60.125.1<br>正在连接 download.redis.io (download.redis.io)45.60.125.1:443… 已连接。<br>已发出 HTTP 请求，正在等待回应… 200 OK<br>长度：1729973 (1.6M) [application&#x2F;octet-stream]<br>正在保存至: “redis-4.0.8.tar.gz”</p>
<p>redis-4.0.8.tar.gz             100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;]   1.65M  1004KB&#x2F;s  用时 1.7s    </p>
<p>2021-05-18 09:19:13 (1004 KB&#x2F;s) - 已保存 “redis-4.0.8.tar.gz” [1729973&#x2F;1729973])</p>
<p>[root@k8s-master01 ~]# tar -xf redis-4.0.8.tar.gz<br>[root@k8s-master01 ~]# cd redis-4.0.8&#x2F;<br>[root@k8s-master01 redis-4.0.8]# ls<br>00-RELEASENOTES  CONTRIBUTING  deps     Makefile   README.md   runtest          runtest-sentinel  src    utils<br>BUGS             COPYING       INSTALL  MANIFESTO  redis.conf  runtest-cluster  sentinel.conf     tests<br>[root@k8s-master01 redis-4.0.8]# make PREFIX&#x3D;&#x2F;data&#x2F;redis install  #服务器上没有gcc环境会报错<br>.<br>.<br>.<br>过程省略<br>[root@k8s-master01 redis-4.0.8]# cd &#x2F;data&#x2F;redis&#x2F;<br>[root@k8s-master01 redis]# ll<br>total 0<br>drwxr-xr-x. 2 root root 134 May 18 08:54 bin<br>[root@k8s-master01 redis]# mkdir conf data logs<br>[root@k8s-master01 redis]# ll<br>total 0<br>drwxr-xr-x. 2 root root 134 May 18 08:54 bin<br>drwxr-xr-x. 2 root root   6 May 18 08:57 conf<br>drwxr-xr-x. 2 root root   6 May 18 08:57 data<br>drwxr-xr-x. 2 root root   6 May 18 08:57 logs<br>[root@k8s-master01 redis]#<br>[root@k8s-master01 redis]# echo ‘export PATH&#x3D;&#x2F;data&#x2F;redis&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile<br>[root@k8s-master01 redis]# source &#x2F;etc&#x2F;profile</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><h4 id="192-168-30-128"><a href="#192-168-30-128" class="headerlink" title="192.168.30.128"></a>192.168.30.128</h4><p># cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7001.conf</p>
<h1 id="cp-x2F-root-x2F-redis-4-0-8-x2F-redis-conf-x2F-data-x2F-redis-x2F-conf-x2F-redis-7002-conf"><a href="#cp-x2F-root-x2F-redis-4-0-8-x2F-redis-conf-x2F-data-x2F-redis-x2F-conf-x2F-redis-7002-conf" class="headerlink" title="cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7002.conf"></a>cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7002.conf</h1><h1 id="vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7001-conf"><a href="#vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7001-conf" class="headerlink" title="vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7001.conf"></a>vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7001.conf</h1><p>bind 192.168.30.128<br>port 7001<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7001.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7001.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7001”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7001.conf<br>cluster-node-timeout 15000</p>
<h1 id="vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7002-conf"><a href="#vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7002-conf" class="headerlink" title="vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7002.conf"></a>vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7002.conf</h1><p>bind 192.168.30.128<br>port 7002<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7002.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7002.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7002”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7002.conf<br>cluster-node-timeout 15000</p>
<h4 id="192-168-30-129"><a href="#192-168-30-129" class="headerlink" title="192.168.30.129"></a>192.168.30.129</h4><p># cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7003.conf</p>
<h1 id="cp-x2F-root-x2F-redis-4-0-8-x2F-redis-conf-x2F-data-x2F-redis-x2F-conf-x2F-redis-7004-conf"><a href="#cp-x2F-root-x2F-redis-4-0-8-x2F-redis-conf-x2F-data-x2F-redis-x2F-conf-x2F-redis-7004-conf" class="headerlink" title="cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7004.conf"></a>cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7004.conf</h1><h1 id="vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7003-conf"><a href="#vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7003-conf" class="headerlink" title="vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7003.conf"></a>vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7003.conf</h1><p>bind 192.168.30.129<br>port 7003<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7003.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7003.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7003”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7003.conf<br>cluster-node-timeout 15000</p>
<h1 id="vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7004-conf"><a href="#vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7004-conf" class="headerlink" title="vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7004.conf"></a>vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7004.conf</h1><p>bind 192.168.30.129<br>port 7004<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7004.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7004.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7004”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7004.conf<br>cluster-node-timeout 15000</p>
<h4 id="192-168-30-130"><a href="#192-168-30-130" class="headerlink" title="192.168.30.130"></a>192.168.30.130</h4><p># cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7005.conf</p>
<h1 id="cp-x2F-root-x2F-redis-4-0-8-x2F-redis-conf-x2F-data-x2F-redis-x2F-conf-x2F-redis-7006-conf"><a href="#cp-x2F-root-x2F-redis-4-0-8-x2F-redis-conf-x2F-data-x2F-redis-x2F-conf-x2F-redis-7006-conf" class="headerlink" title="cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7006.conf"></a>cp &#x2F;root&#x2F;redis-4.0.8&#x2F;redis.conf &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7006.conf</h1><h1 id="vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7005-conf"><a href="#vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7005-conf" class="headerlink" title="vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7005.conf"></a>vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7005.conf</h1><p>bind 192.168.30.130<br>port 7005<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7005.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7005.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7005”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7005.conf<br>cluster-node-timeout 15000</p>
<h1 id="vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7006-conf"><a href="#vim-x2F-data-x2F-redis-x2F-conf-x2F-redis-7006-conf" class="headerlink" title="vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7006.conf"></a>vim &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7006.conf</h1><p>bind 192.168.30.130<br>port 7006<br>daemonize yes<br>pidfile “&#x2F;data&#x2F;redis&#x2F;redis_7006.pid”<br>logfile “&#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7006.log”<br>dir “&#x2F;data&#x2F;redis&#x2F;data&#x2F;redis_7006”<br>masterauth 123456<br>requirepass 123456<br>appendonly yes<br>cluster-enabled yes<br>cluster-config-file nodes_7006.conf<br>cluster-node-timeout 15000</p>
<h3 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h3><h4 id="192-168-30-128-1"><a href="#192-168-30-128-1" class="headerlink" title="192.168.30.128"></a>192.168.30.128</h4><p># redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7001.conf</p>
<h1 id="tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7001-log"><a href="#tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7001-log" class="headerlink" title="tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7001.log"></a>tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7001.log</h1><h1 id="redis-server-x2F-data-x2F-redis-x2F-conf-x2F-redis-7002-conf"><a href="#redis-server-x2F-data-x2F-redis-x2F-conf-x2F-redis-7002-conf" class="headerlink" title="redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7002.conf"></a>redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7002.conf</h1><h1 id="tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7002-log"><a href="#tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7002-log" class="headerlink" title="tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7002.log"></a>tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7002.log</h1><h4 id="192-168-30-129-1"><a href="#192-168-30-129-1" class="headerlink" title="192.168.30.129"></a>192.168.30.129</h4><p># redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7003.conf</p>
<h1 id="tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7003-log"><a href="#tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7003-log" class="headerlink" title="tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7003.log"></a>tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7003.log</h1><h1 id="redis-server-x2F-data-x2F-redis-x2F-conf-x2F-redis-7004-conf"><a href="#redis-server-x2F-data-x2F-redis-x2F-conf-x2F-redis-7004-conf" class="headerlink" title="redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7004.conf"></a>redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7004.conf</h1><h1 id="tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7004-log"><a href="#tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7004-log" class="headerlink" title="tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7004.log"></a>tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7004.log</h1><h4 id="192-168-30-130-1"><a href="#192-168-30-130-1" class="headerlink" title="192.168.30.130"></a>192.168.30.130</h4><p># redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7005.conf</p>
<h1 id="tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7005-log"><a href="#tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7005-log" class="headerlink" title="tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7005.log"></a>tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7005.log</h1><h1 id="redis-server-x2F-data-x2F-redis-x2F-conf-x2F-redis-7006-conf"><a href="#redis-server-x2F-data-x2F-redis-x2F-conf-x2F-redis-7006-conf" class="headerlink" title="redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7006.conf"></a>redis-server &#x2F;data&#x2F;redis&#x2F;conf&#x2F;redis_7006.conf</h1><h1 id="tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7006-log"><a href="#tail-f-x2F-data-x2F-redis-x2F-logs-x2F-redis-7006-log" class="headerlink" title="tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7006.log"></a>tail -f &#x2F;data&#x2F;redis&#x2F;logs&#x2F;redis_7006.log</h1><h2 id="创建cluster集群"><a href="#创建cluster集群" class="headerlink" title="创建cluster集群"></a>创建cluster集群</h2><p>上面我把Redis服务全部单独启动了，现在要把他们关联起来</p>
<p>在任意一台服务器上执行下面操作<br>说明一下：这台服务器上要有ruby环境</p>
<p>[root@k8s-master01 redis]# cp &#x2F;root&#x2F;redis-4.0.8&#x2F;src&#x2F;redis-trib.rb &#x2F;data&#x2F;redis&#x2F;bin&#x2F;<br>[root@k8s-master01 redis]# redis-trib.rb create –replicas 1 192.168.30.128:7001 192.168.30.128:7002 192.168.30.129:7003 192.168.30.129:7004 192.168.30.130:7005  192.168.30.130:7006  #创建</p>
<p>如果有以下报错<br>WARNING: redis-trib.rb is not longer available!You should use redis-cli instead.</p>
<p>很明显，这是一个过时已不再支持的方式，在Redis5.0中创建集群已经使用“<code>redis-cli</code>”来实现。</p>
<p>也可以使用下面命令来创建<br><code>./redis-cli --cluster create 192.168.30.128:7001 192.168.30.128:7002 192.168.30.129:7003 192.168.30.129:7004 192.168.30.130:7005 192.168.30.130:7006 --cluster-replicas 1</code></p>
<h2 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h2><p>192.168.30.128:7001&gt; CLUSTER NODES                  #列出节点信息</p>
<p>6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557455176000 5 connected 10923-16383<br>277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557455174000 6 connected<br>b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557455175000 5 connected<br>80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 myself,master - 0 1557455175000 1 connected 0-5460<br>b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557455174989 4 connected<br>4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557455175995 3 connected 5461-10922</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>redis集群</tag>
        <tag>cluster模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 如何持久化数据，再也不会担心数据丢失了？</title>
    <url>/2021/10/05/redis-%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%8D%E4%B9%9F%E4%B8%8D%E4%BC%9A%E6%8B%85%E5%BF%83%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-1-1024x506.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Redis 的读写都是在内存中进行的，所以它的性能高。而当我们的服务器断开或者重启的时候，数据就会消失，那么我们该怎么解决这个问题呢？</p>
<p>其实 Redis 已经为我们提供了一种持久化的机制，分别是 RDB 和 AOF 两种方式，接下来跟着我一起看看这两个锦囊都是怎么保证数据的持久化的。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><hr>
<p>由于 Redis 是基于内存的数据库，所以当服务器出现故障的时候，我们的数据就得不到安全保障。</p>
<p>这个时候就需要将内存中的数据存储到磁盘中，当我们服务器重启时，便可以通过磁盘来恢复数据，这个过程就叫做 Redis 持久化。</p>
<p><img src="https://img-blog.csdnimg.cn/d3117e849fdc45629cc2decf5293ae44.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="码404-Redis持久化"></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><hr>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><hr>
<p>RDB全称Redis Database Backup file（Redis数据备份文件），也可以称为Redis数据快照。</p>
<p>RDB 文件是一个经过压缩的二进制文件（默认：dump.rdb）；<br>RDB 文件保存在硬盘里；<br>通过保存数据库中的键值对来记录数据库状态。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><hr>
<p>当 Redis 持久化时，程序会将当前内存中的数据库状态保存到磁盘中。<br><img src="https://img-blog.csdnimg.cn/a173a5f2491b41df89ada89262b1b5b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>创建 RDB 文件主要有两个 Redis 命令：SAVE 和 BGSAVE。</p>
<h4 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h4><hr>
<p>同步操作，执行命令时，会阻塞 Redis 服务器进程，拒绝客户端发送的命令请求。</p>
<p>代码示例：</p>
<p>def SAVE():<br>    # 创建 RDB 文件<br>    rdbSave()</p>
<p>图示：<br><img src="https://img-blog.csdnimg.cn/6ff9348b7e11453b91896ccedbdb0ce9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="Save命令-BGSAVE"><a href="#Save命令-BGSAVE" class="headerlink" title="Save命令 BGSAVE"></a>Save命令 BGSAVE</h4><hr>
<p>异步操作，执行命令时，子进程执行保存工作，服务器还可以继续让主线程处理客户端发送的命令请求。</p>
<p>代码示例：</p>
<p>def BGSAVE():<br>    # 创建子进程<br>    pid &#x3D; fork()</p>
<pre><code>if pid == 0:
    # 子进程负责创建 RDB 文件
    rdbSave()
    # 完成之后向父进程发送信号
    signal\_parent()
elif pid &gt; 0:
    # 父进程继续处理命令请求，并通过轮训等待子进程的信号
    handle\_request\_and\_wait\_signal()
else:
    handle\_fork\_error()
</code></pre>
<p>图示：<br><img src="https://img-blog.csdnimg.cn/a3df1903f3a54009afb0c5b3252f8a30.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="bgSave命令-载入"><a href="#bgSave命令-载入" class="headerlink" title="bgSave命令 载入"></a>bgSave命令 载入</h4><hr>
<p>载入工作在服务器启动时自动执行。</p>
<p><img src="https://img-blog.csdnimg.cn/7865c41a2a1148fdbdf8d34252827538.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h4><hr>
<p>服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h4 id="主要设置"><a href="#主要设置" class="headerlink" title="主要设置"></a>主要设置</h4><hr>
<p>Redis 允许用户通过设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令。</p>
<h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><hr>
<p>提供配置如下：</p>
<p>save 900 1<br>save 300 10</p>
<p>在这种情况下，只要满足以下条件中的一个，BGSAVE 命令就会被执行：</p>
<ul>
<li>服务器在 900 秒之内，对数据库进行了至少 1 次修改了；</li>
<li>服务器在 300 秒之内，对数据库进行了至少 10 次修改。</li>
</ul>
<h4 id="saveparams"><a href="#saveparams" class="headerlink" title="saveparams"></a>saveparams</h4><hr>
<p>服务器程序会根据 save 选项所设置的保存条件，设置服务器状态 redisServer 结构的 saveparams 属性。</p>
<ul>
<li>saveparams 属性是一个数组；</li>
<li>数组中的每一个元素都是一个 saveparam 结构；</li>
<li>每个 saveparam 结构都保存了一个 save 选项设置的保存条件。</li>
</ul>
<p>struct saveparam {<br>    &#x2F;&#x2F; 秒数<br>    time_t seconds;<br>    &#x2F;&#x2F; 修改数<br>    int changes;<br>}</p>
<h4 id="dirty"><a href="#dirty" class="headerlink" title="dirty"></a>dirty</h4><hr>
<p>dirty 计数器记录距离上一次成功执行 SAVE 命令或 BGSAVE 命令之后，服务器对数据库状态进行了多少次修改（包括写入、删除、更新等操作）。</p>
<h4 id="lastsave"><a href="#lastsave" class="headerlink" title="lastsave"></a>lastsave</h4><hr>
<p>是一个 UNINX 时间戳，记录了服务器上一次成功执行 SAVE 命令或者 BGSAVE 命令的时间。</p>
<h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><hr>
<p>服务器周期性操作函数 serverCron （该函数对正在运行的服务器进行维护）默认每隔 100 毫秒就会执行一次，其中一项工作就是检查 save 选项所设置的保存条件是否已经满足，满足的话就执行 BGSAVE 命令。</p>
<p>代码示例：</p>
<p>def serverCron():<br>    # ….<br>    # 遍历所有保存条件<br>    for saveparam in server.saveparams:<br>        # 计算距离上次执行保存操作有多少秒<br>        save_interval &#x3D; unixtime_now() - server.lastsave</p>
<pre><code>    # 如果数据库状态的修改次数超过条件所设置的次数
    # 如果距离上次保存的时间超过条件所设置的时间
    if server.dirty &gt;= saveparam.changes and save\_interval &gt; saveparam.seconds:
        BGSAVE()
</code></pre>
<p>默认配置</p>
<p>RDB 文件默认的配置如下：</p>
<p>################################ SNAPSHOTTING  ################################<br>#</p>
<h1 id="Save-the-DB-on-disk"><a href="#Save-the-DB-on-disk" class="headerlink" title="Save the DB on disk:"></a>Save the DB on disk:</h1><p>#在给定的秒数和给定的对数据库的写操作数下，自动持久化操作。</p>
<h1 id="save"><a href="#save" class="headerlink" title="save  "></a>save <seconds> <changes></h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>save 900 1<br>save 300 10<br>save 60 10000</p>
<p>#bgsave发生错误时是否停止写入，一般为yes<br>stop-writes-on-bgsave-error yes</p>
<p>#持久化时是否使用LZF压缩字符串对象?<br>rdbcompression yes</p>
<p>#是否对rdb文件进行校验和检验，通常为yes<br>rdbchecksum yes</p>
<h1 id="RDB持久化文件名"><a href="#RDB持久化文件名" class="headerlink" title="RDB持久化文件名"></a>RDB持久化文件名</h1><p>dbfilename dump.rdb</p>
<p>#持久化文件存储目录<br>dir .&#x2F;</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><hr>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><hr>
<p>AOF全称为 Append Only File（追加日志文件）。日志是写后日志，Redis 是先执行命令，把数据写入内存，然后才记录日志。</p>
<p><img src="https://img-blog.csdnimg.cn/e1a1ff8c7eae4516ba84cb9144944c69.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="写后日志"><a href="#写后日志" class="headerlink" title="写后日志"></a>写后日志</h4><hr>
<ul>
<li>通过保存 Redis 服务器所执行的写命令来记录数据库状态；</li>
<li>写入 AOF 文件的所有命令都是以 Redis 的命令请求协议格式保存的。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr>
<p>AOF 持久化流程实现主要是通过以下流程来实现的：<br><img src="https://img-blog.csdnimg.cn/4a9bc31d5c8b43f79d50716500037093.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="AOF流程-命令追加"><a href="#AOF流程-命令追加" class="headerlink" title="AOF流程 命令追加"></a>AOF流程 命令追加</h4><hr>
<p>若 AOF 持久化功能处于打开状态，服务器在执行完一个命令后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。</p>
<h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><hr>
<p>服务器每次结束一个事件循环之前，都会调用 flushAppendOnlyFile 函数，这个函数会考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里。</p>
<p>flushAppendOnlyFile 函数执行以下流程：</p>
<ul>
<li><strong>WRITE</strong>：根据条件，将 aof_buf 中的缓存写入到 AOF 文件；</li>
<li><strong>SAVE</strong>：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</li>
</ul>
<p>这个函数是由服务器配置的 appendfsync 的三个值：always、everysec、no 来影响的，也被称为三种策略。</p>
<h4 id="Always"><a href="#Always" class="headerlink" title="Always"></a>Always</h4><hr>
<p>每条命令都会 fsync 到硬盘中，这样 redis 的写入数据就不会丢失。<br><img src="https://img-blog.csdnimg.cn/2b39040aea0a41d0b783e24cb81131a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="everysec"><a href="#everysec" class="headerlink" title="everysec"></a>everysec</h4><hr>
<p>每秒都会刷新缓冲区到硬盘中(默认值)。</p>
<p><img src="https://img-blog.csdnimg.cn/38c3fad1a76d4ddd969f97230199e8ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><hr>
<p>根据当前操作系统的规则决定什么时候刷新到硬盘中，不需要我们来考虑。</p>
<p><img src="https://img-blog.csdnimg.cn/05ca8b2322224bbf9244d20f8a7a5b67.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h4><hr>
<ol>
<li>创建一个不带网络连接的伪客户端；</li>
<li>从 AOF 文件中分析并读取出一条写命令；</li>
<li>使用伪客户端执行被读出的写命令；</li>
<li>一直执行步骤 2 和 3，直到 AOF 文件中的所有写命令都被处理完毕为止。</li>
</ol>
<h4 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h4><hr>
<p>为何需要文件重写：</p>
<ul>
<li>为了解决 AOF 文件体积膨胀的问题；</li>
<li>通过重写创建一个新的 AOF 文件来替代现有的 AOF 文件，新的 AOF 文件不会包含任何浪费空间的冗余命令。</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>文件重写的实现原理：</p>
<ul>
<li>不需要对现有的 AOF 文件进行任何操作；</li>
<li>从数据库中直接读取键现在的值；</li>
<li>用一条命令记录键值对，从而代替之前记录这个键值对的多条命令。</li>
</ul>
<h4 id="后台重写"><a href="#后台重写" class="headerlink" title="后台重写"></a>后台重写</h4><hr>
<p>为不阻塞父进程，Redis 将 AOF 重写程序放到子进程里执行。</p>
<p>在子进程执行 AOF 重写期间，服务器进程需要执行三个流程：</p>
<ol>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 AOF 缓冲区；</li>
<li>将执行后的写命令追加到 AOF 重写缓冲区。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/33bb6b89f3124da69ad7025c9efb3f02.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><hr>
<p>AOF 文件默认的配置如下：</p>
<p>############################## APPEND ONLY MODE ###############################</p>
<p>#开启AOF持久化方式<br>appendonly no</p>
<p>#AOF持久化文件名<br>appendfilename “appendonly.aof”<br>#每秒把缓冲区的数据fsync到磁盘<br>appendfsync everysec</p>
<h1 id="appendfsync-no"><a href="#appendfsync-no" class="headerlink" title="appendfsync no"></a>appendfsync no</h1><p>#是否在执行重写时不同步数据到AOF文件<br>no-appendfsync-on-rewrite no</p>
<h1 id="触发AOF文件执行重写的增长率"><a href="#触发AOF文件执行重写的增长率" class="headerlink" title="触发AOF文件执行重写的增长率"></a>触发AOF文件执行重写的增长率</h1><p>auto-aof-rewrite-percentage 100<br>#触发AOF文件执行重写的最小size<br>auto-aof-rewrite-min-size 64mb</p>
<p>#redis在恢复时，会忽略最后一条可能存在问题的指令<br>aof-load-truncated yes</p>
<p>#是否打开混合开关<br>aof-use-rdb-preamble yes</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>通过以上的简介，想必大家都对 Redis 持久化有了大致的了解，那么这两种方式，我们该如何选择呢？</p>
<ul>
<li>对于大中型的应用，我们既想保证数据完整性又想保证高效率，就应该结合使用 RDB 和 AOF 两种方式；</li>
<li>如果只是需要保证数据的完整性，保护数据不会丢失，那么优先使用 AOF 方式；</li>
<li>如果是处理大规模的数据恢复，追求更高更快的效率的话，优先使用 RDB 方式。</li>
</ul>
<h3 id="也可以参照下图进行选择"><a href="#也可以参照下图进行选择" class="headerlink" title="也可以参照下图进行选择"></a>也可以参照下图进行选择</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/1c98a7635a2f40db88506960899e0407.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>AOF</tag>
        <tag>RDB</tag>
        <tag>持久化</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis创建集群报错`require&#39;: cannot load such file -- redis (LoadError)</title>
    <url>/2021/12/14/redis%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E6%8A%A5%E9%94%99require-cannot-load-such-file-redis-loaderror/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-39.png" alt="redis"></p>
<p>redis</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>redis每个节点都启动后，创建集群报错require’: cannot load such file – redis (LoadError)</p>
<p>redis-trib.rb create –replicas 1 192.168.100.10:8001 192.168.100.10:8002 \<br>192.168.100.11:8001 192.168.100.11:8002 \<br>192.168.100.12:8001 192.168.100.12:8002<br>&#x2F;usr&#x2F;share&#x2F;rubygems&#x2F;rubygems&#x2F;core_ext&#x2F;kernel_require.rb:55:in<br>`require’: cannot load such file – redis (LoadError)<br>from &#x2F;usr&#x2F;share&#x2F;rubygems&#x2F;rubygems&#x2F;core_ext&#x2F;kernel_require.rb:55:in `require’<br>from &#x2F;data&#x2F;redis&#x2F;bin&#x2F;redis-trib.rb:25:in `<main>‘</p>
<h3 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h3><hr>
<p>ruby 使用 require 引入依赖<br>缺少 redis 的相关依赖，需要通过 gem 安装</p>
<h3 id="给ruby环境安装redis依赖包"><a href="#给ruby环境安装redis依赖包" class="headerlink" title="给ruby环境安装redis依赖包"></a>给ruby环境安装redis依赖包</h3><hr>
<p>执行命令</p>
<p>gem install redis</p>
<p>如果没有网的话，执行命令，提前把redis的gem包传到服务器上</p>
<p>[<a href="mailto:&#x63;&#111;&#100;&#101;&#x34;&#48;&#x34;&#x40;&#x63;&#x6f;&#x64;&#x65;&#52;&#48;&#x34;&#x2e;&#105;&#99;&#117;">&#x63;&#111;&#100;&#101;&#x34;&#48;&#x34;&#x40;&#x63;&#x6f;&#x64;&#x65;&#52;&#48;&#x34;&#x2e;&#105;&#99;&#117;</a> ~&#x2F;redis]$gem install -l redis-3.3.0.gem<br>Successfully installed redis-3.3.0<br>Parsing documentation for redis-3.3.0<br>Installing ri documentation for redis-3.3.0<br>1 gem installed</p>
<p>安装成功后重新执行创建指令即可成功。</p>
<h3 id="创建Redis集群"><a href="#创建Redis集群" class="headerlink" title="创建Redis集群"></a>创建Redis集群</h3><hr>
<p>redis-trib.rb create –replicas 1 192.168.100.10:8001 192.168.100.10:8002 \<br>192.168.100.11:8001 192.168.100.11:8002 \<br>192.168.100.12:8001 192.168.100.12:8002 </p>
<blockquote>
<blockquote>
<blockquote>
<p>Creating cluster<br>Performing hash slots allocation on 6 nodes…<br>Using 3 masters:<br>192.168.100.10:8001<br>192.168.100.11:8001<br>192.168.100.12:8001<br>Adding replica 192.168.100.11:8002 to 192.168.100.10:8001<br>Adding replica 192.168.100.11:8002 to 192.168.100.11:8001<br>Adding replica 192.168.100.10:8002 to 192.168.100.12:8001<br>M: 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c 192.168.100.10:8001<br>   slots:0-5460 (5461 slots) master<br>S: 5a3c23ee70ee1a77aabb33e93b59611aa48790e1 192.168.100.10:8002<br>   replicates fdc7022e98e9619a9dd4574501f3648627d58c38<br>M: 71663ec6304e762565cd73512bef7a7e4f764235 192.168.100.11:8001<br>   slots:5461-10922 (5462 slots) master<br>S: 0ac27a24f78ff7d3e5b4fff8c97ad4a09700d930 192.168.100.11:8002<br>   replicates 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c<br>M: fdc7022e98e9619a9dd4574501f3648627d58c38 192.168.100.12:8001<br>   slots:10923-16383 (5461 slots) master<br>S: 4a0a20b6c6c925e582997be447848edeee9e8456 192.168.100.11:8002<br>   replicates 71663ec6304e762565cd73512bef7a7e4f764235<br>Can I set the above configuration? (type ‘yes’ to accept): yes<br>Nodes configuration updated<br>Assign a different config epoch to each node<br>Sending CLUSTER MEET messages to join the cluster<br>Waiting for the cluster to join.<br>Performing Cluster Check (using node 192.168.100.10:8001)<br>M: 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c 192.168.100.10:8001<br>   slots:0-5460 (5461 slots) master<br>   1 additional replica(s)<br>S: 4a0a20b6c6c925e582997be447848edeee9e8456 192.168.100.11:8002<br>   slots: (0 slots) slave<br>   replicates 71663ec6304e762565cd73512bef7a7e4f764235<br>S: 0ac27a24f78ff7d3e5b4fff8c97ad4a09700d930 192.168.100.11:8002<br>   slots: (0 slots) slave<br>   replicates 7ef8d6b70f1e1a02c5936ad67454418ef4487a7c<br>M: fdc7022e98e9619a9dd4574501f3648627d58c38 192.168.100.12:8001<br>   slots:10923-16383 (5461 slots) master<br>   1 additional replica(s)<br>M: 71663ec6304e762565cd73512bef7a7e4f764235 192.168.100.11:8001<br>   slots:5461-10922 (5462 slots) master<br>   1 additional replica(s)<br>S: 5a3c23ee70ee1a77aabb33e93b59611aa48790e1 192.168.100.10:8002<br>   slots: (0 slots) slave<br>   replicates fdc7022e98e9619a9dd4574501f3648627d58c38<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.</p>
</blockquote>
</blockquote>
</blockquote>
<p>创建Redis集群完成</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>LoadError</tag>
        <tag>redis-trib.rb</tag>
        <tag>require</tag>
        <tag>创建集群</tag>
      </tags>
  </entry>
  <entry>
    <title>redis未授权访问漏洞修复方法_redis密码设置</title>
    <url>/2021/04/15/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95-redis%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><h3 id="1、网络加固"><a href="#1、网络加固" class="headerlink" title="1、网络加固"></a>1、网络加固</h3><hr>
<p>绑定127.0.0.1，redis默认是监听的127.0.0.1上，如果仅仅是本地通信，请确保监听在本地。这种方式缓解了redis的风险。在&#x2F;etc&#x2F;redis&#x2F;redis.conf中配置如下：</p>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;redis.conf<br>bind127.0.0.1</p>
<h3 id="2、设置防火墙"><a href="#2、设置防火墙" class="headerlink" title="2、设置防火墙"></a>2、设置防火墙</h3><hr>
<p>如果需要其他机器访问，或者设置了slave模式，需添加相应的防火墙设置。命令如下：</p>
<p>#centos7<br>[root@localhost ~]# firewall-cmd –zone&#x3D;public –add-port&#x3D;6379&#x2F;tcp –permanent<br>success<br>[root@localhost ~]# firewall-cmd –reload  #使配置生效<br>success<br>#centos6<br>iptables -A INPUT -sx.x.x.x -p tcp –dport 6379 -j ACCEPT</p>
<h3 id="3、添加认证"><a href="#3、添加认证" class="headerlink" title="3、添加认证"></a>3、添加认证</h3><hr>
<p>redis默认没有开启密码认证<br>修改&#x2F;etc&#x2F;redis&#x2F;redis.conf配置文件， （requirepass 密码）可设置认证密码</p>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;redis.conf<br>requirepass xHlotFav5VNz9&amp;yH</p>
<p>重启redis（&#x2F;etc&#x2F;init.d&#x2F;redis-server restart）之后，需要执行（auth 密码）<br>示例如下：</p>
<p>[root@eureka175 ~]# redis-cli -h 192.168.65.175 -p 6379<br>192.168.65.175:6379&gt;<br>192.168.65.175:6379&gt; KEYS *<br>(error) NOAUTH Authentication required.<br>192.168.65.175:6379&gt; AUTH 1234<br>(error) ERR invalid password<br>192.168.65.175:6379&gt; AUTH xHlotFav5VNz9&amp;y1<br>OK</p>
<h3 id="4、设置单独账户"><a href="#4、设置单独账户" class="headerlink" title="4、设置单独账户"></a>4、设置单独账户</h3><hr>
<p>设置一个单独的redis账户：创建一个redis账户，通过该账户启动。示例如下：</p>
<p>setsid sudo -u redis&#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</p>
<h3 id="5、重命名重要命令"><a href="#5、重命名重要命令" class="headerlink" title="5、重命名重要命令"></a>5、重命名重要命令</h3><hr>
<p>由于redis没有做基本的权限分离，无管理账号和普通账号之分，导致攻击者登录后可执行任意操作，因此需要隐藏重要命令。<br>例如：<code>FLUSHDB, FLUSHALL, KEYS,PEXPIRE, DEL, CONFIG, SHUTDOWN, BGREWRITEAOF, BGSAVE, SAVE, SPOP, SREM, RENAME,DEBUG, EVAL</code></p>
<p>其中在redis2.8.1和RedisRedis3.x (&lt; 3.0.2)存在有eval沙箱逃逸漏洞，攻击者利用漏洞可执行任意lua代码。</p>
<p>设置方法如下，编辑redis.conf文件：</p>
<p>rename-command CONFIG “”<br>rename-command flushall “”<br>rename-command flushdb “”<br>rename-command shutdown shutdown_dvwa</p>
<p>上述配置将config，flushdb，flushall设置为了空，即禁用该命令，我们也可以命名为一些攻击者难以猜测，我们自己却容易记住的的名字。</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;redis-server restart </p>
<p>重启生效</p>
<p>已上就是redis未授权访问漏洞修复过程，觉得有用就给个赞吧</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>密码</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium 如何在已打开的浏览器上继续运行自动化脚本？</title>
    <url>/2021/09/03/selenium-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-1.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>使用selenium 做web自动化的时候，经常会遇到这样一种需求，是否可以在已经打开的浏览器基础上继续运行自动化脚本？<br>这样前面的验证码登录可以手工点过去，后面页面使用脚本继续执行，这样可以解决很大的一个痛点。</p>
<h3 id="命令行启动浏览器"><a href="#命令行启动浏览器" class="headerlink" title="命令行启动浏览器"></a>命令行启动浏览器</h3><hr>
<p>首先右键Chrome浏览器桌面图标，找到chrome.exe的安装路径<br><img src="https://img-blog.csdnimg.cn/669f5f7bb8d0425688714c68630e3d86.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>复制地址C:\Program Files\Google\Chrome\Application 添加到环境变量Path下<br><img src="https://img-blog.csdnimg.cn/09e2ef987e3945639cfbd4ec42d7d9d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>打开cmd输入命令启动chrome浏览器</p>
<p>--remote-debugging-port 是指定运行端口，可以设置容易端口，只要没被占用就行<br>–user-data-dir 指定运行浏览器的运行数据，新建一个干净目录，不影响系统原来的数据</p>
<p>chrome.exe –remote-debugging-port&#x3D;9999 –user-data-dir&#x3D;”D:\selenium_chrome”</p>
<p>执行后会启动chrome浏览器<br><img src="https://img-blog.csdnimg.cn/99458746315344d18159cc8a09028558.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>selenium运行已打开浏览器<br>在已打开的浏览器上输入我的博客地址：<a href="https://www.code404.icu/">https://www.code404.icu/</a><br><img src="https://img-blog.csdnimg.cn/1aaaa303227b43aca7c880665194cfe2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>新建py文件，可以接着浏览器上直接运行，不用重新启动浏览器</p>
<p>from selenium import webdriver<br>from selenium.webdriver.chrome.options import Options</p>
<p>chrome_options &#x3D; Options()<br>chrome_options.add_experimental_option(“debuggerAddress”, “127.0.0.1:9999”)<br>driver &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options)</p>
<h1 id="接着运行"><a href="#接着运行" class="headerlink" title="接着运行"></a>接着运行</h1><p>print(driver.current_url)<br>print(driver.title)</p>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><hr>
<p><a href="https://www.code404.icu/">https://www.code404.icu/</a><br>Code404_码404_运维,开发,测试知识资源共享平台</p>
<p>通过此方法就可以解决登录页面验证码的问题了，验证码手工操作，后面的页面继续用代码操作。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Selenium</tag>
        <tag>自动化脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 脚本的参数解析工具_Shell脚本参数定义</title>
    <url>/2021/08/23/shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-shell%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-20.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>Argbash是一个代码生成器，它为你的脚本生成一个量身定制的解析库。与其他bash模块的通用代码不同，它生成你的脚本所需的最少代码。此外，如果你不需要100%符合那些CLI标准的话，你可以生成更简单的代码。</p>
<h3 id="1-使用空格分隔"><a href="#1-使用空格分隔" class="headerlink" title="1. 使用空格分隔"></a>1. 使用空格分隔</h3><hr>
<p>使用空格作为参数分隔</p>
<p>实际用法</p>
<p>.&#x2F;myscript.sh -e conf -s &#x2F;etc -l &#x2F;usr&#x2F;lib &#x2F;etc&#x2F;hosts</p>
<p>实现脚本</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>POSITIONAL&#x3D;()<br>while [[ $# -gt 0 ]]; do<br>  key&#x3D;”$1”</p>
<p>  case $key in<br>    -e–extension)<br>      EXTENSION&#x3D;”$2”<br>      shift # past argument<br>      shift # past value<br>      ;;<br>    -s–searchpath)<br>      SEARCHPATH&#x3D;”$2”<br>      shift # past argument<br>      shift # past value<br>      ;;<br>    -l–lib)<br>      LIBPATH&#x3D;”$2”<br>      shift # past argument<br>      shift # past value<br>      ;;<br>    –default)<br>      DEFAULT&#x3D;YES<br>      shift # past argument<br>      ;;<br>      *)<br>    POSITIONAL+&#x3D;(“$1”) # save it in an array for later<br>      shift # past argument<br>      ;;<br>  esac<br>done</p>
<p>set – “${POSITIONAL[@]}” # restore positional parameters</p>
<p>echo FILE EXTENSION  &#x3D; “${EXTENSION}”<br>echo SEARCH PATH     &#x3D; “${SEARCHPATH}”<br>echo LIBRARY PATH    &#x3D; “${LIBPATH}”<br>echo DEFAULT         &#x3D; “${DEFAULT}”<br>echo “Number files in SEARCH PATH with EXTENSION:” $(ls -1 “${SEARCHPATH}”&#x2F;*.”${EXTENSION}”  wc -l)<br>if [[ -n $1 ]]; then<br>  echo “Last line of file specified as non-opt&#x2F;last argument:”<br>  tail -1 “$1”<br>fi</p>
<h3 id="2-使用等号分隔"><a href="#2-使用等号分隔" class="headerlink" title="2. 使用等号分隔"></a>2. 使用等号分隔</h3><hr>
<p>使用等号作为参数分隔</p>
<p>实际用法</p>
<p>.&#x2F;myscript.sh -e&#x3D;conf -s&#x3D;&#x2F;etc -l&#x3D;&#x2F;usr&#x2F;lib &#x2F;etc&#x2F;hosts</p>
<p>实现脚本</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>for key in “$@”; do<br>  case $key in<br>    -e&#x3D;*–extension&#x3D;*)<br>      EXTENSION&#x3D;”${key#*&#x3D;}”<br>      shift # past argument&#x3D;value<br>      ;;<br>    -s&#x3D;*–searchpath&#x3D;*)<br>      SEARCHPATH&#x3D;”${key#*&#x3D;}”<br>      shift # past argument&#x3D;value<br>      ;;<br>    -l&#x3D;*–lib&#x3D;*)<br>      LIBPATH&#x3D;”${key#*&#x3D;}”<br>      shift # past argument&#x3D;value<br>      ;;<br>    –default)<br>      DEFAULT&#x3D;YES<br>      shift # past argument with no value<br>      ;;<br>    *)<br>      ;;<br>  esac<br>done</p>
<p>echo “FILE EXTENSION  &#x3D; ${EXTENSION}”<br>echo “SEARCH PATH     &#x3D; ${SEARCHPATH}”<br>echo “LIBRARY PATH    &#x3D; ${LIBPATH}”<br>echo “Number files in SEARCH PATH with EXTENSION:” $(ls -1 “${SEARCHPATH}”&#x2F;*.”${EXTENSION}”  wc -l)<br>if [[ -n $1 ]]; then<br>  echo “Last line of file specified as non-opt&#x2F;last argument:”<br>  tail -1 $1<br>fi </p>
<h3 id="3-使用-getopts-工具"><a href="#3-使用-getopts-工具" class="headerlink" title="3. 使用 getopts 工具"></a>3. 使用 getopts 工具</h3><hr>
<p>使用第三方工具进行参数解析</p>
<p>实际用法</p>
<p>.&#x2F;myscript.sh -h</p>
<p>.&#x2F;myscript.sh -v -f</p>
<p>实现脚本</p>
<p>#!&#x2F;bin&#x2F;sh</p>
<h1 id="重置以防止在前面的shell中使用getopts工具-这是一个POSIX变量"><a href="#重置以防止在前面的shell中使用getopts工具-这是一个POSIX变量" class="headerlink" title="重置以防止在前面的shell中使用getopts工具(这是一个POSIX变量)"></a>重置以防止在前面的shell中使用getopts工具(这是一个POSIX变量)</h1><p>OPTIND&#x3D;1</p>
<h1 id="初始化变量名称"><a href="#初始化变量名称" class="headerlink" title="初始化变量名称"></a>初始化变量名称</h1><p>OUTPUT_FILE&#x3D;””<br>VERSION&#x3D;0</p>
<h1 id="getopts的缺点就是它只能处理短选项，如-h，而不能是–help格式"><a href="#getopts的缺点就是它只能处理短选项，如-h，而不能是–help格式" class="headerlink" title="getopts的缺点就是它只能处理短选项，如-h，而不能是–help格式"></a>getopts的缺点就是它只能处理短选项，如-h，而不能是–help格式</h1><p>while getopts “h?vf:” key; do<br>    case “$key” in<br>    h\?)<br>        show_help<br>        exit 0<br>        ;;<br>    v)<br>        VERSION&#x3D;1<br>        ;;<br>    f)<br>        output_file&#x3D;$OPTARG<br>        ;;<br>    esac<br>done</p>
<p>shift $((OPTIND-1))</p>
<p>[ “${1:-}” &#x3D; “–” ] &amp;&amp; shift</p>
<p>echo “verbose&#x3D;$VERSION, output_file&#x3D;’$output_file’, Leftovers: $@” </p>
<h3 id="4-使用-argbash-工具"><a href="#4-使用-argbash-工具" class="headerlink" title="4. 使用 argbash 工具"></a>4. 使用 argbash 工具</h3><hr>
<p>动态的参数解析工具</p>
<p>这个工具主要提供脚本参数的解析功能，而且不再引用任何第三方库的情况下。就我使用而言，一般会比普通脚本多30多行而且，但是效果非常好。</p>
<p>详细信息可以通过官方网站地址了解。</p>
<p><a href="https://argbash.io/generate#results">https://argbash.io/generate#results</a></p>
<p>#!&#x2F;bin&#x2F;bash</p>
<h1 id="This-is-a-rather-minimal-example-Argbash-potential"><a href="#This-is-a-rather-minimal-example-Argbash-potential" class="headerlink" title="This is a rather minimal example Argbash potential"></a>This is a rather minimal example Argbash potential</h1><h1 id="Example-taken-from-http-argbash-readthedocs-io-en-stable-example-html"><a href="#Example-taken-from-http-argbash-readthedocs-io-en-stable-example-html" class="headerlink" title="Example taken from http://argbash.readthedocs.io/en/stable/example.html"></a>Example taken from <a href="http://argbash.readthedocs.io/en/stable/example.html">http://argbash.readthedocs.io/en/stable/example.html</a></h1><h1 id="可选参数"><a href="#可选参数" class="headerlink" title="[可选参数]"></a>[可选参数]</h1><h1 id="ARG-OPTIONAL-SINGLE-option-o-optional-argument-help-msg"><a href="#ARG-OPTIONAL-SINGLE-option-o-optional-argument-help-msg" class="headerlink" title="ARG_OPTIONAL_SINGLE([option], [o], [optional argument help msg])"></a>ARG_OPTIONAL_SINGLE([option], [o], [optional argument help msg])</h1><h1 id="可选布尔参数"><a href="#可选布尔参数" class="headerlink" title="[可选布尔参数]"></a>[可选布尔参数]</h1><h1 id="ARG-OPTIONAL-BOOLEAN-print-boolean-optional-argument-help-msg"><a href="#ARG-OPTIONAL-BOOLEAN-print-boolean-optional-argument-help-msg" class="headerlink" title="ARG_OPTIONAL_BOOLEAN([print], , [boolean optional argument help msg])"></a>ARG_OPTIONAL_BOOLEAN([print], , [boolean optional argument help msg])</h1><h1 id="固定参数"><a href="#固定参数" class="headerlink" title="[固定参数]"></a>[固定参数]</h1><h1 id="ARG-POSITIONAL-SINGLE-positional-arg-positional-argument-help-msg"><a href="#ARG-POSITIONAL-SINGLE-positional-arg-positional-argument-help-msg" class="headerlink" title="ARG_POSITIONAL_SINGLE([positional-arg], [positional argument help  msg], )"></a>ARG_POSITIONAL_SINGLE([positional-arg], [positional argument help  msg], )</h1><h1 id="帮助信息"><a href="#帮助信息" class="headerlink" title="[帮助信息]"></a>[帮助信息]</h1><h1 id="ARG-HELP-The-general-script’s-help-msg"><a href="#ARG-HELP-The-general-script’s-help-msg" class="headerlink" title="ARG_HELP([The general script’s help msg])"></a>ARG_HELP([The general script’s help msg])</h1><h1 id="ARGBASH-GO"><a href="#ARGBASH-GO" class="headerlink" title="ARGBASH_GO"></a>ARGBASH_GO</h1><h1 id="lt-–-needed-because-of-Argbash"><a href="#lt-–-needed-because-of-Argbash" class="headerlink" title="[ &lt;– needed because of Argbash"></a>[ &lt;– needed because of Argbash</h1><p>echo “Value of –option: $_arg_option”<br>echo “print is $_arg_print”<br>echo “Value of positional-arg: $_arg_positional_arg”</p>
<h1 id="lt-–-needed-because-of-Argbash-1"><a href="#lt-–-needed-because-of-Argbash-1" class="headerlink" title="] &lt;– needed because of Argbash"></a>] &lt;– needed because of Argbash</h1>]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
        <tag>参数</tag>
        <tag>参数定义</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本正常退出状态码echo $?shell中的特殊变量_自定义脚本退出时的状态码</title>
    <url>/2021/09/30/shell%E8%84%9A%E6%9C%AC%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81echo-shell%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-27.png"></p>
<h3 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h3><hr>
<p>命令执行后，使用变量“？”来保存状态码，不同的值反应成功或失败，它的取值范围是0-255</p>
<p>[<a href="mailto:&#114;&#111;&#111;&#116;&#x40;&#x63;&#111;&#x64;&#x65;&#52;&#48;&#52;&#46;&#105;&#x63;&#x75;">&#114;&#111;&#111;&#116;&#x40;&#x63;&#111;&#x64;&#x65;&#52;&#48;&#52;&#46;&#105;&#x63;&#x75;</a> www]# echo $?<br>0           # 上一个 命令执行成功<br>[<a href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#99;&#111;&#x64;&#x65;&#x34;&#x30;&#52;&#46;&#x69;&#x63;&#117;">&#x72;&#x6f;&#111;&#116;&#x40;&#99;&#111;&#x64;&#x65;&#x34;&#x30;&#52;&#46;&#x69;&#x63;&#117;</a> www]# echo $?<br>127         # 上一个命令执行失败</p>
<p>关于命令的退出，可以在命令脚本的中使用一下命令自定义退出状态码：</p>
<p>exit [n]</p>
<p>我们验证一下这个exit的作用：</p>
<p>[<a href="mailto:&#x72;&#111;&#111;&#x74;&#x40;&#x63;&#x6f;&#x64;&#x65;&#52;&#x30;&#x34;&#46;&#105;&#99;&#x75;">&#x72;&#111;&#111;&#x74;&#x40;&#x63;&#x6f;&#x64;&#x65;&#52;&#x30;&#x34;&#46;&#105;&#99;&#x75;</a> www]# cat sysinfo.sh<br>#!&#x2F;bin&#x2F;bash<br>#</p>
<h1 id=""><a href="#" class="headerlink" title="**************************************************************"></a>**************************************************************</h1><h1 id="Author-leenhem-lh"><a href="#Author-leenhem-lh" class="headerlink" title="Author: leenhem.lh"></a>Author: leenhem.lh</h1><h1 id="Create-time-2021年9月30日17-26-59"><a href="#Create-time-2021年9月30日17-26-59" class="headerlink" title="Create time: 2021年9月30日17:26:59"></a>Create time: 2021年9月30日17:26:59</h1><h1 id="site-www-code404-icu"><a href="#site-www-code404-icu" class="headerlink" title="site: www.code404.icu"></a>site: <a href="http://www.code404.icu/">www.code404.icu</a></h1><h1 id="Description-this-is-a-test-file-for-set"><a href="#Description-this-is-a-test-file-for-set" class="headerlink" title="Description: this is a test file for set"></a>Description: this is a test file for set</h1><h1 id="File-name-test-set-sh"><a href="#File-name-test-set-sh" class="headerlink" title="File name: test_set.sh"></a>File name: test_set.sh</h1><h1 id="Copyright-C-2021-All-rights-reserved"><a href="#Copyright-C-2021-All-rights-reserved" class="headerlink" title="Copyright (C): 2021 All rights reserved"></a>Copyright (C): 2021 All rights reserved</h1><h1 id="-1"><a href="#-1" class="headerlink" title="**************************************************************"></a>**************************************************************</h1><p>echo “——————-host systeminfo——————-“<br>echo “HOSTNAME: `hostname`“<br>echo “IPADDR: `ifconfig ens33  egrep -o ‘([0-9]{1,3}\.){3}[0-9]{1,3}’  head -n1`“<br>echo “OS_Version: `cat &#x2F;etc&#x2F;redhat-release`“<br>echo “Kernel: `uname -r`“<br>echo “CPU: `lscpugrep ‘Model name’tr -s ‘ ‘ cut -d : -f2`“<br>echo “Memory: `free -h  grep Mem  tr -s ‘ ‘ :  cut -d : -f2`“</p>
<p>按照上面的脚本书写，然后执行脚本，执行后我们看结果：</p>
<p>[root@k8s-master01 ~]# sh test_set.sh<br>——————-host systeminfo——————-<br>HOSTNAME: k8s-master01<br>ens33: error fetching interface information: Device not found<br>IPADDR:<br>OS_Version: CentOS Linux release 8.3.2011<br>Kernel: 4.18.0-240.el8.x86_64<br>CPU:<br>Memory: 15Gi<br>[root@k8s-master01 ~]# echo $?<br>0</p>
<p>0 # 结果是0，说明sysinfo.sh执行成功</p>
<p>我们再来看：在脚本中随机加上一些不存在的命令</p>
<p>[<a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#x63;&#x6f;&#x64;&#101;&#52;&#x30;&#x34;&#46;&#x69;&#99;&#x75;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#x63;&#x6f;&#x64;&#101;&#52;&#x30;&#x34;&#46;&#x69;&#99;&#x75;</a> www]# cat sysinfo.sh<br>#!&#x2F;bin&#x2F;bash<br>#</p>
<h1 id="-2"><a href="#-2" class="headerlink" title="**************************************************************"></a>**************************************************************</h1><h1 id="Author-Jason-Zhuo"><a href="#Author-Jason-Zhuo" class="headerlink" title="Author: Jason Zhuo"></a>Author: Jason Zhuo</h1><h1 id="Create-time-2021年7月1日17-26-59"><a href="#Create-time-2021年7月1日17-26-59" class="headerlink" title="Create time: 2021年7月1日17:26:59"></a>Create time: 2021年7月1日17:26:59</h1><h1 id="Description-this-is-a-test-file-for-set-1"><a href="#Description-this-is-a-test-file-for-set-1" class="headerlink" title="Description: this is a test file for set"></a>Description: this is a test file for set</h1><h1 id="File-name-test-set-sh-1"><a href="#File-name-test-set-sh-1" class="headerlink" title="File name: test_set.sh"></a>File name: test_set.sh</h1><h1 id="Copyright-C-2021-All-rights-reserved-1"><a href="#Copyright-C-2021-All-rights-reserved-1" class="headerlink" title="Copyright (C): 2021 All rights reserved"></a>Copyright (C): 2021 All rights reserved</h1><h1 id="-3"><a href="#-3" class="headerlink" title="**************************************************************"></a>**************************************************************</h1><p>echo “——————-host systeminfo——————-“<br>echo “HOSTNAME: `hostname`“<br>xxx # 这一行我们加上一个不存在的xxx命令。<br>echo “IPADDR: `ifconfig ens33  egrep -o ‘([0-9]{1,3}\.){3}[0-9]{1,3}’  head -n1`“<br>echo “OS_Version: `cat &#x2F;etc&#x2F;redhat-release`“<br>echo “Kernel: `uname -r`“<br>echo “CPU: `lscpugrep ‘Model name’tr -s ‘ ‘ cut -d : -f2`“<br>echo “Memory: `free -h  grep Mem  tr -s ‘ ‘ :  cut -d : -f2`“</p>
<p>执行一下，然后看执行是否成功</p>
<p>[<a href="mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#x63;&#111;&#x64;&#x65;&#52;&#48;&#x34;&#46;&#x69;&#99;&#x75;">&#114;&#x6f;&#x6f;&#116;&#x40;&#x63;&#111;&#x64;&#x65;&#52;&#48;&#x34;&#46;&#x69;&#99;&#x75;</a> www]# sh sysinfo.sh<br>——————-host systeminfo——————-<br>HOSTNAME: k8s-master01<br>sysinfo.sh: line 12: xxx: command not found # 有报错信息<br>IPADDR: 10.0.0.136<br>OS_Version: CentOS Linux release 7.6.1810 (Core)<br>Kernel: 3.10.0-957.el7.x86_64<br>CPU: Intel(R) Core(TM) i7-1065G7 CPU @ 1.30GHz<br>Memory: 972M<br>[<a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#99;&#x6f;&#x64;&#x65;&#52;&#48;&#x34;&#x2e;&#x69;&#99;&#x75;">&#x72;&#111;&#111;&#116;&#64;&#99;&#x6f;&#x64;&#x65;&#52;&#48;&#x34;&#x2e;&#x69;&#99;&#x75;</a> www]# echo $? # 查看脚本执行是否成功<br>0 # 0，说明执行成功</p>
<p>为什么明明有执行报错，但是查看执行是否成功的时候却显示为0呢？这是因为“$?”仅记录脚本退出时最后一条命令的执行状态，本例中使用的脚本最后一条命令是echo语句，所以这里是执行成功的，这就导致我们查看脚本的执行结果的时候，脚本的执行结果是成功的。</p>
<p>这个时候我们修改一下脚本，就让它在退出时返回99：</p>
<p>[<a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#x63;&#x6f;&#100;&#101;&#52;&#x30;&#x34;&#46;&#x69;&#99;&#117;">&#114;&#x6f;&#111;&#116;&#x40;&#x63;&#x6f;&#100;&#101;&#52;&#x30;&#x34;&#46;&#x69;&#99;&#117;</a> www]# cat sysinfo.sh<br>#!&#x2F;bin&#x2F;bash<br>……为了节省篇幅这地方就省略了<br>echo “Memory: `free -h  grep Mem  tr -s ‘ ‘ :  cut -d : -f2`“<br>exit 99 # 新增这一行</p>
<p>我们再执行一次这个脚本</p>
<p>[<a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#x63;&#111;&#x64;&#x65;&#x34;&#48;&#x34;&#x2e;&#x69;&#99;&#117;">&#x72;&#111;&#x6f;&#x74;&#64;&#x63;&#111;&#x64;&#x65;&#x34;&#48;&#x34;&#x2e;&#x69;&#99;&#117;</a> www]# sh sysinfo.sh<br>……<br>[<a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x63;&#111;&#x64;&#101;&#52;&#x30;&#52;&#46;&#x69;&#99;&#117;">&#114;&#111;&#x6f;&#x74;&#64;&#x63;&#111;&#x64;&#101;&#52;&#x30;&#52;&#46;&#x69;&#99;&#117;</a> www]# echo $?<br>99 # 这不就是我们希望的99嘛</p>
<p>好了，虽然我们可以自定义脚本退出时的状态码，但是我们还是要遵从Linux的做法，成功时退出码是0，不成功时退出码才是非0。上面仅仅是演示exit的用法，但是错误码可以根据自己的情况去定义。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><hr>
<ul>
<li>使用ping命令，ping一个不存在的IP地址，ping的输出信息不要输出到屏幕上。然后查看ping的执行是不是成功了。</li>
</ul>
<p>[root@k8s-master01 ~]# ping 172.25.42.235 -c 1 &gt; &#x2F;dev&#x2F;null ; echo $?<br>0</p>
<h1 id="0代表ping成功"><a href="#0代表ping成功" class="headerlink" title="0代表ping成功"></a>0代表ping成功</h1><p>[root@k8s-master01 ~]# ping 172.25.42.1 -c 1 &gt; &#x2F;dev&#x2F;null ; echo $?<br>1</p>
<h1 id="1代表ping不通"><a href="#1代表ping不通" class="headerlink" title="1代表ping不通"></a>1代表ping不通</h1><ul>
<li>从&#x2F;etc&#x2F;passwd里查找一个不存在的字符串，比如ROOT，然后查看这个查找的执行结果是不是成功了。</li>
</ul>
<p>[root@k8s-master01 ~]# cat &#x2F;etc&#x2F;passwdgrep ROOT &gt; &#x2F;dev&#x2F;null;echo $?<br>1</p>
<h1 id="1代表没有-ROOT-用户"><a href="#1代表没有-ROOT-用户" class="headerlink" title="1代表没有 ROOT 用户"></a>1代表没有 ROOT 用户</h1><p>[root@k8s-master01 ~]# cat &#x2F;etc&#x2F;passwdgrep root &gt; &#x2F;dev&#x2F;null;echo $?<br>0</p>
<h1 id="0代表有-root用户"><a href="#0代表有-root用户" class="headerlink" title="0代表有 root用户"></a>0代表有 root用户</h1><ul>
<li>查看一个用户名是不是存在，请通过命令的执行返回值判断用户是不是存在。</li>
</ul>
<p>[root@k8s-master01 ~]# cat &#x2F;etc&#x2F;passwdgrep ROOT &gt; &#x2F;dev&#x2F;null;echo $?<br>1<br>[root@k8s-master01 ~]# cat &#x2F;etc&#x2F;passwdgrep root &gt; &#x2F;dev&#x2F;null;echo $?<br>0</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>状态码</tag>
        <tag>shell</tag>
        <tag>echo $?</tag>
        <tag>exit</tag>
        <tag>脚本</tag>
        <tag>自定义</tag>
        <tag>退出</tag>
      </tags>
  </entry>
  <entry>
    <title>Skywalking如何过滤不需要被监控的接口地址？</title>
    <url>/2021/11/27/skywalking%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%E4%B8%8D%E9%9C%80%E8%A6%81%E8%A2%AB%E7%9B%91%E6%8E%A7%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-26-1024x576.png" alt="skywalking"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>系统集成了Eureka注册中心，健康监测的Url会不停的传到Skywalking的收集器，展示到控制台页面。我们需要进行过滤。</p>
<h3 id="使用apm-trace-ignore-plugin-8-7-0-jar"><a href="#使用apm-trace-ignore-plugin-8-7-0-jar" class="headerlink" title="使用apm-trace-ignore-plugin-8.7.0.jar"></a>使用apm-trace-ignore-plugin-8.7.0.jar</h3><hr>
<p>好在这个问题Skywalking官方已经为我们提供好了插件，我们只需要按照规则使用即可。</p>
<h3 id="在agent下使用方式"><a href="#在agent下使用方式" class="headerlink" title="在agent下使用方式"></a>在agent下使用方式</h3><hr>
<p>将apache-skywalking-apm-bin-es7&#x2F;agent&#x2F;optional-plugins&#x2F;apm-trace-ignore-plugin-8.7.0.jar复制到apache-skywalking-apm-bin-es7&#x2F;agent&#x2F;plugins下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> optional-plugins/apm-trace-ignore-plugin-8.7.0.jar plugins/</span><br></pre></td></tr></table></figure>
<p>在apache-skywalking-apm-bin-es7&#x2F;agent&#x2F;config下面新建一个配置文件 apm-trace-ignore-plugin.config，文件内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trace.ignore_path=/carsoa-eureka/eureka/apps/**</span><br></pre></td></tr></table></figure>
<h3 id="需要重新启动-应用"><a href="#需要重新启动-应用" class="headerlink" title="需要重新启动 应用"></a>需要重新启动 应用</h3><hr>
<p>应用启动后查看 agent 的日志，代表ignore配置已生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO 2021-11-26 15:54:12:339 main IgnoreConfigInitializer : </span><br><span class="line">Ignore config file found <span class="keyword">in</span> /data/apache-skywalking-apm-bin-es7</span><br><span class="line">/agent/config/apm-trace-ignore-plugin.config.</span><br></pre></td></tr></table></figure>
<p>去skywalking dashboard - 追踪 下面查看，发现没有出现被过滤的接口</p>
]]></content>
      <categories>
        <category>运维监控</category>
        <category>运维</category>
        <category>Skywalking</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>APM</tag>
        <tag>skywalking</tag>
        <tag>trace_ignore</tag>
        <tag>忽略接口</tag>
        <tag>链路追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Eureka 注册服务慢怎么办？</title>
    <url>/2021/11/04/spring-cloud-eureka-%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-4.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>通常情况下，服务注册到 Eureka Server 的过程较慢。在开发或测试时，常常希望能够加快此过程，从而提升工作效率。</p>
<h3 id="Spring-Cloud官方文档详细描述了该问题的原因并提供了解决方案"><a href="#Spring-Cloud官方文档详细描述了该问题的原因并提供了解决方案" class="headerlink" title="Spring Cloud官方文档详细描述了该问题的原因并提供了解决方案"></a>Spring Cloud官方文档详细描述了该问题的原因并提供了解决方案</h3><hr>
<p>Why is it so Slow to Register a Service?</p>
<p>Being an instance also involves a periodic heartbeat to the registry (via the client’s serviceUrl) with default duration 30 seconds. A service is not available for discovery by clients until the instance, the server and the client all have the same metadata in their local cache (so it could take 3 heartbeats). You can change the period using eureka.instance.leaseRenewalIntervalInSeconds and this will speed up the process of getting clients connected to other services. In production it’s probably better to stick with the default because there are some computations internally in the server that make assumptions about the lease renewal period.</p>
<h3 id="翻译Why-is-it-so-Slow-to-Register-a-Service"><a href="#翻译Why-is-it-so-Slow-to-Register-a-Service" class="headerlink" title="翻译Why is it so Slow to Register a Service"></a>翻译Why is it so Slow to Register a Service</h3><hr>
<p>作为实例还涉及到与注册中心的周期性心跳，默认持续时间为30秒（通过serviceUrl）。在实例、服务器、客户端都在本地缓存中具有相同的元数据之前，服务不可用于客户端发现（所以可能需要3次心跳）。你可以使用eureka.instance.leaseRenewalIntervalInSeconds 配置，这将加快客户端连接到其他服务的过程。在生产中，最好坚持使用默认值，因为在服务器内部有一些计算，他们对续约做出假设。</p>
<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><hr>
<p>eureka:<br>  client:<br>    healthcheck:<br>      enabled:true<br>  instance:<br>    #每5秒去服务端续约<br>    lease-renewal-interval-in-seconds: 5</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>综上，要想解决服务注册慢的问题，只需将eureka.instance.leaseRenewalIntervalInSec- onds 设成一个更小的值。该配置用于设置 Eureka Client 向 Eureka Server 发送心跳的时间间隔，默认是 30，单位是s。在生产环境中，建议坚持使用默认值。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>注册</tag>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh远程执行nohup命令不退出</title>
    <url>/2021/07/17/ssh%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8Cnohup%E5%91%BD%E4%BB%A4%E4%B8%8D%E9%80%80%E5%87%BA/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-44.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Linux系统下，使用默认用户root<br>远程target机器的主目录下有个脚本test.sh，可执行权限，内容只有一条命令：sleep 10</p>
<p>在本地机器上执行</p>
<p>ssh target “nohup .&#x2F;test.sh &amp;”</p>
<p>结果ssh不立即退出，等test.sh执行完毕之后才退出。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr>
<p>一般我们使用nohup命令是为了在断开到某个服务器的ssh连接之后，之前执行的命令仍然正常地在服务器运行。<br>但是前面的现象其实与nohup命令没有什么关系，只是ssh本身的问题；nohup其作用的前提是用户使用ssh登录到服务器上。<br>至于跟nohup扯上关系，我猜是因为在大家的印象中上面这种nohup命令的执行方式应该是立即退出的，结果反差太大，所以当作了一个特别问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>手动在命令里面指定重定向<br>即上面的命令换成</p>
<p>ssh target “nohup .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”</p>
<p>然后就OK</p>
<p>下面的分析表明了nohup命令与“ssh host “cmd””方式的ssh命令没有任何关系（因为这种方式不会涉及SIGHUP），所以换成</p>
<p>ssh target “.&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;” 就可以了。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><hr>
<p>一般处理ssh远程执行某个命令的任务，在远程目标机器上先建立一个sshd的子进程（父进程是最初始的sshd），然后由这个sshd进程启动一个bash进程（如果使用bash进程）来执行传递过来的命令。 针对这次任务建立的sshd进程和bash进程在文件描述符方面有一定关系：通常bash进程的0 1 2三个文件描述符通过管道与sshd的相应文件描述符联系起来。这可以通过查找建立的sshd进程和bash进程在&#x2F;proc文件系统下的相应进程的fd目录的详细情况。ssh远程执行命令这种建立ssh连接的方式在ps -ef 中显示的sshd进程是有”sshd root@notty”标记。此sshd进程的命令可以通过命令“ps -ef grep -v grep grep ‘sshd.*notty’ awk ‘{print KaTeX parse error: Expected ‘EOF’, got ‘}’ at position 2: 2}̲’”得到，而相关bash进程的…$获取。远程执行下面命令可以一步到位，得到比较结果：</p>
<p>ssh target “TMPSPID&#x3D;\$(ps -ef  grep -v grep  grep  -e ‘sshd.*notty’  awk ‘{print \$2}’);echo \$TMPSPID;ls -l &#x2F;proc&#x2F;\$TMPSPID&#x2F;fd;echo \$\$;ls -l &#x2F;proc&#x2F;\$\$&#x2F;fd” </p>
<p>如果远程执行的命令是后台执行，那么可以发现新启动的bash进程的父进程成了1，而输入即描述符0重定向到了&#x2F;dev&#x2F;null。 nohup是防止进程被SIGHUP信号中断，正常使用的时候也会进行一些重定向操作，即当标准输入&#x2F;输出&#x2F;错误等是终端的时候，会对它们进行重定向。但是ssh远程执行命令时，这些条件都不满足，因为文件描述符0,1,2（正常情况下）都被重定向到管道了。所以远程执行nohup时不会进行相关重定向操作。而当远程执行后台命令的时候，虽然标准输入被重定向到了&#x2F;dev&#x2F;null，但是标准输出和错误还是管道， 所以针对这次任务启动的sshd进程还不会结束。所以执行远程命令时，还必须自己在命令行上重定向标准输出和标准错误才行。<br>对于上面的test.sh脚本，下面给出几种命令执行执行方式：</p>
<p>ssh target “.&#x2F;test.sh”           # 等待命令完成后退出；本地Ctrl+C中断ssh会话，不会中断test.sh的执行（bash父进程变为1）（与登录终端执行命令而终端连接断开时的行为不一样）<br>ssh target “.&#x2F;test.sh &amp;”        # 等待命令完成后退出；本地Ctrl+C中断ssh会话，不会中断test.sh的执行（bash父进程本来就为1）<br>ssh target “nohup .&#x2F;test.sh &amp;”  # 等待命令完成后退出；本地Ctrl+C中断ssh会话，不会中断test.sh的执行（bash父进程本来就为1）<br>ssh target “nohup .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”  # 启动test.sh执行后就会退出（bash父进程本来就为1）<br>ssh target “.&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”              # 启动test.sh执行后就会退出（bash父进程本来就为1），这也表明ssh不退出与nohup命令本身没有什么关系</p>
<p>实际上如先ssh登录target，执行.&#x2F;test.sh &amp;，然后正常退出ssh(即exit命令），那么.&#x2F;test.sh这个脚本也不会终止，而且会将父进程换成1；如果不正常退出，而是直接关闭连接，那么会导致.&#x2F;test.sh任务终止。</p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><hr>
<p>感觉上面的分析还不是很到位，因为简单命令还不能够显示出真实情况，比如执行</p>
<p>ssh target “.&#x2F;test.sh”</p>
<p>在远程机器上执行“ps -ef grep ‘testnotty’”命令，结果如下</p>
<p>ps -ef  grep ‘test\notty’<br>root     35929  3306  0 19:20 ?        00:00:00 sshd: root@notty<br>root     35931 35929  0 19:20 ?        00:00:00 &#x2F;bin&#x2F;bash .&#x2F;test.sh”</p>
<p>好像执行.&#x2F;test.sh的bash进程直接由显示的sshd进程创建，其实情况应该不是这样的。先执行一个稍复杂的命令：</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh; done”</p>
<p>同样使用上面的查看命令可以看到如下结果：</p>
<p>ps -ef  grep ‘test\notty’<br>root     36219  3306  0 19:29 ?        00:00:00 sshd: root@notty<br>root     36221 36219  0 19:29 ?        00:00:00 bash -c for w in a b c; do .&#x2F;test.sh; done<br>root     36228 36221  0 19:29 ?        00:00:00 &#x2F;bin&#x2F;bash .&#x2F;test.sh</p>
<p>这就表明了其实有两层进程关系，sshd - bash - c - bash，即sshd 先创建一个bash以bash -c的方式执行传递过来的作为命令的字符串，然后再由这个bash创建执行.&#x2F;test.sh脚本的子bash进程（这个可以创建多个）。而本地执行ssh host “cmd”形式命令要能迅速返回，必须满足的条件是：该命令对象的sshd进程（一般是sshd: root@notty），没有子进程需要等待结束（靠将第一个bash搞成后台进程，或者第一个bash会立即执行完命令自然退出——即它启动一些后台子进程）， 而且没有其他进程与它有管道连接关系（靠重定向解决，在第一个bash处或者所有第二层bash处都可以）。简而言之，要ssh host “cmd”形式命令立即返回，在整个命令最后面添加“&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”，是有保证的。注意，对于组合的命令， 可能需要放到{}中才行，比如“{ cmd; } &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”这样的形式。这是因为重定向只对单个简单命令或单个复合命令有效。<br>下面通过一些实际例子的情况帮助大家认识（&#x2F;dev&#x2F;null也可以是某个本地文件）：</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 0&lt;&#x2F;dev&#x2F;null; done”</p>
<p>ssh不返回，.&#x2F;test.sh一个一个启动</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 0&lt;&#x2F;dev&#x2F;null; done &amp;”</p>
<p>ssh 不返回，.&#x2F;test.sh一个一个启动。 第一个bash（由sshd启动的bash -c）是后台执行的，但是文件描述符1和2还与sshd有管道连接，所以不返回</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 0&lt;&#x2F;dev&#x2F;null; done &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”</p>
<p>ssh立即返回，.&#x2F;tesh.sh一个接一个启动</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh ; done &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”</p>
<p>ssh立即返回，.&#x2F;test.sh一个接一个启动；由于执行.&#x2F;test.sh的bash是由第一个bash启动的，而第一个bash执行了重定向，所以该bash也继承了这些重定向，换言之这条命令与上条命令的效果一样，即内层的.&#x2F;test.sh无需重定向了</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &amp; done &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”</p>
<p>ssh立即退出，.&#x2F;test.sh全部启动，第一个bash也退出了</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &amp; done &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1”</p>
<p>ssh立即退出（为什么？因为第一个bash启动三个.&#x2F;tesh.sh的bash进程后，退出了；而执行.&#x2F;test.sh的bash进程因为继承了父bash的文件描述符，所以没有管道与sshd连接，因此ssh退出</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &amp; done “</p>
<p>ssh不返回，因为执行.&#x2F;test.sh与sshd还有管道连接</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 0&lt;&#x2F;dev&#x2F;null &amp; done” </p>
<p>ssh返回，因为第一个bash启动三个子bash之后结束，而子bash与sshd之间又没有管道上连接</p>
<p>ssh target “for w in a b c; do .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 0&lt;&#x2F;dev&#x2F;null &amp; done &amp;”</p>
<p>同上，因为第一个bash启动所有子进程后会退出，此时将第一个bash作为后台进程已经意义不大</p>
<p>ssh target “.&#x2F;test.sh &amp;&amp; .&#x2F;test.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;”</p>
<p>ssh不会返回</p>
<p>ssh target “{ .&#x2F;test.sh &amp;&amp; .&#x2F;test.sh; } &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;” </p>
<p>ssh会返回</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell脚本</tag>
        <tag>远程执行</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP四次挥手的过程</title>
    <url>/2021/06/09/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-27.png"></p>
<h2 id="那么四次挥手的过程呢？"><a href="#那么四次挥手的过程呢？" class="headerlink" title="那么四次挥手的过程呢？"></a>那么四次挥手的过程呢？</h2><ol>
<li><strong>client端</strong>向server发送FIN包，进入FIN_WAIT_1状态，这代表client端已经没有数据要发送了</li>
<li><strong>server端</strong>收到之后，返回一个ACK，进入CLOSE_WAIT等待关闭的状态，因为server端可能还有没有发送完成的数据</li>
<li>等到server端数据都发送完毕之后，<strong>server端</strong>就向client发送FIN，进入LAST_ACK状态</li>
<li><strong>client端</strong>收到ACK之后，进入TIME_WAIT的状态，同时回复ACK，server收到之后直接进入CLOSED状态，连接关闭。但是client要等待2MSL(报文最大生存时间)的时间，才会进入CLOSED状态。</li>
</ol>
<h2 id="为什么要等待2MSL的时间才关闭？"><a href="#为什么要等待2MSL的时间才关闭？" class="headerlink" title="为什么要等待2MSL的时间才关闭？"></a>为什么要等待2MSL的时间才关闭？</h2><p><code>为了保证连接的可靠关闭</code>。如果server没有收到最后一个ACK，那么就会重发FIN。<br>为了避免端口重用带来的数据混淆。如果client直接进入CLOSED状态，又用相同端口号向server建立一个连接，上一次连接的部分数据在网络中延迟到达server，数据就可能发生混淆了。</p>
<h2 id="TCP怎么保证传输过程的可靠性？"><a href="#TCP怎么保证传输过程的可靠性？" class="headerlink" title="TCP怎么保证传输过程的可靠性？"></a>TCP怎么保证传输过程的可靠性？</h2><p><strong>校验和：</strong> 发送方在发送数据之前计算校验和，接收方收到数据后同样计算，如果不一致，那么传输有误。<br>确认应答，序列号：TCP进行传输时数据都进行了编号，每次接收方返回ACK都有确认序列号。<br><strong>超时重传：</strong> 如果发送方发送数据一段时间后没有收到ACK，那么就重发数据。<br><strong>连接管理：</strong> 三次握手和四次挥手的过程。<br><strong>流量控制：</strong> TCP协议报头包含16位的窗口大小，接收方会在返回ACK时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度。<br><strong>拥塞控制：</strong> 刚开始发送数据的时候，拥塞窗口是1，以后每次收到ACK，则拥塞窗口+1，然后将拥塞窗口和收到的窗口取较小值作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为1。这样做的目的就是为了保证传输过程的高效性和可靠性。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>4次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>token 的前端设计方案</title>
    <url>/2021/08/06/token-%E7%9A%84%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-6.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>网上关于移动客户端与服务器数据传输之间的 token 的细节使用好像都没有详细的说明，基本都是一笔带过。对于简简单单的加入一个固定的参数 token，其实是很容易被抓包的。</p>
<p>token 是登录之后服务器返回的一段加密字符串（加密算法自己与后台商量如何加解密），存储到本地。在客户端请求服务端数据的时候可以带上（放在请求头headers，参数都行），更新 token 的方法自己与后台商量，以下只是思路。</p>
<p>下面说一下我自己的方案：</p>
<p><img src="https://img-blog.csdnimg.cn/47782e74115541fbbdf3e8b5a0efb1c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="启动页判断本地是否存在-token"><a href="#启动页判断本地是否存在-token" class="headerlink" title="启动页判断本地是否存在 token"></a>启动页判断本地是否存在 token</h3><hr>
<p>为啥在启动页更新 token 呢？是因为启动页在第一个页面，一般都会有几秒的等待时间，是不做网络请求操作的，而且页面使用率高。这样随机更新可以说安全性高。</p>
<h3 id="a）本地存在-token"><a href="#a）本地存在-token" class="headerlink" title="a）本地存在 token"></a>a）本地存在 token</h3><hr>
<p>1）客户端使用旧 token 请求更新 token<br>2）服务器判断 redis 是否存在 token<br>3）存在则生成新的token 存储在 redis 中，删除旧的 token<br>4）不存在则判断该用户是否存在另一个与之不相等的 token<br>5）存在与之不相等的 token则说明该用户账号在其他设备登录<br>6）不存在~则说明过期被删除或者在其他设备登录之后退出登录被删除（设置token过期时间为30天）</p>
<h3 id="b）本地不存在-token"><a href="#b）本地不存在-token" class="headerlink" title="b）本地不存在 token"></a>b）本地不存在 token</h3><hr>
<p>1）有三种情况，一种重来没登录过，一种是在新设备登录，一种是登录后退出用户</p>
<h3 id="退出用户"><a href="#退出用户" class="headerlink" title="退出用户"></a>退出用户</h3><hr>
<p>网络请求删除 redis 中的token，并删除本地的 token</p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>token</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令中_CPU 使用率_时钟中断_CPU 使用情况统计</title>
    <url>/2021/08/04/top%E5%91%BD%E4%BB%A4%E4%B8%AD-cpu-%E4%BD%BF%E7%94%A8%E7%8E%87-%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD-cpu-%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-3.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>平常我们使用 top 命令来查看系统的性能情况，在 top 命令中可以看到很多不同类型的 CPU 使用率，如下图红框中标出部分<br><img src="https://img-blog.csdnimg.cn/4318714591fc462795b9e0bfebe88119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面，我们来介绍一下这些 CPU 使用率的意义</p>
<ul>
<li>us：user time，表示 CPU 执行用户进程的时间，包括 nice 时间。通常都是希望用户空间CPU越高越好。</li>
<li>sy：system time，表示 CPU 在内核运行的时间，包括 IRQ 和 softirq。系统 CPU 占用越高，表明系统某部分存在瓶颈。通常这个值越低越好。</li>
<li>ni：nice time，具有优先级的用户进程执行时占用的 CPU 利用率百分比。</li>
<li>id：idle time，表示系统处于空闲期，等待进程运行。</li>
<li>wa：waiting time，表示 CPU 在等待 IO 操作完成所花费的时间。系统不应该花费大量的时间来等待 IO 操作，否则就说明 IO 存在瓶颈。</li>
<li>hi：hard IRQ time，表示系统处理硬中断所花费的时间。</li>
<li>si：soft IRQ time，表示系统处理软中断所花费的时间。</li>
<li>st：steal time，被强制等待（involuntary wait）虚拟 CPU 的时间，此时 Hypervisor 在为另一个虚拟处理器服务。</li>
</ul>
<p>当然，单靠上面的解释来理解它们的意义还是比较困难的。所以，本文主要从源码的角度来分析它们到底代表什么。</p>
<h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><hr>
<p>首先，我们要知道统计 CPU 使用情况在什么地方执行的。在分析之前，我们先来了解下 时钟中断：</p>
<p>时钟中断：是一种硬中断，由时间硬件（系统定时器，一种可编程硬件）产生。当 CPU 接收到时钟中断信号后，会在处理完当前指令后调用 时钟中断处理程序 来完成更新系统时间、执行周期性任务等。</p>
<p>可以发现，统计 CPU 使用情况是在 时钟中断处理程序 中完成的。</p>
<p>每个 CPU 的使用情况通过 cpu_usage_stat 结构来记录，我们来看看其定义：</p>
<p>struct cpu_usage_stat {<br>    cputime64_t user;<br>    cputime64_t nice;<br>    cputime64_t system;<br>    cputime64_t softirq;<br>    cputime64_t irq;<br>    cputime64_t idle;<br>    cputime64_t iowait;<br>    cputime64_t steal;<br>    cputime64_t guest;<br>};</p>
<p>从 cpu_usage_stat 结构的定义可以看出，其每个字段与 top 命令的 CPU 使用率类型一一对应。在内核初始化时，会为每个 CPU 创建一个 cpu_usage_stat 结构，用于统计 CPU 的使用情况。</p>
<p>OK，现在我们来分析下内核是怎么统计 CPU 的使用情况的。</p>
<p>每次执行 时钟中断处理程序 都会调用 account_process_tick 函数进行 CPU 使用情况统计，我们来分析一下 account_process_tick 函数的实现：</p>
<p>void account_process_tick(struct task_struct *p, int user_tick)<br>{<br>    cputime_t one_jiffy_scaled &#x3D; cputime_to_scaled(cputime_one_jiffy);<br>    struct rq *rq &#x3D; this_rq();</p>
<pre><code>// 说明：user\_tick 变量标识当前是否处于执行用户应用程序

if (user\_tick) &#123;
    // 1. 如果 CPU 在执行用户程序, 那么调用 account\_user\_time 进行统计
    account\_user\_time(p, cputime\_one\_jiffy, one\_jiffy\_scaled);
&#125; else if ((p != rq-&gt;idle)  (irq\_count() != HARDIRQ\_OFFSET)) &#123;
    // 2. 如果 CPU 在执行内核代码, 那么调用 account\_system\_time 进行统计
    account\_system\_time(p, HARDIRQ\_OFFSET, cputime\_one\_jiffy,
                        one\_jiffy\_scaled);
&#125; else &#123;
    // 3. 否则说明 CPU 在执行 idle 进程(也就是处于空闲状态), 那么调用 account\_idle\_time 进行统计
    account\_idle\_time(cputime\_one\_jiffy);
&#125;
</code></pre>
<p>}</p>
<p>account_process_tick 函数主要分 3 种情况进行统计，如下：</p>
<ul>
<li>如果 CPU 在执行用户程序，那么调用 account_user_time 进行统计。</li>
<li>如果 CPU 在执行内核代码，那么调用 account_system_time 进行统计。</li>
<li>否则说明 CPU 在执行 idle 进程(也就是处于空闲状态)，那么调用 account_idle_time 进行统计。</li>
</ul>
<h3 id="CPU-使用情况统计"><a href="#CPU-使用情况统计" class="headerlink" title="CPU 使用情况统计"></a>CPU 使用情况统计</h3><hr>
<p>下面我们分别对这 3 种统计进行分析。</p>
<ol>
<li>统计用户程序执行时间<br>统计用户程序的执行时间是通过 account_user_time 函数来完成的，我们来看看其实现：</li>
</ol>
<p>void account_user_time(struct task_struct *p, cputime_t cputime,<br>                       cputime_t cputime_scaled)<br>{<br>    &#x2F;&#x2F; 获取 CPU 的统计结构（每个CPU一个 cpu_usage_stat 结构）<br>    struct cpu_usage_stat *cpustat &#x3D; &amp;kstat_this_cpu.cpustat;<br>    cputime64_t tmp;<br>    …</p>
<pre><code>// 分 2 种情况统计 CPU 的使用情况
// 1. 如果进程的 nice 值大于0, 那么将会统计到 nice 字段中
// 2. 如果进程的 nice 值小于等于0, 那么将会统计到 user 字段中
if (TASK\_NICE(p) &gt; 0)
    cpustat-&gt;nice = cputime64\_add(cpustat-&gt;nice, tmp);
else
    cpustat-&gt;user = cputime64\_add(cpustat-&gt;user, tmp);
...
</code></pre>
<p>}</p>
<p>account_user_time 函数主要分两种情况统计：</p>
<ul>
<li>如果进程的 nice 值大于0，那么将会增加到 CPU 统计结构的 nice 字段中。</li>
<li>如果进程的 nice 值小于等于0，那么增加到 CPU 统计结构的 user 字段中。</li>
</ul>
<p>这里说明一下进程 nice 值的作用，nice 值越大，说明进程的优先级越低。所以，nice 统计值主要用来统计低优先级进程的占使用 CPU 的情况。也说明了，user 和 nice 统计值都属于执行用户程序的 CPU 时间。</p>
<ol start="2">
<li>统计内核代码执行时间<br>如果在发生时钟中断前，CPU 处于内核态，也就是说在执行内核代码。那么将会调用 account_system_time 函数进行统计，account_system_time 函数实现如下：</li>
</ol>
<p>void account_system_time(struct task_struct *p, int hardirq_offset,<br>                         cputime_t cputime, cputime_t cputime_scaled)<br>{<br>    &#x2F;&#x2F; 获取 CPU 的统计结构（每个CPU一个 cpu_usage_stat 结构）<br>    struct cpu_usage_stat *cpustat &#x3D; &amp;kstat_this_cpu.cpustat;<br>    cputime64_t tmp;<br>    …</p>
<pre><code>// 主要分 3 种情况进行统计
// 1. 如果当前处于硬中断执行上下文, 那么统计到 irq 字段中
// 2. 如果当前处于软中断执行上下文, 那么统计到 softirq 字段中
// 3. 否则统计到 system 字段中
if (hardirq\_count() - hardirq\_offset)
    cpustat-&gt;irq = cputime64\_add(cpustat-&gt;irq, tmp);
else if (softirq\_count())
    cpustat-&gt;softirq = cputime64\_add(cpustat-&gt;softirq, tmp);
else
    cpustat-&gt;system = cputime64\_add(cpustat-&gt;system, tmp);
...
</code></pre>
<p>}</p>
<p>account_system_time 函数主要分 3 种情况进行统计：</p>
<ul>
<li>如果当前处于硬中断执行上下文，那么增加到 CPU 统计结构的 irq 字段中。</li>
<li>如果当前处于软中断执行上下文，那么增加到 CPU 统计结构的 softirq 字段中。</li>
<li>否则增加到 CPU 统计结构的 system 字段中。</li>
</ul>
<p>从上面代码可以看出，irq 和 softirq 统计值也算是内核代码执行时间。</p>
<ol start="3">
<li>idle 进程执行时间统计<br>当系统中没有可运行的进程时，将会执行 idle 进程。也就是说，当系统执行 idle 进程时，表示系统正处于空闲状态。</li>
</ol>
<p>idle 进程执行时间统计由 account_idle_time 函数完成，其实现如下：</p>
<p>void account_idle_time(cputime_t cputime)<br>{<br>    struct cpu_usage_stat *cpustat &#x3D; &amp;kstat_this_cpu.cpustat;<br>    cputime64_t cputime64 &#x3D; cputime_to_cputime64(cputime);<br>    struct rq *rq &#x3D; this_rq();</p>
<pre><code>// 分 2 种情况统计 CPU 的使用情况
// 1. 如果系统有进程正在等待 I/O 操作完成, 那么将统计到 iowait 字段中
// 2. 否则将统计到 idle 字段中
if (atomic\_read(&amp;rq-&gt;nr\_iowait) &gt; 0)
    cpustat-&gt;iowait = cputime64\_add(cpustat-&gt;iowait, cputime64);
else
    cpustat-&gt;idle = cputime64\_add(cpustat-&gt;idle, cputime64);
</code></pre>
<p>}</p>
<p>account_idle_time 函数也分两种情况进行统计：</p>
<ul>
<li>如果系统中有正在等待 I&#x2F;O 操作完成的进程，那么增加到 CPU 统计结构的 iowait 字段中。</li>
<li>否则增加到 CPU 统计结构的 idle 字段中。</li>
</ul>
<p>从上面的分析可以看出，iowait 统计值也属于空闲时间的一种。</p>
<h3 id="top-命令的-CPU-使用率"><a href="#top-命令的-CPU-使用率" class="headerlink" title="top 命令的 CPU 使用率"></a>top 命令的 CPU 使用率</h3><hr>
<p>通过源码分析，我们知道 top 命令中 CPU 使用率各种类型的意思，现在我们来介绍一下 top 命令是怎么计算各种类型的 CPU 使用率。</p>
<p>要获取各个 CPU 的使用情况信息，可以通过读取 &#x2F;proc&#x2F;stat 文件获取，如下：</p>
<p>[vagrant@localhost ~]$ cat &#x2F;proc&#x2F;stat<br>cpu  245 10 1142 1097923 95 0 28 0 0 0<br>cpu0 245 10 1142 1097923 95 0 28 0 0 0<br>…</p>
<p>上面的结果显示了 CPU 的使用情况信息，第一行代表所有 CPU 的总和，而第二行开始表示每个 CPU 核心的使用情况信息。因为我的电脑只有一个核，所以只有一条数据。</p>
<p>下面说说这些数据的意义，从第一个数值开始分别代表：user ，nice，system，idle，iowait， irq，softirq，steal。</p>
<p>所以，top 命令的 CPU 使用率计算公式如下：</p>
<p>CPU总时间 &#x3D; user + nice + system + idle + wait + irq + softirq + steal<br>%us &#x3D; user &#x2F; CPU总时间<br>%ni &#x3D; nice &#x2F; CPU总时间<br>%sy &#x3D; system &#x2F; CPU总时间<br>%id &#x3D; idel &#x2F; CPU总时间<br>%wa &#x3D; wait &#x2F; CPU总时间<br>%hi &#x3D; irq &#x2F; CPU总时间<br>%si &#x3D; softirq &#x2F; CPU总时间<br>%st &#x3D; steal &#x2F; CPU总时间</p>
<p>嗯，看起来还是挺简单的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>本文主要分析了 top 命令中的 CPU 使用率的意义和实现原理，希望通过本文，能够帮助大家对 top 命令有更深的认识。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>CPU 使用情况统计</tag>
        <tag>TOP</tag>
        <tag>时钟中断</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 12.04.1 desktop 设置 添加 中文输入法</title>
    <url>/2021/11/07/ubuntu-12-04-1-desktop-%E8%AE%BE%E7%BD%AE-%E6%B7%BB%E5%8A%A0-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-7.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在安装完成 Ubuntu 12.04.1 desktop 系统后，进入桌面环境往往会发现，无法输入中文输入法，也无法切换到中文输入法，原因是系统内还没有中文环境，<a href="https://www.code404.icu/1382.html">安装Ubuntu中文支持</a></p>
<h3 id="打开Ubuntu系统设置"><a href="#打开Ubuntu系统设置" class="headerlink" title="打开Ubuntu系统设置"></a>打开Ubuntu系统设置</h3><hr>
<p>一般来说点一下 右上角的下三角就可以，选择 设置 进入配置<br><img src="https://img-blog.csdnimg.cn/bd971e29e6ba437ea10b4262f7dbae48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="进入配置窗口后，选择区域与语言"><a href="#进入配置窗口后，选择区域与语言" class="headerlink" title="进入配置窗口后，选择区域与语言"></a>进入配置窗口后，选择区域与语言</h3><hr>
<p>在输入源下面，点击加号，添加中文语言输入法<br><img src="https://img-blog.csdnimg.cn/38a2b45e6e614094a1b1839b71c7c560.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="添加中文输入法"><a href="#添加中文输入法" class="headerlink" title="添加中文输入法"></a>添加中文输入法</h3><hr>
<p>添加输入源，选择汉语<br><img src="https://img-blog.csdnimg.cn/6fe58e482bc9488794990e001314d191.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="把你需要的输入法都添加上吧"><a href="#把你需要的输入法都添加上吧" class="headerlink" title="把你需要的输入法都添加上吧"></a>把你需要的输入法都添加上吧</h3><hr>
<p>我选了极点五笔和汉语拼音<br><img src="https://img-blog.csdnimg.cn/afeefd348bf84c9daf54431622ae051b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="添加汉语输入法完成"><a href="#添加汉语输入法完成" class="headerlink" title="添加汉语输入法完成"></a>添加汉语输入法完成</h3><hr>
<p>确认看一下，我们加好的输入法<br><img src="https://img-blog.csdnimg.cn/a5cc8d2c63864fecb320c6332aff2b29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="怎么切换输入法呢"><a href="#怎么切换输入法呢" class="headerlink" title="怎么切换输入法呢"></a>怎么切换输入法呢</h3><hr>
<p>下图显示了，如何切换输入法<br>super 键+ 空格 键 下一个输入法<br>shift 键+ super 键+ 空格 键 上一个输入法<br><img src="https://img-blog.csdnimg.cn/d4878624ef2e4bc2ba1c3b739a606446.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/290281b1592b403d9000fe895ea380c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="试试我的中文输入法"><a href="#试试我的中文输入法" class="headerlink" title="试试我的中文输入法"></a>试试我的中文输入法</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/5b5d3bebd3054e829a96aac63dc66ba2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>汉语</tag>
        <tag>汉语输入法</tag>
        <tag>输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 12.04.1 desktop 设置中文界面</title>
    <url>/2021/11/06/ubuntu-12-04-1-desktop-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-6-1024x580.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在安装完成 Ubuntu Desktop 系统后登录桌面发现系统是英文的，那是因为在安装系统时没有选择中文字体。英文界面让我们看也来也不太习惯，下面我教大家如何改成中文界面</p>
<h3 id="打开Ubuntu系统设置"><a href="#打开Ubuntu系统设置" class="headerlink" title="打开Ubuntu系统设置"></a>打开Ubuntu系统设置</h3><hr>
<p>一般来说点一下 右上角的下三角就可以，选择Settings 进入配置<br><img src="https://img-blog.csdnimg.cn/5f40c9defe454b998b51964173696fee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="配置Region和Language"><a href="#配置Region和Language" class="headerlink" title="配置Region和Language"></a>配置Region和Language</h3><hr>
<p>进入配置界面选择 Region &amp; Language 配置语言<br>点击 Manage Installed Languages 进入安装语言界面<br><img src="https://img-blog.csdnimg.cn/438814fe5212462197a2fe0afb195741.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="安装语言"><a href="#安装语言" class="headerlink" title="安装语言"></a>安装语言</h3><hr>
<p>在这一步选择 Install&#x2F;Remove Languages 进行添加或删除语言<br>我们在这里把Chinese（simplified）选中安装<br><img src="https://img-blog.csdnimg.cn/b874e3cad43540fd91f0540ff30e41be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="Chinese（simplified）安装中"><a href="#Chinese（simplified）安装中" class="headerlink" title="Chinese（simplified）安装中"></a>Chinese（simplified）安装中</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/a66a07f1b8de4941986d39f1c91c5e93.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="Chinese（simplified）安装完成"><a href="#Chinese（simplified）安装完成" class="headerlink" title="Chinese（simplified）安装完成"></a>Chinese（simplified）安装完成</h3><hr>
<p>我把Chinese（simplified）拖到最上方，<br><img src="https://img-blog.csdnimg.cn/e0da1ad4be0e45be8d9bb8aab1e93c1d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="重启后就生效了，重启后会提示-把英文目录替换为中文"><a href="#重启后就生效了，重启后会提示-把英文目录替换为中文" class="headerlink" title="重启后就生效了，重启后会提示 把英文目录替换为中文"></a>重启后就生效了，重启后会提示 把英文目录替换为中文</h3><hr>
<p>全部替换就好了</p>
<p><img src="https://img-blog.csdnimg.cn/122d9cab5c4148ee9511300db63c075d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>中文</tag>
        <tag>Ubuntu</tag>
        <tag>ubuntu 20.04 desktop</tag>
        <tag>桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 截图编辑_编辑截图工具</title>
    <url>/2021/12/22/ubuntu-%E6%88%AA%E5%9B%BE%E7%BC%96%E8%BE%91-%E7%BC%96%E8%BE%91%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-14.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在 Linux 中截图，如果只需要获取一张屏幕截图，不对其进行编辑的话，那么键盘的默认快捷键就可以满足要求了。而且不仅仅是 Ubuntu ，绝大部分的 Linux 发行版和桌面环境都支持以下这些快捷键：</p>
<ul>
<li>PrtSc 获取整个屏幕的截图并保存到 Pictures 目录。</li>
<li>Shift + PrtSc 获取屏幕的某个区域截图并保存到 Pictures 目录。</li>
<li>Alt + PrtSc 获取当前窗口的截图并保存到 Pictures 目录。</li>
<li>Ctrl + PrtSc 获取整个屏幕的截图并存放到剪贴板。</li>
<li>Shift + Ctrl + PrtSc 获取屏幕的某个区域截图并存放到剪贴板。</li>
<li>Ctrl + Alt + PrtSc 获取当前窗口的 截图并存放到剪贴板。</li>
</ul>
<p>在 Linux 中使用默认的快捷键获取屏幕截图是相当简单的。但如果要在不把屏幕截图导入到其它应用程序的情况下对屏幕截图进行编辑，还是使用屏幕截图工具比较方便</p>
<h3 id="在-Linux-中使用-Flameshot-获取屏幕截图并编辑"><a href="#在-Linux-中使用-Flameshot-获取屏幕截图并编辑" class="headerlink" title="在 Linux 中使用 Flameshot 获取屏幕截图并编辑"></a>在 Linux 中使用 Flameshot 获取屏幕截图并编辑</h3><hr>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><ul>
<li>注释 (高亮、标示、添加文本、框选)</li>
<li>图片模糊</li>
<li>图片裁剪</li>
<li>上传到 Imgur</li>
<li>用另一个应用打开截图</li>
</ul>
<p>如果你需要的是一个能够用于标注、模糊、上传到 imgur 的新式截图工具，那么 Flameshot 是一个好的选择。</p>
<h3 id="安装截图工具Flameshot"><a href="#安装截图工具Flameshot" class="headerlink" title="安装截图工具Flameshot"></a>安装截图工具Flameshot</h3><hr>
<p>如果你用的是 Ubuntu，那么只需要在 Ubuntu 软件中心上搜索，就可以找到 Flameshot 进而完成安装了<br><img src="https://img-blog.csdnimg.cn/b28090067d254f2d8872795107872971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="使用终端来安装，可以执行以下命令"><a href="#使用终端来安装，可以执行以下命令" class="headerlink" title="使用终端来安装，可以执行以下命令"></a>使用终端来安装，可以执行以下命令</h3><hr>
<p>sudo apt install flameshot</p>
<p>如果你在安装过程中遇到问题，可以按照<a href="https://github.com/flameshot-org/flameshot#installation">官方的安装说明</a>进行操作<br>安装完成后，你还需要进行配置。尽管可以通过搜索来随时启动 Flameshot，但如果想使用 快捷键 触发启动，则需要指定对应的键盘快捷键。</p>
<h3 id="配置截图快捷键"><a href="#配置截图快捷键" class="headerlink" title="配置截图快捷键"></a>配置截图快捷键</h3><ul>
<li>进入系统设置中的“键盘设置”</li>
<li>页面中会列出所有现有的键盘快捷键，拉到底部就会看见一个 “+” 按钮</li>
<li>点击 “+” 按钮添加自定义快捷键并输入以下两个字段：</li>
<li>“名称”： 任意名称均可。</li>
<li>“命令”： &#x2F;usr&#x2F;bin&#x2F;flameshot gui</li>
<li>最后将这个快捷操作绑定到 Ctrl+q 键上，可能会提示与系统的截图功能相冲突，但可以忽略掉这个警告。</li>
</ul>
<p>配置之后，你的自定义快捷键页面大概会是以下这样：<br><img src="https://img-blog.csdnimg.cn/f06d86d4c28941d196f407c5254715bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>IT杂谈</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Flameshot</tag>
        <tag>截图工具</tag>
      </tags>
  </entry>
  <entry>
    <title>umount.nfs4: /mnt/nfs/code404: device is busy</title>
    <url>/2021/12/28/umount-nfs4-mnt-nfs-code404-device-is-busy/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-20.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>执行NFS挂载时，你可能会看到设备繁忙状态。在这种情况下，你必须以适当的方式强制卸载。</p>
<h3 id="查看挂载的分区"><a href="#查看挂载的分区" class="headerlink" title="查看挂载的分区"></a>查看挂载的分区</h3><hr>
<p>使用 df -h 查看分区</p>
<p># df -h<br>Filesystem Size Used Avail Use% Mounted on<br>&#x2F;dev&#x2F;vda1  20G 3G 18G 7% &#x2F;<br>devtmpfs  236M 0 236M 0% &#x2F;dev<br>tmpfs     245M 0 245M 0% &#x2F;dev&#x2F;shm<br>tmpfs     245M 4M 237M 4% &#x2F;run<br>tmpfs     245M 0 245M 0% &#x2F;sys&#x2F;fs&#x2F;cgroup<br>tmpfs      49M 0 49M 0% &#x2F;run&#x2F;user&#x2F;0<br>192.168.55.101:&#x2F;var&#x2F;code404 20G 3G 18G 7% &#x2F;mnt&#x2F;nfs&#x2F;code404</p>
<h3 id="卸载-nfs-挂载"><a href="#卸载-nfs-挂载" class="headerlink" title="卸载 nfs 挂载"></a>卸载 nfs 挂载</h3><hr>
<p>提示 device is busy</p>
<p>umount &#x2F;mnt&#x2F;nfs&#x2F;code404<br>umount.nfs4: &#x2F;mnt&#x2F;nfs&#x2F;code404: device is busy</p>
<h3 id="使用lsof-查看占用进程"><a href="#使用lsof-查看占用进程" class="headerlink" title="使用lsof 查看占用进程"></a>使用lsof 查看占用进程</h3><hr>
<p>lsof（列出打开的文件）命令显示特定文件系统，目录或设备上所有打开的文件及其关联进程的列表。默认情况下，它列出所有当前打开的文件，共享库和目录，并提供有关每个文件的尽可能多的信息。可以使用管道对输出进行过滤，以提供诸如PID，USER等信息。</p>
<p>lsof &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br>COMMAND PID USER FD TYPE DEVICE SIZE&#x2F;OFF NODE NAME<br>bash 24098 root cwd DIR 253,1 4096 519062 &#x2F;mnt&#x2F;nfs&#x2F;code404<br>bash 24125 root cwd DIR 253,1 4096 519062 &#x2F;mnt&#x2F;nfs&#x2F;code404<br>vim 24144 code404 cwd DIR 253,1 4096 519062 &#x2F;mnt&#x2F;nfs&#x2F;code404</p>
<p>存在使用已安装文件夹的进程的PID，并显示正在执行的命令和执行该命令的用户<br>可以杀死正在使用的进程，但可以处理执行的命令<br>在上面可以看到vim命令。这意味着code404用户正在编辑文件<br>因此，如果你杀死进程，他的进度将会丢失。让我们看一下结果，假设你已通知他</p>
<p>lsof &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br>COMMAND PID USER FD TYPE DEVICE SIZE&#x2F;OFF NODE NAME<br>bash 24098 root cwd DIR 253,1 4096 519062 &#x2F;mnt&#x2F;nfs&#x2F;code404<br>bash 24125 root cwd DIR 253,1 4096 519062 &#x2F;mnt&#x2F;nfs&#x2F;code404</p>
<p>看来用户已停止进行更改，但仍在运行bash命令，但我不知道为什么。你可以使用kill命令杀死两个进程。不要错过被杀死的进程的PID。</p>
<p>杀死bash进程</p>
<p>kill -9 24098 24125<br>lsof &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;</p>
<h3 id="umount-卸载文件夹"><a href="#umount-卸载文件夹" class="headerlink" title="umount 卸载文件夹"></a>umount 卸载文件夹</h3><hr>
<p>umount &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br>umount: &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;: not mounted</p>
<p>杀进程时，似乎自动卸载了该文件夹，用df命令检查一下</p>
<p>df -h<br>Filesystem Size Used Avail Use% Mounted on<br>&#x2F;dev&#x2F;vda1 20G 3G 18G 7% &#x2F;<br>devtmpfs  236M 0 236M 0% &#x2F;dev<br>tmpfs     245M 0 245M 0% &#x2F;dev&#x2F;shm<br>tmpfs     245M 3M 237M 4% &#x2F;run<br>tmpfs     245M 0 245M 0% &#x2F;sys&#x2F;fs&#x2F;cgroup<br>tmpfs     49M 0 49M 0% &#x2F;run&#x2F;user&#x2F;0</p>
<h3 id="fuser查找占用进程"><a href="#fuser查找占用进程" class="headerlink" title="fuser查找占用进程"></a>fuser查找占用进程</h3><hr>
<p>fuser（查找用户进程）命令可以帮助识别阻止文件系统卸载的进程。查找与指定为命令行参数的文件，目录或文件系统安装点关联的用户进程。</p>
<p>fuser &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br>&#x2F;mnt&#x2F;nfs&#x2F;code404: 24191c</p>
<p>你可以使用fuser命令 -m 列出访问文件的所有进程或文件系统上的挂载点的选项 -v 显示PID命令，用户，已执行命令等结果的选项。</p>
<p># fuser -mv &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br> USER PID ACCESS COMMAND<br>&#x2F;mnt&#x2F;nfs&#x2F;code404:<br> root kernel mount &#x2F;mnt&#x2F;nfs&#x2F;code404<br> root 24191 ..c.. bash<br> root 24275 ..c.. bash<br> code404 24290 ..c.. vim</p>
<p>你可以使用fuser命令直接停止运行进程。-k 无选项-kill命令</p>
<p># fuser -kmv &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br> USER PID ACCESS COMMAND<br>&#x2F;mnt&#x2F;nfs&#x2F;code404:<br> root kernel mount &#x2F;mnt&#x2F;nfs&#x2F;code404<br> root 24191 ..c.. bash<br> root 24275 ..c.. bash</p>
<p>检查结果</p>
<p>fuser -mv &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;<br> USER PID ACCESS COMMAND<br> &#x2F;mnt&#x2F;nfs&#x2F;code404:<br> root kernel mount &#x2F;mnt&#x2F;nfs&#x2F;code404</p>
<p>只有挂载似乎正在运行。让我们卸载文件夹</p>
<p>umount &#x2F;mnt&#x2F;nfs&#x2F;code404&#x2F;</p>
<p>没有错误消息，正常卸载</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>你需要紧急卸载分区或仅删除设备，但是由于设备繁忙，这可能会引起问题。在决定如何解决问题之前，必须检查系统上的所有进程。使用lsof和fuser命令可以轻松识别阻止文件系统卸载的进程。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>device is busy</tag>
        <tag>mount</tag>
        <tag>nfs4</tag>
        <tag>umount</tag>
        <tag>卸载</tag>
      </tags>
  </entry>
  <entry>
    <title>Unable to acquire dpkg frontend lock. Are You Root?</title>
    <url>/2021/10/31/unable-to-acquire-dpkg-frontend-lock-are-you-root/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我假设你对 Linux 很陌生。</p>
<p>你按照网上的一些教程，告诉你要安装某个程序或运行某个命令。可能是与服务器有关的东西。</p>
<p>但当你运行这个命令时，你遇到了这个错误：</p>
<p>E: Could not open lock file &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend – open (13: Permission denied)<br>E: Unable to acquire the dpkg frontend lock (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend), are you root?</p>
<p>E: Could not open lock file &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend – open (13: Permission denied)<br>E: Unable to acquire the dpkg frontend lock (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend), are you root?<br>或者类似的错误：</p>
<p>dpkg: error: required read&#x2F;write access to the dpkg database directory &#x2F;var&#x2F;lib&#x2F;dpkg<br>E: Sub-process dpkg –set-selections returned an error code (2)<br>E: Executing dpkg failed. Are you root?</p>
<p>dpkg: error: required read&#x2F;write access to the dpkg database directory &#x2F;var&#x2F;lib&#x2F;dpkg<br>E: Sub-process dpkg –set-selections returned an error code (2)<br>E: Executing dpkg failed. Are you root?<br>这两个错误都在问你同一个问题：你是 root 吗？而这就是这个问题的答案。切换 root。</p>
<h3 id="如何让-root-以避免这个错误"><a href="#如何让-root-以避免这个错误" class="headerlink" title="如何让 root 以避免这个错误"></a>如何让 root 以避免这个错误</h3><hr>
<p>你如何 在 Ubuntu 或 Debian 中切换 root？你使用 sudo 命令。</p>
<p>是的，就是这样。无论你在运行什么命令，只要在它前面加上 sudo 即可。</p>
<p>sudo your_command</p>
<p><img src="https://img-blog.csdnimg.cn/5e2783bc25074118886c5a4eadaf53cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>它将要求你输入你的用户账户密码。请记住，当你输入密码时，屏幕上不会显示任何东西，这也没关系。</p>
<p>你的系统没有任何问题。在大多数 Linux 系统中，输入密码时不会显示通常的星号或其他东西是一种“安全特性”。</p>
<p>只要输入密码，并在密码后按下回车键即可。如果密码输入正确，你现在应该可以运行该命令了。</p>
<p>你甚至可以使用这个方便的 Linux 命令行，用 sudo 运行以前的命令：</p>
<p>sudo !!</p>
<p>这很简单，而且立即生效，除非你没有 sudo 权限。然后，你会看到一个不同的错误。</p>
<h3 id="看到一个-“User-is-not-in-sudoer-file”-的错误？"><a href="#看到一个-“User-is-not-in-sudoer-file”-的错误？" class="headerlink" title="看到一个 “User is not in sudoer file” 的错误？"></a>看到一个 “User is not in sudoer file” 的错误？</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/48ff97790ec141f58d153853b9fb1619.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当你 安装 Ubuntu 时，你必须创建一个用户账户。这个用户被自动授予 sudo 权限，在需要时以 root 身份运行命令。</p>
<p>这发生在 Ubuntu 桌面上，而不是服务器上。大多数服务器发行版会有一个单独的 root 账户。如果你单独创建了一个普通账户，你就必须把这个用户添加到 sudoer 中，以便这个普通用户可以使用 sudo。</p>
<p>在上面的截图中，我已经创建了这个额外的用户，但没有将其添加到 sudo 组中。这意味着这里的用户 prakash 没有使用 sudo 命令的权限，因此系统抱怨 “prakash is not in sudoers file”。</p>
<h3 id="该事件日志在哪里？"><a href="#该事件日志在哪里？" class="headerlink" title="该事件日志在哪里？"></a>该事件日志在哪里？</h3><p>错误的 sudo 尝试会被添加到系统日志中。它记录了用户名、虚拟终端号、运行命令的位置和运行的命令。</p>
<p><img src="https://img-blog.csdnimg.cn/14219f9ec4fb4c80b22ffd8b5f4ea0b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这些日志的位置在不同的发行版中有所不同。</p>
<p>通常，在 Ubuntu 中你可以在 journalctl 日志或 &#x2F;var&#x2F;log&#x2F;auth.log 文件中找到它，在 Fedora 中可以在 &#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log 文件中找到它。</p>
<h3 id="如果一个用户不在-sudoer-列表中，你能做什么？"><a href="#如果一个用户不在-sudoer-列表中，你能做什么？" class="headerlink" title="如果一个用户不在 sudoer 列表中，你能做什么？"></a>如果一个用户不在 sudoer 列表中，你能做什么？</h3><hr>
<p>当你不能用当前的用户账户使用 sudo 时，你能做什么？首先，验证该用户是否有 sudo 权限。如果没有，你可以有一些选择：</p>
<p>◈ 以 root 身份登录或切换 root 身份（如果你有 root 密码）。<br>◈ 将该用户加入 sudoer 列表（如果你有其他用户账户的管理或 sudo 权限）。<br>◈ 如果你在多用户的 Linux 系统中，自己没有 root 或 sudo 权限，请你的系统管理员授予你的用户 sudo 权限或安装你想安装的应用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>sudo 是一个非常全面的安全机制，它不仅仅是允许一个普通用户切换 root。它有助于对系统进行审计，了解哪个用户用 sudo 运行了哪个命令。它还可以被配置为只允许某个用户用 sudo 运行某些命令。</p>
<p>你不会在桌面 Linux 上看到如此细化的 sudo 配置，在桌面 Linux 上，它被预先配置为允许 sudo 组中的任何用户以 root 的身份运行任何命令。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sudo</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0x91 in position 151: illegal multibyte sequence</title>
    <url>/2021/10/29/unicodedecodeerror-gbk-codec-cant-decode-byte-0x91-in-position-151-illegal-multibyte-sequence/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-25.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>使用Python操作文件时报错</p>
<p>UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x91 in position 151: illegal multibyte sequence</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr>
<p>settings&#x3D;open(os.path.join(os.getcwd(),’web’,’superman.json’) ,’r’).read()</p>
<h3 id="服务报错内容"><a href="#服务报错内容" class="headerlink" title="服务报错内容"></a>服务报错内容</h3><hr>
<p>RROR:pywebio.session.base:Error<br>Traceback (most recent call last):<br>  File “C:\Users\code404\PycharmProjects\OpsGuide\venv\lib\site-packages\pywebio\session\threadbased.py”, line 86, in main_task<br>    target()<br>  File “C:\Users\code404\PycharmProjects\OpsGuide\web\guide.py”, line 9, in bmi<br>    settings&#x3D;open(os.path.join(os.getcwd(),’web’,’superman.json’) ,’r’).read()<br>UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x91 in position 151: illegal multibyte sequence</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><hr>
<p>txt是utf-8编码，所以编码需要转为utf-8</p>
<h3 id="把代码修改为"><a href="#把代码修改为" class="headerlink" title="把代码修改为"></a>把代码修改为</h3><hr>
<p>settings&#x3D;open(os.path.join(os.getcwd(),’web’,’superman.json’) ,’r’,encoding&#x3D;’utf-8’).read()</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编码</tag>
        <tag>GBK</tag>
        <tag>utf-8</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>URL和URI之间的区别</title>
    <url>/2021/05/28/url%E5%92%8Curi%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-49.png"></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>浏览网页时，我们需要知道“网址”才能访问，这里说的“网址”通常就是指URL，比如：<a href="https://www.code404.icu/index.html%EF%BC%8C%E8%80%8C%E5%B9%B3%E6%97%B6%E4%B9%9F%E4%BC%9A%E8%AF%B4URI%E3%80%81URN%EF%BC%8C%E9%82%A3%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E4%BB%8A%E5%A4%A9%E5%B0%B1%E6%9D%A5%E6%8D%8B%E4%B8%80%E6%8D%8B%E3%80%82">https://www.code404.icu/index.html，而平时也会说URI、URN，那又是什么呢？今天就来捋一捋。</a></p>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p><strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符，就是我们说的网址，标准格式如下：</p>
<p>协议类型有很多，常见的有http、ftp、file等，既然代表一个资源，那么数据库连接字符串也算作URL，如：jdbc:datadirect:oracle:&#x2F;&#x2F;myserver:1521;sid&#x3D;testdb。</p>
<h1 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h1><p><strong>U</strong>niform <strong>R</strong>esource <strong>N</strong>ame，统一资源名称，指互联网上某一独一无二的资源的名称，标准格式如下：</p>
<blockquote>
<p>urn:<nid>:<nss></p>
</blockquote>
<p>开头的urn:序列大小写不敏感的。<nid>是命名空间标识，它是一个“命名空间特定”的字符串，决定了如何解释<nss>的句法，比如这个：urn:isbn:0-486-27557-4，指向的就是莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。</p>
<h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><p><strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标志符，是标志互联网上某一资源的字符串，它包含URL和URN，如图：</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-48.png"></p>
<p>所以，URN如同一个人的名称，URL代表一个人的地址。还是拿上面的ISBN 0-486-27557-4举例，它表示的是一本书，为了获得这本书的资源来阅读，就需要知道它的位置，也就是URL。更进一步，URN定义某事物的身份，而URL提供查找该事物的方法。</p>
<h1 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a>URL Scheme</h1><p>这是ios在很久之前推出的为了在app间通信的一种特殊链接，就是我们常说的Deep Link，比如：taobao:&#x2F;&#x2F;market.m.taobao.com&#x2F;app&#x2F;tmall-def&#x2F;daily-welfare&#x2F;pages&#x2F;index?wh_weex&#x3D;true，在浏览器里输入这个链接就能直接打开淘宝APP的领红包页面，可以看到URL Scheme的协议字段是自定义的，一些其他的APP URL Scheme可以看我这篇文章，局限性，比如APP开发人员要维护两套逻辑，而且自定义的协议字段有可能被其他APP占用。</p>
<h1 id="Universal-Link"><a href="#Universal-Link" class="headerlink" title="Universal Link"></a>Universal Link</h1><p>后来，由于URL Scheme的各种局限性，ios 9之后又推出了Universal Link，官网的解释如下：</p>
<blockquote>
<p>Seamlessly link to content inside your app, or on your website in iOS 9 or later. With universal links, you can always give users the most integrated mobile experience, even when your app isn’t installed on their device.</p>
</blockquote>
<p>通俗地讲，Universal Link可以让用户点击跳转的时候直接打开APP，并跳转到指定页面，这个和上面的Deep Link一样，只不过不用自定义协议字段，直接用通用的网址链接就可以打开APP，比如浏览器中输入<a href="https://www.code404.icu/%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%9F%90%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%90%8C%E6%97%B6%E5%A6%82%E6%9E%9C%E5%AE%89%E8%A3%85%E4%BA%86APP%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B0%B1%E4%BC%9A%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80APP%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BE%88%E5%8E%89%E5%AE%B3%E3%80%82">https://www.code404.icu/，浏览器会跳转到某个页面，同时如果安装了APP的话，就会直接打开APP对应的页面，是不是很厉害。</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
        <category>url</category>
      </categories>
      <tags>
        <tag>url</tag>
        <tag>uri</tag>
        <tag>urn</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 大神操作手册_退出vim_编辑vim_查找vim_vim替换？</title>
    <url>/2021/10/17/vim-%E5%A4%A7%E7%A5%9E%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C-%E9%80%80%E5%87%BAvim-%E7%BC%96%E8%BE%91vim-%E6%9F%A5%E6%89%BEvim-vim%E6%9B%BF%E6%8D%A2%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-13.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我本人是 Vim 的重度使用者，就因为喜欢上这种双手不离键盘就可以操控一切的feel，Vim 可以让我对文本的操作更加精准、高效。</p>
<p>对于未使用过 Vim 的朋友来说，可能还无法体会到这种感觉。由于使用 Vim 有一定的学习成本，只有做到非常熟练的程度才能感受到它带来的快捷。</p>
<p>这里我就自己日常有使用过的 Vim 指令做一个总结，总共分成 21 点，建议有想学习 Vim 的同学，可以按照文章配合搜索引擎多多尝试，相信你会慢慢喜欢上 Vim。</p>
<p>本文更倾向于有一定基础的同学，因为内容很多，如果写得太详细的话，会变得相当啰嗦。</p>
<h3 id="1-vim模式"><a href="#1-vim模式" class="headerlink" title="1. vim模式"></a>1. vim模式</h3><hr>
<p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i进入） 左下角显示–INSERT–<br>可视模式（按v进入） 左下角显示–VISUAL–</p>
<h3 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="2. 打开文件"></a>2. 打开文件</h3><hr>
<p># 打开单个文件<br>vim file    </p>
<h1 id="同时打开多个文件"><a href="#同时打开多个文件" class="headerlink" title="同时打开多个文件"></a>同时打开多个文件</h1><p>vim file1 file2..  </p>
<h1 id="在vim窗口中打开一个新文件"><a href="#在vim窗口中打开一个新文件" class="headerlink" title="在vim窗口中打开一个新文件"></a>在vim窗口中打开一个新文件</h1><p>:open [file]       </p>
<p>【举个例子】</p>
<h1 id="当前打开1-txt，做了一些编辑没保存"><a href="#当前打开1-txt，做了一些编辑没保存" class="headerlink" title="当前打开1.txt，做了一些编辑没保存"></a>当前打开1.txt，做了一些编辑没保存</h1><p>:open!         放弃这些修改，并重新打开未修改的文件</p>
<h1 id="当前打开1-txt，做了一些编辑并保存"><a href="#当前打开1-txt，做了一些编辑并保存" class="headerlink" title="当前打开1.txt，做了一些编辑并保存"></a>当前打开1.txt，做了一些编辑并保存</h1><p>:open 2.txt    直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤</p>
<h1 id="打开远程文件，比如ftp或者share-folder"><a href="#打开远程文件，比如ftp或者share-folder" class="headerlink" title="打开远程文件，比如ftp或者share folder"></a>打开远程文件，比如ftp或者share folder</h1><p>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a><br>:e \qadrive\test\1.txt</p>
<h1 id="以只读形式打开文件，但是仍然可以使用-wq-写入"><a href="#以只读形式打开文件，但是仍然可以使用-wq-写入" class="headerlink" title="以只读形式打开文件，但是仍然可以使用 :wq! 写入"></a>以只读形式打开文件，但是仍然可以使用 :wq! 写入</h1><p>vim -R file </p>
<h1 id="强制性关闭修改功能，无法使用-wq-写入"><a href="#强制性关闭修改功能，无法使用-wq-写入" class="headerlink" title="强制性关闭修改功能，无法使用 :wq! 写入"></a>强制性关闭修改功能，无法使用 :wq! 写入</h1><p>vim -M file </p>
<h3 id="3-vim插入命令"><a href="#3-vim插入命令" class="headerlink" title="3. vim插入命令"></a>3. vim插入命令</h3><hr>
<p>i 在当前位置生前插入<br>I 在当前行首插入</p>
<p>a 在当前位置后插入<br>A 在当前行尾插入</p>
<p>o 在当前行之后插入一行<br>O 在当前行之前插入一行</p>
<h3 id="4-vim查找命令"><a href="#4-vim查找命令" class="headerlink" title="4. vim查找命令"></a>4. vim查找命令</h3><p>最简单的查找</p>
<p>&#x2F;text　　查找text，按n健查找下一个，按N健查找前一个。<br>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</p>
<p>vim中有一些特殊字符在查找时需要转义　　.*[]^%&#x2F;?~$</p>
<p>:set ignorecase　　忽略大小写的查找<br>:set noignorecase　　不忽略大小写的查找<br>快速查找，不需要手打字符即可查找</p>
<p>*        向后（下）寻找游标所在处的单词</p>
<h1 id="向前（上）寻找游标所在处的单词"><a href="#向前（上）寻找游标所在处的单词" class="headerlink" title="向前（上）寻找游标所在处的单词"></a>向前（上）寻找游标所在处的单词</h1><p>以上两种查找，n,N 的继续查找命令依然可以适用<br>精准查找：匹配单词查找</p>
<p>如果文本中有这三个单词</p>
<p>hellohelloworldhellopython</p>
<p>那我使用 &#x2F;hello ，这三个词都会匹配到。</p>
<p>有没有办法实现精准查找呢？你可以使用</p>
<p>&#x2F;hello\&gt;<br>精准查找：匹配行首、行末</p>
<h1 id="hello位于行首"><a href="#hello位于行首" class="headerlink" title="hello位于行首"></a>hello位于行首</h1><p>&#x2F;^hello</p>
<h1 id="world位于行末"><a href="#world位于行末" class="headerlink" title="world位于行末"></a>world位于行末</h1><p>&#x2F;world$</p>
<h3 id="5-vim替换命令"><a href="#5-vim替换命令" class="headerlink" title="5. vim替换命令"></a>5. vim替换命令</h3><hr>
<p>~  反转游标字母大小写</p>
<p>r&lt;字母&gt;           将当前字符替换为所写字母<br>R&lt;字母&gt;&lt;字母&gt;…  连续替换字母</p>
<p>cc    替换整行（就是删除当前行，并在下一行插入）<br>cw    替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）<br>C     (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）</p>
<p>:s&#x2F;old&#x2F;new&#x2F;    用old替换new，替换当前行的第一个匹配<br>:s&#x2F;old&#x2F;new&#x2F;g   用old替换new，替换当前行的所有匹配</p>
<p>:%s&#x2F;old&#x2F;new&#x2F;   用old替换new，替换所有行的第一个匹配<br>:%s&#x2F;old&#x2F;new&#x2F;g  用old替换new，替换整个文件的所有匹配</p>
<p>:10,20 s&#x2F;^&#x2F; &#x2F;g 在第10行至第20行每行前面加四个空格，用于缩进。</p>
<p>ddp    交换光标所在行和其下紧邻的一行。</p>
<h3 id="6-撤销与重做"><a href="#6-撤销与重做" class="headerlink" title="6. 撤销与重做"></a>6. 撤销与重做</h3><hr>
<p>u 撤销（Undo）</p>
<p>U 撤销对整行的操作</p>
<p>Ctrl + r 重做（Redo），即撤销的撤销。</p>
<h3 id="7-删除命令"><a href="#7-删除命令" class="headerlink" title="7. 删除命令"></a>7. 删除命令</h3><hr>
<p>需要说明的是，vim 其实并没有单纯的删除命令，下面你理解为剪切更加准确。</p>
<p>以字符为单位删除</p>
<p>x   删除当前字符<br>3x  删除当前字符3次</p>
<p>X   删除当前字符的前一个字符。<br>3X  删除当前光标向前三个字符</p>
<p>dl  删除当前字符， dl&#x3D;x<br>dh  删除前一个字符，X&#x3D;dh</p>
<p>D   删除当前字符至行尾。D&#x3D;d$<br>d$  删除当前字符至行尾<br>d^  删除当前字符之前至行首<br>以单词为单位删除</p>
<p>dw  删除当前字符到单词尾<br>daw 删除当前字符所在单词<br>以行为单位删除</p>
<p>dd  删除当前行<br>dj  删除下一行<br>dk  删除上一行</p>
<p>dgg  删除当前行至文档首部<br>d1G  删除当前行至文档首部<br>dG   删除当前行至文档尾部</p>
<p>kdgg  删除当前行之前所有行（不包括当前行）<br>jdG   删除当前行之后所有行（不包括当前行）</p>
<p>10d     删除当前行开始的10行。<br>:1,10d  删除1-10行<br>:11,$d  删除11行及以后所有的行<br>:1,$d   删除所有行<br>J　　   删除两行之间的空行，实际上是合并两行。</p>
<h3 id="8-复制粘贴"><a href="#8-复制粘贴" class="headerlink" title="8. 复制粘贴"></a>8. 复制粘贴</h3><hr>
<p>普通模式中使用y复制</p>
<p>yy   复制游标所在的整行（3yy表示复制3行）</p>
<p>y^   复制至行首，或y0。不含光标所在处字符。<br>y$   复制至行尾。含光标所在处字符。</p>
<p>yw   复制一个单词。<br>y2w  复制两个单词。</p>
<p>yG   复制至文本末。<br>y1G  复制至文本开头。<br>普通模式中使用p粘贴</p>
<p>p(小写)：代表粘贴至光标后（下边，右边）<br>P(大写)：代表粘贴至光标前（上边，左边）</p>
<h3 id="9-剪切粘贴"><a href="#9-剪切粘贴" class="headerlink" title="9. 剪切粘贴"></a>9. 剪切粘贴</h3><hr>
<p>dd    其实就是剪切命令，剪切当前行<br>ddp   剪切当前行并粘贴，可实现当前行和下一行调换位置</p>
<p>正常模式下按v（逐字）或V（逐行）进入可视模式<br>然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</p>
<p>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</p>
<p>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</p>
<p>:1, 10 m 20 将第1-10行移动到第20行之后。</p>
<h3 id="10-退出保存"><a href="#10-退出保存" class="headerlink" title="10. 退出保存"></a>10. 退出保存</h3><hr>
<p>:wq 保存并退出</p>
<p>ZZ 保存并退出</p>
<p>:q! 强制退出并忽略所有更改</p>
<p>:e! 放弃所有修改，并打开原来文件。</p>
<p>ZZ 保存并退出</p>
<p>:sav(eas) new.txt  另存为一个新文件，退出原文件的编辑且不会保存<br>:f(ile) new.txt    新开一个文件，并不保存，退出原文件的编辑且不会保存</p>
<h3 id="11-移动命令"><a href="#11-移动命令" class="headerlink" title="11. 移动命令"></a>11. 移动命令</h3><hr>
<p>以字符为单位移动</p>
<p>h   左移一个字符<br>l   右移一个字符<br>k   上移一个字符<br>j   下移一个字符</p>
<h1 id="【定位字符】f和F"><a href="#【定位字符】f和F" class="headerlink" title="【定位字符】f和F"></a>【定位字符】f和F</h1><p>fx    找到光标后第一个为x的字符<br>3fd   找到光标后第三个为d的字符</p>
<p>F   同f，反向查找。<br>以行为单位移动</p>
<h1 id="10指代所有数字，可任意指定"><a href="#10指代所有数字，可任意指定" class="headerlink" title="10指代所有数字，可任意指定"></a>10指代所有数字，可任意指定</h1><p>10h  左移10个字符<br>10l  右移10个字符<br>10k  上移10行<br>10j  下移10行</p>
<p>$   移动到行尾<br>3$  移动到下面3行的行尾<br>以单词为单位移动</p>
<p>w  向前移动一个单词（光标停在单词首部）<br>b  向后移动一个单词<br>e，同w，只不过是光标停在单词尾部<br>ge 同b，光标停在单词尾部。<br>以句为单位移动</p>
<p>(   移动到句首<br>)   移动到句尾<br>跳转到文件的首尾</p>
<p>gg  移动到文件头。 &#x3D; [[  &#x3D;&#x3D; ``<br>G   移动到文件尾。 &#x3D; ]]<br>其他移动方法</p>
<p>^   移动到本行第一个非空白字符上。<br>0   移动到本行第一个字符上(可以是空格)<br>使用 具名标记 跳转，个人感觉这个很好用，因为可以跨文件。</p>
<p>使用 ma ，可以将此处标记为 a，使用 ‘a 进行跳转<br>使用 :marks 可以查看所有的标记<br>使用 :delm！可以删除所有的标记<br>当在查看错误日志时，正常的步骤是，vim打开文件，然后使用 shift+g  再跳转到最后一行，这里有个更简单的操作可以在打开文件时立即跳到最后一行。只要在 vim 和 文件 中间加个 + 即可。</p>
<p>vim + you.log<br>举一反三，当你想打开文件立即跳转到指定行时，可以这样</p>
<h1 id="打开文件并跳转到-20-行"><a href="#打开文件并跳转到-20-行" class="headerlink" title="打开文件并跳转到 20 行"></a>打开文件并跳转到 20 行</h1><p>vim you.log +20<br>当你使用 &#x2F; 搜索定位跳转或者使用 :行号 进行精准跳转时，有时我们想返回到上一次的位置，如何实现？</p>
<p>只要使用 Ctrl+o 即可返回上一次的位置。</p>
<h3 id="12-排版功能"><a href="#12-排版功能" class="headerlink" title="12. 排版功能"></a>12. 排版功能</h3><hr>
<p>缩进</p>
<p>:set shiftwidth?   查看缩进值<br>:set shiftwidth&#x3D;4  设置缩进值为4</p>
<h1 id="缩进相关-最好写到配置文件中-x2F-vimrc"><a href="#缩进相关-最好写到配置文件中-x2F-vimrc" class="headerlink" title="缩进相关 最好写到配置文件中  ~&#x2F;.vimrc"></a>缩进相关 最好写到配置文件中  ~&#x2F;.vimrc</h1><p>:set tabstop&#x3D;4<br>:set softtabstop&#x3D;4<br>:set shiftwidth&#x3D;4<br>:set expandtab</p>
<blockquote>
<blockquote>
<p>  向右缩进<br>&lt;&lt;   取消缩进<br>如何你要对代码进行缩进，还可以用 &#x3D;&#x3D; 对当前行缩进，如果要对多行对待缩进，则使用 n&#x3D;&#x3D;，这种方式要求你所编辑的文件的扩展名是被vim所识别的，比如.py文件。</p>
</blockquote>
</blockquote>
<p>排版</p>
<p>:ce   居中<br>:le   靠左<br>:ri   靠右</p>
<h3 id="13-注释命令"><a href="#13-注释命令" class="headerlink" title="13. 注释命令"></a>13. 注释命令</h3><hr>
<p>多行注释</p>
<p>进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来</p>
<p>按大写字母I，再插入注释符，例如&#x2F;&#x2F;</p>
<p>按esc键就会全部注释了<br>取消多行注释</p>
<p>进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 &#x2F;&#x2F; 需要选中2列</p>
<p>按字母j，或者k选中注释符号</p>
<p>按d键就可全部取消注释<br>复杂注释</p>
<p>:3,5 s&#x2F;^&#x2F;#&#x2F;g 注释第3-5行<br>:3,5 s&#x2F;^#&#x2F;&#x2F;g 解除3-5行的注释</p>
<p>:1,$ s&#x2F;^&#x2F;#&#x2F;g 注释整个文档<br>:1,$ s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档</p>
<p>:%s&#x2F;^&#x2F;#&#x2F;g 注释整个文档，此法更快<br>:%s&#x2F;^#&#x2F;&#x2F;g 取消注释整个文档</p>
<h3 id="14-调整视野"><a href="#14-调整视野" class="headerlink" title="14. 调整视野"></a>14. 调整视野</h3><hr>
<p>“zz”：命令会把当前行置为屏幕正中央，<br>“zt”：命令会把当前行置于屏幕顶端<br>“zb”：则把当前行置于屏幕底端.</p>
<p>Ctrl + e 向下滚动一行<br>Ctrl + y 向上滚动一行</p>
<p>Ctrl + d 向下滚动半屏<br>Ctrl + u 向上滚动半屏</p>
<p>Ctrl + f 向下滚动一屏<br>Ctrl + b 向上滚动一屏</p>
<p>【跳到指定行】：两种方法</p>
<p>可以先把行号打开<br>:set nu  打开行号</p>
<p>:20    跳到第20行<br>20G    跳到第20行</p>
<h3 id="15-区域选择"><a href="#15-区域选择" class="headerlink" title="15. 区域选择"></a>15. 区域选择</h3><hr>
<p>要进行区域选择，要先进入可视模式</p>
<p>v   以字符为单位，上下左右选择<br>V   以行为单位，上下选择</p>
<p>选择后可进行操作<br>d   剪切&#x2F;删除<br>y   复制</p>
<p>Ctrl+v   如果当前是V(大写)模式，就变成v(小写)<br>         如果当前是v(小写)模式，就变成普通模式。<br>         如果当前是普通模式，就进入v(小写)模式</p>
<p>利用这个，可以进行多行缩进。</p>
<p>ggVG   选择全文</p>
<h3 id="16-窗口控制"><a href="#16-窗口控制" class="headerlink" title="16. 窗口控制"></a>16. 窗口控制</h3><hr>
<p>```bash<br>新建窗口</p>
<h1 id="打开两个文件分属两个窗口"><a href="#打开两个文件分属两个窗口" class="headerlink" title="打开两个文件分属两个窗口"></a>打开两个文件分属两个窗口</h1><p>vim -o 1.txt 2.txt</p>
<h1 id="假设现在已经打开了1-txt"><a href="#假设现在已经打开了1-txt" class="headerlink" title="假设现在已经打开了1.txt"></a>假设现在已经打开了1.txt</h1><p>:sp 2.txt   开启一个横向的窗口，编辑2.txt<br>:vsp 2.txt  开启一个竖向的窗口，编辑2.txt</p>
<p>:split        将当前窗口再复制一个窗口出来，内容同步，游标可以不同<br>:split 2.txt  在新窗口打开2.txt的横向窗口</p>
<h1 id="需要注意：内容同步，但是游标位置是独立的"><a href="#需要注意：内容同步，但是游标位置是独立的" class="headerlink" title="需要注意：内容同步，但是游标位置是独立的"></a>需要注意：内容同步，但是游标位置是独立的</h1><p>Ctrl-w s    将当前窗口分成水平窗口<br>Ctrl-w v    将当前窗口分成竖直窗口</p>
<p>Ctrl-w q    等同:q 结束分割出来的视窗。<br>Ctrl-w q!   等同:q! 结束分割出来的视窗。<br>Ctrl-w o    打开一个视窗并且隐藏之前的所有视窗<br>窗口切换</p>
<h1 id="特别说明：Ctrl-w-lt-字母-gt-不需要同时按"><a href="#特别说明：Ctrl-w-lt-字母-gt-不需要同时按" class="headerlink" title="特别说明：Ctrl w &lt;字母&gt; 不需要同时按"></a>特别说明：Ctrl w &lt;字母&gt; 不需要同时按</h1><p>Ctrl-w h    切换到左边窗口<br>Ctrl-w l    切换到右边窗口</p>
<p>Ctrl-w j    切换到下边窗口<br>Ctrl-w k    切换到上边窗口</p>
<h1 id="特别说明：全屏模式下"><a href="#特别说明：全屏模式下" class="headerlink" title="特别说明：全屏模式下"></a>特别说明：全屏模式下</h1><p>:n    切换下一个窗口<br>:N    切换上一个窗口<br>:bp   切换上一个窗口</p>
<h1 id="特别说明：非全屏模式"><a href="#特别说明：非全屏模式" class="headerlink" title="特别说明：非全屏模式"></a>特别说明：非全屏模式</h1><p>:bn    切换下一个窗口，就当前位置的窗口的内容变了，其他窗口不变<br>:bN    切换上一个窗口，就当前位置的窗口的内容变了，其他窗口不变<br>窗口移动</p>
<h1 id="特别说明：Ctrl-w-lt-字母-gt-不需要同时按-1"><a href="#特别说明：Ctrl-w-lt-字母-gt-不需要同时按-1" class="headerlink" title="特别说明：Ctrl w &lt;字母&gt; 不需要同时按"></a>特别说明：Ctrl w &lt;字母&gt; 不需要同时按</h1><p>Ctrl-w J   将当前视窗移至最下面<br>Ctrl-w K   将当前视窗移最上面</p>
<p>Ctrl-w H   将当前视窗移至最左边<br>Ctrl-w L   将当前视窗移至最右边</p>
<p>Ctrl-ww    按顺序切换窗口<br>调整尺寸</p>
<h1 id="友情提示：键盘切记不要处于中文状态"><a href="#友情提示：键盘切记不要处于中文状态" class="headerlink" title="友情提示：键盘切记不要处于中文状态"></a>友情提示：键盘切记不要处于中文状态</h1><p>Ctrl-w +   增加窗口高度<br>Ctrl-w -   减少窗口高度<br>退出窗口</p>
<p>:close    关闭当前窗口<br>:close!   强制关闭当前窗口</p>
<p>:q       退出，不保存<br>:q!      强制退出，不保存</p>
<p>:x       保存退出<br>:wq      保存退出<br>:wq!     强制保存退出</p>
<p>:w &lt;[路径&#x2F;]文件名&gt;        另存为<br>:savesa &lt;[路径&#x2F;]文件名&gt;   另存为</p>
<p>ZZ 保存并退出。</p>
<p>:only    关闭所有窗口，只保留当前窗口(前提：其他窗口内容有改变的话都要先保存)<br>:only!   关闭所有窗口，只保留当前窗口</p>
<p>:qall 放弃所有操作并退出<br>:wall 保存所有，<br>:wqall 保存所有并退出。</p>
<h3 id="17-文档加密"><a href="#17-文档加密" class="headerlink" title="17. 文档加密"></a>17. 文档加密</h3><hr>
<p>vim -x file_name</p>
<p>然后输入密码：<br>确认密码：</p>
<p>如果不修改内容也要保存。:wq，不然密码设定不会生效。</p>
<h3 id="18-录制宏"><a href="#18-录制宏" class="headerlink" title="18. 录制宏"></a>18. 录制宏</h3><hr>
<p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p>
<h3 id="19-执行命令"><a href="#19-执行命令" class="headerlink" title="19. 执行命令"></a>19. 执行命令</h3><hr>
<p># 重复前一次命令<br>. </p>
<h1 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h1><p>:!command</p>
<h1 id="比如列出当前目录下文件"><a href="#比如列出当前目录下文件" class="headerlink" title="比如列出当前目录下文件"></a>比如列出当前目录下文件</h1><p>:!ls </p>
<h1 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h1><p>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。<br>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</p>
<p>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p>
<h3 id="20-帮助命令"><a href="#20-帮助命令" class="headerlink" title="20. 帮助命令"></a>20. 帮助命令</h3><hr>
<p>在Unix&#x2F;Linux系统上<br>$ vimtutor</p>
<h1 id="普通模式下"><a href="#普通模式下" class="headerlink" title="普通模式下"></a>普通模式下</h1><p>键盘输入vim或F1</p>
<h1 id="命令行模式下"><a href="#命令行模式下" class="headerlink" title="命令行模式下"></a>命令行模式下</h1><p>:help     显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起</p>
<p>在Windows系统上<br>:help tutor</p>
<h3 id="21-配置命令"><a href="#21-配置命令" class="headerlink" title="21. 配置命令"></a>21. 配置命令</h3><hr>
<p>显示当前设定</p>
<p>:set或者:se显示所有修改过的配置<br>:set all 显示所有的设定值<br>:set option? 显示option的设定值<br>:set nooption 取消当期设定值<br>:ver   显示vim的所有信息（包括版本和参数等）</p>
<h1 id="需要注意：全屏模式下"><a href="#需要注意：全屏模式下" class="headerlink" title="需要注意：全屏模式下"></a>需要注意：全屏模式下</h1><p>:args   查看当前打开的文件列表，当前正在编辑的文件会用[]括起来<br>更改设定</p>
<p>:set nu   显示行号</p>
<p>set autoindent(ai)   设置自动缩进<br>set autowrite(aw)    设置自动存档，默认未打开<br>set backup(bk) 设置自动备份，默认未打开</p>
<p>set background&#x3D;dark或light，设置背景风格</p>
<p>set cindent(cin) 设置C语言风格缩进</p>
<p>:set ts&#x3D;4   设置tab键转换为4个空格</p>
<p>:set ff&#x3D;unix   # 修改文件dos文件为unix</p>
<p>:set shiftwidth?   查看缩进值<br>:set shiftwidth&#x3D;4  设置缩进值为4</p>
<p>:set ignorecase　　忽略大小写的查找<br>:set noignorecase　　不忽略大小写的查找</p>
<p>:set paste  # insert模式下，粘贴格式不会乱掉</p>
<p>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</p>
<p>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</p>
<p>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs&#x3D;tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p>
<p>:syntax        列出已经定义的语法项<br>:syntax clear  清除已定义的语法规则</p>
<p>:syntax case match    大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore   大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p>
<p>以上就是我使用 Vim 的一些使用总结，希望对你能有帮助。</p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualbox后台静默运行虚拟机</title>
    <url>/2021/12/26/virtualbox%E5%90%8E%E5%8F%B0%E9%9D%99%E9%BB%98%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-19.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>安装好VirtualBox后，配置完成后发现不能后台运行 每次启动都会有界面，对于想要模拟集群的我来说很麻烦</p>
<h3 id="启动-VirtualBox-虚拟机"><a href="#启动-VirtualBox-虚拟机" class="headerlink" title="启动 VirtualBox 虚拟机"></a>启动 VirtualBox 虚拟机</h3><hr>
<p>我们查看一下正常启动的虚拟机进程</p>
<p>leenhem@leenhem-Thinkpad-T440P:~$ ps -ef grep vir<br>leenhem     2395    1627  0 08:25 ?        00:00:11 &#x2F;usr&#x2F;lib&#x2F;virtualbox&#x2F;VBoxXPCOMIPCD<br>leenhem     2401    1627  0 08:25 ?        00:00:34 &#x2F;usr&#x2F;lib&#x2F;virtualbox&#x2F;VBoxSVC –auto-shutdown<br>leenhem     4443    2401 53 08:35 ?        00:34:53 &#x2F;usr&#x2F;lib&#x2F;virtualbox&#x2F;VirtualBoxVM –comment win10 –startvm 01ba9392-82bc-4a14-ac00-481f206675a4 –no-startvm-errormsgbox<br>leenhem     4719    2401  0 08:36 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;virtualbox&#x2F;VBoxNetDHCP –comment HostInterfaceNetworking-vboxnet0 –config &#x2F;home&#x2F;leenhem&#x2F;.config&#x2F;VirtualBox&#x2F;HostInterfaceNetworking-vboxnet0-Dhcpd.config –log &#x2F;home&#x2F;leenhem&#x2F;.config&#x2F;VirtualBox&#x2F;HostInterfaceNetworking-vboxnet0-Dhcpd.log<br>leenhem     8067    2401  0 09:37 ?        00:00:01 &#x2F;usr&#x2F;lib&#x2F;virtualbox&#x2F;VirtualBoxVM –comment CentOS7-01 –startvm ff9818a6-ad1a-48dd-91c9-676bf932a0e9 –no-startvm-errormsgbox –separate<br>leenhem     8193    4101  0 09:41 pts&#x2F;0    00:00:00 grep –color&#x3D;auto vir</p>
<p>可以看到正常的虚拟机进程是<br>VirtualBoxVM –comment CentOS7-01 –startvm ff9818a6-ad1a-48dd-91c9-676bf932a0e9</p>
<h3 id="使用-VirtualBoxVM-后台启动"><a href="#使用-VirtualBoxVM-后台启动" class="headerlink" title="使用 VirtualBoxVM 后台启动"></a>使用 VirtualBoxVM 后台启动</h3><hr>
<p>查看VirtualBoxVM参数没有发现，后台启动的参数</p>
<p>leenhem@leenhem-Thinkpad-T440P:~$ VirtualBoxVM –help<br>Oracle VM VirtualBox VM Runner v6.1.26_Ubuntu<br>(C) 2005-2021 Oracle Corporation<br>All rights reserved.</p>
<p>Options:<br>  –startvm <vmnameUUID>    start a VM by specifying its UUID or name<br>  –separate                 start a separate VM process<br>  –normal                   keep normal (windowed) mode during startup<br>  –fullscreen               switch to fullscreen mode during startup<br>  –seamless                 switch to seamless mode during startup<br>  –scale                    switch to scale mode during startup<br>  –no-startvm-errormsgbox   do not show a message box for VM start errors<br>  –restore-current          restore the current snapshot before starting<br>  –no-aggressive-caching    delays caching media info in VM processes<br>  –fda <imagenone>         Mount the specified floppy image<br>  –dvd <imagenone>         Mount the specified DVD image<br>  –dbg                      enable the GUI debug menu<br>  –debug                    like –dbg and show debug windows at VM startup<br>  –debug-command-line       like –dbg and show command line window at VM startup<br>  –debug-statistics         like –dbg and show statistics window at VM startup<br>  –no-debug                 disable the GUI debug menu and debug windows<br>  –start-paused             start the VM in the paused state<br>  –start-running            start the VM running (for overriding –debug*)</p>
<p>Expert options:<br>  –disable-patm             disable code patching (ignored by AMD-V&#x2F;VT-x)<br>  –disable-csam             disable code scanning (ignored by AMD-V&#x2F;VT-x)<br>  –recompile-supervisor     recompiled execution of supervisor code (*)<br>  –recompile-user           recompiled execution of user code (*)<br>  –recompile-all            recompiled execution of all code, with disabled<br>                             code patching and scanning<br>  –execute-all-in-iem       For debugging the interpreted execution mode.<br>  –warp-pct <pct>           time warp factor, 100%% (&#x3D; 1.0) &#x3D; normal speed<br>  (*) For AMD-V&#x2F;VT-x setups the effect is –recompile-all.</p>
<p>The following environment (and extra data) variables are evaluated:<br>  VBOX_GUI_DBG_ENABLED (GUI&#x2F;Dbg&#x2F;Enabled)<br>                             enable the GUI debug menu if set<br>  VBOX_GUI_DBG_AUTO_SHOW (GUI&#x2F;Dbg&#x2F;AutoShow)<br>                             show debug windows at VM startup<br>  VBOX_GUI_NO_DEBUGGER<br>                             disable the GUI debug menu and debug windows</p>
<h3 id="vboxmanage启动虚拟机"><a href="#vboxmanage启动虚拟机" class="headerlink" title="vboxmanage启动虚拟机"></a>vboxmanage启动虚拟机</h3><p>按照百度知道上面的说法 <code>https://jingyan.baidu.com/article/60ccbceb6d042964cab19730.html</code></p>
<p>应该执行以下命令去启动虚拟机</p>
<p>leenhem@leenhem-Thinkpad-T440P:~$ vboxmanage startvm CentOS7-01 -type headless<br>Waiting for VM “CentOS7-01” to power on…<br>VM “CentOS7-01” has been successfully started.</p>
<p>虚拟机正常启动</p>
<h3 id="批量启动虚拟机"><a href="#批量启动虚拟机" class="headerlink" title="批量启动虚拟机"></a>批量启动虚拟机</h3><hr>
<p>把启动命令放到脚本中 startvm.sh</p>
<p>vim startvm.sh<br>vboxmanage startvm CentOS7-01 -type headless<br>vboxmanage startvm CentOS7-02 -type headless<br>vboxmanage startvm CentOS7-03 -type headless<br>vboxmanage startvm CentOS7-04 -type headless<br>vboxmanage startvm CentOS7-05 -type headless</p>
<h3 id="查看启动后的虚拟机"><a href="#查看启动后的虚拟机" class="headerlink" title="查看启动后的虚拟机"></a>查看启动后的虚拟机</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/6d9ea66ba6e54a4a96725df12c3270cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/76b6366bd2dc41e188af4be4b5e533ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/4212eead00d6491ea594427f2e55d0a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>virtualbox</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
        <tag>后台运行</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>skywalking 如何显示 Oracle 数据库操作SQL参数？</title>
    <url>/2021/09/29/skywalking-%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA-oracle-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9Csql%E5%8F%82%E6%95%B0%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-26-1024x576.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>SkyWalking默认不采集SQL参数，但是提供了采集SQL参数采集的方式，在应用端启动时，加入启动参数，或者在agent&#x2F;config&#x2F;agent.config配置文件里面配置相关参数即可。</p>
<h3 id="方式一：应用端启动参数"><a href="#方式一：应用端启动参数" class="headerlink" title="方式一：应用端启动参数"></a>方式一：应用端启动参数</h3><hr>
<p>plugin.jdbc.trace_sql_parameters，数据库参数采集选项，默认false不采集，如果需要采集，将其配置为true。</p>
<p>-Dskywalking.plugin.jdbc.trace_sql_parameters&#x3D;true</p>
<p>不推荐应用端加启动参数</p>
<h3 id="方式二：配置文件agent"><a href="#方式二：配置文件agent" class="headerlink" title="方式二：配置文件agent"></a>方式二：配置文件agent</h3><hr>
<p>配置文件 apache-skywalking-apm-bin-es7&#x2F;agent&#x2F;config&#x2F;agent.config</p>
<p># plugin.jdbc.trace_sql_parameters&#x3D;${SW_JDBC_TRACE_SQL_PARAMETERS:false}<br>plugin.jdbc.trace_sql_parameters&#x3D;${SW_JDBC_TRACE_SQL_PARAMETERS:true}</p>
<h3 id="添加apm-oracle驱动"><a href="#添加apm-oracle驱动" class="headerlink" title="添加apm-oracle驱动"></a>添加apm-oracle驱动</h3><hr>
<p>把驱动放到应用服务agent端 apache-skywalking-apm-bin-es7&#x2F;agent&#x2F;plugin&#x2F; 下面</p>
<p>[<a href="mailto:&#114;&#x6f;&#111;&#116;&#64;&#x63;&#x6f;&#100;&#101;&#52;&#x30;&#52;&#46;&#x69;&#99;&#117;">&#114;&#x6f;&#111;&#116;&#64;&#x63;&#x6f;&#100;&#101;&#52;&#x30;&#52;&#46;&#x69;&#99;&#117;</a> plugins]# ll apm-oracle-10.x-plugin-2.1.0.jar<br>-rw-r–r– 1 root root 25083 9月   2 11:06 apm-oracle-10.x-plugin-2.1.0.jar</p>
<h3 id="启动应用脚本"><a href="#启动应用脚本" class="headerlink" title="启动应用脚本"></a>启动应用脚本</h3><p># SkyWalking Agent 配置<br>export SW_AGENT_NAME&#x3D;demo-application # 配置 Agent 名字。一般来说，我们直接使用 Spring Boot 项目的 `spring.application.name` 。<br>export SW_AGENT_COLLECTOR_BACKEND_SERVICES&#x3D;127.0.0.1:11800 # 配置 Collector 地址。<br>export SW_AGENT_SPAN_LIMIT&#x3D;2000 # 配置链路的最大 Span 数量。一般情况下，不需要配置，默认为 300 。主要考虑，有些新上 SkyWalking Agent 的项目，代码可能比较糟糕。<br>export JAVA_AGENT&#x3D;-javaagent:&#x2F;data&#x2F;skywalking&#x2F;apache-skywalking-apm-bin-es7&#x2F;agent&#x2F;skywalking-agent.jar # SkyWalking Agent jar 地址。</p>
<h1 id="Jar-启动"><a href="#Jar-启动" class="headerlink" title="Jar 启动"></a>Jar 启动</h1><p>java -jar $JAVA_AGENT -jar lab-39-demo-2.2.2.RELEASE.jar</p>
<p>注意：修改完agent配置后要重启 应用程序，以加载新的agent配置</p>
]]></content>
      <categories>
        <category>Skywalking</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
        <tag>skywalking</tag>
        <tag>SQL参数</tag>
        <tag>操作</tag>
        <tag>显示</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode中6个好用的前端重构插件</title>
    <url>/2021/08/01/vscode%E4%B8%AD6%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>Visual Studio Code（简称VS Code）是一款由微软开发且跨平台的免费源代码编辑器。基于其丰富的插件体系与语言支持，目前已经成为了最流程的集成开发环境。本文介绍了笔者用过的最好用的几款前端重构插件。</p>
<h3 id="JavaScript-Booster"><a href="#JavaScript-Booster" class="headerlink" title="JavaScript Booster"></a>JavaScript Booster</h3><hr>
<p>JavaScript Booster 是一种代码重构工具，具有多种编码操作，例如将 var 转换为 const 或 let、删除多余的 else 语句以及合并声明和初始化。只需注意左侧的灯泡并按下它即可了解如何转换光标下的代码。</p>
<h3 id="Stepsize"><a href="#Stepsize" class="headerlink" title="Stepsize"></a>Stepsize</h3><hr>
<p>Stepsize 允许您为要重构的技术债务和代码添加书签和报告。如果您遇到需要重构的代码，但您没有时间立即进行重构，则可以使其可见并直接在 VS Code 中提出问题。</p>
<h3 id="Abracadabra"><a href="#Abracadabra" class="headerlink" title="Abracadabra"></a>Abracadabra</h3><hr>
<p>VS Code 附带了一些基本的重构。Abracadabra 使用快捷的方式为您的编辑器，在适当的时候快速修复以建议重构，根据您的需求自定义 UX 的选项，与 .js、.jsx、.ts、.tsx 和.vue 文件。</p>
<h3 id="Glean"><a href="#Glean" class="headerlink" title="Glean"></a>Glean</h3><hr>
<p>Glean 为您的 React 代码库提供了重构工具：将 JSX 提取到一个新组件中，将类组件转换为功能组件，使用 Hooks 进行包装。它允许将 JSX 提取到新组件中，将类组件转换为功能组件，反之亦然，使用条件包装 JSX，同时重命名状态变量及其设置器等等。</p>
<h3 id="SonarL"><a href="#SonarL" class="headerlink" title="SonarL"></a>SonarL</h3><hr>
<p>SonarLint 在您编写代码时突出显示错误和安全漏洞，并提供明确的补救指导，以便您可以在代码提交之前修复它们。VS Code 中的 SonarLint 支持分析 JavaScript、TypeScript、Python、Java、HTML 和 PHP 代码。</p>
<h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><hr>
<p>Prettier 是一个非常流行的扩展，它为大多数编程语言提供自动代码格式，它在 html javascript 和其他语言中特别有用。</p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>win10 WSL2问题解决WslRegisterDistribution failed with error: 0x800701bc</title>
    <url>/2021/07/01/win10-wsl2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3wslregisterdistribution-failed-with-error-0x800701bc/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-1.png"></p>
<p>win10 WSL2问题解决WslRegisterDistribution failed with error: 0x800701bc<br>在win10 2004系统中，WSL1安装Mongodb永远无法启动，于是按照网上的教程，升级到了WSL2。在升级了WSL2以后重新安装Ubuntu20.04 时遇到问题，安装完成后无法正常启动，报错信息如下：  </p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image.png"></p>
<p>造成该问题的原因是WSL版本由原来的WSL1升级到WSL2后，内核没有升级，前往微软WSL官网下载安装适用于 x64 计算机的最新 WSL2 Linux 内核更新包即可。</p>
<p>下载链接：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl/_update/_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl\_update\_x64.msi</a></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows子系统</tag>
        <tag>WSL2</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 安装 WSL 2</title>
    <url>/2021/04/09/windows-10-%E5%AE%89%E8%A3%85-wsl-2/</url>
    <content><![CDATA[<p>若要安装并开始使用 WSL 2，请完成以下步骤：</p>
<blockquote>
<p>WSL 2 仅适用于 Windows 10 版本 18917 或更高版本</p>
</blockquote>
<ul>
<li>请确保你已安装 WSL（可以在<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">此处</a>找到有关执行此操作的说明），并且运行的是 Windows 10 <strong>版本 18917</strong> 或更高版本<ul>
<li>若要确保使用的是版本 18917 或更高版本，请加入 <a href="https://insider.windows.com/en-us/">Windows 预览体验计划</a>并选择“快速”环或“慢速”环形。</li>
<li>可以通过打开命令提示符并运行 <code>ver</code> 命令来检查 Windows 版本。</li>
</ul>
</li>
<li>启用“虚拟机平台”可选组件</li>
<li>使用命令行设置要由 WSL 2 支持的发行版</li>
<li>验证发行版使用的 WSL 版本</li>
</ul>
<h2 id="启用“虚拟机平台”可选组件并确保启用了-WSL"><a href="#启用“虚拟机平台”可选组件并确保启用了-WSL" class="headerlink" title="启用“虚拟机平台”可选组件并确保启用了 WSL"></a>启用“虚拟机平台”可选组件并确保启用了 WSL</h2><p>你需要确保同时安装了”适用于 Linux 的 Windows 子系统”和”虚拟机平台”可选组件。 可以通过在 PowerShell 中运行以下命令来执行该操作：</p>
<p>你需要确保同时安装了”适用于 Linux 的 Windows 子系统”和”虚拟机平台”可选组件。 可以通过在 PowerShell 中运行以下命令来执行该操作：</p>
<p>dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Windows-Subsystem-Linux &#x2F;all &#x2F;norestart<br>dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:VirtualMachinePlatform &#x2F;all &#x2F;norestart</p>
<p>请重启计算机来完成两个组件的安装。</p>
<h2 id="使用命令行设置要由-WSL-2-支持的发行版"><a href="#使用命令行设置要由-WSL-2-支持的发行版" class="headerlink" title="使用命令行设置要由 WSL 2 支持的发行版"></a>使用命令行设置要由 WSL 2 支持的发行版</h2><p>如果尚未安装 Linux 发行版，请参阅<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#install-your-linux-distribution-of-choice">在 Windows 10 上安装</a>文档页，以获取有关进行安装的说明。</p>
<p>若要设置发行版，请运行：</p>
<p>wsl –set-version <Distro> 2</p>
<p>并且确保将 `` 替换为你的发行版的实际名称。 （可使用以下命令找到这些内容：<code>wsl -l</code>）。 可以随时更改回 WSL 1，方法是运行与上面相同的命令，但将“2”替换为“1”。</p>
<p>此外，如果要使 WSL 2 成为你的默认体系结构，可以通过此命令执行该操作：</p>
<p>wsl –set-default-version 2</p>
<p>这会使你安装的任何新发行版均初始化为 WSL 2 发行版。</p>
<h2 id="完成验证发行版使用的-WSL-版本"><a href="#完成验证发行版使用的-WSL-版本" class="headerlink" title="完成验证发行版使用的 WSL 版本"></a>完成验证发行版使用的 WSL 版本</h2><p>若要验证每个发行版使用的 WSL 版本，请使用以下命令（仅在 Windows 版本 18917 或更高版本中可用）：</p>
<p>wsl –list –verbose  或  wsl -l -v</p>
<p>上面选择的发行版现在应在“version”列下显示“2”。 既然已经完成，便可以随时开始使用 WSL 2 发行版了！</p>
<h2 id="故障排除："><a href="#故障排除：" class="headerlink" title="故障排除："></a>故障排除：</h2><p>下面是安装 WSL 2 时的相关错误和建议的修补程序。 请参阅 <a href="https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting">WSL 故障排除页</a>以了解其他常见的 WSL 错误及其解决方案。</p>
<ul>
<li><strong>安装失败，出现错误 0x80070003 或错误 0x80370102</strong><ul>
<li>请确保在计算机的 BIOS 内已启用虚拟化。 有关如何执行此操作的说明因计算机而异，并且很可能在 CPU 相关选项下。</li>
</ul>
</li>
<li><strong>尝试升级时出错：<code>Invalid command line option: wsl --set-version Ubuntu 2</code></strong><ul>
<li>请确保已启用适用于 Linux 的 Windows 子系统，并且你使用的是 Windows 内部版本 18917 或更高版本。 若要启用 WSL，请在 Powershell 提示符下以具有管理员权限的身份运行此命令：<code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code>。 可在<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">此处</a>找到完整的 WSL 安装说明。</li>
</ul>
</li>
<li><strong>由于虚拟磁盘系统的某个限制，无法完成所请求的操作。虚拟硬盘文件必须是解压缩的且未加密的，并且不能是稀疏的。</strong><ul>
<li>请检查 <a href="https://github.com/microsoft/WSL/issues/4103">WSL Github 主题 #4103</a>，其中跟踪了此问题以提供更新的信息。</li>
</ul>
</li>
<li><strong>无法将词语“wsl”识别为 cmdlet、函数、脚本文件或可运行程序的名称。</strong><ul>
<li>请确保<a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-install#enable-the-virtual-machine-platform-optional-component-and-make-sure-wsl-is-enabled">已安装“适用于 Linux 的 Windows 子系统”可选组件</a>。<br>此外，如果你使用的是 Arm64 设备，并从 PowerShell 运行此命令，则会收到此错误。 请改为从 <a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-6">PowerShell Core</a> 或从命令提示符运行 <code>wsl.exe</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows子系统</tag>
        <tag>WSL2</tag>
        <tag>Linux子系统</tag>
        <tag>windows内安装linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>WPS 广告关闭 如何取消WPS的广告？ 关闭弹窗-热点-广告推送</title>
    <url>/2021/07/21/wps-%E5%B9%BF%E5%91%8A%E5%85%B3%E9%97%AD-%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88wps%E7%9A%84%E5%B9%BF%E5%91%8A%EF%BC%9F-%E5%85%B3%E9%97%AD%E5%BC%B9%E7%AA%97-%E7%83%AD%E7%82%B9-%E5%B9%BF%E5%91%8A%E6%8E%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/wps.png"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>不知道为啥雷总的公司对于广告是情有独钟的喜爱，比如：金山毒霸、MIUI、WPS等等全是广告大户。<br>今天在无意中发现了关闭WPS广告的方法</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><hr>
<ol>
<li>打开wps</li>
<li>左上角“首页”</li>
<li>右上角齿轮标志 &gt; 配置和修复工具<br><img src="https://img-blog.csdnimg.cn/20210720145452870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>高级<br><img src="https://img-blog.csdnimg.cn/2021072014550216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>其他选项，“关闭WPS热点” + “关闭广告弹窗推送”<br><img src="https://img-blog.csdnimg.cn/20210720145522973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>确定，重启wps</li>
</ol>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>Office</tag>
        <tag>WPS</tag>
        <tag>办公</tag>
        <tag>广告</tag>
        <tag>弹窗</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell脚本统计一个目录下的所有目录的文件数量，并实现按照数量大小排序和打印。</title>
    <url>/2021/05/22/xshell%E8%84%9A%E6%9C%AC%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F%EF%BC%8C%E5%B9%B6/</url>
    <content><![CDATA[<p>xshell脚本统计一个总目录下的所有分目录的文件数量，并实现按照每个目录下的文件数量大小排序，打印到一个文本里。</p>
<p>#!&#x2F;bin&#x2F;bash<br>echo &gt;  &#x2F;tmp&#x2F;tmp.txt<br>echo &gt;  &#x2F;tmp&#x2F;tmp1.txt</p>
<p>find &#x2F;etc -type d &gt; &#x2F;tmp&#x2F;tmp.txt<br>cat &#x2F;tmp&#x2F;tmp.txt while read line<br>do<br>echo  `ls -l $linegrep ^-wc -l` “$line” &gt;&gt; tmp1.txt<br>done<br>cat &#x2F;tmp&#x2F;tmp1.txtuniq sort -n -k 1 -r </p>
<p>cat &#x2F;tmp&#x2F;tmp1.txtuniq sort -n -k 1 -r &gt; result.txt</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件数</tag>
        <tag>shell</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 XML_XML怎么使用</title>
    <url>/2021/08/10/%E4%BB%80%E4%B9%88%E6%98%AF-xml-xml%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-7-1024x576.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>XML 是一种分层的标记语言。它使用打开和关闭标签来定义数据，它常用来存储和交换数据，而且由于它极大的灵活性，不论是在 文档 还是 图像 中都用的非常多。</p>
<p>这里是一个 XML 文档的例子：</p>
<xml>
  <os>
   <linux>
    <distribution>
      <name>Fedora</name>
      <release>8</release>
      <codename>Werewolf</codename>
    </distribution>
    <distribution>
      <name>Slackware</name>
      <release>12.1</release>
      <mascot>
        <official>Tux</official>
        <unofficial>Bob Dobbs</unofficial>
      </mascot>
    </distribution>
   </linux>
  </os>    
</xml>

<p>阅读这个示例 XML，你可能会发现这个 XML 的格式具有直观的特性。无论你是否熟悉这个文档的主题，你都可能理解本文档中的数据。这部分原因是因为 XML 被认为是冗长的。它使用了很多标签，标签可以有很长的描述性名称，并且数据以分层的方式排序，这有助于解释数据之间的关系。你可能从这个示例中了解到 Fedora 发行版和 Slackware 发行版是两个不同且不相关的 Linux 发行版，因为每个实例都“包含”在自己独立的 标签中。</p>
<p>XML 也非常灵活。与 HTML 不同，它没有预定义的标签列表。你可以自由创建你需要表示任何数据结构的标签。</p>
<h3 id="XML-的组成"><a href="#XML-的组成" class="headerlink" title="XML 的组成"></a>XML 的组成</h3><hr>
<p>数据的存在为了读取，当计算机“读取”数据时，该过程称为 解析。再次使用示例 XML 数据，以下是大多数 XML 解析器认为重要的术语。</p>
<p>◈ 文档： 标签标记文档的开始， 标签标记文档的结束。<br>◈ 节点：、、 这些都是节点，在解析术语中，节点是包含其他标签的标签。<br>◈ 元素：像 Fedora 和 Tux 这些都是元素。从第一个&lt;开始，到最后一个 &gt; 结束是一个元素。<br>◈ 内容：在两个元素标签之间的数据被称之为内容，在第一个 标签中，Fedora 字符串就是一个内容。</p>
<h3 id="XML-模式"><a href="#XML-模式" class="headerlink" title="XML 模式"></a>XML 模式</h3><hr>
<p>XML 文档中的标签和标签继承性称为 模式。</p>
<p>一些模式是随意组成的（例如，本文中的示例 XML 代码纯粹是即兴创作的），而其他模式则由标准组织严格定义。例如，可缩放矢量图形（SVG）模式 由 W3C 定义，而 DocBook 模式 由 Norman Walsh 定义。</p>
<p>模式强制执行一致性。最基本的模式通常也是最严格的。在我的示例 XML 代码中，将发行版名称放在 节点中是没有意义的，因为文档的隐含模式清楚地表明 mascot 必须是发行版的“子”元素。</p>
<h3 id="数据对象模型（DOM）"><a href="#数据对象模型（DOM）" class="headerlink" title="数据对象模型（DOM）"></a>数据对象模型（DOM）</h3><hr>
<p>如果你必须不断地描述标签和位置（例如，“系统部分中的 Linux 部分中第二个发行版标签的名称标签”），那么谈论 XML 会让人感到困惑，因此解析器使用文档对象模型（DOM）的概念来表示 XML 数据。DOM 将 XML 数据放入一种“家谱”结构中，从根元素（在我的示例 XML 中，即 os 标记）开始并包括路径上的每个标记。</p>
<p><img src="https://img-blog.csdnimg.cn/55ef87455b084290be1c6f496210ab5e.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<p>Document Object Model</p>
<p>这种相同的 XML 数据结构可以表示为路径，就像 Linux 系统中的文件或互联网上网页的位置一样。例如， 标签的路径可以表示为 &#x2F;&#x2F;os&#x2F;linux&#x2F;distribution&#x2F;slackware&#x2F;mascot。</p>
<p>两个 标签可以被表示为 &#x2F;&#x2F;os&#x2F;linux&#x2F;distribution ，因为这里有两个发行版的节点，因此一个解析器可以直接将两个节点的内容载入到一个数组中，可以进行查询。</p>
<h3 id="严格的-XML"><a href="#严格的-XML" class="headerlink" title="严格的 XML"></a>严格的 XML</h3><hr>
<p>XML 也以严格而著称。这意味着大多数应用程序被设计为在遇到 XML 错误时就会故意失败。这听起来可能有问题，但这是开发人员最欣赏 XML 的事情之一，因为当应用程序试图猜测如何解决错误时，可能会发生不可预测的事情。例如，在 HTML 定义明确之前，大多数 Web 浏览器都包含“怪癖模式”，因此当人们试图查看糟糕的 HTML 代码时，Web 浏览器却可以加载作者可能想要的内容。结果非常难以预测，尤其是当一个浏览器的猜测与另一个浏览器不同时。</p>
<p>XML 通过在出现故意错误时失败而不允许这样做。这让作者可以修复错误，直到它们生成有效的 XML。因为 XML 是良好定义的，所以有许多应用程序的验证器插件以及像 xmllint 和 xmlstarlet 这样的独立命令来帮助你及早定位错误。</p>
<h3 id="转换-XML"><a href="#转换-XML" class="headerlink" title="转换 XML"></a>转换 XML</h3><hr>
<p>因为 XML 通常用作数据交换，所以将 XML 转换为其他数据格式或其他 XML 模式是很常见的。经典示例包括 XSLTProc、xmlto 和 pandoc，但从技术上讲，还有许多其他应用程序或者至少程序的一部分就是在转换 XML。</p>
<p>事实上，LibreOffice 使用 XML 来布局其文字处理器和电子表格文档，因此无论何时你导出或 从 LibreOffice 转换文件，你都在转换 XML。</p>
<p>开源 EPUB 格式的电子书 使用 XML，因此无论何时你 将文档转换为 EPUB 或从 EPUB 转换，你都在转换 XML。</p>
<p>Inkscape 是基于矢量的插图应用程序，它将其文件保存在 SVG 中，这是一种专为图形设计的 XML 模式。任何时候你将 Inkscape 中的图像导出为 PNG 文件时，你都在转换 XML。</p>
<p>名单还可以一直继续下去。XML 是一种数据存储格式，旨在确保你的数据，无论是画布上的点和线、图表上的节点，还是文档中的文字，都可以轻松准确地提取、更新和转换。</p>
<h3 id="学习-XML"><a href="#学习-XML" class="headerlink" title="学习 XML"></a>学习 XML</h3><hr>
<p>编写 XML 很像编写 HTML。感谢 Jay Nick 的辛勤工作，在线提供免费且有趣的 XML 课程 可以教你如何使用 XML 创建图形。</p>
<p>通常，探索 XML 所需的特殊工具很少。由于 HTML 和 XML 之间的密切关系，你可以 使用 Web 浏览器查看 XML。此外，QXmlEdit、NetBeans 和 Kate 等开源文本编辑器通过有用的提示、自动完成、语法验证等，使键入和阅读 XML 变得容易。</p>
<h3 id="选择-XML"><a href="#选择-XML" class="headerlink" title="选择 XML"></a>选择 XML</h3><p>XML 起初可能看起来有很多数据，但它与 HTML 并没有太大的不同（实际上，HTML 已经 以 XHTML 的形式重新实现为 XML）。XML 有一个独特的好处，即构成其结构的标签也恰好是元数据，提供有关其存储内容的信息。精心设计的 XML 模式包含并描述你的数据，使用户能够一目了然并快速解析它，并使开发人员能够使用一些库 快速解析。</p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 ansible 如何部署 k8s_kubernets?</title>
    <url>/2021/10/15/%E4%BD%BF%E7%94%A8-ansible-%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2-k8s-kubernets/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-11.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Ansible 是一个配置管理和应用部署工具,即在管理主机上操作一些命令就能在节点主机上进行相应的动作。由 Python 编写,由模块化组成,即执行动作的实体,在 ansible 上都是靠着相应的模块执行动作,比如拷贝 copy 模块、执行 command 模块、shell 模块等</p>
<h3 id="安装-ansible"><a href="#安装-ansible" class="headerlink" title="安装 ansible"></a>安装 ansible</h3><hr>
<p># 系统改成阿里 yum 源，并更新系统<br>mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.$(date +%Y%m%d)<br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a><br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo <a href="http://mirrors.aliyun.com/repo/epel-7.repo">http://mirrors.aliyun.com/repo/epel-7.repo</a><br>yum clean all &amp;&amp; yum makecache &amp;&amp; yum update -y</p>
<p>#安装 ansible<br>yum -y install epel-release<br>yum install ansible -y<br>ssh-keygen -t rsa<br>ssh-copy-id xx.xx.xx.xx</p>
<h2 id="批量拷贝秘钥"><a href="#批量拷贝秘钥" class="headerlink" title="批量拷贝秘钥"></a>批量拷贝秘钥</h2><h4 id="编写机器-ip-访问端口-登录密码"><a href="#编写机器-ip-访问端口-登录密码" class="headerlink" title="##编写机器 ip 访问端口 登录密码"></a>##编写机器 ip 访问端口 登录密码</h4><p>cat &lt;<EOF> hostname.txt<br>192.168.10.11 22 fana<br>192.168.10.12 22 fana<br>192.168.10.13 22 fana<br>192.168.10.14 22 fana<br>EOF</p>
<h4 id="不输入-yes-修改后重启-sshd"><a href="#不输入-yes-修改后重启-sshd" class="headerlink" title="不输入 yes,修改后重启 sshd"></a>不输入 yes,修改后重启 sshd</h4><p>sed -i ‘&#x2F;StrictHostKeyChecking&#x2F;s&#x2F;^#&#x2F;&#x2F;; &#x2F;StrictHostKeyChecking&#x2F;s&#x2F;ask&#x2F;no&#x2F;‘ &#x2F;etc&#x2F;ssh&#x2F;ssh_config</p>
<h4 id="然后执行拷贝秘钥"><a href="#然后执行拷贝秘钥" class="headerlink" title="然后执行拷贝秘钥"></a>然后执行拷贝秘钥</h4><p>cat hostname.txt  while read ip port pawd;do sshpass -p $pawd ssh-copy-id -p $port root@$ip;done</p>
<h4 id="安装-sshpass"><a href="#安装-sshpass" class="headerlink" title="安装 sshpass"></a>安装 sshpass</h4><p>wget <a href="http://sourceforge.net/projects/sshpass/files/sshpass">http://sourceforge.net/projects/sshpass/files/sshpass</a><br>tar xvzf sshpass-1.06.tar.gz<br>.&#x2F;configure<br>make<br>make install</p>
<h1 id="CentOS升级内核版本-linux升级内核版本-Redhat升级内核版本"><a href="#CentOS升级内核版本-linux升级内核版本-Redhat升级内核版本" class="headerlink" title="CentOS升级内核版本_linux升级内核版本_Redhat升级内核版本"></a>CentOS升级内核版本_linux升级内核版本_Redhat升级内核版本</h1><h2 id="升级内核参考：https-www-code404-icu-240-html"><a href="#升级内核参考：https-www-code404-icu-240-html" class="headerlink" title="升级内核参考：https://www.code404.icu/240.html"></a>升级内核参考：<a href="https://www.code404.icu/240.html">https://www.code404.icu/240.html</a></h2><h3 id="安装-k8s"><a href="#安装-k8s" class="headerlink" title="安装 k8s"></a>安装 k8s</h3><hr>
<p>## 下载 ansible 脚本<br>#链接：<a href="https://pan.baidu.com/s/1VKQ5txJ2xgwUVim/_E2P9kA">https://pan.baidu.com/s/1VKQ5txJ2xgwUVim\_E2P9kA</a><br>#提取码：3cq2</p>
<h2 id="ansible-安装-k8s"><a href="#ansible-安装-k8s" class="headerlink" title="ansible 安装 k8s"></a>ansible 安装 k8s</h2><p>ansible-playbook -i inventory installK8s.yml</p>
<h2 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h2><p>k8s: 1.14.8<br>etcd: 3.3.18<br>flanneld: 0.11.0<br>docker: 19.03.5<br>nginx: 1.16.1</p>
<h2 id="自签-TLS-证书"><a href="#自签-TLS-证书" class="headerlink" title="自签 TLS 证书"></a>自签 TLS 证书</h2><p>etcd：ca.pem server.pem server-key.pem<br>flannel：ca.pem server.pem server-key.pem<br>kube-apiserver：ca.pem server.pem server-key.pem<br>kubelet：ca.pem ca-key.pem<br>kube-proxy：ca.pem kube-proxy.pem kube-proxy-key.pem<br>kubectl：ca.pem admin.pem admin-key.pem —— 用于管理员访问集群</p>
<h2 id="检查证书时长，官方建议一年最少升级一次-k8s-集群，升级的时候证书时长也会升级"><a href="#检查证书时长，官方建议一年最少升级一次-k8s-集群，升级的时候证书时长也会升级" class="headerlink" title="检查证书时长，官方建议一年最少升级一次 k8s 集群，升级的时候证书时长也会升级"></a>检查证书时长，官方建议一年最少升级一次 k8s 集群，升级的时候证书时长也会升级</h2><p>openssl x509 -in ca.pem -text -noout</p>
<h3 id="显示如下"><a href="#显示如下" class="headerlink" title="显示如下"></a>显示如下</h3><p>Certificate:<br>    Data:<br>        Version: 3 (0x2)<br>        Serial Number:<br>            51:5c:66:8b:40:24:d7:bb:ea:94:e7:5a:33:fe:44:a2:e2:18:51:b3<br>    Signature Algorithm: sha256WithRSAEncryption<br>        Issuer: C&#x3D;CN, ST&#x3D;ShangHai, L&#x3D;ShangHai, O&#x3D;k8s, OU&#x3D;System, CN&#x3D;kubernetes<br>        Validity<br>            Not Before: Dec 14 13:26:00 2019 GMT<br>            Not After : Dec 11 13:26:00 2029 GMT #时长为10年<br>        Subject: C&#x3D;CN, ST&#x3D;ShangHai, L&#x3D;ShangHai, O&#x3D;k8s, OU&#x3D;System, CN&#x3D;kubernetes<br>        Subject Public Key Info:<br>            Public Key Algorithm: rsaEncryption<br>                Public-Key: (2048 bit)<br>                Modulus:<br>                    00:c2:5c:92:dd:36:67:3f:d4:f1:e0:5f:e0:48:40:</p>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><p>kubelet:  243662875&#x2F;pause-amd64:3.1<br>coredns:  243662875&#x2F;coredns:1.3.1<br>dashboard: 243662875&#x2F;kubernetes-dashboard-amd64:v1.10.1<br>metrics-server: 243662875&#x2F;metrics-server-amd64:v0.3.6<br>traefik: traefik:latest<br>es:  elasticsearch:6.6.1<br>fluentd-es:  243662875&#x2F;fluentd-elasticsearch:v2.4.0<br>kibana:  243662875&#x2F;kibana-oss:6.6.1</p>
<h3 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h3><hr>
<h4 id="检查-etcd"><a href="#检查-etcd" class="headerlink" title="检查 etcd"></a>检查 etcd</h4><hr>
<p>systemctl status etcdgrep active</p>
<p>etcdctl –ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd.pem \<br>–key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd-key.pem cluster-health<br>##显示如下：<br>member 1af68d968c7e3f22 is healthy: got healthy result from <a href="https://192.168.10.12:2379/">https://192.168.10.12:2379</a><br>member 7508c5fadccb39e2 is healthy: got healthy result from <a href="https://192.168.10.11:2379/">https://192.168.10.11:2379</a><br>member e8d9a97b17f26476 is healthy: got healthy result from <a href="https://192.168.10.13:2379/">https://192.168.10.13:2379</a><br>cluster is healthy</p>
<p>etcdctl –endpoints&#x3D;<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379</a> \<br>–ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd.pem \<br>–key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd-key.pem member list</p>
<p>ETCDCTL_API&#x3D;3 etcdctl \<br>-w table –cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd.pem \<br>–key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd-key.pem \<br>–endpoints&#x3D;”<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;</a> endpoint status</p>
<h3 id="显示如下-1"><a href="#显示如下-1" class="headerlink" title="显示如下"></a>显示如下</h3><p>+—————————-+——————+———+———+———–+———–+————+<br> ENDPOINT  ID  VERSION  DB SIZE  IS LEADER  RAFT TERM  RAFT INDEX<br>+—————————-+——————+———+———+———–+———–+————+<br> <a href="https://192.168.10.11:2379/">https://192.168.10.11:2379</a>  7508c5fadccb39e2  3.3.18  762 kB  false  421  287371<br> <a href="https://192.168.10.12:2379/">https://192.168.10.12:2379</a>  1af68d968c7e3f22  3.3.18  762 kB  true  421  287371<br> <a href="https://192.168.10.13:2379/">https://192.168.10.13:2379</a>  e8d9a97b17f26476  3.3.18  762 kB  false  421  287371<br>+—————————-+——————+———+———+———–+———–+————+</p>
<p>#遇到报错：cannot unmarshal event: proto: wrong wireType &#x3D; 0 for field Key<br>#解决办法参考：<a href="https://www.code404.icu/1306.html">https://www.code404.icu/1306.html</a></p>
<p>#查询 etcd API3 的键<br>ETCDCTL_API&#x3D;3 etcdctl –endpoints&#x3D;”<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;</a> \<br>–cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd.pem \<br>–key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd-key.pem get &#x2F; –prefix –keys-only</p>
<h4 id="检查-flanneld"><a href="#检查-flanneld" class="headerlink" title="检查 flanneld"></a>检查 flanneld</h4><hr>
<p>systemctl status flanneldgrep Active</p>
<p>ip addr showgrep flannel<br>ip addr showgrep docker</p>
<p>cat &#x2F;run&#x2F;flannel&#x2F;docker</p>
<p>cat &#x2F;run&#x2F;flannel&#x2F;subnet.env</p>
<h4 id="列出键值存储的目录"><a href="#列出键值存储的目录" class="headerlink" title="列出键值存储的目录"></a>列出键值存储的目录</h4><p>etcdctl \<br>–ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld.pem \<br>–key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld-key.pem ls -r</p>
<h2 id="显示如下-2"><a href="#显示如下-2" class="headerlink" title="显示如下"></a>显示如下</h2><p>&#x2F;kubernetes<br>&#x2F;kubernetes&#x2F;network<br>&#x2F;kubernetes&#x2F;network&#x2F;config<br>&#x2F;kubernetes&#x2F;network&#x2F;subnets<br>&#x2F;kubernetes&#x2F;network&#x2F;subnets&#x2F;172.30.12.0-24<br>&#x2F;kubernetes&#x2F;network&#x2F;subnets&#x2F;172.30.43.0-24<br>&#x2F;kubernetes&#x2F;network&#x2F;subnets&#x2F;172.30.9.0-24</p>
<h4 id="检查分配的-pod-网段"><a href="#检查分配的-pod-网段" class="headerlink" title="检查分配的 pod 网段"></a>检查分配的 pod 网段</h4><p>etcdctl \<br>–endpoints&#x3D;”<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;</a> \<br>–ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld.pem \<br>–key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld-key.pem \<br>get &#x2F;kubernetes&#x2F;network&#x2F;config</p>
<h4 id="检查分配的-pod-子网列表"><a href="#检查分配的-pod-子网列表" class="headerlink" title="检查分配的 pod 子网列表"></a>检查分配的 pod 子网列表</h4><p>etcdctl \<br>–endpoints&#x3D;”<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;</a> \<br>–ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld.pem \<br>–key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld-key.pem \<br>ls &#x2F;kubernetes&#x2F;network&#x2F;subnets</p>
<h4 id="检查-pod-网段对于的-IP-和-flannel-接口"><a href="#检查-pod-网段对于的-IP-和-flannel-接口" class="headerlink" title="检查 pod 网段对于的 IP 和 flannel 接口"></a>检查 pod 网段对于的 IP 和 flannel 接口</h4><p>etcdctl \<br>–endpoints&#x3D;”<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;</a> \<br>–ca-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld.pem \<br>–key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;flanneld-key.pem \<br>get &#x2F;kubernetes&#x2F;network&#x2F;subnets&#x2F;172.30.74.0-24</p>
<h4 id="检查-nginx-和-keepalived"><a href="#检查-nginx-和-keepalived" class="headerlink" title="检查 nginx 和 keepalived"></a>检查 nginx 和 keepalived</h4><hr>
<p>ps -efgrep nginx<br>ps -efgrep keepalived<br>netstat -lntupgrep nginx<br>ip addgrep 192.168      # 查看 VIP，显示如下<br>  inet 192.168.10.11&#x2F;24 brd 192.168.10.255 scope global noprefixroute ens32<br>    inet 192.168.10.100&#x2F;32 scope global ens32</p>
<h4 id="检查-kube-apiserver"><a href="#检查-kube-apiserver" class="headerlink" title="检查 kube-apiserver"></a>检查 kube-apiserver</h4><hr>
<p>netstat -lntup  grep kube-apiser</p>
<h1 id="显示如下-3"><a href="#显示如下-3" class="headerlink" title="显示如下"></a>显示如下</h1><p>tcp 0      0 192.168.10.11:6443      0.0.0.0:* LISTEN 115454&#x2F;kube-apiserv</p>
<p>kubectl cluster-info</p>
<h1 id="显示如下-4"><a href="#显示如下-4" class="headerlink" title="显示如下"></a>显示如下</h1><p>Kubernetes master is running at <a href="https://192.168.10.100:8443/">https://192.168.10.100:8443</a><br>Elasticsearch is running at <a href="https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy">https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy</a><br>Kibana is running at <a href="https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/kibana-logging/proxy">https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/kibana-logging/proxy</a><br>CoreDNS is running at <a href="https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy">https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</a><br>kubernetes-dashboard is running at <a href="https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy">https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy</a><br>Metrics-server is running at <a href="https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy">https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy</a><br>To further debug and diagnose cluster problems, use ‘kubectl cluster-info dump’.</p>
<p>kubectl get all –all-namespaces</p>
<p>kubectl get cs</p>
<h1 id="显示如下-5"><a href="#显示如下-5" class="headerlink" title="显示如下"></a>显示如下</h1><p>NAME STATUS MESSAGE ERROR<br>controller-manager Healthy ok<br>scheduler Healthy ok<br>etcd-1               Healthy {“health”:”true”}<br>etcd-2               Healthy {“health”:”true”}<br>etcd-0               Healthy {“health”:”true”}</p>
<h4 id="打印-kube-apiserver-写入-etcd-数据"><a href="#打印-kube-apiserver-写入-etcd-数据" class="headerlink" title="打印 kube-apiserver 写入 etcd 数据"></a>打印 kube-apiserver 写入 etcd 数据</h4><p>ETCDCTL_API&#x3D;3 etcdctl \<br>–endpoints&#x3D;”<a href="https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;">https://192.168.10.11:2379,https://192.168.10.12:2379,https://192.168.10.13:2379&quot;</a> \<br>–cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem \<br>–cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd.pem \<br>–key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd-key.pem \<br>get &#x2F;registry&#x2F; –prefix –keys-only</p>
<h4 id="遇到报错"><a href="#遇到报错" class="headerlink" title="遇到报错"></a>遇到报错</h4><p>unexpected ListAndWatch error: storage&#x2F;cacher.go:&#x2F;secrets: Failed to list *core.Secret: unable to transform key “&#x2F;registry&#x2F;secrets&#x2F;kube-system&#x2F;bootstrap-token-2z8s62”: invalid padding on input</p>
<h5 id="原因，集群上的，kube-apiserver-的-token-不一致-文件是：encryption-config-yaml-必须保证-secret-的参数-一致"><a href="#原因，集群上的，kube-apiserver-的-token-不一致-文件是：encryption-config-yaml-必须保证-secret-的参数-一致" class="headerlink" title="原因，集群上的，kube-apiserver 的 token 不一致 文件是：encryption-config.yaml 必须保证 secret 的参数 一致"></a>原因，集群上的，kube-apiserver 的 token 不一致 文件是：encryption-config.yaml 必须保证 secret 的参数 一致</h5><h4 id="检查-kube-controller-manager"><a href="#检查-kube-controller-manager" class="headerlink" title="检查 kube-controller-manager"></a>检查 kube-controller-manager</h4><hr>
<p>netstat -lntupgrep kube-control</p>
<h1 id="显示如下-6"><a href="#显示如下-6" class="headerlink" title="显示如下"></a>显示如下</h1><p>tcp 0      0 127.0.0.1:10252         0.0.0.0:* LISTEN 117775&#x2F;kube-control<br>tcp6 0      0 :::10257                :::* LISTEN 117775&#x2F;kube-control</p>
<p>kubectl get cs</p>
<p>kubectl get endpoints kube-controller-manager –namespace&#x3D;kube-system  -o yaml</p>
<h1 id="显示如下，可以看到-kube12-变成-leader"><a href="#显示如下，可以看到-kube12-变成-leader" class="headerlink" title="显示如下，可以看到 kube12 变成 leader"></a>显示如下，可以看到 kube12 变成 leader</h1><p>apiVersion: v1<br>kind: Endpoints<br>metadata:<br>  annotations:<br>    control-plane.alpha.kubernetes.io&#x2F;leader: ‘{“holderIdentity”:”kube12_753e65bf-1e65-11ea-b9c4-000c293dd01c”,”leaseDurationSeconds”:15,”acquireTime”:”2019-12-14T11:32:49Z”,”renewTime”:”2019-12-14T12:43:20Z”,”leaderTransitions”:0}’<br>  creationTimestamp: “2019-12-14T11:32:49Z”<br>  name: kube-controller-manager<br>  namespace: kube-system<br>  resourceVersion: “8282”<br>  selfLink: &#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;endpoints&#x2F;kube-controller-manager<br>  uid: 753d2be7-1e65-11ea-b980-000c29e3f448</p>
<h4 id="检查-kube-scheduler"><a href="#检查-kube-scheduler" class="headerlink" title="检查 kube-scheduler"></a>检查 kube-scheduler</h4><hr>
<p>netstat -lntupgrep kube-sche</p>
<h1 id="显示如下-7"><a href="#显示如下-7" class="headerlink" title="显示如下"></a>显示如下</h1><p>tcp 0      0 127.0.0.1:10251         0.0.0.0:* LISTEN 119678&#x2F;kube-schedul<br>tcp6 0      0 :::10259                :::* LISTEN 119678&#x2F;kube-schedul</p>
<p>kubectl get cs</p>
<p>kubectl get endpoints kube-scheduler –namespace&#x3D;kube-system  -o yaml</p>
<h1 id="显示如下，可以看到-kube12-变成-leader-1"><a href="#显示如下，可以看到-kube12-变成-leader-1" class="headerlink" title="显示如下，可以看到 kube12 变成 leader"></a>显示如下，可以看到 kube12 变成 leader</h1><p>apiVersion: v1<br>kind: Endpoints<br>metadata:<br>  annotations:<br>    control-plane.alpha.kubernetes.io&#x2F;leader: ‘{“holderIdentity”:”kube12_89050e00-1e65-11ea-8f5e-000c293dd01c”,”leaseDurationSeconds”:15,”acquireTime”:”2019-12-14T11:33:23Z”,”renewTime”:”2019-12-14T12:45:22Z”,”leaderTransitions”:0}’<br>  creationTimestamp: “2019-12-14T11:33:23Z”<br>  name: kube-scheduler<br>  namespace: kube-system<br>  resourceVersion: “8486”<br>  selfLink: &#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;endpoints&#x2F;kube-scheduler<br>  uid: 899d1625-1e65-11ea-b980-000c29e3f448</p>
<h4 id="检查-kubelet"><a href="#检查-kubelet" class="headerlink" title="检查 kubelet"></a>检查 kubelet</h4><hr>
<p>netstat -lntupgrep kubelet</p>
<h1 id="显示如下-8"><a href="#显示如下-8" class="headerlink" title="显示如下"></a>显示如下</h1><p>tcp 0      0 127.0.0.1:35173         0.0.0.0:* LISTEN 123215&#x2F;kubelet<br>tcp 0      0 127.0.0.1:10248         0.0.0.0:* LISTEN 123215&#x2F;kubelet<br>tcp 0      0 192.168.10.11:10250     0.0.0.0:* LISTEN 123215&#x2F;kubelet</p>
<p>kubeadm token list –kubeconfig ~&#x2F;.kube&#x2F;config</p>
<h1 id="查看创建的-token"><a href="#查看创建的-token" class="headerlink" title="查看创建的 token"></a>查看创建的 token</h1><p>TOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPS<br>hf0fa4.ta6haf1wsz1fnobf 22h 2019-12-15T19:33:26+08:00   authentication,signing kubelet-bootstrap-token system:bootstrappers:kube11<br>oftjgn.01tob30h8v9l05lm 22h 2019-12-15T19:33:26+08:00   authentication,signing kubelet-bootstrap-token system:bootstrappers:kube12<br>zuezc4.7kxhmayoue16pycb 22h 2019-12-15T19:33:26+08:00   authentication,signing kubelet-bootstrap-token system:bootstrappers:kube13</p>
<p>kubectl get csr</p>
<h1 id="已经批准"><a href="#已经批准" class="headerlink" title="已经批准"></a>已经批准</h1><p>NAME AGE REQUESTOR CONDITION<br>node-csr-Oarn7xdWDiq7-CLn7yrE3fkTtmJtoSenmlGj3XL85lM 72m   system:bootstrap:zuezc4 Approved,Issued<br>node-csr-hJrfQXlhIqJTROLD1ExmcXq74J78uu6rjHuh5ZyVlMg 72m   system:bootstrap:zuezc4 Approved,Issued<br>node-csr-s-BAbqc8hOKfDj8xqdJ6fWjwdustqG9LhwbpYxa9x68 72m   system:bootstrap:zuezc4 Approved,Issued</p>
<p>kubectl get nodes</p>
<h1 id="显示如下-9"><a href="#显示如下-9" class="headerlink" title="显示如下"></a>显示如下</h1><p>NAME STATUS ROLES AGE VERSION<br>192.168.10.11   Ready <none>   73m   v1.14.8<br>192.168.10.12   Ready <none>   73m   v1.14.8<br>192.168.10.13   Ready <none>   73m   v1.14.8</p>
<p>systemctl status kubelet</p>
<h4 id="1-遇到报错："><a href="#1-遇到报错：" class="headerlink" title="1.遇到报错："></a>1.遇到报错：</h4><p> Failed to connect to apiserver: the server has asked for the client to provide credentials</p>
<h4 id="检查-api-是不是有问题，如没有问题，需要重新生成-kubelet-bootstrap-kubeconfig-文件-然后重启-kubelet"><a href="#检查-api-是不是有问题，如没有问题，需要重新生成-kubelet-bootstrap-kubeconfig-文件-然后重启-kubelet" class="headerlink" title="检查 api 是不是有问题，如没有问题，需要重新生成 kubelet-bootstrap.kubeconfig 文件,然后重启 kubelet"></a>检查 api 是不是有问题，如没有问题，需要重新生成 kubelet-bootstrap.kubeconfig 文件,然后重启 kubelet</h4><h4 id="2-启动不起来，没有报错信息"><a href="#2-启动不起来，没有报错信息" class="headerlink" title="2.启动不起来，没有报错信息"></a>2.启动不起来，没有报错信息</h4><p>#检查 kubelet.config.json 文件 “address”: “192.168.10.12”, 是不是本机 IP</p>
<h4 id="3-遇到问题："><a href="#3-遇到问题：" class="headerlink" title="3.遇到问题："></a>3.遇到问题：</h4><p>failed to ensure node lease exists, will retry in 7s, error: leases.coordination.k8s.io “192.168.10.12” is forbidden: User “system:node:192.168.10.11” cannot get resource “leases” in API group “coordination.k8s.io” in the namespace “kube-node-lease”: can only access node lease with the same name as the requesting node<br>Unable to register node “192.168.10.12” with API server: nodes “192.168.10.12” is forbidden: node “192.168.10.11” is not allowed to modify node “192.168.10.12”<br>#检查 kubelet.config.json 文件 “address”: “192.168.10.12”, 是不是本机 IP</p>
<h4 id="检查-kube-proxy"><a href="#检查-kube-proxy" class="headerlink" title="检查 kube-proxy"></a>检查 kube-proxy</h4><hr>
<p>netstat -lnptgrep kube-proxy</p>
<h1 id="显示如下-10"><a href="#显示如下-10" class="headerlink" title="显示如下"></a>显示如下</h1><p>tcp 0      0 192.168.10.11:10249     0.0.0.0:* LISTEN 125459&#x2F;kube-proxy<br>tcp 0      0 192.168.10.11:10256     0.0.0.0:* LISTEN 125459&#x2F;kube-proxy<br>tcp6 0      0 :::32698                :::* LISTEN 125459&#x2F;kube-proxy<br>tcp6 0      0 :::32699                :::* LISTEN 125459&#x2F;kube-proxy<br>tcp6 0      0 :::32700                :::* LISTEN 125459&#x2F;kube-proxy</p>
<p>ipvsadm -ln</p>
<h3 id="检查附加组件"><a href="#检查附加组件" class="headerlink" title="检查附加组件"></a>检查附加组件</h3><hr>
<h4 id="检查-coredns"><a href="#检查-coredns" class="headerlink" title="检查 coredns"></a>检查 coredns</h4><hr>
<p>kubectl  get pods -n kube-system #查看 pod 是否都启动完成</p>
<p>#使用容器验证<br>kubectl run dig –rm -it –image&#x3D;docker.io&#x2F;azukiapp&#x2F;dig &#x2F;bin&#x2F;sh<br>#ping 百度<br>ping <a href="http://www.baidu.com/">www.baidu.com</a><br>PING <a href="http://www.baidu.com/">www.baidu.com</a> (180.101.49.11): 56 data bytes<br>64 bytes from 180.101.49.11: seq&#x3D;0 ttl&#x3D;127 time&#x3D;10.772 ms<br>64 bytes from 180.101.49.11: seq&#x3D;1 ttl&#x3D;127 time&#x3D;9.347 ms<br>64 bytes from 180.101.49.11: seq&#x3D;2 ttl&#x3D;127 time&#x3D;10.937 ms<br>64 bytes from 180.101.49.11: seq&#x3D;3 ttl&#x3D;127 time&#x3D;11.149 ms<br>64 bytes from 180.101.49.11: seq&#x3D;4 ttl&#x3D;127 time&#x3D;10.677 ms</p>
<p>cat &#x2F;etc&#x2F;resolv.conf #查看<br>nameserver 10.254.0.2<br>search default.svc.cluster.local. svc.cluster.local. cluster.local.<br>options ndots:5</p>
<p>nslookup <a href="http://www.baidu.com/">www.baidu.com</a><br>#显示如下<br>Server: 10.254.0.2<br>Address: 10.254.0.2#53</p>
<p>Non-authoritative answer:<br><a href="http://www.baidu.com/">www.baidu.com</a> canonical name &#x3D; <a href="http://www.a.shifen.com/">www.a.shifen.com</a>.<br>Name: <a href="http://www.a.shifen.com/">www.a.shifen.com</a><br>Address: 180.101.49.12<br>Name: <a href="http://www.a.shifen.com/">www.a.shifen.com</a><br>Address: 180.101.49.11</p>
<p>nslookup kubernetes.default #执行<br>Server: 10.254.0.2<br>Address: 10.254.0.2#53</p>
<p>Name: kubernetes.default.svc.cluster.local<br>Address: 10.254.0.1</p>
<p>nslookup kubernetes #执行<br>Server: 10.254.0.2<br>Address: 10.254.0.2#53</p>
<p>Name: kubernetes.default.svc.cluster.local<br>Address: 10.254.0.1</p>
<h4 id="检查-dashboard"><a href="#检查-dashboard" class="headerlink" title="检查 dashboard"></a>检查 dashboard</h4><hr>
<p>### 使用谷歌浏览器访问 <a href="https://192.168.10.13:10250/metrics">https://192.168.10.13:10250/metrics</a> 报 Unauthorized 是需要使用证书，生成证书方式参考如下</p>
<p>#1.Windows 机器，需要安装 jdk 然后使用 keytool 工具在 bin 目录下, 需要把 ca.pem 拷贝下来,我放在 E 盘了,执行导入证书命令<br>.\keytool -import -v -trustcacerts -alias appmanagement -file “E:\ca.pem” -storepass password -keystore cacerts #导入证书<br>.\keytool -delete -v -trustcacerts -alias appmanagement -file “E:\ca.pem” -storepass password -keystore cacerts #删除证书</p>
<p>#2.执行过后，然后在 linux 上执行如下：<br>openssl pkcs12 -export -out admin.pfx -inkey admin-key.pem -in admin.pem -certfile ca.pem</p>
<p>#3.然后通过浏览器把 admin.pfx 证书导进去，就可以正常访问了。</p>
<h1 id="然后访问-dashboard"><a href="#然后访问-dashboard" class="headerlink" title="然后访问 dashboard"></a>然后访问 dashboard</h1><p><a href="https://192.168.10.13:32700/">https://192.168.10.13:32700</a></p>
<h4 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h4><p><a href="https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy">https://192.168.10.100:8443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy</a></p>
<h4 id="需要使用-kubeconfig：已经自动生成了在-x2F-etc-x2F-kubernetes-x2F-dashboard-kubeconfig"><a href="#需要使用-kubeconfig：已经自动生成了在-x2F-etc-x2F-kubernetes-x2F-dashboard-kubeconfig" class="headerlink" title="需要使用 kubeconfig：已经自动生成了在&#x2F;etc&#x2F;kubernetes&#x2F;dashboard.kubeconfig"></a>需要使用 kubeconfig：已经自动生成了在&#x2F;etc&#x2F;kubernetes&#x2F;dashboard.kubeconfig</h4><p>#令牌保存在 &#x2F;dashboard_login_token.txt 文件里，也可以用下面的命令获取 token<br>kubectl -n kube-system describe secret `kubectl -n kube-system get secretgrep dashboard  awk ‘{print $1}’`</p>
<h3 id="检查-traefik"><a href="#检查-traefik" class="headerlink" title="检查 traefik"></a>检查 traefik</h3><hr>
<p>#每个 node 节点上部署一个 traefik<br>kubectl  get pod,deploy,daemonset,service,ingress -n kube-system  grep traefik</p>
<h3 id="显示如下-11"><a href="#显示如下-11" class="headerlink" title="显示如下"></a>显示如下</h3><p>pod&#x2F;traefik-ingress-controller-gl7vs 1&#x2F;1     Running 0          43m<br>pod&#x2F;traefik-ingress-controller-qp26j 1&#x2F;1     Running 0          43m<br>pod&#x2F;traefik-ingress-controller-x99ls 1&#x2F;1     Running 0          43m<br>daemonset.extensions&#x2F;traefik-ingress-controller 3         3         3       3            3           <none> 43m<br>service&#x2F;traefik-ingress-service ClusterIP 10.254.148.220   <none> 80&#x2F;TCP,8080&#x2F;TCP 43m<br>service&#x2F;traefik-web-ui ClusterIP 10.254.139.95    <none> 80&#x2F;TCP 43m<br>ingress.extensions&#x2F;traefik-web-ui traefik-ui 80      43m</p>
<h1 id="访问返回如下："><a href="#访问返回如下：" class="headerlink" title="访问返回如下："></a>访问返回如下：</h1><p>curl -H ‘host:traefik-ui’ 192.168.10.11<br><a href="/dashboard/">Found</a>.<br>curl -H ‘host:traefik-ui’ 192.168.10.12<br><a href="/dashboard/">Found</a>.<br>curl -H ‘host:traefik-ui’ 192.168.10.13<br><a href="/dashboard/">Found</a>.</p>
<p>#查看端口<br>netstat -lntupgrep traefik<br>tcp6 0      0 :::8080                 :::* LISTEN 66426&#x2F;traefik<br>tcp6 0      0 :::80                   :::* LISTEN 66426&#x2F;traefik</p>
<p>#然后访问 <a href="http://192.168.10.11:8080/">http://192.168.10.11:8080/</a></p>
<h4 id="检查-metrics"><a href="#检查-metrics" class="headerlink" title="检查 metrics"></a>检查 metrics</h4><hr>
<p>kubectl top node</p>
<p>###报错：Error from server (Forbidden): forbidden: User “system:anonymous” cannot get path “&#x2F;apis&#x2F;metrics.k8s.io&#x2F;v1beta1”<br>Error from server (Forbidden): nodes.metrics.k8s.io is forbidden: User “system:anonymous” cannot list resource “nodes” in API group “metrics.k8s.io” at the cluster scope<br>###解决办法<br>kubectl create clusterrolebinding the-boss –user system:anonymous –clusterrole cluster-admin</p>
<h3 id="遇到报错：Error-from-server-ServiceUnavailable-the-server-is-currently-unable-to-handle-the-request-get-nodes-metrics-k8s-io"><a href="#遇到报错：Error-from-server-ServiceUnavailable-the-server-is-currently-unable-to-handle-the-request-get-nodes-metrics-k8s-io" class="headerlink" title="遇到报错：Error from server (ServiceUnavailable): the server is currently unable to handle the request (get nodes.metrics.k8s.io)"></a>遇到报错：Error from server (ServiceUnavailable): the server is currently unable to handle the request (get nodes.metrics.k8s.io)</h3><h4 id="检查-EFK"><a href="#检查-EFK" class="headerlink" title="检查 EFK"></a>检查 EFK</h4><hr>
<p>es: <a href="http://192.168.10.11:32698/">http://192.168.10.11:32698/</a><br>Kibana: <a href="http://192.168.10.11:32699/">http://192.168.10.11:32699</a></p>
<h4 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h4><hr>
<p>kubectl create ns myapp</p>
<p>kubectl apply -f nginx.yaml</p>
<p>kubectl get pod,svc,ing -n myapp -o wide<br>###显示如下<br>NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES<br>pod&#x2F;my-nginx-69f8f65796-zd777 1&#x2F;1     Running 0          19m   172.30.36.15   192.168.10.11   <none> <none></p>
<p>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR<br>service&#x2F;my-nginx ClusterIP 10.254.131.1   <none> 80&#x2F;TCP 21m   app&#x3D;my-nginx</p>
<p>NAME HOSTS ADDRESS PORTS AGE<br>ingress.extensions&#x2F;my-nginx myapp.nginx.com 80      21m</p>
<p>#验证访问是否正常<br>curl <a href="http://172.30.36.15/">http://172.30.36.15</a><br>curl <a href="http://10.254.131.1/">http://10.254.131.1</a><br>curl -H “host:myapp.nginx.com” 192.168.10.11</p>
<h3 id="通过谷歌浏览器访问：http-192-168-10-100-8088"><a href="#通过谷歌浏览器访问：http-192-168-10-100-8088" class="headerlink" title="通过谷歌浏览器访问：http://192.168.10.100:8088/"></a>通过谷歌浏览器访问：<a href="http://192.168.10.100:8088/">http://192.168.10.100:8088/</a></h3><h3 id="我们部署的时候已经通过-nginx-代理了-traefik-地址-x2F-data-x2F-nginx-x2F-conf-x2F-nginx-conf"><a href="#我们部署的时候已经通过-nginx-代理了-traefik-地址-x2F-data-x2F-nginx-x2F-conf-x2F-nginx-conf" class="headerlink" title="我们部署的时候已经通过 nginx 代理了 traefik 地址 &#x2F;data&#x2F;nginx&#x2F;conf&#x2F;nginx.conf"></a>我们部署的时候已经通过 nginx 代理了 traefik 地址 &#x2F;data&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</h3><p>kubectl exec -it my-nginx-69f8f65796-zd777 -n myapp bash<br>echo “hello world” &gt;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html #然后浏览器访问 <a href="http://192.168.10.100:8088/">http://192.168.10.100:8088/</a> 显示 hello world</p>
<h3 id="重启所有组件"><a href="#重启所有组件" class="headerlink" title="重启所有组件"></a>重启所有组件</h3><hr>
<p>systemctl restart etcd &amp;&amp; systemctl status etcd<br>systemctl restart flanneld &amp;&amp; systemctl status flanneld<br>systemctl restart docker &amp;&amp; systemctl status docker<br>systemctl stop nginx &amp;&amp; systemctl start nginx &amp;&amp; systemctl status nginx<br>systemctl restart keepalived &amp;&amp; systemctl status keepalived<br>systemctl restart kube-apiserver &amp;&amp; systemctl status kube-apiserver<br>systemctl restart kube-controller-manager &amp;&amp; systemctl status kube-controller-manager<br>systemctl restart kube-scheduler &amp;&amp; systemctl status kube-scheduler<br>systemctl restart kubelet &amp;&amp; systemctl status kubelet<br>systemctl restart kube-proxy &amp;&amp; systemctl status kube-proxy</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernets</tag>
        <tag>etcd</tag>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Jenkins 构建 CI/CD 之多分支流水线_Multibranch ?</title>
    <url>/2021/10/23/%E4%BD%BF%E7%94%A8-jenkins-%E6%9E%84%E5%BB%BA-ci-cd-%E4%B9%8B%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-multibranch/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-19.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>由于公司的 Jenkins 配置没有部署成功的通知，在我学了几天的 Jenkins 后终于是对公司的 Jenkins 配置下手了，结果我刚装完 dingtalk 插件自动重启后，发现之前主管配置的构建项目数据都丢失了，正好给了我练手的机会，于是就有了以下从0到1的辛酸历程。</p>
<h3 id="在-Docker-中安装并运行-Jenkins"><a href="#在-Docker-中安装并运行-Jenkins" class="headerlink" title="在 Docker 中安装并运行 Jenkins"></a>在 Docker 中安装并运行 Jenkins</h3><hr>
<p>这里假设你的服务器已经装好了docker</p>
<p>使用的镜像是 jenkinsci&#x2F;blueocean，这是一个 Jenkins 的稳定及持续维护的镜像源，本身就集成了 Blue Ocean 等使用插件，非常方便。</p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><hr>
<p>docker pull jenkinsci&#x2F;blueocean</p>
<h4 id="运行-Jenkins"><a href="#运行-Jenkins" class="headerlink" title="运行 Jenkins"></a>运行 Jenkins</h4><hr>
<p>docker run -idt –name kmywjenkins -p 9090:8080 -p 60000:50000 -v jenkins-data:&#x2F;var&#x2F;jenkins_home -v &#x2F;data&#x2F;web-data&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock jenkinsci&#x2F;blueocean</p>
<h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><hr>
<ul>
<li>-idt 以交互的方式、新建一个模拟终端运行容器</li>
<li>–name 容器的别名</li>
<li>-p 指定容器映射宿主机的端口 -&gt; 宿主机端口:容器端口</li>
<li>-v jenkins-data:&#x2F;var&#x2F;jenkins_home Jenkins容器在工作的时候，如果要执行Docker的命令（例如 docker ps、docker run等），需要有个途径能连接到宿主机的docker服务，此参数就是用来建立容器和宿主机docker服务的连接的</li>
<li>-v &#x2F;data&#x2F;web-data&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock 将该容器的数据保留在宿主机的目录，这样即使容器崩溃了，里面的配置和任务都不会丢失</li>
</ul>
<p>需要注意的是，docker 中默认是以 Jenkins 用户运行的 Jenkins，如需以 root 用户可以加参数 -u root，本示例未指定 root。</p>
<h3 id="访问-Jenkins-Docker-容器"><a href="#访问-Jenkins-Docker-容器" class="headerlink" title="访问 Jenkins Docker 容器"></a>访问 Jenkins Docker 容器</h3><hr>
<p>有时候需要进入 Jenkins 容器执行一些命令，可以通过 docker exec 命令访问，例如：</p>
<p>docker exec -it [containerid] bash</p>
<p>若要手动重启 Jenkins，可以执行以下命令：</p>
<p>docker restart [containerid]</p>
<h3 id="Jenkins-基本配置"><a href="#Jenkins-基本配置" class="headerlink" title="Jenkins 基本配置"></a>Jenkins 基本配置</h3><hr>
<p>通过以上步骤，如果正常走到这里，可以通过以下地址访问<a href="http://xxx.xxx.xx.xx:9090/%EF%BC%8CIP">http://xxx.xxx.xx.xx:9090/，IP</a> 地址为服务器的地址。</p>
<h4 id="解锁-Jenkins"><a href="#解锁-Jenkins" class="headerlink" title="解锁 Jenkins"></a>解锁 Jenkins</h4><hr>
<p>输入一下命令获取解锁的 token，</p>
<p>docker exec kmywjenkins cat &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword</p>
<p>在浏览器中输入对应的 token 以解锁：</p>
<p><img src="https://img-blog.csdnimg.cn/fe1ff64ca51941808cde6d3d9a2777c0.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="创建凭据"><a href="#创建凭据" class="headerlink" title="创建凭据"></a>创建凭据</h4><hr>
<p>连接 git 仓库，ssh 连接服务器均需要相应的凭据，可以在凭据管理中先创建好，然后需要使用的地方直接选择凭据即可。这里以连接git、ssh需要的凭据为例：</p>
<p>我司用得版本管理工具是 gitte，以 gitte 为例，其它版本管理工具配置也一样<br>类型选择 Username with password，用户名密码为登录 gitte 的账号密码，ID 是凭据的唯一标识，可自定义，后面在 JenkinsFile 中通过 ID 去引用凭据。<br><img src="https://img-blog.csdnimg.cn/2908ed90404b4d1ca61ef40f0d83793c.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>SSH 连接服务器时需要密钥，我们先在服务器生成一对公私钥，然后复制私钥，填入即可。类型选择 SSH Username with private key，Username 是连接服务器的用户名，如 Jenkins 在 Private Key 项选中 Enter directly，点击 Add，粘贴刚复制的私钥。<br><img src="https://img-blog.csdnimg.cn/19916852a27e477098b254c96182cce1.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="创建一个多分支流水线"><a href="#创建一个多分支流水线" class="headerlink" title="创建一个多分支流水线"></a>创建一个多分支流水线</h3><hr>
<p>之前的 Jenkins 任务是 FreeStyle 的方式创建的，这种方式不够灵活，界面也不够清爽，这里选择使用声明式流水线方式（Declarative Pipeline）创建，可以多分支独立构建，便于以后的扩展。<br>我们这里使用 BlueOcean 这种方式来完成此处 CI&#x2F;CD 的工作，BlueOcean 是 Jenkins 团队从用户体验角度出发，专为 Jenkins Pipeline 重新设计的一套 UI 界面，仍然兼容以前的 fressstyle 类型的 job，BlueOcean 具有以下的一些特性：</p>
<ul>
<li>连续交付（CD）Pipeline 的复杂可视化，允许快速直观的了解 Pipeline 的状态</li>
<li>可以通过 Pipeline 编辑器直观的创建 Pipeline</li>
<li>需要干预或者出现问题时快速定位，BlueOcean 显示了 Pipeline 需要注意的地方，便于异常处理和提高生产力</li>
<li>用于分支和拉取请求的本地集成可以在 GitHub 或者 Bitbucket 中与其他人进行代码协作时最大限度提高开发人员的生产力。</li>
</ul>
<p>如果安装的是 Jenkinsci&#x2F;blueocean 镜像，默认是已经集成了 BlueOcean，没有的可前往插件管理安装对应的插件。</p>
<p><img src="https://img-blog.csdnimg.cn/22cc0b21e1674610b8041fdd978c27c3.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>点击打开Blue Ocean，可以看到已经创建好的两个流水线，分别是前端和后台，需要用到不同的工具，在后面会提到，如何创建流水线。<br><img src="https://img-blog.csdnimg.cn/979eed4392874fbe8c4452e7e3cacd31.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="点击创建流水线"><a href="#点击创建流水线" class="headerlink" title="点击创建流水线"></a>点击创建流水线</h3><hr>
<p>我司用的是gitte，所以选择Git，然后填入要连接的仓库地址，需要连接到Git仓库的凭据，我们之前已经创建好了，直接选中即可，如果未创建，在下面的表单直接编辑即可，最后点击创建流水线。<br><img src="https://img-blog.csdnimg.cn/7af1ba2855164d0299560afef390869b.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>到这里我们就创建了一个多分支流水线，Jenkins 会扫描仓库，带有 JenkinsFile 的分支会被检测出来，JenkinFile 是多分支流水线的配置文件，使用的是 Groovy 语法，可以直接点击创建流水线，Jenkins 会自动为你的项目创建一个 JenkinsFile。<br><img src="https://img-blog.csdnimg.cn/241936d5d2004a1f80ffc7604a31fbfe.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f783317778574180bd4be4ed18390135.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>现在可以可视化地编辑想要执行的阶段及步骤，这里加了一个打包的阶段，里面有个步骤是提示开始打包，点击保存。</p>
<p><img src="https://img-blog.csdnimg.cn/1e7064d2658f4e718032dc221540e7e9.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>填入提交信息，点击 Save &amp; Run，会讲 JenkinsFile 上传到 git，并根据 JenkinsFile 执行一个构建任务，目前的构建步骤只有一个，是提示开始打包。</p>
<p><img src="https://img-blog.csdnimg.cn/26b2c3ed1648489daf4177703d734ff0.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我这里不知道为什么会卡在这个地方不动，所以我在 vscode 直接创建并编辑 JenkinsFile，这种方式更灵活，我更推荐这种方式，下面我会先简单介绍下 JeninsFile 的基础语法，仅包含本项目用到的，对于中小企业的构建需求，基本够用了。</p>
<h3 id="JenkinsFile-基础语法"><a href="#JenkinsFile-基础语法" class="headerlink" title="JenkinsFile 基础语法"></a>JenkinsFile 基础语法</h3><hr>
<p>只需先了解大致的语法，具体的用法会在后面说明：</p>
<p>&#x2F;&#x2F; 前端项目JenkinsFile配置，后端项目配置稍有不同，后面会区分说明<br>pipeline {<br>  agent any<br>  environment {<br>    HOST_TEST &#x3D; ‘<a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#49;&#50;&#x31;&#46;&#x34;&#x31;&#46;&#x31;&#x36;&#46;&#x31;&#56;&#x33;">&#x72;&#111;&#111;&#116;&#64;&#49;&#50;&#x31;&#46;&#x34;&#x31;&#46;&#x31;&#x36;&#46;&#x31;&#56;&#x33;</a>‘<br>    HOST_ONLINE &#x3D; ‘<a href="mailto:&#106;&#101;&#110;&#107;&#105;&#110;&#115;&#x40;&#x33;&#x39;&#x2e;&#x31;&#48;&#49;&#x2e;&#50;&#x31;&#x39;&#46;&#x31;&#x31;&#x30;">&#106;&#101;&#110;&#107;&#105;&#110;&#115;&#x40;&#x33;&#x39;&#x2e;&#x31;&#48;&#49;&#x2e;&#50;&#x31;&#x39;&#46;&#x31;&#x31;&#x30;</a>‘<br>    SOURCE_DIR &#x3D; ‘dist&#x2F;*‘<br>    TARGET_DIR &#x3D; ‘&#x2F;data&#x2F;www&#x2F;kuaimen-yunying-front’<br>  }<br>  parameters {<br>    choice(<br>      description: ‘你需要选择哪个环境进行部署 ?’,<br>      name: ‘env’,<br>      choices: [‘测试环境’, ‘线上环境’]<br>    )<br>    string(name: ‘update’, defaultValue: ‘’, description: ‘本次更新内容?’)<br>  }<br>  triggers {<br>    GenericTrigger(<br>     genericVariables: [<br>      [key: ‘ref’, value: ‘$.ref’]<br>     ],<br>     causeString: ‘Triggered on $ref’,<br>     token: ‘runcenter-front-q1w2e3r4t5’,<br>     tokenCredentialId: ‘’,<br>     printContributedVariables: true,<br>     printPostContent: true,<br>     silentResponse: false,<br>     regexpFilterText: ‘$ref’,<br>     regexpFilterExpression: ‘refs&#x2F;heads&#x2F;‘ + BRANCH_NAME<br>    )<br>  }<br>  stages {<br>    stage(‘获取git commit message’) {<br>     steps {<br>       script {<br>         env.GIT_COMMIT_MSG &#x3D; sh (script: ‘git log -1 –pretty&#x3D;%B ${GIT_COMMIT}’, returnStdout: true).trim()<br>       }<br>     }<br>  }</p>
<pre><code>stage(&#39;打包&#39;) &#123;
  steps &#123;
    nodejs(&#39;nodejs-12.16&#39;) &#123;
      echo &#39;开始安装依赖&#39;
      sh &#39;yarn&#39;
      echo &#39;开始打包&#39;
      sh &#39;yarn run build&#39;
    &#125;
  &#125;
&#125;

stage(&#39;部署&#39;) &#123;
  when &#123;
    expression &#123;
      params.env == &#39;测试环境&#39;
    &#125;
  &#125;
  steps &#123;
    sshagent(credentials: \[&#39;km-test2&#39;\]) &#123;
      sh &quot;ssh -o StrictHostKeyChecking=no $&#123;HOST\_TEST&#125; uname -a&quot;
      sh &quot;scp -r $&#123;SOURCE\_DIR&#125; $&#123;HOST\_TEST&#125;:$&#123;TARGET\_DIR&#125;&quot;
      sh &#39;echo &quot;部署成功~&quot;&#39;
    &#125;
  &#125;
&#125;

stage(&#39;发布&#39;) &#123;
  when &#123;
    expression &#123;
      params.env == &#39;线上环境&#39;
    &#125;
  &#125;
  steps &#123;
    sshagent(credentials: \[&#39;km-online&#39;\]) &#123;
      sh &quot;ssh -o StrictHostKeyChecking=no $&#123;HOST\_ONLINE&#125; uname -a&quot;
      sh &quot;scp -r $&#123;SOURCE\_DIR&#125; $&#123;HOST\_ONLINE&#125;:$&#123;TARGET\_DIR&#125;&quot;
      sh &#39;echo &quot;发布成功~&quot;&#39;
    &#125;
  &#125;
&#125;
</code></pre>
<p>  }</p>
<p>  post {<br>    success {<br>      dingtalk (<br>        robot: ‘77d4c82d-3794-4583-bc7f-556902fee6b0’,<br>        type: ‘MARKDOWN’,<br>        atAll: true,<br>        title: ‘你有新的消息，请注意查收’,<br>        text:[<br>          ‘# 运营管理系统发布通知’,<br>          ‘—‘,<br>          ‘#### **所属：前端**‘,<br>          “#### **构建任务：${env.BUILD_DISPLAY_NAME}**“,<br>          “#### **Git commit：${env.GIT_COMMIT_MSG}**“,<br>          “#### **本次更新内容：${params.update}**“,<br>          “#### **部署环境：${params.env}**“,<br>          ‘#### **构建结果：成功**‘<br>        ]<br>      )<br>    }<br>  }<br>}</p>
<ul>
<li>pipeline 必须在最外层</li>
<li>agent 定义了在哪个环境里执行，默认any</li>
<li>stages 阶段，标识构建流程的标签块，子节点是stage</li>
<li>steps 执行步骤</li>
<li>post 所有阶段执行完成后执行一些逻辑</li>
<li>when 可以控制该阶段是否执行</li>
<li>environment 环境变量，在这里定义的变量，JenkinsFile的任何地方都可以访问</li>
<li>tools 项目使用到的构建工具，声明系统配置中已经定义好的工具，如maven</li>
<li>parameters 定义参数，可以提供用户输入或者选择</li>
<li>post 构建结束后会执行这里，有success、failure、success，本示例将在success（构建成功时）发起钉钉通知</li>
</ul>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>pipeline</tag>
        <tag>流水线</tag>
        <tag>Multibranch</tag>
        <tag>多分枝</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 kubeadm 搭建 Kubernetes 集群</title>
    <url>/2021/08/30/%E4%BD%BF%E7%94%A8-kubeadm-%E6%90%AD%E5%BB%BA-kubernetes-%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-27.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>虽然网上有大量从零搭建 K8S 的文章，但大都针对老版本，若直接照搬去安装最新的 1.20 版本会遇到一堆问题。故此将我的安装步骤记录下来，希望能为读者提供 copy and paste 式的集群搭建帮助。</p>
<h3 id="1-部署准备工作"><a href="#1-部署准备工作" class="headerlink" title="1. 部署准备工作"></a>1. 部署准备工作</h3><hr>
<p>部署最小化 K8S 集群：master + node1 + node2</p>
<p>Ubuntu 是一款基于 Debian Linux 的以桌面应用为主的操作系统，内容涵盖文字处理、电子邮件、软件开发工具和 Web 服务等，可供用户免费下载、使用和分享。</p>
<p>➜ vgs<br>Current machine states:<br>master                    running (virtualbox)<br>node1                     running (virtualbox)<br>node2                     running (virtualbox)</p>
<h4 id="1-1-基础环境信息"><a href="#1-1-基础环境信息" class="headerlink" title="1.1 基础环境信息"></a>1.1 基础环境信息</h4><hr>
<ul>
<li>设置系统主机名以及 Host 文件各节点之间的相互解析 <code>使用这个的 Vagrantfile 启动的三节点服务已经配置好了 以下使用 master 节点进行演示查看，其他节点操作均一致</code></li>
</ul>
<p># hostnamectl<br>vagrant@k8s-master:~$ hostnamectl<br>   Static hostname: k8s-master</p>
<h1 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h1><p>vagrant@k8s-master:~$ cat &#x2F;etc&#x2F;hosts<br>127.0.0.1        localhost<br>127.0.1.1        vagrant.vm    vagrant<br>192.168.30.30    k8s-master<br>192.168.30.31    k8s-node1<br>192.168.30.32    k8s-node2</p>
<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><p>vagrant@k8s-master:~$ ping k8s-node1<br>PING k8s-node1 (192.168.30.31) 56(84) bytes of data.<br>64 bytes from k8s-node1 (192.168.30.31): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.689 ms</p>
<h4 id="1-2-阿里源配置"><a href="#1-2-阿里源配置" class="headerlink" title="1.2 阿里源配置"></a>1.2 阿里源配置</h4><hr>
<ul>
<li>配置 Ubuntu 的阿里源来加速安装速度 <code>阿里源镜像地址</code></li>
</ul>
<p># 登录服务器<br>➜ vgssh master&#x2F;node1&#x2F;nod2<br>Welcome to Ubuntu 18.04.2 LTS (GNU&#x2F;Linux 4.15.0-50-generic x86_64)</p>
<h1 id="设置阿里云Ubuntu镜像"><a href="#设置阿里云Ubuntu镜像" class="headerlink" title="设置阿里云Ubuntu镜像"></a>设置阿里云Ubuntu镜像</h1><p>$ sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list{,.bak}<br>$ sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</p>
<h1 id="配置kubeadm的阿里云镜像源"><a href="#配置kubeadm的阿里云镜像源" class="headerlink" title="配置kubeadm的阿里云镜像源"></a>配置kubeadm的阿里云镜像源</h1><p>$ sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list<br>deb <a href="https://mirrors.aliyun.com/kubernetes/apt">https://mirrors.aliyun.com/kubernetes/apt</a> kubernetes-xenial main<br>$ sudo gpg –keyserver keyserver.ubuntu.com –recv-keys BA07F4FB<br>$ sudo gpg –export –armor BA07F4FB  sudo apt-key add -</p>
<h1 id="配置docker安装"><a href="#配置docker安装" class="headerlink" title="配置docker安装"></a>配置docker安装</h1><p>$ curl -fsSL <a href="https://download.docker.com/linux/ubuntu/gpg">https://download.docker.com/linux/ubuntu/gpg</a>  sudo apt-key add -<br>$ sudo apt-key fingerprint 0EBFCD88<br>$ sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list<br>deb [arch&#x3D;amd64] <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a> bionic stable</p>
<h1 id="更新仓库"><a href="#更新仓库" class="headerlink" title="更新仓库"></a>更新仓库</h1><p>$ sudo apt update<br>$ sudo apt dist-upgrade</p>
<h4 id="1-3-基础工具安装"><a href="#1-3-基础工具安装" class="headerlink" title="1.3 基础工具安装"></a>1.3 基础工具安装</h4><hr>
<ul>
<li>部署阶段的基础工具安装 <code>基础组件 docker 部署工具 kubeadm 路由规则 ipvsadm 时间同步 ntp</code></li>
</ul>
<p># 基础工具安装<br>$ sudo apt install -y \<br>    docker-ce docker-ce-cli containerd.io \<br>    kubeadm ipvsadm \<br>    ntp ntpdate \<br>    nginx supervisor</p>
<h1 id="将当前普通用户加入docker组-需重新登录"><a href="#将当前普通用户加入docker组-需重新登录" class="headerlink" title="将当前普通用户加入docker组(需重新登录)"></a>将当前普通用户加入docker组(需重新登录)</h1><p>$ sudo usermod -a -G docker $USER</p>
<h1 id="服务启用"><a href="#服务启用" class="headerlink" title="服务启用"></a>服务启用</h1><p>$ sudo systemctl enable docker.service<br>$ sudo systemctl start docker.service<br>$ sudo systemctl enable kubelet.service<br>$ sudo systemctl start kubelet.service</p>
<h4 id="1-4-操作系统配置"><a href="#1-4-操作系统配置" class="headerlink" title="1.4 操作系统配置"></a>1.4 操作系统配置</h4><hr>
<ul>
<li>操作系统相关配置 <code>关闭缓存 配置内核参数 调整系统时区 升级内核版本(默认为4.15.0的版本)</code></li>
</ul>
<p># 关闭缓存<br>$ sudo swapoff -a</p>
<h1 id="为K8S来调整内核参数"><a href="#为K8S来调整内核参数" class="headerlink" title="为K8S来调整内核参数"></a>为K8S来调整内核参数</h1><p>$ sudo touch &#x2F;etc&#x2F;sysctl.d&#x2F;kubernetes.conf<br>$ sudo cat &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;kubernetes.conf &lt;&lt;EOF<br>net.bridge.bridge-nf-call-iptables &#x3D; 1 # 开启网桥模式(必须)<br>net.bridge.bridge-nf-call-ip6tables &#x3D; 1 # 开启网桥模式(必须)<br>net.ipv6.conf.all.disable_ipv6 &#x3D; 1 # 关闭IPv6协议(必须)<br>net.ipv4.ip_forward &#x3D; 1 # 转发模式(默认开启)<br>vm.panic_on_oom&#x3D;0 # 开启OOM(默认开启)<br>vm.swappiness &#x3D; 0 # 禁止使用swap空间<br>vm.overcommit_memory&#x3D;1 # 不检查物理内存是否够用<br>fs.inotify.max_user_instances&#x3D;8192<br>fs.inotify.max_user_watches&#x3D;1048576<br>fs.file-max &#x3D; 52706963 # 设置文件句柄数量<br>fs.nr_open &#x3D; 52706963 # 设置文件的最大打开数量<br>net.netfilter.nf_conntrack_max &#x3D; 2310720<br>EOF</p>
<h1 id="查看系统内核参数的方式"><a href="#查看系统内核参数的方式" class="headerlink" title="查看系统内核参数的方式"></a>查看系统内核参数的方式</h1><p>$ sudo sysctl -a  grep xxx</p>
<h1 id="使内核参数配置文件生效"><a href="#使内核参数配置文件生效" class="headerlink" title="使内核参数配置文件生效"></a>使内核参数配置文件生效</h1><p>$ sudo sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;kubernetes.conf</p>
<h1 id="设置系统时区为中国-x2F-上海"><a href="#设置系统时区为中国-x2F-上海" class="headerlink" title="设置系统时区为中国&#x2F;上海"></a>设置系统时区为中国&#x2F;上海</h1><p>$ sudo timedatectl set-timezone Asia&#x2F;Shanghai</p>
<h1 id="将当前的UTC时间写入硬件时钟"><a href="#将当前的UTC时间写入硬件时钟" class="headerlink" title="将当前的UTC时间写入硬件时钟"></a>将当前的UTC时间写入硬件时钟</h1><p>$ sudo timedatectl set-local-rtc 0</p>
<h4 id="1-5-开启-ipvs-服务"><a href="#1-5-开启-ipvs-服务" class="headerlink" title="1.5 开启 ipvs 服务"></a>1.5 开启 ipvs 服务</h4><hr>
<ul>
<li>开启 ipvs 服务 <code>kube-proxy 开启 ipvs 的前置条件</code></li>
</ul>
<p># 载入指定的个别模块<br>$ modprobe br_netfilter</p>
<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><p>$ cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &lt;&lt;EOF<br>#!&#x2F;bin&#x2F;bash<br>modprobe – ip_vs<br>modprobe – ip_vs_rr<br>modprobe – ip_vs_wrr<br>modprobe – ip_vs_sh<br>modprobe – nf_conntrack_ipv<br>EOF</p>
<h1 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h1><p>$ chmod 755 &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules \<br>    &amp;&amp; bash &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules \<br>    &amp;&amp; lsmod  grep -e ip_vs -e nf_conntrack_ipv</p>
<h3 id="2-部署-Master-节点"><a href="#2-部署-Master-节点" class="headerlink" title="2. 部署 Master 节点"></a>2. 部署 Master 节点</h3><hr>
<p>节点最低配置: 2C+2G 内存；从节点资源尽量充足</p>
<p>kubeadm 工具的 init 命令，即可初始化以单节点部署的 master。为了避免翻墙，这里可以使用阿里云的谷歌源来代替。在执行 kubeadm 部署命令的时候，指定对应地址即可。当然，可以将其加入本地的镜像库之中，更易维护。</p>
<ul>
<li>注意事项 <code>阿里云谷歌源地址 使用 kubeadm 定制控制平面配置</code></li>
</ul>
<p># 登录服务器<br>➜ vgssh master<br>Welcome to Ubuntu 18.04.2 LTS (GNU&#x2F;Linux 4.15.0-50-generic x86_64)</p>
<h1 id="部署节点-命令行"><a href="#部署节点-命令行" class="headerlink" title="部署节点(命令行)"></a>部署节点(命令行)</h1><h1 id="注意pod和service的地址需要不同-否则会报错"><a href="#注意pod和service的地址需要不同-否则会报错" class="headerlink" title="注意pod和service的地址需要不同(否则会报错)"></a>注意pod和service的地址需要不同(否则会报错)</h1><p>$ sudo kubeadm init \<br>    –kubernetes-version&#x3D;1.20.2 \<br>    –image-repository registry.aliyuncs.com&#x2F;google_containers \<br>    –apiserver-advertise-address&#x3D;192.168.30.30 \<br>    –pod-network-cidr&#x3D;10.244.0.0&#x2F;16 \<br>    –service-cidr&#x3D;10.245.0.0&#x2F;16</p>
<h1 id="部署镜像配置-配置文件"><a href="#部署镜像配置-配置文件" class="headerlink" title="部署镜像配置(配置文件)"></a>部署镜像配置(配置文件)</h1><p>$ sudo kubeadm init –config .&#x2F;kubeadm-config.yaml<br>Your Kubernetes control-plane has initialized successfully!</p>
<h1 id="查看IP段是否生效-iptable"><a href="#查看IP段是否生效-iptable" class="headerlink" title="查看IP段是否生效(iptable)"></a>查看IP段是否生效(iptable)</h1><p>$ ip route show<br>10.244.0.0&#x2F;24 dev cni0 proto kernel scope link src 10.244.0.1<br>10.244.1.0&#x2F;24 via 10.244.1.0 dev flannel.1 onlink<br>10.244.2.0&#x2F;24 via 10.244.2.0 dev flannel.1 onlink</p>
<h1 id="查看IP段是否生效-ipvs"><a href="#查看IP段是否生效-ipvs" class="headerlink" title="# 查看IP段是否生效(ipvs)"></a># 查看IP段是否生效(ipvs)</h1><p>$ ipvsadm -L -n<br>IP Virtual Server version 1.2.1 (size&#x3D;4096)<br>Prot LocalAddress:Port Scheduler Flags<br>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</p>
<ul>
<li>配置文件定义 <code>接口使用了 v1beta2 版本 配置主节点 IP 地址为 192.168.30.30 为 flannel 分配的是 10.244.0.0/16 网段 选择的 kubernetes 是当前最新的 1.20.2 版本 加入了 controllerManager 的水平扩容功能</code></li>
</ul>
<p># kubeadm-config.yaml</p>
<h1 id="sudo-kubeadm-config-print-init-defaults-gt-kubeadm-config-yaml"><a href="#sudo-kubeadm-config-print-init-defaults-gt-kubeadm-config-yaml" class="headerlink" title="sudo kubeadm config print init-defaults &gt; kubeadm-config.yaml"></a>sudo kubeadm config print init-defaults &gt; kubeadm-config.yaml</h1><p>apiVersion: kubeadm.k8s.io&#x2F;v1beta2<br>imageRepository: registry.aliyuncs.com&#x2F;google_containers<br>kind: ClusterConfiguration<br>kubernetesVersion: v1.20.2<br>apiServer:<br>  extraArgs:<br>    advertise-address: 192.168.30.30<br>networking:<br>  podSubnet: 10.244.0.0&#x2F;16<br>controllerManager:<br>  ExtraArgs:<br>    horizontal-pod-autoscaler-use-rest-clients: “true”<br>    horizontal-pod-autoscaler-sync-period: “10s”<br>    node-monitor-grace-period: “10s”</p>
<ul>
<li>执行成功之后会输出如下信息，需要安装如下步骤操作下<strong>第一步</strong> 在 kubectl 默认控制和操作集群节点的时候，需要使用到 CA 的密钥，传输过程是通过 TLS 协议保障通讯的安全性。通过下面 3 行命令拷贝密钥信息到当前用户家目录下，这样 kubectl 执行时会首先访问 .kube 目录，使用这些授权信息访问集群。<strong>第二步</strong> 之后添加 worker 节点时，要通过 token 才能保障安全性。因此，先把显示的这行命令保存下来，以备后续使用会用到。</li>
</ul>
<p># master setting step one<br>To start cluster, you need to run the following as a regular user:<br>  mkdir -p $HOME&#x2F;.kube<br>  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config<br>  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</p>
<p>Alternatively, if you are the root user, you can run:<br>  export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf</p>
<h1 id="master-setting-step-two"><a href="#master-setting-step-two" class="headerlink" title="master setting step two"></a>master setting step two</h1><p>You should now deploy a pod network to the cluster.<br>Run “kubectl apply -f [podnetwork].yaml” with one of the options listed:<br>  <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p>
<p>Join any number of worker nodes by running the following on each as root:<br>kubeadm join 192.168.30.30:6443 \<br>  –token lebbdi.p9lzoy2a16tmr6hq \<br>  –discovery-token-ca-cert-hash \<br>  sha256:6c79fd83825d7b2b0c3bed9e10c428acf8ffcd615a1d7b258e9b500848c20cae</p>
<ul>
<li>将子节点加入主节点中</li>
</ul>
<p>$ kubectl get nodes<br>NAME         STATUS     ROLES                  AGE   VERSION<br>k8s-master   NotReady   control-plane,master   62m   v1.20.2<br>k8s-node1    NotReady   <none>                 82m   v1.20.2<br>k8s-node2    NotReady   <none>                 82m   v1.20.2</p>
<p># 查看token令牌<br>$ sudo kubeadm token list</p>
<h1 id="生成token令牌"><a href="#生成token令牌" class="headerlink" title="生成token令牌"></a>生成token令牌</h1><p>$ sudo kubeadm token create</p>
<h1 id="忘记sha编码"><a href="#忘记sha编码" class="headerlink" title="忘记sha编码"></a>忘记sha编码</h1><p>$ openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt \<br>     openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null \<br>     openssl dgst -sha256 -hex  sed ‘s&#x2F;^.* &#x2F;&#x2F;‘</p>
<p># 生成一个新的 token 令牌(比上面的方便)<br>$ kubeadm token generate</p>
<h1 id="直接生成-join-命令-比上面的方便"><a href="#直接生成-join-命令-比上面的方便" class="headerlink" title="直接生成 join 命令(比上面的方便)"></a>直接生成 join 命令(比上面的方便)</h1><p>$ kubeadm token create &lt;token_generate&gt; –print-join-command –ttl&#x3D;0</p>
<ul>
<li>执行完成之后可以通过如下命令，查看主节点信息</li>
</ul>
<ol>
<li>默认生成四个命名空间default、kube-system、kube-public、kube-node-lease</li>
<li>部署的核心服务有以下几个 (kube-system)coredns、etcdkube-apiserver、kube-schedulerkube-controller-manager、kube-controller-manager</li>
<li>此时 master 并没有 ready 状态(需要安装网络插件)，下一章节中，我们将安装 flannel 这个网络插件</li>
</ol>
<p># 命名空间<br>$ kubectl get namespace<br>NAME              STATUS   AGE<br>default           Active   19m<br>kube-node-lease   Active   19m<br>kube-public       Active   19m<br>kube-system       Active   19m</p>
<h1 id="核心服务"><a href="#核心服务" class="headerlink" title="核心服务"></a>核心服务</h1><p>$ kubectl get pod -n kube-system<br>NAME                                 READY   STATUS    RESTARTS   AGE<br>coredns-7f89b7bc75-bh42f             1&#x2F;1     Running   0          19m<br>coredns-7f89b7bc75-dvzpl             1&#x2F;1     Running   0          19m<br>etcd-k8s-master                      1&#x2F;1     Running   0          19m<br>kube-apiserver-k8s-master            1&#x2F;1     Running   0          19m<br>kube-controller-manager-k8s-master   1&#x2F;1     Running   0          19m<br>kube-proxy-5rlpv                     1&#x2F;1     Running   0          19m<br>kube-scheduler-k8s-master            1&#x2F;1     Running   0          19m</p>
<h3 id="3-部署-flannel-网络"><a href="#3-部署-flannel-网络" class="headerlink" title="3. 部署 flannel 网络"></a>3. 部署 flannel 网络</h3><hr>
<p>网络服务用于管理 K8S 集群中的服务网络</p>
<p>flannel 网络需要指定 IP 地址段，即上一步中通过编排文件设置的 10.244.0.0&#x2F;16。其实可以通过 flannel 官方和 HELM 工具直接部署服务，但是原地址是需要搭梯子的。所以，可以将其内容保存在如下配置文件中，修改对应镜像地址。</p>
<ul>
<li>部署 flannel 服务的官方下载地址</li>
</ul>
<p># 部署flannel服务</p>
<h1 id="1-修改镜像地址-如果下载不了的话"><a href="#1-修改镜像地址-如果下载不了的话" class="headerlink" title="1.修改镜像地址(如果下载不了的话)"></a>1.修改镜像地址(如果下载不了的话)</h1><h1 id="2-修改Network为–pod-network-cidr的参数IP段"><a href="#2-修改Network为–pod-network-cidr的参数IP段" class="headerlink" title="2.修改Network为–pod-network-cidr的参数IP段"></a>2.修改Network为–pod-network-cidr的参数IP段</h1><p>$ kubectl apply -f .&#x2F;kube-flannel.yml</p>
<h1 id="如果部署出现问题可通过如下命令查看日志"><a href="#如果部署出现问题可通过如下命令查看日志" class="headerlink" title="如果部署出现问题可通过如下命令查看日志"></a>如果部署出现问题可通过如下命令查看日志</h1><p>$ kubectl logs kube-flannel-ds-6xxs5 –namespace&#x3D;kube-system<br>$ kubectl describe pod kube-flannel-ds-6xxs5 –namespace&#x3D;kube-system</p>
<p><img src="https://img-blog.csdnimg.cn/1a4d8ce2511347d2884cd9fa5cdcf1ea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>如果使用当中存在问题的，可以参考官方的问题手册</li>
</ul>
<ol>
<li>因为我们这里使用的是 Vagrant 虚拟出来的机器进行 K8S 的部署，但是在运行对应 yaml 配置的时候，会报错。通过查看日志发现是因为默认绑定的是虚拟机上面的 eth0 这块网卡，而这块网卡是 Vagrant 使用的，我们应该绑定的是 eth1 才对。</li>
<li>Vagrant 通常为所有 VM 分配两个接口，第一个为所有主机分配的 IP 地址为 10.0.2.15，用于获得 NAT 的外部流量。这样会导致 flannel 部署存在问题。通过官方问题说明，我们可以使用 –iface&#x3D;eth1 这个参数选择第二个网卡。</li>
<li>对应的参数使用方式，可以参考 flannel use –iface&#x3D;eth1 中的回答自行添加，而这里我直接修改了启动的配置文件，在启动服务的时候通过 args 修改了，如下所示。</li>
</ol>
<p>$ kubectl get pods -n kube-system<br>NAME                                 READY   STATUS    RESTARTS   AGE<br>coredns-7f89b7bc75-bh42f             1&#x2F;1     Running   0          61m<br>coredns-7f89b7bc75-dvzpl             1&#x2F;1     Running   0          61m<br>etcd-k8s-master                      1&#x2F;1     Running   0          62m<br>kube-apiserver-k8s-master            1&#x2F;1     Running   0          62m<br>kube-controller-manager-k8s-master   1&#x2F;1     Running   0          62m<br>kube-flannel-ds-zl148                1&#x2F;1     Running   0          44s<br>kube-flannel-ds-ll523                1&#x2F;1     Running   0          44s<br>kube-flannel-ds-wpmhw                1&#x2F;1     Running   0          44s<br>kube-proxy-5rlpv                     1&#x2F;1     Running   0          61m<br>kube-scheduler-k8s-master            1&#x2F;1     Running   0          62m</p>
<ul>
<li>配置文件如下所示</li>
</ul>
<p>-–<br>apiVersion: policy&#x2F;v1beta1<br>kind: PodSecurityPolicy<br>metadata:<br>  name: psp.flannel.unprivileged<br>  annotations:<br>    seccomp.security.alpha.kubernetes.io&#x2F;allowedProfileNames: docker&#x2F;default<br>    seccomp.security.alpha.kubernetes.io&#x2F;defaultProfileName: docker&#x2F;default<br>    apparmor.security.beta.kubernetes.io&#x2F;allowedProfileNames: runtime&#x2F;default<br>    apparmor.security.beta.kubernetes.io&#x2F;defaultProfileName: runtime&#x2F;default<br>spec:<br>  privileged: false<br>  volumes:<br>    - configMap<br>    - secret<br>    - emptyDir<br>    - hostPath<br>  allowedHostPaths:<br>    - pathPrefix: “&#x2F;etc&#x2F;cni&#x2F;net.d”<br>    - pathPrefix: “&#x2F;etc&#x2F;kube-flannel”<br>    - pathPrefix: “&#x2F;run&#x2F;flannel”<br>  readOnlyRootFilesystem: false</p>
<h1 id="Users-and-groups"><a href="#Users-and-groups" class="headerlink" title="Users and groups"></a>Users and groups</h1><p>  runAsUser:<br>    rule: RunAsAny<br>  supplementalGroups:<br>    rule: RunAsAny<br>  fsGroup:<br>    rule: RunAsAny</p>
<h1 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h1><p>  allowPrivilegeEscalation: false<br>  defaultAllowPrivilegeEscalation: false</p>
<h1 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h1><p>  allowedCapabilities: [“NET_ADMIN”, “NET_RAW”]<br>  defaultAddCapabilities: []<br>  requiredDropCapabilities: []</p>
<h1 id="Host-namespaces"><a href="#Host-namespaces" class="headerlink" title="Host namespaces"></a>Host namespaces</h1><p>  hostPID: false<br>  hostIPC: false<br>  hostNetwork: true<br>  hostPorts:<br>    - min: 0<br>      max: 65535</p>
<h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1><p>  seLinux:<br>    # SELinux is unused in CaaSP<br>    rule: “RunAsAny”</p>
<hr>
<p>kind: ClusterRole<br>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>metadata:<br>  name: flannel<br>rules:</p>
<ul>
<li>apiGroups: [“extensions”]<br>resources: [“podsecuritypolicies”]<br>verbs: [“use”]<br>resourceNames: [“psp.flannel.unprivileged”]</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>pods<br>verbs:</li>
<li>get</li>
</ul>
</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>nodes<br>verbs:</li>
<li>list</li>
<li>watch</li>
</ul>
</li>
<li>apiGroups:<ul>
<li>“”<br>resources:</li>
<li>nodes&#x2F;status<br>verbs:</li>
<li>patch</li>
</ul>
</li>
</ul>
<hr>
<p>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>metadata:<br>  name: flannel<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: flannel<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: flannel<br>namespace: kube-system</li>
</ul>
<hr>
<p>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: flannel<br>  namespace: kube-system</p>
<hr>
<p>kind: ConfigMap<br>apiVersion: v1<br>metadata:<br>  name: kube-flannel-cfg<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>data:<br>  cni-conf.json:<br>    {<br>      “name”: “cbr0”,<br>      “cniVersion”: “0.3.1”,<br>      “plugins”: [<br>        {<br>          “type”: “flannel”,<br>          “delegate”: {<br>            “hairpinMode”: true,<br>            “isDefaultGateway”: true<br>          }<br>        },<br>        {<br>          “type”: “portmap”,<br>          “capabilities”: {<br>            “portMappings”: true<br>          }<br>        }<br>      ]<br>    }<br>  net-conf.json:<br>    {<br>      “Network”: “10.244.0.0&#x2F;16”,<br>      “Backend”: {<br>        “Type”: “vxlan”<br>      }<br>    }</p>
<hr>
<p>apiVersion: apps&#x2F;v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: kubernetes.io&#x2F;os<br>                    operator: In<br>                    values:<br>                      - linux<br>      hostNetwork: true<br>      priorityClassName: system-node-critical<br>      tolerations:<br>        - operator: Exists<br>          effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>        - name: install-cni<br>          image: quay.io&#x2F;coreos&#x2F;flannel:v0.13.1-rc1<br>          command:<br>            - cp<br>          args:<br>            - -f<br>            - &#x2F;etc&#x2F;kube-flannel&#x2F;cni-conf.json<br>            - &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-flannel.conflist<br>          volumeMounts:<br>            - name: cni<br>              mountPath: &#x2F;etc&#x2F;cni&#x2F;net.d<br>            - name: flannel-cfg<br>              mountPath: &#x2F;etc&#x2F;kube-flannel&#x2F;<br>      containers:<br>        - name: kube-flannel<br>          image: quay.io&#x2F;coreos&#x2F;flannel:v0.13.1-rc1<br>          command:<br>            - &#x2F;opt&#x2F;bin&#x2F;flanneld<br>          args:<br>            - –ip-masq<br>            - –kube-subnet-mgr<br>            - –iface&#x3D;eth1<br>          resources:<br>            requests:<br>              cpu: “100m”<br>              memory: “50Mi”<br>            limits:<br>              cpu: “100m”<br>              memory: “50Mi”<br>          securityContext:<br>            privileged: false<br>            capabilities:<br>              add: [“NET_ADMIN”, “NET_RAW”]<br>          env:<br>            - name: POD_NAME<br>              valueFrom:<br>                fieldRef:<br>                  fieldPath: metadata.name<br>            - name: POD_NAMESPACE<br>              valueFrom:<br>                fieldRef:<br>                  fieldPath: metadata.namespace<br>          volumeMounts:<br>            - name: run<br>              mountPath: &#x2F;run&#x2F;flannel<br>            - name: flannel-cfg<br>              mountPath: &#x2F;etc&#x2F;kube-flannel&#x2F;<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: &#x2F;run&#x2F;flannel<br>        - name: cni<br>          hostPath:<br>            path: &#x2F;etc&#x2F;cni&#x2F;net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg</p>
<p>至此集群部署成功！如果有参数错误需要修改，你也可以在 reset 后重新 init 集群。</p>
<p>$ kubectl get nodes<br>NAME         STATUS   ROLES                  AGE   VERSION<br>k8s-master   Ready    control-plane,master   62m   v1.20.2<br>k8s-node1    Ready    control-plane,master   82m   v1.20.2<br>k8s-node2    Ready    control-plane,master   82m   v1.20.2</p>
<h1 id="重启集群"><a href="#重启集群" class="headerlink" title="重启集群"></a>重启集群</h1><p>$ sudo kubeadm reset<br>$ sudo kubeadm init</p>
<h3 id="4-部署-dashboard-服务"><a href="#4-部署-dashboard-服务" class="headerlink" title="4. 部署 dashboard 服务"></a>4. 部署 dashboard 服务</h3><hr>
<p>以 WEB 页面的可视化 dashboard 来监控集群的状态</p>
<p>这个还是会遇到需要搭梯子下载启动配置文件的问题，下面是对应的下载地址，可以下载之后上传到服务器上面在进行部署。</p>
<ul>
<li>部署 dashboard 服务的官方下载地址</li>
</ul>
<p># 部署flannel服务<br>$ kubectl apply -f .&#x2F;kube-dashboard.yaml</p>
<h1 id="如果部署出现问题可通过如下命令查看日志-1"><a href="#如果部署出现问题可通过如下命令查看日志-1" class="headerlink" title="如果部署出现问题可通过如下命令查看日志"></a>如果部署出现问题可通过如下命令查看日志</h1><p>$ kubectl logs \<br>    kubernetes-dashboard-c9fb67ffc-nknpj \<br>    –namespace&#x3D;kubernetes-dashboard<br>$ kubectl describe pod \<br>    kubernetes-dashboard-c9fb67ffc-nknpj \<br>    –namespace&#x3D;kubernetes-dashboard</p>
<p>$ kubectl get svc -n kubernetes-dashboard<br>NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE<br>dashboard-metrics-scraper   ClusterIP   10.245.214.11    <none>        8000&#x2F;TCP   26s<br>kubernetes-dashboard        ClusterIP   10.245.161.146   <none>        443&#x2F;TCP    26s</p>
<p>需要注意的是 dashboard 默认不允许外网访问，即使通过 kubectl proxy 允许外网访问。但 dashboard 又只允许 HTTPS 访问，这样 kubeadm init 时自签名的 CA 证书是不被浏览器承认的。</p>
<p>我采用的方案是 Nginx 作为反向代理，使用 Lets Encrypt 提供的有效证书对外提供服务，再经由 proxy_pass 指令反向代理到 kubectl proxy 上，如下所示。此时，本地可经由 8888 访问到 dashboard 服务，再通过 Nginx 访问它。</p>
<p># 代理(可以使用supervisor)<br>$ kubectl proxy –accept-hosts&#x3D;’^*$’<br>$ kubectl proxy –port&#x3D;8888 –accept-hosts&#x3D;’^*$’</p>
<h1 id="测试代理是否正常-默认监听在8001端口上"><a href="#测试代理是否正常-默认监听在8001端口上" class="headerlink" title="测试代理是否正常(默认监听在8001端口上)"></a>测试代理是否正常(默认监听在8001端口上)</h1><p>$ curl -X GET -L <a href="http://localhost:8001/">http://localhost:8001</a></p>
<h1 id="本地-可以使用nginx"><a href="#本地-可以使用nginx" class="headerlink" title="本地(可以使用nginx)"></a>本地(可以使用nginx)</h1><p>proxy_pass <a href="http://localhost:8001/">http://localhost:8001</a>;<br>proxy_pass <a href="http://localhost:8888/">http://localhost:8888</a>;</p>
<h1 id="外网访问如下URL地址"><a href="#外网访问如下URL地址" class="headerlink" title="外网访问如下URL地址"></a>外网访问如下URL地址</h1><p><a href="https://mydomain/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login">https://mydomain/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login</a></p>
<ul>
<li>配置文件整理</li>
</ul>
<ol>
<li>nginx</li>
<li>supervisor</li>
</ol>
<p># k8s.conf</p>
<p>client_max_body_size     80M;<br>client_body_buffer_size  128k;<br>proxy_connect_timeout    600;<br>proxy_read_timeout       600;<br>proxy_send_timeout       600;</p>
<p>server {<br>    listen       8080 ssl;<br>    server_name  _;</p>
<pre><code>ssl\_certificate     /etc/kubernetes/pki/ca.crt;
ssl\_certificate\_key /etc/kubernetes/pki/ca.key;

access\_log /var/log/nginx/k8s.access.log;
error\_log  /var/log/nginx/k8s.error.log  error;

location / &#123;
    proxy\_set\_header   X-Forwarded-Proto $scheme;
    proxy\_set\_header   Host              $http\_host;
    proxy\_set\_header   X-Real-IP         $remote\_addr;
    proxy\_pass http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/;
&#125;
</code></pre>
<p>}</p>
<p># k8s.conf</p>
<p>[program:k8s-master]<br>command&#x3D;kubectl proxy –accept-hosts&#x3D;’^*$’<br>user&#x3D;vagrant<br>environment&#x3D;KUBECONFIG&#x3D;”&#x2F;home&#x2F;vagrant&#x2F;.kube&#x2F;config”<br>stopasgroup&#x3D;true<br>stopasgroup&#x3D;true<br>autostart&#x3D;true<br>autorestart&#x3D;unexpected<br>stdout_logfile_maxbytes&#x3D;1MB<br>stdout_logfile_backups&#x3D;10<br>stderr_logfile_maxbytes&#x3D;1MB<br>stderr_logfile_backups&#x3D;10<br>stderr_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;k8s-stderr.log<br>stdout_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;k8s-stdout.log</p>
<ul>
<li>配置文件如下所示</li>
</ul>
<p># Copyright 2017 The Kubernetes Authors.<br>#</p>
<h1 id="Licensed-under-the-Apache-License-Version-2-0-the-“License”"><a href="#Licensed-under-the-Apache-License-Version-2-0-the-“License”" class="headerlink" title="Licensed under the Apache License, Version 2.0 (the “License”);"></a>Licensed under the Apache License, Version 2.0 (the “License”);</h1><h1 id="you-may-not-use-this-file-except-in-compliance-with-the-License"><a href="#you-may-not-use-this-file-except-in-compliance-with-the-License" class="headerlink" title="you may not use this file except in compliance with the License."></a>you may not use this file except in compliance with the License.</h1><h1 id="You-may-obtain-a-copy-of-the-License-at"><a href="#You-may-obtain-a-copy-of-the-License-at" class="headerlink" title="You may obtain a copy of the License at"></a>You may obtain a copy of the License at</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="http-www-apache-org-licenses-LICENSE-2-0"><a href="#http-www-apache-org-licenses-LICENSE-2-0" class="headerlink" title="http://www.apache.org/licenses/LICENSE-2.0"></a><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="Unless-required-by-applicable-law-or-agreed-to-in-writing-software"><a href="#Unless-required-by-applicable-law-or-agreed-to-in-writing-software" class="headerlink" title="Unless required by applicable law or agreed to in writing, software"></a>Unless required by applicable law or agreed to in writing, software</h1><h1 id="distributed-under-the-License-is-distributed-on-an-“AS-IS”-BASIS"><a href="#distributed-under-the-License-is-distributed-on-an-“AS-IS”-BASIS" class="headerlink" title="distributed under the License is distributed on an “AS IS” BASIS,"></a>distributed under the License is distributed on an “AS IS” BASIS,</h1><h1 id="WITHOUT-WARRANTIES-OR-CONDITIONS-OF-ANY-KIND-either-express-or-implied"><a href="#WITHOUT-WARRANTIES-OR-CONDITIONS-OF-ANY-KIND-either-express-or-implied" class="headerlink" title="WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."></a>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</h1><h1 id="See-the-License-for-the-specific-language-governing-permissions-and"><a href="#See-the-License-for-the-specific-language-governing-permissions-and" class="headerlink" title="See the License for the specific language governing permissions and"></a>See the License for the specific language governing permissions and</h1><h1 id="limitations-under-the-License"><a href="#limitations-under-the-License" class="headerlink" title="limitations under the License."></a>limitations under the License.</h1><p>apiVersion: v1<br>kind: Namespace<br>metadata:<br>  name: kubernetes-dashboard</p>
<hr>
<p>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard</p>
<hr>
<p>kind: Service<br>apiVersion: v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>spec:<br>  ports:<br>    - port: 443<br>      targetPort: 8443<br>  selector:<br>    k8s-app: kubernetes-dashboard</p>
<hr>
<p>apiVersion: v1<br>kind: Secret<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard-certs<br>  namespace: kubernetes-dashboard<br>type: Opaque</p>
<hr>
<p>apiVersion: v1<br>kind: Secret<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard-csrf<br>  namespace: kubernetes-dashboard<br>type: Opaque<br>data:<br>  csrf: “”</p>
<hr>
<p>apiVersion: v1<br>kind: Secret<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard-key-holder<br>  namespace: kubernetes-dashboard<br>type: Opaque</p>
<hr>
<p>kind: ConfigMap<br>apiVersion: v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard-settings<br>  namespace: kubernetes-dashboard</p>
<hr>
<p>kind: Role<br>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>rules:</p>
<h1 id="Allow-Dashboard-to-get-update-and-delete-Dashboard-exclusive-secrets"><a href="#Allow-Dashboard-to-get-update-and-delete-Dashboard-exclusive-secrets" class="headerlink" title="Allow Dashboard to get, update and delete Dashboard exclusive secrets."></a>Allow Dashboard to get, update and delete Dashboard exclusive secrets.</h1><ul>
<li>apiGroups: [“”]<br>resources: [“secrets”]<br>resourceNames:<br>  [<br>“kubernetes-dashboard-key-holder”,<br>“kubernetes-dashboard-certs”,<br>“kubernetes-dashboard-csrf”,<br>  ]<br>verbs: [“get”, “update”, “delete”]<h1 id="Allow-Dashboard-to-get-and-update-‘kubernetes-dashboard-settings’-config-map"><a href="#Allow-Dashboard-to-get-and-update-‘kubernetes-dashboard-settings’-config-map" class="headerlink" title="Allow Dashboard to get and update ‘kubernetes-dashboard-settings’ config map."></a>Allow Dashboard to get and update ‘kubernetes-dashboard-settings’ config map.</h1></li>
<li>apiGroups: [“”]<br>resources: [“configmaps”]<br>resourceNames: [“kubernetes-dashboard-settings”]<br>verbs: [“get”, “update”]<h1 id="Allow-Dashboard-to-get-metrics"><a href="#Allow-Dashboard-to-get-metrics" class="headerlink" title="Allow Dashboard to get metrics."></a>Allow Dashboard to get metrics.</h1></li>
<li>apiGroups: [“”]<br>resources: [“services”]<br>resourceNames: [“heapster”, “dashboard-metrics-scraper”]<br>verbs: [“proxy”]</li>
<li>apiGroups: [“”]<br>resources: [“services&#x2F;proxy”]<br>resourceNames:<br>  [<br>“heapster”,<br>“http:heapster:”,<br>“https:heapster:”,<br>“dashboard-metrics-scraper”,<br>“http:dashboard-metrics-scraper”,<br>  ]<br>verbs: [“get”]</li>
</ul>
<hr>
<p>kind: ClusterRole<br>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>rules:</p>
<h1 id="Allow-Metrics-Scraper-to-get-metrics-from-the-Metrics-server"><a href="#Allow-Metrics-Scraper-to-get-metrics-from-the-Metrics-server" class="headerlink" title="Allow Metrics Scraper to get metrics from the Metrics server"></a>Allow Metrics Scraper to get metrics from the Metrics server</h1><ul>
<li>apiGroups: [“metrics.k8s.io”]<br>resources: [“pods”, “nodes”]<br>verbs: [“get”, “list”, “watch”]</li>
</ul>
<hr>
<p>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>kind: RoleBinding<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: Role<br>  name: kubernetes-dashboard<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: kubernetes-dashboard<br>namespace: kubernetes-dashboard</li>
</ul>
<hr>
<p>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: kubernetes-dashboard<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: kubernetes-dashboard<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: kubernetes-dashboard<br>namespace: kubernetes-dashboard</li>
</ul>
<hr>
<p>kind: Deployment<br>apiVersion: apps&#x2F;v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>spec:<br>  replicas: 1<br>  revisionHistoryLimit: 10<br>  selector:<br>    matchLabels:<br>      k8s-app: kubernetes-dashboard<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: kubernetes-dashboard<br>    spec:<br>      containers:<br>        - name: kubernetes-dashboard<br>          image: registry.cn-shanghai.aliyuncs.com&#x2F;jieee&#x2F;dashboard:v2.0.4<br>          imagePullPolicy: Always<br>          ports:<br>            - containerPort: 8443<br>              protocol: TCP<br>          args:<br>            - –auto-generate-certificates<br>            - –namespace&#x3D;kubernetes-dashboard<br>            # Uncomment the following line to manually specify Kubernetes API server Host<br>            # If not specified, Dashboard will attempt to auto discover the API server and connect<br>            # to it. Uncomment only if the default does not work.<br>            # - –apiserver-host&#x3D;<a href="http://my-address:port">http://my-address:port</a><br>          volumeMounts:<br>            - name: kubernetes-dashboard-certs<br>              mountPath: &#x2F;certs<br>              # Create on-disk volume to store exec logs<br>            - mountPath: &#x2F;tmp<br>              name: tmp-volume<br>          livenessProbe:<br>            httpGet:<br>              scheme: HTTPS<br>              path: &#x2F;<br>              port: 8443<br>            initialDelaySeconds: 30<br>            timeoutSeconds: 30<br>          securityContext:<br>            allowPrivilegeEscalation: false<br>            readOnlyRootFilesystem: true<br>            runAsUser: 1001<br>            runAsGroup: 2001<br>      volumes:<br>        - name: kubernetes-dashboard-certs<br>          secret:<br>            secretName: kubernetes-dashboard-certs<br>        - name: tmp-volume<br>          emptyDir: {}<br>      serviceAccountName: kubernetes-dashboard<br>      nodeSelector:<br>        “kubernetes.io&#x2F;os”: linux<br>      # Comment the following tolerations if Dashboard must not be deployed on master<br>      tolerations:<br>        - key: node-role.kubernetes.io&#x2F;master<br>          effect: NoSchedule</p>
<hr>
<p>kind: Service<br>apiVersion: v1<br>metadata:<br>  labels:<br>    k8s-app: dashboard-metrics-scraper<br>  name: dashboard-metrics-scraper<br>  namespace: kubernetes-dashboard<br>spec:<br>  ports:<br>    - port: 8000<br>      targetPort: 8000<br>  selector:<br>    k8s-app: dashboard-metrics-scraper</p>
<hr>
<p>kind: Deployment<br>apiVersion: apps&#x2F;v1<br>metadata:<br>  labels:<br>    k8s-app: dashboard-metrics-scraper<br>  name: dashboard-metrics-scraper<br>  namespace: kubernetes-dashboard<br>spec:<br>  replicas: 1<br>  revisionHistoryLimit: 10<br>  selector:<br>    matchLabels:<br>      k8s-app: dashboard-metrics-scraper<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: dashboard-metrics-scraper<br>      annotations:<br>        seccomp.security.alpha.kubernetes.io&#x2F;pod: “runtime&#x2F;default”<br>    spec:<br>      containers:<br>        - name: dashboard-metrics-scraper<br>          image: registry.cn-shanghai.aliyuncs.com&#x2F;jieee&#x2F;metrics-scraper:v1.0.4<br>          ports:<br>            - containerPort: 8000<br>              protocol: TCP<br>          livenessProbe:<br>            httpGet:<br>              scheme: HTTP<br>              path: &#x2F;<br>              port: 8000<br>            initialDelaySeconds: 30<br>            timeoutSeconds: 30<br>          volumeMounts:<br>            - mountPath: &#x2F;tmp<br>              name: tmp-volume<br>          securityContext:<br>            allowPrivilegeEscalation: false<br>            readOnlyRootFilesystem: true<br>            runAsUser: 1001<br>            runAsGroup: 2001<br>      serviceAccountName: kubernetes-dashboard<br>      nodeSelector:<br>        “kubernetes.io&#x2F;os”: linux<br>      # Comment the following tolerations if Dashboard must not be deployed on master<br>      tolerations:<br>        - key: node-role.kubernetes.io&#x2F;master<br>          effect: NoSchedule<br>      volumes:<br>        - name: tmp-volume<br>          emptyDir: {}</p>
<ul>
<li>第一种：登录 dashboard 的方式(配置文件)</li>
</ul>
<ol>
<li>采用 token 方式</li>
<li>采用秘钥文件方式</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/1fea07e66dd44b78abd19981cf450082.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p># 创建管理员帐户(dashboard)<br>$ cat &lt;&lt;EOF  kubectl apply -f -<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: admin-user<br>  namespace: kubernetes-dashboard<br>EOF</p>
<p># 将用户绑定已经存在的集群管理员角色<br>$ cat &lt;&lt;EOF  kubectl apply -f -<br>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: admin-user<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: cluster-admin<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: admin-user<br>namespace: kubernetes-dashboard<br>EOF</li>
</ul>
<p># 获取可用户于访问的token令牌<br>$ kubectl -n kubernetes-dashboard describe secret \<br>    $(kubectl -n kubernetes-dashboard get secret \<br>     grep admin-user  awk ‘{print $1}’)</p>
<ul>
<li>登录界面展示</li>
</ul>
<ol>
<li>针对 Chrome 浏览器，在空白处点击然后输入：thisisunsafe</li>
<li>针对 Firefox 浏览器，遇到证书过期，添加例外访问</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/4c384caff52e4561bcf0c2c4433abc7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>第二种：授权 dashboard 权限(不适用配置文件)</li>
</ul>
<ol>
<li>如果登录之后提示权限问题的话，可以执行如下操作</li>
<li>把 serviceaccount 绑定在 clusteradmin</li>
<li>授权 serviceaccount 用户具有整个集群的访问管理权限</li>
</ol>
<p># 创建serviceaccount<br>$ kubectl create serviceaccount dashboard-admin -n kube-system</p>
<h1 id="把serviceaccount绑定在clusteradmin"><a href="#把serviceaccount绑定在clusteradmin" class="headerlink" title="把serviceaccount绑定在clusteradmin"></a>把serviceaccount绑定在clusteradmin</h1><h1 id="授权serviceaccount用户具有整个集群的访问管理权限"><a href="#授权serviceaccount用户具有整个集群的访问管理权限" class="headerlink" title="授权serviceaccount用户具有整个集群的访问管理权限"></a>授权serviceaccount用户具有整个集群的访问管理权限</h1><p>$ kubectl create clusterrolebinding \<br>    dashboard-cluster-admin –clusterrole&#x3D;cluster-admin \<br>    –serviceaccount&#x3D;kube-system:dashboard-admin</p>
<h1 id="获取serviceaccount的secret信息，可得到token令牌的信息"><a href="#获取serviceaccount的secret信息，可得到token令牌的信息" class="headerlink" title="获取serviceaccount的secret信息，可得到token令牌的信息"></a>获取serviceaccount的secret信息，可得到token令牌的信息</h1><p>$ kubectl get secret -n kube-system</p>
<h1 id="通过上边命令获取到dashboard-admin-token-slfcr信息"><a href="#通过上边命令获取到dashboard-admin-token-slfcr信息" class="headerlink" title="通过上边命令获取到dashboard-admin-token-slfcr信息"></a>通过上边命令获取到dashboard-admin-token-slfcr信息</h1><p>$ kubectl describe secret <dashboard-admin-token-slfcr> -n kube-system</p>
<h1 id="浏览器访问登录并把token粘贴进去登录即可"><a href="#浏览器访问登录并把token粘贴进去登录即可" class="headerlink" title="浏览器访问登录并把token粘贴进去登录即可"></a>浏览器访问登录并把token粘贴进去登录即可</h1><p><a href="https://192.168.30.30:8080/">https://192.168.30.30:8080/</a></p>
<h1 id="快捷查看token的命令"><a href="#快捷查看token的命令" class="headerlink" title="快捷查看token的命令"></a>快捷查看token的命令</h1><p>$ kubectl describe secrets -n kube-system \<br>    $(kubectl -n kube-system get secret  awk ‘&#x2F;admin&#x2F;{print $1}’)</p>
<h3 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h3><ul>
<li>十分钟搭建好 K8S 集群</li>
<li>基于阿里云 ubuntu 的 k8s-1.8.2 环境搭建</li>
<li>从零开始在 ubuntu 上安装和使用 k8s 集群及报错解决</li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubeadm</tag>
        <tag>kubernets</tag>
        <tag>k8s集群</tag>
        <tag>集群搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>使用openresty的lua-resty-upload实现文件上传</title>
    <url>/2021/06/27/%E4%BD%BF%E7%94%A8openresty%E7%9A%84lua-resty-upload%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-64.png"></p>
<h3 id="服务端：使用openresty的lua-resty-upload模块来实现文件上传"><a href="#服务端：使用openresty的lua-resty-upload模块来实现文件上传" class="headerlink" title="服务端：使用openresty的lua-resty-upload模块来实现文件上传"></a>服务端：使用openresty的lua-resty-upload模块来实现文件上传</h3><p>接受前端的上传请求，将处理好的文件保存起来</p>
<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li>文件存储路径</li>
<li>指定上传逻辑代码路径</li>
</ol>
<p>在nginx上添加一个server</p>
<p>#上传文件服务<br>server<br>     {<br>        listen   19999;<br>        set $store_dir “&#x2F;data&#x2F;vue&#x2F;fffoa&#x2F;“; # 文件存储路径<br>        location &#x2F;upfile {<br>            content_by_lua_file conf&#x2F;lua&#x2F;upload.lua; # 实现文件上传的逻辑<br>        }<br>        location &#x2F;download {<br>            autoindex on;<br>            autoindex_localtime on;<br>            alias   &#x2F;data&#x2F;vue&#x2F;fffoa&#x2F;;<br>            index  index.html;<br>        }<br>    access_log  logs&#x2F;uploadfile_access.log  main;<br>    error_log  logs&#x2F;uploadfile_error.log crit;<br>  }</p>
<h3 id="实现上传逻辑代码-conf-lua-upload-lua"><a href="#实现上传逻辑代码-conf-lua-upload-lua" class="headerlink" title="实现上传逻辑代码 conf/lua/upload.lua"></a>实现上传逻辑代码 <code>conf/lua/upload.lua</code></h3><p>注意：我使用的是openresty，可以直接引用resty.upload等lua库，如果你是nginx，还需要找到upload.lua、cjson库</p>
<p>-- upload.lua<br>–&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>– 文件上传<br>–&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>local upload &#x3D; require “resty.upload”<br>local cjson &#x3D; require “cjson”<br>local chunk_size &#x3D; 4096<br>local form, err &#x3D; upload:new(chunk_size)<br>if not form then<br>    ngx.log(ngx.ERR, “failed to new upload: “, err)<br>    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)<br>end<br>form:set_timeout(1000)<br>– 字符串 split 分割<br>string.split &#x3D; function(s, p)<br>    local rt&#x3D; {}<br>    string.gsub(s, ‘[^’..p..’]+’, function(w) table.insert(rt, w) end )<br>    return rt<br>end<br>– 支持字符串前后 trim<br>string.trim &#x3D; function(s)<br>    return (s:gsub(“^%s*(.-)%s*$”, “%1”))<br>end<br>– 文件保存的根路径<br>local saveRootPath &#x3D; ngx.var.store_dir<br>– 保存的文件对象<br>local fileToSave<br>–文件是否成功保存<br>local ret_save &#x3D; false<br>while true do<br>    local typ, res, err &#x3D; form:read()<br>    if not typ then<br>        ngx.say(“failed to read: “, err)<br>        return<br>    end<br>    if typ &#x3D;&#x3D; “header” then<br>        – 开始读取 http header<br>        – 解析出本次上传的文件名<br>        local key &#x3D; res[1]<br>        local value &#x3D; res[2]<br>        if key &#x3D;&#x3D; “Content-Disposition” then<br>            – 解析出本次上传的文件名<br>            – form-data; name&#x3D;”testFileName”; filename&#x3D;”testfile.txt”<br>            local kvlist &#x3D; string.split(value, ‘;’)<br>            for _, kv in ipairs(kvlist) do<br>                local seg &#x3D; string.trim(kv)<br>                if seg:find(“filename”) then<br>                    local kvfile &#x3D; string.split(seg, “&#x3D;”)<br>                    local filename &#x3D; string.sub(kvfile[2], 2, -2)<br>                    if filename then<br>                        fileToSave &#x3D; io.open(saveRootPath .. filename, “w+”)<br>                        if not fileToSave then<br>                            ngx.say(“failed to open file “, filename)<br>                            return<br>                        end<br>                        break<br>                    end<br>                end<br>            end<br>        end<br>    elseif typ &#x3D;&#x3D; “body” then<br>        – 开始读取 http body<br>        if fileToSave then<br>            fileToSave:write(res)<br>        end<br>    elseif typ &#x3D;&#x3D; “part_end” then<br>        – 文件写结束，关闭文件<br>        if fileToSave then<br>            fileToSave:close()<br>            fileToSave &#x3D; nil<br>        end</p>
<pre><code>    ret\_save = true
elseif typ == &quot;eof&quot; then
    -- 文件读取结束
    break
else
    ngx.log(ngx.INFO, &quot;do other things&quot;)
end
</code></pre>
<p>end<br>if ret_save then<br>    ngx.say(“save file ok”)<br>end</p>
<h3 id="测试上传文件"><a href="#测试上传文件" class="headerlink" title="测试上传文件"></a>测试上传文件</h3><p>在postman里面写上 地址:19999&#x2F;upload&#x2F;<br>配置好文件，选发送，上传成功显示 save file ok</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-62.png"></p>
<h3 id="查看服务器内容"><a href="#查看服务器内容" class="headerlink" title="查看服务器内容"></a>查看服务器内容</h3><p><img src="https://code404.icu/img/moveypu/2021/06/image-63.png"></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>Openresty</tag>
        <tag>lua-resty-upload</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python如何给图片加水印？</title>
    <url>/2021/09/14/%E4%BD%BF%E7%94%A8python%E5%A6%82%E4%BD%95%E7%BB%99%E5%9B%BE%E7%89%87%E5%8A%A0%E6%B0%B4%E5%8D%B0%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-12.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>人生苦短，快学Python！<br>版权相当重要，对于某张图片，可能是你精心制作的思维导图，或者你精心设计的某个logo。你可能花费好多时间来弄，最后却被别人直接搬运过去使用，好气哦！</p>
<p>基于此，本文我就带着大家学学如何给你的图片加水印，仅需要2行Python代码，任何人都可以学会。</p>
<h3 id="filestools库介绍"><a href="#filestools库介绍" class="headerlink" title="filestools库介绍"></a>filestools库介绍</h3><hr>
<p>今天给大家介绍的Python库，叫做filestools，由小小明开发，直接使用如下命令，安装后使用。</p>
<p>pip install filestools –index-url&#x3D;<a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a> -U</p>
<p>这个库一共集成了4个功能，4个库都已经全部迁移到了filestools库中，因此安装这一个库，就可以使用所有的4个功能了，你只需要在使用对应功能，分别导入对应的模块即可。</p>
<p># 给图片加水印<br>from watermarker.marker import add_mark</p>
<p>add_mark()方法一共有8个参数，如果你不知道怎么查看参数，在jupyter notebook可以输入如下命令，即可查看。<br><img src="https://img-blog.csdnimg.cn/aee9c91cd0db4572b612c4be39258910.png" alt="在这里插入图片描述"></p>
<p>下面分别为大家讲述add_mark()方法中8个参数的含义，介绍如下 ：</p>
<ul>
<li>file： 待添加水印的照片；</li>
<li>mark： 使用哪些字作为水印；</li>
<li>out： 添加水印后保存的位置；</li>
<li>color： 水印字体的颜色，默认颜色#8B8B1B；</li>
<li>size： 水印字体的大小，默认50；</li>
<li>opacity： 水印字体的透明度，默认0.15；</li>
<li>space： 水印字体之间的间隔, 默认75个空格；</li>
<li>angle： 水印字体的旋转角度，默认30度；接下来，我们仅用一行代码，给图片添加水印。</li>
</ul>
<h3 id="一行代码给图片加水印"><a href="#一行代码给图片加水印" class="headerlink" title="一行代码给图片加水印"></a>一行代码给图片加水印</h3><hr>
<p>原图长这样：<br><img src="https://img-blog.csdnimg.cn/d319196194414f5b8c80528a0012d668.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>使用下面这行代码，仅仅两行代码：</p>
<p>from watermarker.marker import add_mark<br>add_mark(file&#x3D;r”aixin.jpg”, out&#x3D;r”C:\Users\Administrator\Desktop\练习”, mark&#x3D;”人生苦短，快学Python”, opacity&#x3D;0.2, angle&#x3D;45, space&#x3D;30)</p>
<p>加水印后长这样：<br><img src="https://img-blog.csdnimg.cn/1838080f2ab94dd78d7fa8bbb703ebc5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>最后再为大家解释一下，这一行代码的含义。</p>
<p>add_mark(file&#x3D;r”code404.jpg”,<br>out&#x3D;r”C:\Users\Administrator\Desktop\练习”,<br>mark&#x3D;”人生苦短，快学Python”,<br>opacity&#x3D;0.2, angle&#x3D;45, space&#x3D;30)</p>
<p>含义： 给当前工作环境下名为code404.jpg的图片，添加一张水印。水印字样为快学Python，水印透明度是0.2，水印的旋转角度是45°，水印之间的间隔是30个空格。添加水印后，最后将处理后的图片保存在一个指定目录下。</p>
<p>如果你想详细学习filestools库，参考下方网站：</p>
<p><a href="https://pypi.org/project/filestools/">https://pypi.org/project/filestools/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>filestools</tag>
        <tag>水印</tag>
        <tag>添加</tag>
      </tags>
  </entry>
  <entry>
    <title>使用reGeorg+Proxifier进行内网穿透_内网渗透教程</title>
    <url>/2021/08/20/%E4%BD%BF%E7%94%A8regeorgproxifier%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-17.png"></p>
<h3 id="reGeorg-Proxifier代理工具介绍"><a href="#reGeorg-Proxifier代理工具介绍" class="headerlink" title="reGeorg+Proxifier代理工具介绍"></a>reGeorg+Proxifier代理工具介绍</h3><hr>
<h3 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h3><p>reGeorg是reDuh的继承者，利用了会话层的socks5协议，主要功能是把内网服务器端口的数据通过的数据通过HTTP&#x2F;HTTPS隧道转发到本机，实现基于HTTP协议的通信。reGeorg的出现，方便了安全测试代理进入内网，现在使用reGeorg和Proxifier，在安全测试过程中，可以利用他们的组合完成从外网到内网的通信，reGeog支持ASPX、PHP、JSP等web脚本，并特别提供一个Tomcat5版本。</p>
<h3 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h3><p>Proxifier 是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。提供了跨平台的端口转发和代理功能，适用于windows、linux、macOS，支持socks4，socks5，http代理协议，支持TCP，UDP协议。</p>
<h3 id="提供两个工具的下载地址"><a href="#提供两个工具的下载地址" class="headerlink" title="提供两个工具的下载地址"></a>提供两个工具的下载地址</h3><p>reGeorg：<a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a><br>Proxifier：<a href="https://www.filehorse.com/download-proxifier/">https://www.filehorse.com/download-proxifier/</a></p>
<p><img src="https://img-blog.csdnimg.cn/e3320d7dd0a44b06881d0157e76fc479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="实战环境"><a href="#实战环境" class="headerlink" title="实战环境"></a>实战环境</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/2c4a2dcd869c4804a2ba6c13257a1c09.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>攻击机：Windows10

 IP地址：192.168.92.11

 靶机：Windows Server 2008
 域名：www.xxxx.com
 内网IP：10.130.1.20
 靶机内网存在多个服务器网段：
    10.130.1.0/16
    10.131.10.0/16
    10.133.3.0/24
    10.128.1.0/24 
</code></pre>
<p>通过该靶机后台存在文件上传漏洞，我们成功将脚本上传到服务器，访问脚本路径，显示以下页面则表示脚本上传成功且可正常使用。</p>
<p><img src="https://img-blog.csdnimg.cn/d8ee672e95ba46c089a7fd63cee112c0.png" alt="在这里插入图片描述"></p>
<p>访问成功后我们在攻击机上使用Python2环境执行以下命令：</p>
<p>python reGeorgSocksProxy.py -p 9999 -u <a href="http://www.xxxx.com/tunnel.nosocket.php">http://www.xxxx.com/tunnel.nosocket.php</a><br><img src="https://img-blog.csdnimg.cn/72305a9138a546f5acb004feb3115bc6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>攻击机利用proxifier在本地配置代理服务器，端口即上述命令开启的监听端口，配置如图：</p>
<p><img src="https://img-blog.csdnimg.cn/e555fd5a23204903ad9c576e48ff2f26.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="实战渗透"><a href="#实战渗透" class="headerlink" title="实战渗透"></a>实战渗透</h3><hr>
<p>将如上工作配置好以后我们就可以直接在本地对靶机内网进行渗透了！例如我们直接远程登录到靶机，打开mstsc，输入靶机内网地址10.130.1.20。</p>
<p><img src="https://img-blog.csdnimg.cn/01d7c64f199942f6a5363e0306e6edea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/5a9e11fb90df47e8bc2be3687f5f031f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来我们就可以进行内网渗透啦</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>运维</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>Proxifier</tag>
        <tag>reGeorg</tag>
        <tag>内网渗透</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Swagger如何自动生成Jmeter脚本?</title>
    <url>/2021/08/22/%E4%BD%BF%E7%94%A8swagger%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90jmeter%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-19-1024x324.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>我们熟知的，Jmeter可以自身录制脚本，还可以Fiddler录制生成Jmeter脚本，不管是Jmeter本身的录制还是Fiddler录制，都需要耗费较长的时间。今天我们介绍更简便的方法，swagger通过OpenAPI Generator自动生成Jmeter脚本。</p>
<h3 id="环境准备说明"><a href="#环境准备说明" class="headerlink" title="环境准备说明"></a>环境准备说明</h3><hr>
<p>① win10<br>② swagger文档<br>③ OpenAPI Generator jar包<br>④ jmeter工具</p>
<h3 id="OpenAPI-Generator-jar包"><a href="#OpenAPI-Generator-jar包" class="headerlink" title="OpenAPI Generator jar包"></a>OpenAPI Generator jar包</h3><hr>
<p>链接: <a href="https://pan.baidu.com/s/1tj5G99/_aCbRc8FKRNrP8vg">https://pan.baidu.com/s/1tj5G99\_aCbRc8FKRNrP8vg</a><br>提取码: 3ugu</p>
<h3 id="swagger文档生成json文件"><a href="#swagger文档生成json文件" class="headerlink" title="swagger文档生成json文件"></a>swagger文档生成json文件</h3><hr>
<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。官方传送门：</p>
<p><a href="https://swagger.io/">https://swagger.io/</a></p>
<p>① 准备一份swagger接口文档。公司的或者自己练习项目使用的swagger接口都可以。为了方便大家边看文章边练习，这里附上官方提供的swagger地址：</p>
<p><a href="https://petstore.swagger.io/">https://petstore.swagger.io</a></p>
<p>如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/11d5e72954044570b9ec8b4c8be4d947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>② 点击页面圈出的链接，跳转到swagger.json页面。<br><img src="https://img-blog.csdnimg.cn/12ffb2ed4867485f800ea3092c6a526b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>③ swagger.json页面，快捷键ctrl+s，保存到本地。<br>保存为json文件到指定目录即可<br><img src="https://img-blog.csdnimg.cn/108e73f38cc549bea1815ea24f7fc2dc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="OpenAPI-Generator下载及生成jmeter脚本"><a href="#OpenAPI-Generator下载及生成jmeter脚本" class="headerlink" title="OpenAPI Generator下载及生成jmeter脚本"></a>OpenAPI Generator下载及生成jmeter脚本</h3><hr>
<p>OpenAPI Generator 可用于在给定 OpenAPI 规范（v2, v3）的情况下自动生成 API 客户端库、server stubs、文档以及配置。</p>
<p>① 下载OpenAPI Generator jar包，下载传送门：</p>
<p><a href="https://openapi-generator.tech/docs/installation/#jar">https://openapi-generator.tech/docs/installation/#jar</a></p>
<p>根据自己的操作系统选择下载即可。</p>
<p><img src="https://img-blog.csdnimg.cn/a4f997fb95bd4b63b2107ce862c0c717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>② 下载完成后，将openapi-generator-cli-5.1.0.jar和之前保存到本地的swagger.json文件放到同一目录下。</p>
<p><img src="https://img-blog.csdnimg.cn/d94d26e4566049499cba291dcdf39a1c.png" alt="在这里插入图片描述"></p>
<p>③ 接下来就要生成jmeter脚本了。切换到存放openapi-generator-cli-5.1.0.jar及swagger.json目录下，执行命令：</p>
<p>java -jar openapi-generator-cli-5.1.0.jar generate -i swagger.json -g jmeter</p>
<p>如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/e4f0297fdc0b45cba075cf3446aa16b6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>当然，能够成功执行命令的前提是，已经安装、配置jdk、jmeter。</p>
<p>④ 命令执行成功后，在目录下会生成csv、jmx等文件。<br><img src="https://img-blog.csdnimg.cn/dea0b44846764e4fb4dcb52468756d50.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Jmeter导入自动生成的jmx脚本"><a href="#Jmeter导入自动生成的jmx脚本" class="headerlink" title="Jmeter导入自动生成的jmx脚本"></a>Jmeter导入自动生成的jmx脚本</h3><hr>
<p>① 打开Jmeter程序。<br>② Jmeter菜单栏，依次选择File–&gt;Open。<br>③ 选择UserApi.jmx，导入到jmeter。</p>
<p><img src="https://img-blog.csdnimg.cn/81890c4338924f27a7b33ca8a05e19e7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>④ 我们可以发现，接口的相关数据已经填充了。</p>
<p><img src="https://img-blog.csdnimg.cn/649932a97bae497993e49b30132c38d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>当然，自动生成的不代表可以一键执行成功，还是需要我们调试、增强脚本。没有一个工具是完美的，所以在工作中无论是手动编写脚本、还是各种工具录制脚本，需根据我们实际情况来定。</p>
]]></content>
      <categories>
        <category>Jmeter</category>
        <category>测试</category>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
        <tag>Jmeter脚本</tag>
        <tag>自动生成</tag>
      </tags>
  </entry>
  <entry>
    <title>使用秘钥登录linux服务器</title>
    <url>/2021/12/10/%E4%BD%BF%E7%94%A8%E7%A7%98%E9%92%A5%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-6.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>有时候我们希望不用每次登录linux服务器都要输入密码，那么这个时候可以选择ssh密钥登录，就是rsa公钥放到服务器上，私钥放在客户端上，每次登录的时候，用密钥登录；这样更方便也更安全</p>
<h3 id="两台主机-服务器-秘钥登录流程图"><a href="#两台主机-服务器-秘钥登录流程图" class="headerlink" title="两台主机(服务器)秘钥登录流程图"></a>两台主机(服务器)秘钥登录流程图</h3><hr>
<p>我们从A主机(左边)秘钥登录到B服务器(右边)<br><img src="https://img-blog.csdnimg.cn/5d5c7e5ddc22411e86799c6843981825.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p>
<h3 id="A主机生成公钥"><a href="#A主机生成公钥" class="headerlink" title="A主机生成公钥"></a>A主机生成公钥</h3><hr>
<p>生成公钥私钥，一般不需要特殊设置一路回车默认下一步即可</p>
<p>&gt; ssh-keygen<br>Generating public&#x2F;private rsa key pair.<br>Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.<br>Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub.<br>The key fingerprint is:<br>SHA256:+ims1qKnA9kAUbwuaGmGLdg+V4w1PMj7RO4gMHI7NCU root@JD<br>The key’s randomart image is:<br>+—[RSA 2048]—-+<br>.+.<br>. E .<br>.  &#x3D; o<br>&#x3D; &#x3D; o *<br>&#x3D;%.o B oS<br>O&#x3D;O + &#x3D;.<br>+&#x3D; o O.          </p>
<ul>
<li>&#x3D; *. .<br>  oO.o .o</li>
</ul>
<p>+—-[SHA256]—–+</p>
<h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><hr>
<p>&gt; ls -al ~&#x2F;.ssh<br>-rw——-   1 root root  1675 May  7 21:39 id_rsa &#x2F;&#x2F;私钥<br>-rw-r–r–   1 root root   389 May  7 21:39 id_rsa.pub &#x2F;&#x2F;公钥</p>
<blockquote>
<p>cat id_rsa.pub<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDULg8kwT2rW8Z&#x2F;r0h5lvO6KziZWV1roM&#x2F;0eKVnkxeKOF9A0JAL46WF4ZA2XsNfG2camxTekC0ZwArB6uvFQTR8RZtDCwdsdsdsds6K3ytR&#x2F;FOzira6z+7xbk6LvPylaCLfjfMmta04Q7dsdsdsdsdsds5MDr7oY73TWt2XToDA3FynMnl9MQjO4SoTU&#x2F;Z1PiKsdOoCnbeP&#x2F;O6KL+6sh9tbd5HoPPLm8LtDCeebZNhvZSulsbeTFZ5Z+HzPLostXJVhRFtiwUlaemAhXngVdIB5D9feXCYdQiP3NM0zAI94XUFCFyaSnZdv3+OTqHmxJ root@local</p>
</blockquote>
<h3 id="id-rsa-pub公钥要发送到B服务器"><a href="#id-rsa-pub公钥要发送到B服务器" class="headerlink" title="id_rsa.pub公钥要发送到B服务器"></a>id_rsa.pub公钥要发送到B服务器</h3><hr>
<p>B服务器添加A主机的公钥<br>在B服务器对应登录账号的家目录下的.ssh&#x2F;authorized_keys文件添加A主机的公钥<br>比如我们要使用code404账号进行秘钥登录,就是配置&#x2F;home&#x2F;code404&#x2F;.ssh&#x2F;authorized_keys</p>
<p>&gt; cat &#x2F;home&#x2F;code404&#x2F;.ssh&#x2F;authorized_keys<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDULg8kwT2rW8Z&#x2F;r0h5lvO6KziZWV1roM&#x2F;0eKVnkxeKOF9A0JAL46WF4ZA2XsNfG2camxTekC0ZwArB6uvFQTR8RZtDCwdsdsdsds6K3ytR&#x2F;FOzira6z+7xbk6LvPylaCLfjfMmta04Q7dsdsdsdsdsds5MDr7oY73TWt2XToDA3FynMnl9MQjO4SoTU&#x2F;Z1PiKsdOoCnbeP&#x2F;O6KL+6sh9tbd5HoPPLm8LtDCeebZNhvZSulsbeTFZ5Z+HzPLostXJVhRFtiwUlaemAhXngVdIB5D9feXCYdQiP3NM0zAI94XUFCFyaSnZdv3+OTqHmxJ root@local</p>
<h3 id="给公钥及目录添加权限"><a href="#给公钥及目录添加权限" class="headerlink" title="给公钥及目录添加权限"></a>给公钥及目录添加权限</h3><hr>
<p>&gt; chmod 600 &#x2F;home&#x2F;code404&#x2F;.ssh&#x2F;authorized_keys</p>
<blockquote>
<p>chmod 700 &#x2F;home&#x2F;code404&#x2F;.ssh</p>
</blockquote>
<h3 id="sshd服务安全配置-开启秘钥登录"><a href="#sshd服务安全配置-开启秘钥登录" class="headerlink" title="sshd服务安全配置 开启秘钥登录"></a>sshd服务安全配置 开启秘钥登录</h3><hr>
<p>&gt; vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>RSAAuthentication yes<br>PubkeyAuthentication yes</p>
<h3 id="重启sshd服务"><a href="#重启sshd服务" class="headerlink" title="重启sshd服务"></a>重启sshd服务</h3><hr>
<p>密钥方式登录成功后，再禁用密码登录<br>一定要秘钥登录成功后,再禁用密码登录。</p>
<p>&gt; service sshd restart</p>
<blockquote>
<p>vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PasswordAuthentication no</p>
</blockquote>
<blockquote>
<p>service sshd restart</p>
</blockquote>
<h3 id="秘钥登录测试-A主机的命令行输入"><a href="#秘钥登录测试-A主机的命令行输入" class="headerlink" title="秘钥登录测试 A主机的命令行输入"></a>秘钥登录测试 A主机的命令行输入</h3><hr>
<p>&gt; ssh code404@B服务器ip<br>Last login: Tue Mar 11 11:23:22 2021</p>
]]></content>
      <categories>
        <category>运维监控</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>证书</tag>
        <tag>SSh</tag>
        <tag>密钥登录</tag>
        <tag>禁用密码</tag>
      </tags>
  </entry>
  <entry>
    <title>内存OOM排查神器分析工具之mat(MemoryAnalyzer)使用手册</title>
    <url>/2021/09/22/%E5%86%85%E5%AD%98oom%E6%8E%92%E6%9F%A5%E7%A5%9E%E5%99%A8%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B9%8Bmatmemoryanalyzer%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-19.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>大家都知道，在存储用户输入的密码时候，会使用一些hash算法对密码进行加工，比如sha-1、bcrypt。这些信息同样不允许在日志输出里出现，必须做脱敏处理。但是对于一个拥有系统权限的攻击者来说，这些防护依然是不够的。攻击者可能会直接从内存中获取明文数据，尤其对于Java来说，由于提供了jmap一类非常方便的工具，可以把整个堆内存的数据dump下来。比如，“我的世界”一类使用Java开发的游戏，会比其他语言的游戏更加容易破解一些，所以我们在JVM中，如果把密码存储为char数组，安全性会稍微高一些。</p>
<p>这是一把双刃剑，在保证安全的前提下，我们也可以借助一些外部的分析工具，帮助我们方便的找到问题根本。</p>
<p>可以有两种方式来获取内存的快照。我们前面提到，通过配置一些参数，可以在发生OOM的时候，被动dump一份堆栈信息，这是一种。另一种，就是通过jmap主动去获取内存的快照。</p>
<p>jmap命令在Java9之后，使用jhsdb命令替代，它们在用法上，区别不大。注意，这些命令本身会占用操作系统的资源，在某些情况下会造成服务响应缓慢，所以不要频繁执行。</p>
<p>jmap -dump:format&#x3D;b,file&#x3D;heap.bin 37340<br>jhsdb jmap  –binaryheap –pid  37340</p>
<h3 id="1、工具介绍"><a href="#1、工具介绍" class="headerlink" title="1、工具介绍"></a>1、工具介绍</h3><hr>
<p>专业的事情要有专业的工具来做，今天给大家介绍的是一款专业的开源分析工具，叫做MAT。</p>
<p><a href="https://www.eclipse.org/mat/MAT%E5%B7%A5%E5%85%B7%E6%98%AF%E5%9F%BA%E4%BA%8Eeclipse%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%EF%BC%8C%E6%9C%AC%E8%BA%AB%E6%98%AF%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E5%A0%86%E5%BF%AB%E7%85%A7%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E4%B8%80%E5%8F%B0%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E5%88%86%E6%9E%90%E6%9C%BA%E5%99%A8%EF%BC%8C%E5%B9%B6%E7%BB%99MAT%E6%9C%AC%E8%BA%AB%E5%8A%A0%E5%A4%A7%E5%88%9D%E5%A7%8B%E5%86%85%E5%AD%98%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84MemoryAnalyzer.ini%E6%96%87%E4%BB%B6%E3%80%82">https://www.eclipse.org/mat/MAT工具是基于eclipse平台开发的，本身是一个Java程序，所以如果你的堆快照比较大的话，就需要一台内存比较大的分析机器，并给MAT本身加大初始内存，这个可以修改安装目录中的MemoryAnalyzer.ini文件。</a></p>
<p>可以看一下MAT工具的截图，主要功能都体现在工具栏上。其中，默认的启动界面，展示了占用内存最高的一些对象，并有一些常用的快捷方式。通常，发生内存泄漏的对象，会在快照中占用比较大的比重，分析这些比较大的对象，是我们切入问题的第一步。<br><img src="https://img-blog.csdnimg.cn/34fc067d16fc40938531ae17be2001db.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点击对象，可以浏览对象的引用关系。这是一个非常有用的功能。</p>
<ul>
<li>outgoing references 对象的引出。</li>
<li>incoming references 对象的引入。</li>
<li>path to GC Roots 这是快速分析的一个常用功能，显示和GC Roots之间的路径。<br><img src="https://img-blog.csdnimg.cn/6b246221923b4d79991944985e1d035d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>另外一个比较重要的概念，就是浅堆（Shallow Heap）和深堆（Retained Heap），在MAT上经常看到这两个数值。<br><img src="https://img-blog.csdnimg.cn/7af543e2de754db7b2dcf6ff2524b394.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>浅堆代表了对象本身的内存占用。包括对象自身的内存占用，以及“为了引用”其他对象所占用的内存。</li>
</ul>
<p>深堆是一个统计结果，会循环计算引用的具体对象所占用的内存。但是深堆和“对象大小”有一点不同，深堆指的是一个对象被垃圾回收后，能够释放的内存大小，这些被释放的对象集合，叫做保留集（Retained Set）。<br><img src="https://img-blog.csdnimg.cn/99e26fd1e55441468cec3ac431e7aecc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如上图，A对象浅堆大小1KB，B对象2KB，C对象100KB。A对象同时引用了B对象和C对象，但由于C对象也被D引用，所以A对象的深堆大小为3KB（1KB+2KB）。</p>
<p>A对象大小（1KB+2KB+100KB）&gt; A对象深堆 &gt; A对象浅堆。</p>
<h3 id="2、内存泄漏检测"><a href="#2、内存泄漏检测" class="headerlink" title="2、内存泄漏检测"></a>2、内存泄漏检测</h3><hr>
<p>如果问题特别突出，可以通过Find Leaks菜单快速找出问题。<br><img src="https://img-blog.csdnimg.cn/f2edc35dbe6d45a09f98c6bc4a087ee9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如图，展示了名称叫做huge-thread的线程，持有了超过96%的对象，数据被一个HashMap所持有。</p>
<p><img src="https://img-blog.csdnimg.cn/0c296fcc65e24bf593659bf40c943ca1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对于特别明显的内存泄漏，在这里能够帮助我们迅速定位，但通常内存泄漏问题会比较隐蔽，我们需要更加复杂的分析。</p>
<h3 id="3、支配树视图"><a href="#3、支配树视图" class="headerlink" title="3、支配树视图"></a>3、支配树视图</h3><hr>
<p>支配树视图对数据进行了归类，体现了对象之间的依赖关系。如图，我们通常会根据“深堆”进行倒序排序，可以很容易的看到占用内存比较高的几个对象。点击前面的箭头，即可一层层展开支配关系。</p>
<p>图中显示的是其中的1MB数据，从左侧的inspector视图，可以看到这1MB的byte数组具体内容。<br><img src="https://img-blog.csdnimg.cn/ddaf038d27c142c2ac2d6ef270819519.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>从支配树视图同样能够找到我们创建的两个循环依赖。但它们并没有显示这个过程。</p>
<p><img src="https://img-blog.csdnimg.cn/0b316c45c3c648efb229da52b73259c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>支配树视图的概念有一点点复杂，我们只需要了解这个概念即可。</p>
<p><img src="https://img-blog.csdnimg.cn/f08d9f4b4fa94c15aa43f9e7a797de32.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如上图，左边是引用关系，右边是支配树视图。可以看到A、B、C被当作是“虚拟”的根。支配关系是可传递的，因为C支配E，E支配G，所以C也支配G。</p>
<p>另外，到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。同理，对象E是H的支配者。</p>
<p>我们再来看比较特殊的D和F。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。</p>
<p>可以看到支配树视图并不一定总是能看到对象的真实应用关系，但对我们分析问题的影响并不是很大。</p>
<p>这个视图是非常好用的，甚至可以根据package进行归类，对目标类的查找是非常快捷的。<br><img src="https://img-blog.csdnimg.cn/0253cd69932346a6879aa4f757aff9fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>编译下面这段代码，可以展开视图，实际观测一下支配树，这和我们上面介绍的是一致的。</p>
<p>public class DorminatorTreeDemo {<br>    static class A {<br>        C c;</p>
<pre><code>    byte\[\] data = new byte\[1024 \* 1024 \* 2\];
&#125;

static class B &#123;
    C c;
    byte\[\] data = new byte\[1024 \* 1024 \* 3\];
&#125;

static class C &#123;
    D d;
    E e;
    byte\[\] data = new byte\[1024 \* 1024 \* 5\];
&#125;

static class D &#123;
    F f;
    byte\[\] data = new byte\[1024 \* 1024 \* 7\];
&#125;

static class E &#123;
    G g;
    byte\[\] data = new byte\[1024 \* 1024 \* 11\];
&#125;

static class F &#123;
    D d;
    H h;
    byte\[\] data = new byte\[1024 \* 1024 \* 13\];
&#125;

static class G &#123;
    H h;
    byte\[\] data = new byte\[1024 \* 1024 \* 17\];
&#125;

static class H &#123;
    byte\[\] data = new byte\[1024 \* 1024 \* 19\];
&#125;

A makeRef(A a, B b) &#123;
    C c = new C();
    D d = new D();
    E e = new E();
    F f = new F();
    G g = new G();
    H h = new H();
    a.c = c;
    b.c = c;
    c.e = e;
    c.d = d;
    d.f = f;
    e.g = g;
    f.d = d;
    f.h = h;
    g.h = h;
    return a;
&#125;

static A a = new A();
static B b = new B();

public static void main(String\[\] args) throws Exception &#123;

    new DorminatorTreeDemo().makeRef(a, b);

    Thread.sleep(Integer.MAX\_VALUE);
&#125;
</code></pre>
<p>}</p>
<p><img src="https://img-blog.csdnimg.cn/556c66b1f81c4cc6bf1750915243013f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="4、线程视图"><a href="#4、线程视图" class="headerlink" title="4、线程视图"></a>4、线程视图</h3><hr>
<p>想要看具体的引用关系，可以通过线程视图。我们在第5小节，就了解到线程其实是可以作为GC Roots的。如图展示了线程内对象的引用关系，以及方法调用关系，相对比jstack获取的栈dump，我们能够更加清晰的看到内存中具体的数据。</p>
<p>如下图，我们找到了huge-thread，依次展开找到holder对象，可以看到循环依赖已经陷入了无限循环的状态。这在查看一些Java对象的时候，经常发生，不要感到奇怪。<br><img src="https://img-blog.csdnimg.cn/5eaa8d4359304bffb3207ea9844afaf2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="5、柱状图视图"><a href="#5、柱状图视图" class="headerlink" title="5、柱状图视图"></a>5、柱状图视图</h3><hr>
<p>我们返回头来再看一下柱状图视图，可以看到除了对象的大小，还有类的实例个数。结合MAT提供的不同显示方式，往往能够直接定位问题。也可以通过正则可以过滤一些信息，我们在这里输入MAT，过滤猜测的、可能出现问题的类。可以看到我们创建的这些自定义对象，不多不少正好一百个。<br><img src="https://img-blog.csdnimg.cn/6bb96eac592c453b92bd7f2798981c8a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>右键点击类，然后选择incoming，这会列出所有的引用关系。</p>
<p><img src="https://img-blog.csdnimg.cn/4f6546989cfa4c0b8c73be98abd62299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>再次选择某个引用关系，然后选择菜单“Path To GC Roots”，即可显示到GC Roots的全路径。通常在排查内存泄漏的时候，会选择排除虚弱软等引用。</p>
<p><img src="https://img-blog.csdnimg.cn/835615ac0d8a46578789938e13c15938.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/29c0ec151029413e919473572031c6b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>使用这种方式，即可在引用之间进行跳转，方便的找到所需要的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/748e0f1e410048f3b959023a338f77f7.png" alt="在这里插入图片描述"></p>
<p>再给大家介绍一个比较高级的功能。</p>
<p>我们对于堆的快照，其实是一个“瞬时态”，有时候仅仅分析这个瞬时状态，并不一定能确定问题，这就需要对两个或者多个快照进行对比，来确定一个增长趋势。</p>
<p><img src="https://img-blog.csdnimg.cn/72398c7e91e2485286d168bb87494d33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以将代码中的100改成10或其他数字，再次dump一份快照进行比较。如图，通过分析某类对象的增长，即可辅助问题定位。</p>
<h3 id="6、高级功能-OQL"><a href="#6、高级功能-OQL" class="headerlink" title="6、高级功能-OQL"></a>6、高级功能-OQL</h3><hr>
<p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language），这个查询语言VisualVM工具也支持。<br><img src="https://img-blog.csdnimg.cn/c8e638f70a8145d5b927be8b79ee57b0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>以下是几个例子，大家可以实际实践一下。</p>
<p>查询A4MAT对象。</p>
<p>SELECT * FROM  Objects4MAT$A4MAT </p>
<p>正则查询MAT结尾的对象。</p>
<p>SELECT * FROM “.*MAT” </p>
<p>查询String类的char数组。</p>
<p>SELECT OBJECTS s.value FROM java.lang.String s<br>SELECT OBJECTS mat.b4MAT FROM  Objects4MAT$A4MAT mat</p>
<p>根据内存地址查找对象。</p>
<p>select * from 0x55a034c8 </p>
<p>使用INSTANCEOF关键字，查找所有子类。</p>
<p>SELECT * FROM INSTANCEOF java.util.AbstractCollection </p>
<p>查询长度大于1000的byte数组。</p>
<p>SELECT * FROM byte[] s WHERE s.@length&gt;1000</p>
<p>查询包含java字样的所有字符串。</p>
<p>SELECT * FROM java.lang.String s WHERE toString(s) LIKE “.*java.*“ </p>
<p>查找所有深堆大小大于1万的对象。</p>
<p>SELECT * FROM INSTANCEOF java.lang.Object o WHERE o.@retainedHeapSize&gt;10000</p>
<p>如果你忘记这些属性的名称的话，MAT是可以自动补全的。<br><img src="https://img-blog.csdnimg.cn/26e417fb528c4bb68ebfb7d681da5321.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>OQL有比较多的语法和用法，深入可以参考</p>
<p><a href="http://tech.novosoft-us.com/products/oql/_book.htm">http://tech.novosoft-us.com/products/oql\_book.htm</a><br>一般，我们使用上面这些简单的查询语句就够用了。</p>
<p>OQL还有一个好处，就是可以分享。如果你和同事同时在分析一个大堆，你不必告诉他先点哪一步，再点哪一步，共享给他一个OQL语句就可以了。</p>
<p>如下图，MAT贴心的提供了复制OQL的功能，但是用在其他快照上，不会起作用，因为它复制的是如下的内容。<br><img src="https://img-blog.csdnimg.cn/2076183635a740bfad3821333b7deed7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><hr>
<p>我们把问题设定为内存泄漏，但其实OOM或者频繁GC不一定就是内存泄漏，它也可能是由于某次或者某批请求频繁创建了大量对象，所以一些严重的、频繁的GC问题也能在这里找到原因。有些情况下，占用内存最多的对象，并不一定是引起内存泄漏问题的元凶，但我们也有一个比较通用的分析过程。</p>
<p>并不是所有的堆都值得分析的。我们分析在做这个耗时的分析之前，需要有个依据。比如，经过初步调优之后，GC的停顿时间还是较长，我们需要找到频繁GC的原因；再比如，我们发现了内存泄漏，需要找到是谁在搞鬼。</p>
<p>首先，我们高度关注快照载入后的初始分析。占用内存高的topN对象，大概率是问题产生者。</p>
<p>如果不能通过大对象发现问题，就需要对快照进行深入分析。使用柱状图和支配树视图，配合引入引出和各种排序，能够对内存的使用进行整体的摸底。由于我们能够看到内存中的具体数据，排查一些异常数据就容易的多。</p>
<p>可以在程序运行的不同时间点，获取多份内存快照，对比之后问题会更加容易发现。我们还是用一个例子来看。有一个应用，使用了Kafka消息队列，开了一般大小的消费缓冲区，Kafka会复用这个缓冲区，按理说不应该有内存问题，但是应用却频繁发生GC。通过对比请求高峰和低峰期间的内存快照，我们发现有工程师把消费数据放入了另外一个 “内存队列”，写了一些画蛇添足的代码，结果在业务高峰期一股脑把数据加载到了内存中。</p>
<p>上面这些问题通过分析业务代码，也不难发现其关联性。问题如果非常隐蔽，就需要使用OQL等语言，对问题一一排查、确认。</p>
<p>可以看到，MAT工具的上手是有一定门槛的，除了其操作模式，还需要对我们前面介绍的理论知识有深入的理解。比如GC Roots，各种引用级别等。</p>
<p>在很多场景，MAT并不仅仅用于内存泄漏的排查。由于我们能够看到内存上的具体数据，在排查一些难度非常高的bug时，MAT也有用武之地。比如，因为某些脏数据，引起了程序的执行异常。这个时候，想要找到它们，不要忘了MAT这个老朋友。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>OOM</tag>
        <tag>内存溢出</tag>
        <tag>mat</tag>
        <tag>MemoryAnalyzer</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>内网DNS服务安装使用系列教程（一）介绍</title>
    <url>/2021/09/04/%E5%86%85%E7%BD%91dns%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-2-1024x408.png" alt="什么是 DNS ?"></p>
<h3 id="1-DNS-服务介绍"><a href="#1-DNS-服务介绍" class="headerlink" title="1. DNS 服务介绍"></a>1. DNS 服务介绍</h3><hr>
<p><strong>DNS</strong>（Domain Name System，域名系统），因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<ul>
<li>DNS 协议运行在UDP和TCP之上，使用53号端口</li>
<li>其中在DNS解析查询时用到UDP协议，而在主从传递区域数据库文件时，用到TCP协议</li>
</ul>
<h3 id="2-互联网域名结构"><a href="#2-互联网域名结构" class="headerlink" title="2. 互联网域名结构"></a>2. 互联网域名结构</h3><hr>
<h5 id="一般结构"><a href="#一般结构" class="headerlink" title="一般结构"></a>一般结构</h5><ul>
<li>主机名.二级域名.顶级域名.根</li>
<li><a href="http://www.code404.icu/">www.code404.icu</a>.</li>
</ul>
<h5 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h5><ul>
<li>Internet 的顶级域名由 Internet 网络协会域名注册查询负责网络地址分配的委员会进行登记和管理</li>
<li>它还为 Internet 的每一台主机分配唯一的 IP 地址<br><img src="https://img-blog.csdnimg.cn/e764c097b08d4cbe81f1a20453d47258.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ul>
<h3 id="3-DNS-的功能"><a href="#3-DNS-的功能" class="headerlink" title="3. DNS 的功能"></a>3. DNS 的功能</h3><hr>
<blockquote>
<p>每个 IP 地址都可以有一个主机名，主机名由一个或多个字符串组成，字符串之间用小数点隔开。有了主机名，就不要死记硬背每台 IP 设备的 IP 地址，只要记住相对直观有意义的主机名就行了。</p>
</blockquote>
<h5 id="主机名到-IP-地址映射的两种方式"><a href="#主机名到-IP-地址映射的两种方式" class="headerlink" title="主机名到 IP 地址映射的两种方式"></a>主机名到 IP 地址映射的两种方式</h5><ul>
<li>静态映射<br>&#x2F;etc&#x2F;hosts文件<br>在每台设备上都有主机到IP的映射关系，只供此设备使用</li>
<li>动态映射<br>&#x2F;etc&#x2F;resolv.conf文件</li>
</ul>
<p>指通过DNS服务器配置主机到IP的映射关系</p>
<p># cat &#x2F;etc&#x2F;hosts<br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</p>
<h1 id="cat-x2F-etc-x2F-resolv-conf"><a href="#cat-x2F-etc-x2F-resolv-conf" class="headerlink" title="cat &#x2F;etc&#x2F;resolv.conf"></a>cat &#x2F;etc&#x2F;resolv.conf</h1><p>nameserver 172.16.242.2</p>
<h5 id="解析方式-FQDN-Full-Qualified-Domain-Name"><a href="#解析方式-FQDN-Full-Qualified-Domain-Name" class="headerlink" title="解析方式 - FQDN(Full Qualified Domain Name)"></a>解析方式 - FQDN(Full Qualified Domain Name)</h5><ul>
<li>正向 &#x3D;&#x3D;&gt; FQDN –&gt; IP</li>
<li>反向 &#x3D;&#x3D;&gt; IP –&gt; FQDN</li>
<li>权威</li>
<li>非权威</li>
</ul>
<h5 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a>解析顺序</h5><p>在解析域名时，首先采用静态域名解析的方法，如果静态域名解析不成功，再采用动态域名解析的方法<br><img src="https://img-blog.csdnimg.cn/7e67724ead11439687f9bc87e30cb0a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h5 id="一次完整的查询请求经过的流程"><a href="#一次完整的查询请求经过的流程" class="headerlink" title="一次完整的查询请求经过的流程"></a>一次完整的查询请求经过的流程</h5><p><img src="https://img-blog.csdnimg.cn/6b42717ee0fe4e45b16d044693fecda8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="4-技术实现"><a href="#4-技术实现" class="headerlink" title="4. 技术实现"></a>4. 技术实现</h3><hr>
<p><strong>DNS</strong>通过允许一个名称服务器把他的一部分名称服务，众所周知的<strong>zone</strong>，委托给子服务器而实现了一种层次结构的名称空间，成为<strong>子域授权</strong>机制。</p>
<ul>
<li>DNS还提供了一些额外的信息，例如系统别名、联系信息以及哪一个主机正在充当系统组或域的邮件枢纽</li>
<li>任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。</li>
</ul>
<h5 id="实现-DNS-的软件"><a href="#实现-DNS-的软件" class="headerlink" title="实现 DNS 的软件"></a>实现 DNS 的软件</h5><ul>
<li>BIND</li>
<li>DJBDNS</li>
<li>MaraDNS</li>
<li>Name Server Daemon</li>
<li>PowerDNS</li>
<li>Dnsmasq</li>
</ul>
<h5 id="DNS-查询类型"><a href="#DNS-查询类型" class="headerlink" title="DNS 查询类型"></a>DNS 查询类型</h5><ul>
<li>迭代查询</li>
<li>递归查询<br><img src="https://img-blog.csdnimg.cn/037d6309033e41cba878dcdc3c46000e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2ee5ce8fa17148e08f39a0da74a6a9b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ul>
<h3 id="5-DNS-的类型"><a href="#5-DNS-的类型" class="headerlink" title="5. DNS 的类型"></a>5. DNS 的类型</h3><hr>
<ul>
<li>（1）Primary DNS Server(Master)<br>一个域的主服务器保存着该域的zone配置文件，该域所有的配置、更改都是在该服务器上进行，本篇随笔要讲解的也是如何配置一个域的主DNS服务器。</li>
<li>（2）Secondary DNS Server(Slave)<br>域从服务器一般都是作为冗余负载使用，一个域的从服务器是从该域的主服务器上抓取zone配置文件，从服务器不会进行任何信息的更改，zone配置文件的修改只能在主DNS服务器上进行，所有的修改都有主服务器同步。</li>
<li>（3）Caching only Server(Cache)<br>DNS缓存服务器不存在任何的zone配置文件，仅仅依靠缓存来为客户端提供服务，通常用于负载均衡及加速访问操作。</li>
<li>（4）转发服务器<br>只负责转发功能</li>
</ul>
<h5 id="主-DNS-服务器"><a href="#主-DNS-服务器" class="headerlink" title="主 DNS 服务器"></a>主 DNS 服务器</h5><ul>
<li>维护所负责解析的区域内解析库服务器</li>
<li>解析库由管理维护，可以是手工也可以是自动的</li>
<li>通知机制</li>
<li>一旦主 DNS 服务器解析库发生改变会立即通知从服务器</li>
</ul>
<h5 id="从-DNS-服务器"><a href="#从-DNS-服务器" class="headerlink" title="从 DNS 服务器"></a>从 DNS 服务器</h5><ul>
<li>从主DNS服务器或其他的从DNS服务器那里复制(区域传送)一份解析库</li>
<li>序列号<br>来表示解析库的版本号<br>前提是，主服务器解析库内容发生改变，其序列递增</li>
<li>刷新时间<br>从服务器从主服务器请求同步解析库的时间间隔</li>
<li>重试时间<br>从服务器从服务器请求同步解析库失败的时候，再次尝试的时间间隔</li>
<li>过期时长<br>从服务器始终联系不到主服务器时，多久后放弃从服务器角度，停止提供服务</li>
</ul>
<h5 id="全量传送"><a href="#全量传送" class="headerlink" title="全量传送"></a>全量传送</h5><ul>
<li>传送整个解析库</li>
</ul>
<h5 id="增量传送"><a href="#增量传送" class="headerlink" title="增量传送"></a>增量传送</h5><ul>
<li>传送解析库变化的那部分内容</li>
</ul>
<h3 id="6-资源记录类型"><a href="#6-资源记录类型" class="headerlink" title="6. 资源记录类型"></a>6. 资源记录类型</h3><hr>
<h5 id="DNS-系统中，常见的资源记录类型："><a href="#DNS-系统中，常见的资源记录类型：" class="headerlink" title="DNS 系统中，常见的资源记录类型："></a>DNS 系统中，常见的资源记录类型：</h5><ul>
<li>主机记录（A记录）<br>FQDN –&gt; IP<br>A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上</li>
<li>指针记录（PTR记录）<br>IP –&gt; FQDN<br>引导至一个规范名称（Canonical Name），最常用来运行反向DNS查找</li>
<li>权威记录的起始（SOA记录）<br>一个区域解析库有且仅能有一个SOA记录，而必须为解析库的第一条记录</li>
<li>名称服务器记录（NS记录）<br>专用于标明当前区域的DNS服务器</li>
<li>别名记录（CNAME记录）<br>CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录</li>
<li>MX 记录（MX记录）<br>引导域名到该域名的邮件传输代理（Message Transfer Agents）列表</li>
<li>IPv6 主机记录（AAAA记录）<br>FQDN –&gt; IP<br>与 A 记录对应，用于将特定的主机名映射到一个主机的IPv6地址。</li>
<li>服务位置记录（SRV记录）<br>用于定义提供特定服务的服务器的位置，如主机hostname，端口port</li>
<li>NAPTR 记录<br>它提供了正则表达式方式去映射一个域名。NAPTR记录非常著名的一个应用是用于ENUM查询。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/069a3f6b2de741878ec8ea3ffb39f663.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="7-资源记录格式"><a href="#7-资源记录格式" class="headerlink" title="7. 资源记录格式"></a>7. 资源记录格式</h3><hr>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>name [TTL] IN rr_type value</p>
<ul>
<li>(1) TTL如果从全局继承可以省略，为缓存时长</li>
<li>(2)IN表示Internet</li>
<li>(3)rr_type表示资源记录类型</li>
<li>(4) @可用于引用当前区域的名字</li>
<li>(5) 同一个名字可以通过多条记录定义多个不同的值，此时DNS服务器会以轮询方式响应</li>
<li>(6) 同一个值也可能有多个不同的定义名字，通过多个不同的名字指向同一个值进行定义，此仅表示通过多个不同的名字可以找到同一个主机而已</li>
</ul>
<h5 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h5><ul>
<li>name: 当前区域的名字，例如code404.icu.</li>
<li>value: 有多部分组成:</li>
</ul>
<ol>
<li>当前区域的主DNS服务器的FQDN，也可以使用当前区域的名字</li>
<li>当前区域管理员的邮箱地址，但地址中不能使用@符号，一般用.替换，例如mail.code404.icu</li>
<li>主从服务协调属性的定义以及否定的答案的统一的TTL</li>
</ol>
<p># 86400为TTL值，单位为秒钟</p>
<h1 id="主DNS服务器地址为ns-wsescape-com"><a href="#主DNS服务器地址为ns-wsescape-com" class="headerlink" title="主DNS服务器地址为ns.wsescape.com."></a>主DNS服务器地址为ns.wsescape.com.</h1><h1 id="邮箱地址为nsadmin-wsescape-com"><a href="#邮箱地址为nsadmin-wsescape-com" class="headerlink" title="邮箱地址为nsadmin.wsescape.com."></a>邮箱地址为nsadmin.wsescape.com.</h1><h1 id="第一版为2016052201，标识版本号"><a href="#第一版为2016052201，标识版本号" class="headerlink" title="第一版为2016052201，标识版本号"></a>第一版为2016052201，标识版本号</h1><p>wsescape.com.86400INSOAns.nsadmin.wsescape.com.(<br>2016052201  ;序列号<br>2H          ;刷新时间，2小时<br>10M;重试时间，10分钟<br>1W;过期时间，一周<br>1D;否定答案的TTL值，一天<br>)</p>
<h5 id="NS"><a href="#NS" class="headerlink" title="NS"></a>NS</h5><ul>
<li>name: 当前区域的名字</li>
<li>value: 当前区域的某DNS服务器的名字，例如ns.wsescape.com.</li>
<li>注意:</li>
</ul>
<ol>
<li>相邻的两个资源记录的name相同时，后续的可省略</li>
<li>对NS记录而言，任何一个NS记录后面的服务器名字，都应该在后续有一个A记录</li>
</ol>
<p># 一个区域可以有多个NS记录</p>
<h1 id="ns1-wsescape-com-和ns2-wsescape-com-都应该在后续有一个A记录"><a href="#ns1-wsescape-com-和ns2-wsescape-com-都应该在后续有一个A记录" class="headerlink" title="ns1.wsescape.com.和ns2.wsescape.com.都应该在后续有一个A记录"></a>ns1.wsescape.com.和ns2.wsescape.com.都应该在后续有一个A记录</h1><p>wsescape.com.INNS  ns1.wsescape.com.<br>wsescape.com.INNS  ns2.wsescape.com.</p>
<p>MX</p>
<ul>
<li>name: 当前区域的名字</li>
<li>value: 当前区域的某邮件服务器(smtp服务器)的主机名</li>
</ul>
<ol>
<li>一个区域内，MX记录可以有多个</li>
<li>但每个记录的value之前应该有一个数字(0-99)，表示此服务器的优先级</li>
<li>数字越小优先级越高</li>
</ol>
<ul>
<li>注意</li>
</ul>
<ol>
<li>相邻的两个资源记录的name相同时，后续的可省略</li>
<li>对MX记录而言，任何一个MX记录后面的服务器名字，都应该在后续有一个A记录</li>
</ol>
<p># mx1.wsescape.com.和mx2.wsescape.com.都应该在后续有一个A记录<br>wsescape.com.IN  MX  10  mx1.wsescape.com.<br>INMX  20  mx2.wsescape.com.</p>
<h5 id="A"><a href="#A" class="headerlink" title="A"></a>A</h5><ul>
<li>name: 某主机的FQDN，例如<a href="http://www.wsescape.com/">www.wsescape.com</a>.</li>
<li>value: 主机名对应主机的 IP 地址；</li>
<li>注意<br>避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址</li>
</ul>
<p># 轮询<br><a href="http://www.wsescape.com.in/">www.wsescape.com.IN</a>  A1.1.1.1<br><a href="http://www.wsescape.com.in/">www.wsescape.com.IN</a>  A  1.1.1.2</p>
<h1 id="一个主机有多个名称而已"><a href="#一个主机有多个名称而已" class="headerlink" title="一个主机有多个名称而已"></a>一个主机有多个名称而已</h1><p>mx1.wsescape.com.IN    A   1.1.1.3<br>mx2.wsescape.com.  IN  A   1.1.1.3</p>
<p># 避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址<br>*.wsescape.com.IN  A  1.1.1.4<br>wsescape.com.IN  A   1.1.1.4</p>
<h5 id="AAAA"><a href="#AAAA" class="headerlink" title="AAAA"></a>AAAA</h5><p>与 <code>A</code> 记录类似，这是只是表示IPv6地址而已</p>
<p># 轮询<br><a href="http://www.wsescape.com.in/">www.wsescape.com.IN</a>  AAAA1.1.1.1<br><a href="http://www.wsescape.com.in/">www.wsescape.com.IN</a>  AAAA  1.1.1.2</p>
<h1 id="一个主机有多个名称而已-1"><a href="#一个主机有多个名称而已-1" class="headerlink" title="一个主机有多个名称而已"></a>一个主机有多个名称而已</h1><p>mx1.wsescape.com.IN    AAAA   1.1.1.3<br>mx2.wsescape.com.  IN  AAAA   1.1.1.3</p>
<h1 id="避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址"><a href="#避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址" class="headerlink" title="避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址"></a>避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址</h1><p>*.wsescape.com.IN  AAAA  1.1.1.4<br>wsescape.com.IN  AAAA   1.1.1.4</p>
<h5 id="PTR"><a href="#PTR" class="headerlink" title="PTR"></a>PTR</h5><ul>
<li>name: 这里的name表示的是IP地址</li>
<li>IP地址有特定格式，把IP地址反过来写，如果是1.2.3.4需要写作4.3.2.1</li>
<li>还有特定后缀in-addr.arpa.，完整写法为4.3.2.1.in-addra.arpa.</li>
<li>value: 这里的value值为FQDN</li>
<li>注意<br>网络地址及后缀可省略，主机地址依然需要反着写</li>
</ul>
<p># 实例<br>4.3.2.1.in-addr.arpa.INPTR<a href="http://www.wsescape.com/">www.wsescape.com</a>.</p>
<h1 id="如果3-2-1是网络地址简写成为"><a href="#如果3-2-1是网络地址简写成为" class="headerlink" title="如果3.2.1是网络地址简写成为"></a>如果3.2.1是网络地址简写成为</h1><p>4   IN  PTR<a href="http://www.wsescape.com/">www.wsescape.com</a>.</p>
<h1 id="如果2-1是网络地址简写成为"><a href="#如果2-1是网络地址简写成为" class="headerlink" title="如果2.1是网络地址简写成为"></a>如果2.1是网络地址简写成为</h1><p>4.3  IN  PTR<a href="http://www.wsescape.com/">www.wsescape.com</a>.</p>
<h5 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h5><ul>
<li>name: 别名的FQDN</li>
<li>value: 正工名字的FQDN</li>
</ul>
<p>web.escapelife.com.IN  CNAME  <a href="http://www.escapelife.com/">www.escapelife.com</a>.</p>
<h3 id="8-个人使用"><a href="#8-个人使用" class="headerlink" title="8. 个人使用"></a>8. 个人使用</h3><hr>
<blockquote>
<p>子域授权就是每个域的名称服务器，都是通过其上级名称服务器在解析库进行授权</p>
</blockquote>
<p>类似根域授权tld</p>
<p>.com.INNS     ns1.com.<br>.com.   IN    NSns2.com.<br>ns1.com.INA   2.2.2.1<br>ns2.com.      INA2.2.2.2</p>
<p>这里以<strong>wsescape.com</strong>为例</p>
<p># wsescape.com. 在.com的名称服务器上，解析库中添加资源记录<br>wsescape.com.INNSns1.wsescape.com.<br>wsescape.com.INNSns2.wsescape.com.<br>wsescape.com.INNSns3.wsescape.com.<br>ns1.wsescape.com.INA  3.3.3.1<br>ns2.wsescape.com.INA  3.3.3.2<br>ns3.wsescape.com.INA  3.3.3.3</p>
<h4 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h4><ul>
<li>代理商</li>
<li>万网</li>
<li>新网</li>
<li>godaddy</li>
</ul>
<h4 id="绑定服务器"><a href="#绑定服务器" class="headerlink" title="绑定服务器"></a>绑定服务器</h4><ul>
<li>注册完成以后，想自己用专用服务来解析？</li>
<li>管理后台，把 NS 记录指向的服务器名称和 A 记录指向的服务器地址</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>AAAA</tag>
        <tag>CANME</tag>
        <tag>域名</tag>
        <tag>查询类型</tag>
        <tag>资源记录格式</tag>
        <tag>资源记录类型</tag>
      </tags>
  </entry>
  <entry>
    <title>内网DNS服务安装使用系列教程（三）BIND的安装配置</title>
    <url>/2021/09/06/%E5%86%85%E7%BD%91dns%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89bind%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-4-1024x408.png"></p>
<p>DNS服务，程序包名bind，程序名named。</p>
<h3 id="1-程序包"><a href="#1-程序包" class="headerlink" title="1. 程序包"></a>1. 程序包</h3><hr>
<p>只需要安装bind、bind-libs和bind-utils即可</p>
<ul>
<li>bind 主包</li>
<li>bind-libs 依赖的库文件，包括 32 位和 64 位</li>
<li>bind-utils 提供客户端工具，例如dig、host、nslookup和nsupdate</li>
<li>bind-chroot 建立不要安装，很容易被入侵</li>
</ul>
<p>bind-chroot 包的作用是提高安全性，将 DNS 服务的配置文件&#x2F;etc&#x2F;named.conf 等，创建一个硬链接转到&#x2F;var&#x2F;named&#x2F;chroot&#x2F;etc&#x2F; 文件夹下面，而且使用服务帐号登录，不使用root用户登录</p>
<p>注意，修改配置文件要修改&#x2F;etc&#x2F;下面的，这样会自动同步到chroot下面的链接文件中</p>
<p>bind-sdb</p>
<p>bind-dyndb-ldap</p>
<p>以上这两种方式，是将解析库文件放在不同的数据库中进行存储</p>
<h3 id="2-BIND配置文件"><a href="#2-BIND配置文件" class="headerlink" title="2. BIND配置文件"></a>2. BIND配置文件</h3><hr>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><ul>
<li>服务启动脚本<br>在CentOS6下</li>
</ul>
<p>&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;named</p>
<ul>
<li>主配置文件</li>
</ul>
<p>&#x2F;etc&#x2F;named.conf<br>&#x2F;etc&#x2F;rndc.key</p>
<p>为rndc的秘钥共享文件，提供认证用的</p>
<ul>
<li>rndc是什么？<br>远程名称控制器<br>默认与bind安装在同一主机，且只能通过本地回环地址127.0.0.1来连接named进程<br>提供辅助性的管理功能，如查看解析状态等<br>默认工作在 953&#x2F;tcp 端口上<br>&#x2F;etc&#x2F;named.rfc1912.zones</li>
</ul>
<h4 id="请求注解文档"><a href="#请求注解文档" class="headerlink" title="请求注解文档"></a>请求注解文档</h4><ul>
<li>解析库文件</li>
</ul>
<p>&#x2F;var&#x2F;named&#x2F;ZONE_NAME.ZONE</p>
<p>在**&#x2F;var&#x2F;named&#x2F;**目录下存在多个解析库文件</p>
<p>&#x2F;var&#x2F;named&#x2F;named.ca</p>
<p>指向根DNS该文件不需要管理员更改，而是系统自带</p>
<p>&#x2F;var&#x2F;named&#x2F;named.local</p>
<p>本地子域解析，将<strong>localhost</strong>反向解析为<strong>127.0.0.1</strong></p>
<ul>
<li>注意</li>
</ul>
<ol>
<li>一台物理服务器可同时为多个区域提供解析</li>
<li>必须要有根区域文件，在<strong>named.ca</strong>中包含<strong>13</strong>根节点地址，由<strong>dig</strong>命令生成而来的</li>
<li>应该有两个(如果包括<strong>ipv6</strong>的，应该更多)实现<strong>localhost</strong>和<strong>本地回环地址</strong>的解析库</li>
</ol>
<p>#  在CentOS6下<br>[root@localhost ~]# rpm -ql bind  less<br>&#x2F;etc&#x2F;NetworkManager&#x2F;dispatcher.d&#x2F;13-named<br>&#x2F;etc&#x2F;logrotate.d&#x2F;named<br>&#x2F;etc&#x2F;named<br>&#x2F;etc&#x2F;named.conf<br>&#x2F;etc&#x2F;named.iscdlv.key<br>&#x2F;etc&#x2F;named.rfc1912.zones<br>&#x2F;etc&#x2F;named.root.key<br>&#x2F;etc&#x2F;portreserve&#x2F;named<br>&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;named<br>&#x2F;etc&#x2F;rndc.conf<br>&#x2F;etc&#x2F;rndc.key<br>&#x2F;etc&#x2F;sysconfig&#x2F;named<br>&#x2F;usr&#x2F;lib64&#x2F;bind<br>&#x2F;usr&#x2F;sbin&#x2F;arpaname<br>……</p>
<p># @表示当前区域的区域名称，在主配置文件&#x2F;etc&#x2F;named.conf中定义的</p>
<h1 id="TTL的值没写，因为定义了宏-TTL-1D，直接继承"><a href="#TTL的值没写，因为定义了宏-TTL-1D，直接继承" class="headerlink" title="TTL的值没写，因为定义了宏$TTL 1D，直接继承"></a>TTL的值没写，因为定义了宏$TTL 1D，直接继承</h1><h1 id="rname-invalid-表示管理员的邮箱地址"><a href="#rname-invalid-表示管理员的邮箱地址" class="headerlink" title="rname.invalid.表示管理员的邮箱地址"></a>rname.invalid.表示管理员的邮箱地址</h1><h1 id="后面的如NS、A等缺省，因为继承前者的"><a href="#后面的如NS、A等缺省，因为继承前者的" class="headerlink" title="后面的如NS、A等缺省，因为继承前者的"></a>后面的如NS、A等缺省，因为继承前者的</h1><p>[root@localhost named]# cat &#x2F;var&#x2F;named&#x2F;named.localhost<br>$TTL 1D<br>@IN SOA@ rname.invalid. (<br>0; serial<br>1D; refresh<br>1H; retry<br>1W; expire<br>3H ); minimum<br>NS@<br>A127.0.0.1<br>AAAA::1</p>
<p>[root@localhost named]# cat &#x2F;var&#x2F;named&#x2F;named.loopback<br>$TTL 1D<br>@IN SOA@ rname.invalid. (<br>0; serial<br>1D; refresh<br>1H; retry<br>1W; expire<br>3H ); minimum<br>NS@<br>A127.0.0.1<br>AAAA::1<br>PTRlocalhost.</p>
<h4 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h4><ul>
<li>全局配置</li>
</ul>
<p>options {}</p>
<ul>
<li>日志子系统配置</li>
</ul>
<p>logging {}</p>
<ul>
<li>区域定义<br>本机能够为哪些zone进行解析，就要定义哪些<strong>zone</strong></li>
</ul>
<p>zone “ZONE_NAME” IN {}</p>
<ul>
<li>注意<br>任何服务程序如果期望其能够通过网络被其它主机访问，至少应该监听在一个能与外部主机通信的IP地址上</li>
</ul>
<p>[root@localhost ~]# cat &#x2F;etc&#x2F;named.conf<br>options {<br>listen-on port 53 { 127.0.0.1; };<br>listen-on-v6 port 53 { ::1; };<br>directory”&#x2F;var&#x2F;named”;<br>dump-file”&#x2F;var&#x2F;named&#x2F;data&#x2F;cache_dump.db”;<br>        statistics-file “&#x2F;var&#x2F;named&#x2F;data&#x2F;named_stats.txt”;<br>        memstatistics-file “&#x2F;var&#x2F;named&#x2F;data&#x2F;named_mem_stats.txt”;<br>allow-query     { localhost; };<br>recursion yes;</p>
<p>dnssec-enable yes;<br>dnssec-validation yes;<br>dnssec-lookaside auto;</p>
<p>&#x2F;* Path to ISC DLV key *&#x2F;<br>bindkeys-file “&#x2F;etc&#x2F;named.iscdlv.key”;</p>
<p>managed-keys-directory “&#x2F;var&#x2F;named&#x2F;dynamic”;<br>};</p>
<p>logging {<br>        channel default_debug {<br>                file “data&#x2F;named.run”;<br>                severity dynamic;<br>        };<br>};</p>
<p>zone “.” IN {<br>type hint;<br>file “named.ca”;<br>};</p>
<p>include “&#x2F;etc&#x2F;named.rfc1912.zones”;<br>include “&#x2F;etc&#x2F;named.root.key”;</p>
<p># localhost.localdomain就是区域名称，也就是@<br>[root@localhost ~]# cat &#x2F;etc&#x2F;named.rfc1912.zones<br>zone “localhost.localdomain” IN {<br>type master;<br>file “named.localhost”;<br>allow-update { none; };<br>};</p>
<p>zone “localhost” IN {<br>type master;<br>file “named.localhost”;<br>allow-update { none; };<br>};</p>
<p>zone “1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa” IN {<br>type master;<br>file “named.loopback”;<br>allow-update { none; };<br>};</p>
<p>zone “1.0.0.127.in-addr.arpa” IN {<br>type master;<br>file “named.loopback”;<br>allow-update { none; };<br>};</p>
<p>zone “0.in-addr.arpa” IN {<br>type master;<br>file “named.empty”;<br>allow-update { none; };<br>};</p>
<h3 id="3-缓存名称服务器配置"><a href="#3-缓存名称服务器配置" class="headerlink" title="3. 缓存名称服务器配置"></a>3. 缓存名称服务器配置</h3><hr>
<p>安装上bind之后，其实就算的上是一个缓存名称服务器，只需要进行少许的配置即可完成</p>
<ul>
<li>修改<strong>listen-on port 53</strong></li>
<li>修改<strong>allow-query</strong></li>
<li>修改<strong>recursion</strong></li>
</ul>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><p>[root@localhost ~]#yum install bind</p>
<h4 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h4><p>[root@localhost ~]# service named start<br>Generating &#x2F;etc&#x2F;rndc.key:                                  [  OK  ]<br>Starting named:                                            [  OK  ]</p>
<h4 id="3-查看"><a href="#3-查看" class="headerlink" title="3. 查看"></a>3. 查看</h4><p># 为了安全，安装上bind之后，默认只会监听本地，不对外提供服务</p>
<h1 id="任何服务程序如果期望其能够通过网络被其它主机访问，至少应该监听在一个能与外部主机通信的-IP-地址上"><a href="#任何服务程序如果期望其能够通过网络被其它主机访问，至少应该监听在一个能与外部主机通信的-IP-地址上" class="headerlink" title="任何服务程序如果期望其能够通过网络被其它主机访问，至少应该监听在一个能与外部主机通信的`IP`地址上"></a>任何服务程序如果期望其能够通过网络被其它主机访问，至少应该监听在一个能与外部主机通信的`IP`地址上</h1><h1 id="编辑主配置文件即可"><a href="#编辑主配置文件即可" class="headerlink" title="编辑主配置文件即可"></a>编辑主配置文件即可</h1><p>[root@localhost ~]# ss -tunlp  grep :53<br>udp    UNCONN     0      0              127.0.0.1:53                    *:*      users:((“named”,39822,512))<br>udp    UNCONN     0      0                    ::1:53                   :::*      users:((“named”,39822,513))<br>tcp    LISTEN     0      3                    ::1:53                   :::*      users:((“named”,39822,21))<br>tcp    LISTEN     0      3              127.0.0.1:53                    *:*      users:((“named”,39822,20))</p>
<h4 id="4-修改"><a href="#4-修改" class="headerlink" title="4. 修改"></a>4. 修改</h4><p># 修改之前先备份一下</p>
<h1 id="逗号之前没有内容，默认为前一个的名称，后面为复制的内容"><a href="#逗号之前没有内容，默认为前一个的名称，后面为复制的内容" class="headerlink" title="逗号之前没有内容，默认为前一个的名称，后面为复制的内容"></a>逗号之前没有内容，默认为前一个的名称，后面为复制的内容</h1><p>[root@localhost ~]# cp &#x2F;etc&#x2F;named.conf{,.bak}<br>[root@localhost ~]# ll &#x2F;etc&#x2F;named*<br>-rw-r—–. 1 root named  984 11月 20 2015 &#x2F;etc&#x2F;named.conf<br>-rw-r—–. 1 root root   984 6月  20 21:53 &#x2F;etc&#x2F;named.conf.bak</p>
<p># &#x2F;&#x2F;表示单行注释，注释ipv6</p>
<h1 id="x2F-x2F-表示多行注释"><a href="#x2F-x2F-表示多行注释" class="headerlink" title="&#x2F;**&#x2F;表示多行注释"></a>&#x2F;**&#x2F;表示多行注释</h1><h1 id="修改的时候必须以-结尾且-的两端必须有空格，否则为语法错误"><a href="#修改的时候必须以-结尾且-的两端必须有空格，否则为语法错误" class="headerlink" title="修改的时候必须以;结尾且{}的两端必须有空格，否则为语法错误"></a>修改的时候必须以;结尾且{}的两端必须有空格，否则为语法错误</h1><h1 id="directory用来定义区域解析库文件存放位置"><a href="#directory用来定义区域解析库文件存放位置" class="headerlink" title="directory用来定义区域解析库文件存放位置"></a>directory用来定义区域解析库文件存放位置</h1><h1 id="建议关闭dnssec功能"><a href="#建议关闭dnssec功能" class="headerlink" title="建议关闭dnssec功能"></a>建议关闭dnssec功能</h1><h1 id="将dnssec-enable和dnssec-validation改为no，并注释key文件即可"><a href="#将dnssec-enable和dnssec-validation改为no，并注释key文件即可" class="headerlink" title="将dnssec-enable和dnssec-validation改为no，并注释key文件即可"></a>将dnssec-enable和dnssec-validation改为no，并注释key文件即可</h1><h1 id="把能够以外网进行通信的地址写在listen-on-port-53之后，如果有多个可以多个添加，不能省略"><a href="#把能够以外网进行通信的地址写在listen-on-port-53之后，如果有多个可以多个添加，不能省略" class="headerlink" title="把能够以外网进行通信的地址写在listen-on port 53之后，如果有多个可以多个添加，不能省略"></a>把能够以外网进行通信的地址写在listen-on port 53之后，如果有多个可以多个添加，不能省略</h1><h1 id="如果将listen-on-port-53进行注释或者删除，默认是监听在所有"><a href="#如果将listen-on-port-53进行注释或者删除，默认是监听在所有" class="headerlink" title="如果将listen-on port 53进行注释或者删除，默认是监听在所有"></a>如果将listen-on port 53进行注释或者删除，默认是监听在所有</h1><h1 id="将allow-query注释或改为allow-query-any"><a href="#将allow-query注释或改为allow-query-any" class="headerlink" title="将allow-query注释或改为allow-query { any; };"></a>将allow-query注释或改为allow-query { any; };</h1><h1 id="是否允许递归recursion，必须为yes"><a href="#是否允许递归recursion，必须为yes" class="headerlink" title="是否允许递归recursion，必须为yes"></a>是否允许递归recursion，必须为yes</h1><p>[root@localhost ~]# vim &#x2F;etc&#x2F;named.conf<br>options {<br>        listen-on port 53 { 172.16.242.178; 127.0.0.1; };<br>        listen-on-v6 port 53 { ::1; };<br>        directory       “&#x2F;var&#x2F;named”;<br>        dump-file       “&#x2F;var&#x2F;named&#x2F;data&#x2F;cache_dump.db”;<br>        statistics-file “&#x2F;var&#x2F;named&#x2F;data&#x2F;named_stats.txt”;<br>        memstatistics-file “&#x2F;var&#x2F;named&#x2F;data&#x2F;named_mem_stats.txt”;<br>&#x2F;&#x2F;      allow-query     { localhost; };<br>        recursion yes;<br>        dnssec-enable no;<br>        dnssec-validation no;<br>        &#x2F;* Path to ISC DLV key *&#x2F;<br>&#x2F;&#x2F;      bindkeys-file “&#x2F;etc&#x2F;named.iscdlv.key”;<br>&#x2F;&#x2F;      managed-keys-directory “&#x2F;var&#x2F;named&#x2F;dynamic”;<br>};</p>
<h4 id="5-重启生效"><a href="#5-重启生效" class="headerlink" title="5. 重启生效"></a>5. 重启生效</h4><p># 重启之后才能生效配置<br>[root@localhost ~]# service named restart<br>Stopping named: .                                          [  OK  ]<br>Starting named:                                            [  OK  ]</p>
<p>[root@localhost ~]# ss -tunlp  grep :53<br>udp    UNCONN     0      0         172.16.242.178:53                    *:*      users:((“named”,40086,513))<br>udp    UNCONN     0      0              127.0.0.1:53                    *:*      users:((“named”,40086,512))<br>udp    UNCONN     0      0                    ::1:53                   :::*      users:((“named”,40086,514))<br>tcp    LISTEN     0      3                    ::1:53                   :::*      users:((“named”,40086,22))<br>tcp    LISTEN     0      3         172.16.242.178:53                    *:*      users:((“named”,40086,21))<br>tcp    LISTEN     0      3              127.0.0.1:53                    *:*      users:((“named”,40086,20))</p>
<h3 id="4-主-DNS-名称服务器配置"><a href="#4-主-DNS-名称服务器配置" class="headerlink" title="4. 主 DNS 名称服务器配置"></a>4. 主 DNS 名称服务器配置</h3><hr>
<p>主 DNS 名称服务器配置就是在缓存DNS服务器的基础之上增加zone配置文件就可以了</p>
<ul>
<li>在&#x2F;etc&#x2F;named.rfc1912.zones添加zone记录</li>
<li>在&#x2F;var&#x2F;named&#x2F;增加zone文件</li>
</ul>
<h4 id="1-在主配置文件中定义区域"><a href="#1-在主配置文件中定义区域" class="headerlink" title="1. 在主配置文件中定义区域"></a>1. 在主配置文件中定义区域</h4><p><strong>格式</strong></p>
<p># master表示主DNS</p>
<h1 id="slave表示从DNS"><a href="#slave表示从DNS" class="headerlink" title="slave表示从DNS"></a>slave表示从DNS</h1><h1 id="hint表示根"><a href="#hint表示根" class="headerlink" title="hint表示根"></a>hint表示根</h1><h1 id="forward做转发"><a href="#forward做转发" class="headerlink" title="forward做转发"></a>forward做转发</h1><h1 id="file使用的是主配置文件directory定义的路径"><a href="#file使用的是主配置文件directory定义的路径" class="headerlink" title="file使用的是主配置文件directory定义的路径"></a>file使用的是主配置文件directory定义的路径</h1><p>zone “ZONE_NAME” IN {<br>type {masterslavehintforward};<br>file “ZONE_NAME.zone”;<br>};</p>
<p><strong>修改配置</strong></p>
<p># 在&#x2F;etc&#x2F;named.rfc1912.zones文件内定义域名</p>
<h1 id="named-checkconf用来检查语法错误"><a href="#named-checkconf用来检查语法错误" class="headerlink" title="named-checkconf用来检查语法错误"></a>named-checkconf用来检查语法错误</h1><p>[root@localhost ~]# vim &#x2F;etc&#x2F;named.rfc1912.zones<br>zone “code404.icu” IN {<br>        type master;<br>        file “code404.icu.zone”;<br>};</p>
<p>[root@localhost ~]# named-checkconf</p>
<h4 id="2-定义区域解析库文件"><a href="#2-定义区域解析库文件" class="headerlink" title="2. 定义区域解析库文件"></a>2. 定义区域解析库文件</h4><p><strong>格式</strong></p>
<p>出现的内容：<br>宏定义；<br>资源记录；</p>
<p><strong>修改配置</strong></p>
<p># 这里$TTL用于定义TTL的值，86400为秒，可以使用1D来代替</p>
<h1 id="ORIGIN用于指定域名词尾，如ns以及mx都为缺省了"><a href="#ORIGIN用于指定域名词尾，如ns以及mx都为缺省了" class="headerlink" title="$ORIGIN用于指定域名词尾，如ns以及mx都为缺省了"></a>$ORIGIN用于指定域名词尾，如ns以及mx都为缺省了</h1><h1 id="named-checkzone"><a href="#named-checkzone" class="headerlink" title="named-checkzone"></a>named-checkzone</h1><h1 id="两个www，在访问的时候会进行轮询操作的"><a href="#两个www，在访问的时候会进行轮询操作的" class="headerlink" title="两个www，在访问的时候会进行轮询操作的"></a>两个www，在访问的时候会进行轮询操作的</h1><h1 id="泛域名解析这里的-，表示无论用户输入什么都不报错"><a href="#泛域名解析这里的-，表示无论用户输入什么都不报错" class="headerlink" title="泛域名解析这里的*，表示无论用户输入什么都不报错"></a>泛域名解析这里的*，表示无论用户输入什么都不报错</h1><h1 id="或者写成-IN-A-172-16-100-11，因为CNAME不能输入ip地址"><a href="#或者写成-IN-A-172-16-100-11，因为CNAME不能输入ip地址" class="headerlink" title="或者写成*  IN  A  172.16.100.11，因为CNAME不能输入ip地址"></a>或者写成*  IN  A  172.16.100.11，因为CNAME不能输入ip地址</h1><p>[root@localhost ~]# cd &#x2F;var&#x2F;named&#x2F;<br>[root@localhost named]# vim code404.icu.zone<br>$TTL 86400<br>$ORIGIN code404.icu.<br>@    IN    SOA    ns1.code404.icu.    admin.code404.icu (<br>2016042201<br>1H<br>5M<br>7D<br>1D )<br> IN    NS        ns1<br> IN    NS        ns2<br> IN    MX 10     mx1<br> IN    MX 20     mx2<br>ns1  IN    A172.16.100.11<br>ns2 IN    A172.16.100.12<br>mx1 IN    A172.16.100.13<br>mx2 IN    A172.16.100.14<br>www IN    A172.16.100.11<br>www IN    A172.16.100.12<br>ftp INCNAMEwww<br>*    IN CNAME   www</p>
<p>[root@localhost named]# named-checkzone “code404.icu” &#x2F;var&#x2F;named&#x2F;code404.icu.zone<br>zone code404.icu&#x2F;IN: loaded serial 2016042201<br>OK</p>
<p><strong>更改权限</strong></p>
<p># 可以查出进程是以named运行的</p>
<h1 id="其中-x2F-etc-x2F-named-conf文件的属主为root，属组为named"><a href="#其中-x2F-etc-x2F-named-conf文件的属主为root，属组为named" class="headerlink" title="其中&#x2F;etc&#x2F;named.conf文件的属主为root，属组为named"></a>其中&#x2F;etc&#x2F;named.conf文件的属主为root，属组为named</h1><h1 id="为了安全起见，对自己创建的文件进行权限修改"><a href="#为了安全起见，对自己创建的文件进行权限修改" class="headerlink" title="为了安全起见，对自己创建的文件进行权限修改"></a>为了安全起见，对自己创建的文件进行权限修改</h1><p>[root@localhost named]# ps -aux  grep named<br>named     40086  0.0  1.1 160072 11736 ?        Ssl  22:07   0:00 &#x2F;usr&#x2F;sbin&#x2F;named -u named<br>root      40785  0.0  0.0 103324   864 pts&#x2F;0    S+   23:19   0:00 grep named</p>
<p>[root@localhost named]# ll &#x2F;etc&#x2F;named.conf<br>-rw-r—–. 1 root named 1004 6月  20 22:23 &#x2F;etc&#x2F;named.conf</p>
<p>[root@localhost named]# id named<br>uid&#x3D;25(named) gid&#x3D;25(named) 组&#x3D;25(named)</p>
<p>[root@localhost named]# ll<br>总用量 32<br>drwxrwx—. 2 named named 4096 6月  20 21:45 data<br>drwxrwx—. 2 named named 4096 6月  20 21:45 dynamic<br>-rw-r—–. 1 root  named 3171 1月  11 22:12 named.ca<br>-rw-r—–. 1 root  named  152 12月 15 2009 named.empty<br>-rw-r—–. 1 root  named  152 6月  21 2007 named.localhost<br>-rw-r—–. 1 root  named  168 12月 15 2009 named.loopback<br>drwxrwx—. 2 named named 4096 5月  11 07:07 slaves<br>-rw-r–r–. 1 root  root   408 6月  20 22:53 code404.icu.zone</p>
<p>[root@localhost named]# chmod 640 code404.icu.zone<br>[root@localhost named]# chown :named code404.icu.zone</p>
<p>[root@localhost named]# ll<br>总用量 32<br>drwxrwx—. 2 named named 4096 6月  20 21:45 data<br>drwxrwx—. 2 named named 4096 6月  20 21:45 dynamic<br>-rw-r—–. 1 root  named 3171 1月  11 22:12 named.ca<br>-rw-r—–. 1 root  named  152 12月 15 2009 named.empty<br>-rw-r—–. 1 root  named  152 6月  21 2007 named.localhost<br>-rw-r—–. 1 root  named  168 12月 15 2009 named.loopback<br>drwxrwx—. 2 named named 4096 5月  11 07:07 slaves<br>-rw-r—–. 1 root  named  408 6月  20 22:53 code404.icu.zone</p>
<p><strong>重启生效</strong></p>
<p>[root@localhost ~]# service named restart<br>Stopping named: .                                          [  OK  ]<br>Starting named:                                            [  OK  ]</p>
<h1 id="使用dig命令来帮助我们验证信息"><a href="#使用dig命令来帮助我们验证信息" class="headerlink" title="使用dig命令来帮助我们验证信息"></a>使用dig命令来帮助我们验证信息</h1><h1 id="因为之前的配置，这里会进行轮询操作"><a href="#因为之前的配置，这里会进行轮询操作" class="headerlink" title="因为之前的配置，这里会进行轮询操作"></a>因为之前的配置，这里会进行轮询操作</h1><p>[root@localhost ~]# dig -t A code404.icu @172.16.242.178</p>
<h3 id="5-反向区域"><a href="#5-反向区域" class="headerlink" title="5. 反向区域"></a>5. 反向区域</h3><hr>
<p>反向解析和正向解析各为独立的系统，所以可以部署在不同的或者是相同的机器之上，都是可以</p>
<ul>
<li>一个区域只能有一个主服务器，无论是正向还是反向</li>
<li>一个主服务器可以有多个从服务器</li>
</ul>
<p>根据配置文件中定义的主机地址，来确定网络地址</p>
<ul>
<li>如果都为172.16.100内的主机，那么网络地址就是172.16.100.</li>
<li>存在多种地址，如172.16.100.12、172.16.200.121等，那么网络地址就是172.16.</li>
<li>以此类推</li>
</ul>
<h4 id="什么是反向区域"><a href="#什么是反向区域" class="headerlink" title="什么是反向区域"></a>什么是反向区域</h4><p>不变的部分用来当做区域名称，变化的部分用来当做实现解析时候的name</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>区域名称：网络地址反写.in-addr.arpa.<br>如172.16.100. &#x3D;&#x3D;&gt; 100.16.172.in-addr.arpa.</p>
<h4 id="如何定义反向区域"><a href="#如何定义反向区域" class="headerlink" title="如何定义反向区域"></a>如何定义反向区域</h4><ol>
<li>定义区域</li>
</ol>
<p># file同样是一个相对路径，&#x2F;var&#x2F;named&#x2F;</p>
<h1 id="如果有多个正向域对应同一个网络的话，多个区域就重名了，所以这里的网络地址其实自己可以随意定义，如”网络地址1-zone”、”网络地址2-zone”等"><a href="#如果有多个正向域对应同一个网络的话，多个区域就重名了，所以这里的网络地址其实自己可以随意定义，如”网络地址1-zone”、”网络地址2-zone”等" class="headerlink" title="如果有多个正向域对应同一个网络的话，多个区域就重名了，所以这里的网络地址其实自己可以随意定义，如”网络地址1.zone”、”网络地址2.zone”等"></a>如果有多个正向域对应同一个网络的话，多个区域就重名了，所以这里的网络地址其实自己可以随意定义，如”网络地址1.zone”、”网络地址2.zone”等</h1><h1 id="如果只有一个反向区域的话，就只需要书写一个反向解析库，就可以”网络地址-zone”这样命名了"><a href="#如果只有一个反向区域的话，就只需要书写一个反向解析库，就可以”网络地址-zone”这样命名了" class="headerlink" title="如果只有一个反向区域的话，就只需要书写一个反向解析库，就可以”网络地址.zone”这样命名了"></a>如果只有一个反向区域的话，就只需要书写一个反向解析库，就可以”网络地址.zone”这样命名了</h1><p>zone “ZONE_NAME” IN {<br>type {masterslaveforward}；<br>file “网络地址.zone”；<br>};</p>
<p># 因为172.16.242.178和我们的其他服务器(172.16.100.12&#x2F;172.16.100.11),所以只能写成”16.172.in-addr.arpa”和”172.16.zone”</p>
<h1 id="最后添加如下内容"><a href="#最后添加如下内容" class="headerlink" title="最后添加如下内容"></a>最后添加如下内容</h1><p>[root@localhost ~]# vim &#x2F;etc&#x2F;named.rfc1912.zones<br>zone “16.172.in-addr.arpa” IN {<br>type master；<br>file “172.16.zone”；<br>};</p>
<ol start="2">
<li>区域解析库文件</li>
</ol>
<ul>
<li>以PTR记录为主</li>
<li>不需要MX和A以及AAAA记录</li>
</ul>
<p># $TTL表示宏定义的TTL值</p>
<h1 id="ORIGIN这里表示反向区域的名称"><a href="#ORIGIN这里表示反向区域的名称" class="headerlink" title="$ORIGIN这里表示反向区域的名称"></a>$ORIGIN这里表示反向区域的名称</h1><h1 id="反向的主机名称不能省略"><a href="#反向的主机名称不能省略" class="headerlink" title="反向的主机名称不能省略"></a>反向的主机名称不能省略</h1><h1 id="这里的11和12会自动补充上16-172-in-addr-arpa"><a href="#这里的11和12会自动补充上16-172-in-addr-arpa" class="headerlink" title="这里的11和12会自动补充上16.172.in-addr.arpa."></a>这里的11和12会自动补充上16.172.in-addr.arpa.</h1><h1 id="别名记录不用反解，所以ftp没有书写反向解析"><a href="#别名记录不用反解，所以ftp没有书写反向解析" class="headerlink" title="别名记录不用反解，所以ftp没有书写反向解析"></a>别名记录不用反解，所以ftp没有书写反向解析</h1><h1 id="这里可以使用vim-o-code404-icu-zone-16-172-zone来同时编辑两个文件的"><a href="#这里可以使用vim-o-code404-icu-zone-16-172-zone来同时编辑两个文件的" class="headerlink" title="这里可以使用vim -o code404.icu.zone 16.172.zone来同时编辑两个文件的"></a>这里可以使用vim -o code404.icu.zone 16.172.zone来同时编辑两个文件的</h1><p>[root@localhost ~]# cd &#x2F;var&#x2F;named&#x2F;<br>[root@localhost named]# vim 100.16.zone<br>$TTL 86400<br>$ORIGIN 16.172.in-addr.arpa.<br>@IN  SOAns1.code404.icu. admin.code404.icu. (<br>  2016042201<br>  1H<br>  5M<br>  7D<br>  1D )<br>IN  NSns1.code404.icu.<br>IN    NSns2.code404.icu.<br>11.100IN  PTRns1.code404.icu.<br>11.100IN  PTR<a href="http://www.code404.icu/">www.code404.icu</a>.<br>12.100IN  PTRmx1.code404.icu.<br>12.100IN  PTR<a href="http://www.code404.icu/">www.code404.icu</a>.<br>13.100IN  PTRmx2.code404.icu.</p>
<p># 反向解析如果没有$ORIGIN的情况下，也可以这样写<br>[root@localhost named]# vim 100.16.zone<br>$TTL 86400<br>@IN  SOAns1.code404.icu. admin.code404.icu. (<br>  2016042201<br>  1H<br>  5M<br>  7D<br>  1D )<br>16.172.in-addr.arpa.IN  NSns1.code404.icu.<br>IN    NSns2.code404.icu.<br>11.100IN  PTRns1.code404.icu.<br>11.100IN  PTR<a href="http://www.code404.icu/">www.code404.icu</a>.<br>12.100IN  PTRmx1.code404.icu.<br>12.100IN  PTR<a href="http://www.code404.icu/">www.code404.icu</a>.<br>13.100IN  PTRmx2.code404.icu.</p>
<ol start="3">
<li>修改权限并重启</li>
</ol>
<p>[root@localhost named]# chmod 640 16.172.zone<br>[root@localhost named]# chmod :named 16.172.zone</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>[root@localhost named]# named-checkconf<br>[root@localhost named]# named-checkzone “16.172.inaddr-addr” 16.172.zone<br>ok<br>[root@localhost named]# service named reload</p>
<h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>[root@localhost named]# host -t PRT 172.16.100.12 172.16.242.178<br>[root@localhost named]# dig -x 172.16.100.12 @172.16.242.178</p>
<h3 id="6-从-DNS-名称服务器配置"><a href="#6-从-DNS-名称服务器配置" class="headerlink" title="6. 从 DNS 名称服务器配置"></a>6. 从 DNS 名称服务器配置</h3><p>定义从 DNS 服务器就是在缓存服务器的基础上，进行修改配置</p>
<ul>
<li>在&#x2F;etc&#x2F;named.rfc1912.zones添加zone记录</li>
</ul>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ol>
<li>应该为一台独立的名称服务器</li>
<li>主服务器的区域解析库文件中必须有一条 NS 记录是指向从服务器</li>
<li>从服务器只需要定义区域，而无须提供解析库文件；解析库文件应该放置于&#x2F;var&#x2F;named&#x2F;slaves&#x2F;目录中</li>
<li>主服务器得允许从服务器作区域传送</li>
<li>主从服务器时间应该同步，可通过ntp进行</li>
<li>bind程序的版本应该保持一致；否则，应该从高逐低</li>
</ol>
<h4 id="定义从区域的方法"><a href="#定义从区域的方法" class="headerlink" title="定义从区域的方法"></a>定义从区域的方法</h4><ul>
<li>正向从服务器格式</li>
</ul>
<p># 从服务器同步主服务器的解析文件会放在&#x2F;var&#x2F;named&#x2F;slaves&#x2F;中<br>zone “ZONE_NAME” IN {<br>type slave;<br>masters { MASTER_IP; };<br>file “slaves&#x2F;ZONE_NAME.zone”;<br>};</p>
<ul>
<li>反向从服务器格式</li>
</ul>
<p># 从服务器同步主服务器的解析文件会放在&#x2F;var&#x2F;named&#x2F;slaves&#x2F;中<br>zone “Reverse_Net_Addr.in-addr.arpa” IN {<br>type master;<br>file “SOMEFILE.zone”;<br>};</p>
<ul>
<li>正向从服务器的实例</li>
</ul>
<p># 注意这里的从DNS服务器，需要在主DNS服务器中定义上NS记录</p>
<h1 id="这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的"><a href="#这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的" class="headerlink" title="这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的"></a>这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的</h1><p>[root@localhost ~]# vim &#x2F;etc&#x2F;named.rfc1912.zones<br>zone “code404.icu” IN {<br>type slave;<br>masters { 172.16.242.178; };<br>file “slaves&#x2F;code404.icu.zone”;<br>};</p>
<h1 id="重起服务即可成效"><a href="#重起服务即可成效" class="headerlink" title="重起服务即可成效"></a>重起服务即可成效</h1><p>[root@localhost ~]# rndc reload</p>
<h1 id="可以通过log进行查看"><a href="#可以通过log进行查看" class="headerlink" title="可以通过log进行查看"></a>可以通过log进行查看</h1><p>[root@localhost ~]# tail &#x2F;var&#x2F;log&#x2F;messages</p>
<ul>
<li>反向从服务器的实例</li>
</ul>
<p># 注意这里的从DNS服务器，需要在主DNS服务器中定义上NS记录</p>
<h1 id="这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的-1"><a href="#这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的-1" class="headerlink" title="这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的"></a>这样才能在主DNS的解析库发生改变的时候通知从DNS服务器进行同步，否则不会同步的</h1><p>[root@localhost ~]# vim &#x2F;etc&#x2F;named.rfc1912.zones<br>zone “16.172.in-addr.arpa” IN {<br>type slave;<br>masters { 172.16.242.178; };<br>file “slaves&#x2F;172.16.zone”;<br>};</p>
<h1 id="重起服务即可成效-1"><a href="#重起服务即可成效-1" class="headerlink" title="重起服务即可成效"></a>重起服务即可成效</h1><p>[root@localhost ~]# rndc reload</p>
<h1 id="可以通过log进行查看-1"><a href="#可以通过log进行查看-1" class="headerlink" title="可以通过log进行查看"></a>可以通过log进行查看</h1><p>[root@localhost ~]# tail &#x2F;var&#x2F;log&#x2F;messages</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>DNS</category>
        <category>BIND</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>Bind</tag>
        <tag>DNS解析</tag>
        <tag>named</tag>
        <tag>nslookup</tag>
        <tag>解析配置</tag>
      </tags>
  </entry>
  <entry>
    <title>内网DNS服务安装使用系列教程（二）常用命令</title>
    <url>/2021/09/05/%E5%86%85%E7%BD%91dns%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-3-1024x408.png"></p>
<h3 id="1-dig命令"><a href="#1-dig命令" class="headerlink" title="1. dig命令"></a>1. dig命令</h3><hr>
<p>dig用于测试dns系统，因此不会查询hosts文件进行解析</p>
<ul>
<li>用于询问 DNS 域名服务器的灵活的工具</li>
<li>除非被告知请求特定域名服务器，dig将尝试 &#x2F;etc&#x2F;resolv.conf中列举的任何服务器</li>
<li>当未指定任何命令行参数或选项时，dig将对.（根）执行NS查询</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>dig [-t type] name [@SERVER] [query options]</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>类型查询</li>
</ul>
<p>dig -t NS code404.icu @140.205.41.23<br>dig -t MS code404.icu @140.205.41.23<br>dig -t A <a href="http://www.code404.icu/">www.code404.icu</a></p>
<ul>
<li>查询选项</li>
</ul>
<p>+[no]trace：跟踪解析过程<br>+[no]recurse：进行递归解析</p>
<ul>
<li>测试反向解析：</li>
</ul>
<p>dig -x IP @SERVER<br>dig -x 172.16.100.11 @172.16.242.178</p>
<ul>
<li>模拟区域传送：</li>
</ul>
<p>dig -t axfr ZONE_NAME @SERVER<br>dig -t axfr code404.icu @106.11.141.113</p>
<h3 id="2-host命令"><a href="#2-host命令" class="headerlink" title="2. host命令"></a>2. host命令</h3><hr>
<p><strong>host</strong>命令用于查询<strong>DNS</strong>的工具</p>
<ul>
<li>它通过常转换指定主机名称的主机名称为 IP 地址</li>
<li>当不指定参数时，它显示host命令的帮助信息</li>
</ul>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><p>host [-t type] name [SERVER]</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li>-a 等同于-v -t</li>
<li>-C 在需要认证的域名服务器上查找 SOA 记录</li>
<li>-l 列出一个域内所有的主机</li>
<li>-i 反向查找</li>
<li>-r 不使用递归处理</li>
<li>-v 运行时显示详细的处理信息</li>
<li>-4 用于 IPv4 的查询</li>
<li>-6 用于 IPv6 的查询</li>
<li>-t &lt;类型&gt; 指定类型，包括a、all、mx、ns等</li>
</ul>
<h4 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h4><p>[root@localhost ~]# host -t A <a href="http://www.code404.icu/">www.code404.icu</a> 114.114.114.114<br>Using domain server:<br>Name: 114.114.114.114<br>Address: 114.114.114.114#53<br>Aliases: </p>
<p><a href="http://www.code404.icu/">www.code404.icu</a> has address 182.92.75.185</p>
<p>[root@localhost ~]# host –help<br>host: illegal option – -<br>Usage: host [-aCdlriTwv] [-c class] [-N ndots] [-t type] [-W time]<br>            [-R number] [-m flag] hostname [server]<br>       -a is equivalent to -v -t ANY<br>       -c specifies query class for non-IN data<br>       -C compares SOA records on authoritative nameservers<br>       -d is equivalent to -v<br>       -l lists all hosts in a domain, using AXFR<br>       -i IP6.INT reverse lookups<br>       -N changes the number of dots allowed before root lookup is done<br>       -r disables recursive processing<br>       -R specifies number of retries for UDP packets<br>       -s a SERVFAIL response should stop query<br>       -t specifies the query type<br>       -T enables TCP&#x2F;IP mode<br>       -v enables verbose output<br>       -w specifies to wait forever for a reply<br>       -W specifies how long to wait for a reply<br>       -4 use IPv4 query transport only<br>       -6 use IPv6 query transport only<br>       -m set memory debugging flag (tracerecordusage)</p>
<h3 id="3-nslookup命令"><a href="#3-nslookup命令" class="headerlink" title="3. nslookup命令"></a>3. nslookup命令</h3><hr>
<p>nslookup 命令用于查找域名服务器的程序，有两种模式为互交和非互交</p>
<h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><p>nslookup [-option] [name  -] [server]</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><ul>
<li>非交互模式</li>
<li>直接查询即可</li>
<li>交互式模式</li>
</ul>
<p>nslookup&gt;<br>server IP: 指明使用哪个DNS server进行查询；<br>set q&#x3D;RR_TYPE: 指明查询的资源记录类型；<br>NAME: 要查询的名称；</p>
<h4 id="实例展示-1"><a href="#实例展示-1" class="headerlink" title="实例展示"></a>实例展示</h4><p>[root@k8s-master01 ~]# nslookup </p>
<blockquote>
<p>server 114.114.114.114<br>Default server: 114.114.114.114<br>Address: 114.114.114.114#53<br>set q&#x3D;A<br><a href="http://www.code404.icu/">www.code404.icu</a><br>Server:114.114.114.114<br>Address:114.114.114.114#53</p>
</blockquote>
<p>Non-authoritative answer:<br>Name:<a href="http://www.code404.icu/">www.code404.icu</a><br>Address: 182.92.75.185</p>
<blockquote>
<p>set q&#x3D;NS<br>code404.icu<br>Server:114.114.114.114<br>Address:114.114.114.114#53</p>
</blockquote>
<p>Non-authoritative answer:<br>code404.icunameserver &#x3D; dns2.hichina.com.<br>code404.icunameserver &#x3D; dns1.hichina.com.</p>
<p>Authoritative answers can be found from:</p>
<p># 非交互模式查询<br>[root@k8s-master01 ~]# nslookup code404.icu<br>Server:172.17.0.14<br>Address:172.17.0.14#53</p>
<p>Non-authoritative answer:<br>Name:code404.icu<br>Address: 182.92.75.185</p>
<p># 非交互模式查询<br>[root@k8s-master01 ~]# nslookup </p>
<blockquote>
<p><a href="http://www.code404.icu/">www.code404.icu</a><br>Server:172.17.0.14<br>Address:172.17.0.14#53</p>
</blockquote>
<p>Non-authoritative answer:     #非权威答案，表明是在缓存中读取的<br>Name:<a href="http://www.code404.icu/">www.code404.icu</a><br>Address: 182.92.75.185       #返回第一个IP地址</p>
<blockquote>
<p>server 8.8.8.8              #设置域名服务器为 8.8.8.8<br>Default server: 8.8.8.8<br>Address: 8.8.8.8#53<br><a href="http://www.baidu.com/">www.baidu.com</a><br><a href="http://www.code404.icu/">www.code404.icu</a>               #再次请求码404的IP地址<br>Server:8.8.8.8<br>Address:8.8.8.8#53</p>
</blockquote>
<p>Non-authoritative answer:<br>Name:<a href="http://www.code404.icu/">www.code404.icu</a><br>Address: 182.92.75.185      #不同的DNS获取的IP地址是不同的。</p>
<h3 id="4-rndc命令"><a href="#4-rndc命令" class="headerlink" title="4. rndc命令"></a>4. rndc命令</h3><hr>
<p>rndc客户端是通过建立套接字连接服务端，监听在TCP的953端口，来对服务端的named进行修改操作，但由于安全考虑，所以rndc的客户端和服务端安装在同一台主机之上。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法 1"></a>语法 1</h4><ul>
<li><strong>-b</strong> source-address 使用 source-address 作为连接服务器的源地址允许多个实例设置 IPv4 和 IPv6 源地址</li>
<li><strong>-c</strong> config-file 使用config-file 作为缺省的配置文件&#x2F;etc&#x2F;rndc.conf 的替代</li>
<li><strong>-k</strong> key-file 使用 key-file 作为缺省的密钥文件&#x2F;etc&#x2F;rndc.key 的替代 如果config-file 不存在，&#x2F;etc&#x2F;rndc.key 中的密钥将用于认证发向服务器的命令</li>
<li><strong>-s</strong> server server 是与rndc的配置文件中server语句匹配的服务器的名字或地址 如果命令行没有提供服务器，会使用rndc配置文件中options语句中的default-server子句所命名的主机</li>
<li><strong>-p</strong> port 发送命令到TCP端口port，以取代BIND 9的缺省控制通道端口 953</li>
<li><strong>-V</strong> 打开冗余日志</li>
<li><strong>-y</strong> key_id 使用配置文件中的密钥key_id</li>
</ul>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法 2"></a>语法 2</h4><ul>
<li><strong>reload</strong> 重载主配置文件和区域解析库文件</li>
<li><strong>reload zone</strong> 重载区域解析库文件</li>
<li><strong>refresh zone</strong> 安排区域的立即维护</li>
<li><strong>retransfer zone</strong> 手动启动区域传送过程，而不管序列号是否增加</li>
<li><strong>notify zone</strong> 重新对区域传送发通知</li>
<li><strong>reconfig</strong> 重载主配置文件</li>
<li><strong>status</strong> 将服务器统计信息写入统计文件中</li>
<li><strong>querylog</strong> 开启或关闭查询日志<br>建议调试的时候开启，否则日志消耗太多性能</li>
<li><strong>dumpdb</strong> 将高速缓存转储到转储文件 (named_dump.db)</li>
<li><strong>stop</strong> 将暂挂更新保存到主文件并停止服务器</li>
<li><strong>halt</strong> 停止服务器，但不保存暂挂更新</li>
<li><strong>trace</strong> 将调试级别增加一级<br>建议调试的时候开启，否则日志消耗太多性能</li>
<li><strong>trace level</strong> 更改调试级别</li>
<li><strong>notrace</strong> 将调试级别设置为0</li>
<li><strong>flush</strong> 刷新服务器的所有高速缓存</li>
<li><strong>status</strong> 显示服务器的状态</li>
<li><strong>restart</strong> 重新启动服务器</li>
</ul>
<h4 id="实例展示-2"><a href="#实例展示-2" class="headerlink" title="实例展示"></a>实例展示</h4><p># rndc工具能够帮助我们输出系统信息<br>[root@localhost ~]# rndc status<br>version: 9.8.2rc1-RedHat-9.8.2-0.47.rc1.el6<br>CPUs found: 1<br>worker threads: 1<br>number of zones: 20<br>debug level: 0<br>xfers running: 0<br>xfers deferred: 0<br>soa queries in progress: 0<br>query logging is OFF<br>recursive clients: 0&#x2F;0&#x2F;1000<br>tcp clients: 0&#x2F;100<br>server is up and running</p>
<h1 id="rndc不重启加载区域文件"><a href="#rndc不重启加载区域文件" class="headerlink" title="rndc不重启加载区域文件"></a>rndc不重启加载区域文件</h1><p>[root@localhost ~]# rndc reload</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>常用命令</tag>
        <tag>nslookup</tag>
        <tag>dig</tag>
        <tag>host</tag>
        <tag>rndc</tag>
      </tags>
  </entry>
  <entry>
    <title>内网DNS服务安装使用系列教程（四）高级功能之编译安装BIND服务</title>
    <url>/2021/09/07/%E5%86%85%E7%BD%91dns%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%BC%96/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-5.png"></p>
<h3 id="最小化安装机器"><a href="#最小化安装机器" class="headerlink" title="最小化安装机器"></a>最小化安装机器</h3><hr>
<p>[root@localhost ~]# yum  groupinstall “Development Tools” “Server Platform Development”</p>
<h3 id="去官网isc-org下载安装包，bind-9-10-1-P1-tar-gz"><a href="#去官网isc-org下载安装包，bind-9-10-1-P1-tar-gz" class="headerlink" title="去官网isc.org下载安装包，bind-9.10.1-P1.tar.gz"></a>去官网isc.org下载安装包，bind-9.10.1-P1.tar.gz</h3><hr>
<p>bind9和bind10的区别很大，而且bind10还在测试阶段<br>创建named用户和组<br>安装在同一目录下&#x2F;usr&#x2F;local&#x2F;bind9，系统文件放在&#x2F;etc&#x2F;named&#x2F;<br>禁用IPv6功能，禁用chroot功能，启动线程多核工作</p>
<h3 id="自己手动编译安装bind可能会出现的问题"><a href="#自己手动编译安装bind可能会出现的问题" class="headerlink" title="自己手动编译安装bind可能会出现的问题"></a>自己手动编译安装bind可能会出现的问题</h3><hr>
<p>（1）在&#x2F;etc&#x2F;named&#x2F;没有配置文件或者为空，需要自己创建<br>（2）没有任何区域解析库文件，即&#x2F;var&#x2F;named，所以也没有13个根节点，需要自己创建<br>（3）没有rndc的配置文件，需要自己创建<br>（4）没有启动脚本，没有&#x2F;etc&#x2F;init.d&#x2F;named文件<br>这里由于自定义安装到了&#x2F;usr&#x2F;local&#x2F;bind9中，所以像dig、host等工具不能直接调用，需要完整路径</p>
<p>[root@localhost ~]# tar xf bind-9.10.1-P1.tar.gz<br>[root@localhost ~]# cd bind-9.10.1-P1<br>[root@localhost ~]# groupadd -r -g 53 named<br>[root@localhost ~]# useradd -r -u 53 -g 53 named<br>[root@localhost ~]# .&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;bind9 –sysconfdir&#x3D;&#x2F;etc&#x2F;named&#x2F; –disable-ipv6 –disable-chroot –enable-threads<br>[root@localhost ~]# make<br>[root@localhost ~]# make install</p>
<h3 id="添加环境变量，就可以调用相关命令"><a href="#添加环境变量，就可以调用相关命令" class="headerlink" title="添加环境变量，就可以调用相关命令"></a>添加环境变量，就可以调用相关命令</h3><hr>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;profile.d&#x2F;named.sh<br>export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bind9&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bind9&#x2F;sbin:$PATH<br>[root@localhost ~]# . &#x2F;etc&#x2F;profile.d&#x2F;named.sh</p>
<h3 id="导出库文件"><a href="#导出库文件" class="headerlink" title="导出库文件"></a>导出库文件</h3><hr>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;ld.so.conf.d&#x2F;named.conf<br>&#x2F;usr&#x2F;loacl&#x2F;bind9&#x2F;lib</p>
<h3 id="重新载入库文件"><a href="#重新载入库文件" class="headerlink" title="重新载入库文件"></a>重新载入库文件</h3><hr>
<p>[root@localhost ~]# ldconfig -v</p>
<h3 id="如果有头文件，导出头文件"><a href="#如果有头文件，导出头文件" class="headerlink" title="如果有头文件，导出头文件"></a>如果有头文件，导出头文件</h3><hr>
<p>[root@localhost ~]# ln -sv &#x2F;usr&#x2F;local&#x2F;bind9&#x2F;include &#x2F;usr&#x2F;include&#x2F;named</p>
<h3 id="之后就可以使用-x2F-usr-x2F-include-x2F-named来访问-x2F-usr-x2F-local-x2F-bind9-x2F-中的头文件了"><a href="#之后就可以使用-x2F-usr-x2F-include-x2F-named来访问-x2F-usr-x2F-local-x2F-bind9-x2F-中的头文件了" class="headerlink" title="之后就可以使用&#x2F;usr&#x2F;include&#x2F;named来访问&#x2F;usr&#x2F;local&#x2F;bind9&#x2F;中的头文件了"></a>之后就可以使用&#x2F;usr&#x2F;include&#x2F;named来访问&#x2F;usr&#x2F;local&#x2F;bind9&#x2F;中的头文件了</h3><hr>
<p>[root@localhost ~]# ls &#x2F;usr&#x2F;include&#x2F;named</p>
<h3 id="在-x2F-usr-x2F-local-x2F-bind9-x2F-下有share的帮助文件，添加MANPATH将其放入man中"><a href="#在-x2F-usr-x2F-local-x2F-bind9-x2F-下有share的帮助文件，添加MANPATH将其放入man中" class="headerlink" title="在&#x2F;usr&#x2F;local&#x2F;bind9&#x2F;下有share的帮助文件，添加MANPATH将其放入man中"></a>在&#x2F;usr&#x2F;local&#x2F;bind9&#x2F;下有share的帮助文件，添加MANPATH将其放入man中</h3><hr>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;man.conf<br>MANPATH &#x2F;usr&#x2F;local&#x2F;bind9&#x2F;share&#x2F;man</p>
<h3 id="添加主配置文件，这里只添加directory就可以了"><a href="#添加主配置文件，这里只添加directory就可以了" class="headerlink" title="添加主配置文件，这里只添加directory就可以了"></a>添加主配置文件，这里只添加directory就可以了</h3><hr>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;named&#x2F;named.conf<br>option  {<br>directory “&#x2F;var&#x2F;named”<br>};</p>
<p>zone  “.”  IN  {<br>type hint;<br>file “named.ca”;<br>};</p>
<p>zone  “localhost”  IN  {<br>type master;<br>file “localhost.zone”;<br>allow-update { none; };<br>};</p>
<p>zone  “0.0.127.in-addr.arpa”  IN  {<br>type master;<br>file “named.local”;<br>allow-update { none; };<br>};</p>
<p>[root@localhost ~]# mkdir &#x2F;var&#x2F;named&#x2F;{named.ca, localhost.zone, named.local}</p>
<h3 id="使用dig命令来生成13个根节点，172-16-0-1为网关地址，可以帮助我们连接外网的地址，获取13个根节点"><a href="#使用dig命令来生成13个根节点，172-16-0-1为网关地址，可以帮助我们连接外网的地址，获取13个根节点" class="headerlink" title="使用dig命令来生成13个根节点，172.16.0.1为网关地址，可以帮助我们连接外网的地址，获取13个根节点"></a>使用dig命令来生成13个根节点，172.16.0.1为网关地址，可以帮助我们连接外网的地址，获取13个根节点</h3><hr>
<p>[root@localhost ~]# dig -t NS . @172.16.0.1 &gt; &#x2F;var&#x2F;named&#x2F;named.ca<br>[root@localhost ~]# vim &#x2F;var&#x2F;named&#x2F;localhost.zone<br>$TTL 1D<br>@    IN    SOA    localhost.    admin.localhost. (<br>  2016042201<br>  1H<br>  5M<br>  7D<br>  1D )<br>   IN    NS   localhost.<br>localhost.    IN    A    172.0.0.1</p>
<p>[root@localhost ~]# vim &#x2F;var&#x2F;named&#x2F;named.local<br>$TTL 1D<br>@    IN    SOA    localhost.    admin.localhost. (<br>  2016042201<br>  1H<br>  5M<br>  7D<br>  1D )<br>   IN    NS   localhost.<br>1    IN    PRT    localhost.</p>
<p>[root@localhost ~]# cd &#x2F;var&#x2F;named&#x2F;<br>[root@localhost named]# chmod 640 .&#x2F;*<br>[root@localhost named]# chown :named *<br>[root@localhost named]# chmod 640 &#x2F;etc&#x2F;named&#x2F;named.conf</p>
<h3 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h3><hr>
<p>[root@localhost ~]# man named</p>
<h3 id="启动named服务，调试"><a href="#启动named服务，调试" class="headerlink" title="启动named服务，调试"></a>启动named服务，调试</h3><hr>
<p>[root@localhost ~]# named -u named -f -g -d 3</p>
<h3 id="启动named服务，不调试"><a href="#启动named服务，不调试" class="headerlink" title="启动named服务，不调试"></a>启动named服务，不调试</h3><hr>
<p>[root@localhost ~]# named -u named</p>
<h3 id="查看是否启动"><a href="#查看是否启动" class="headerlink" title="查看是否启动"></a>查看是否启动</h3><hr>
<p>[root@localhost ~]# ss -tunl named  grep :53</p>
<h3 id="关闭named服务"><a href="#关闭named服务" class="headerlink" title="关闭named服务"></a>关闭named服务</h3><hr>
<p>[root@localhost ~]# killall named</p>
<h3 id="添加解析区域"><a href="#添加解析区域" class="headerlink" title="添加解析区域"></a>添加解析区域</h3><hr>
<p>[root@localhost ~]# vim &#x2F;etc&#x2F;named&#x2F;named.conf<br>zone  “wsescape.com”  IN  {<br>type master;<br>file “wsescape.com.zone”;<br>allow-update { none; };<br>};</p>
<p>[root@localhost ~]# vim &#x2F;var&#x2F;named&#x2F;wsescape.com.zone<br>$TTL 1D<br>$ORIGIN wsescape.com.<br>@    IN    SOA    ns.wsescape.com.    admin.wsescape.com. (<br>  2016042201<br>  1H<br>  5M<br>  7D<br>  1D )<br>   IN    NS   ns<br>ns     IN    A    172.16.100.11<br>www    IN    A    172.16.100.11</p>
<p>[root@localhost named]# chmod 640 wsescape.com.zone<br>[root@localhost named]# chown :named wsescape.com.zone</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><hr>
<p>[root@localhost named]# named -u named</p>
<h3 id="解析正常"><a href="#解析正常" class="headerlink" title="解析正常"></a>解析正常</h3><hr>
<p>[root@localhost named]# dig -t A <a href="http://www.wsescape.com/">www.wsescape.com</a> @172.16.100.11</p>
<p>当我们使用<strong>rndc reload</strong>的时候，会提示我们没有配置文件<br>想让<strong>rndc</strong>可用，使用<strong>rndc-confgen</strong>来生成配置文件<br>如果使用<strong>rndc-confgen</strong>发生堵塞，可以使用<strong>rndc-confgen -r &#x2F;dev&#x2F;urandom</strong>来生成随机数<br>用<strong>rndc-confgen</strong>生成的文件，将#Start和#End之间的配置文件放到**&#x2F;etc&#x2F;named&#x2F;rndc.conf**中，之后根据提示将后续的内容放到&#x2F;etc&#x2F;named&#x2F;named.conf中</p>
<p>[root@localhost ~]# rndc-confgen</p>
<h1 id="Start-of-rndc-conf"><a href="#Start-of-rndc-conf" class="headerlink" title="Start of rndc.conf"></a>Start of rndc.conf</h1><p>key “rndc-key” {<br>algorithm hmac-md5;<br>secret “ZeE7NXZTprjARrGN&#x2F;KRANQ&#x3D;&#x3D;”;<br>};</p>
<p>options {<br>default-key “rndc-key”;<br>default-server 127.0.0.1;<br>default-port 953;<br>};</p>
<h1 id="End-of-rndc-conf"><a href="#End-of-rndc-conf" class="headerlink" title="End of rndc.conf"></a>End of rndc.conf</h1><h1 id="Use-with-the-following-in-named-conf-adjusting-the-allow-list-as-needed"><a href="#Use-with-the-following-in-named-conf-adjusting-the-allow-list-as-needed" class="headerlink" title="Use with the following in named.conf, adjusting the allow list as needed:"></a>Use with the following in named.conf, adjusting the allow list as needed:</h1><h1 id="key-“rndc-key”"><a href="#key-“rndc-key”" class="headerlink" title="key “rndc-key” {"></a>key “rndc-key” {</h1><p>#algorithm hmac-md5;<br>#secret “ZeE7NXZTprjARrGN&#x2F;KRANQ&#x3D;&#x3D;”;</p>
<h1 id=""><a href="#" class="headerlink" title="};"></a>};</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="controls"><a href="#controls" class="headerlink" title="controls {"></a>controls {</h1><p>#inet 127.0.0.1 port 953<br>#allow { 127.0.0.1; } keys { “rndc-key”; };</p>
<h1 id="-2"><a href="#-2" class="headerlink" title="};"></a>};</h1><h1 id="End-of-named-conf"><a href="#End-of-named-conf" class="headerlink" title="End of named.conf"></a>End of named.conf</h1><h1 id="现在rndc-reload可以使用了"><a href="#现在rndc-reload可以使用了" class="headerlink" title="现在rndc reload可以使用了"></a>现在rndc reload可以使用了</h1><p>[root@localhost ~]# rndc reload</p>
<h1 id="之后就只需要给提供一个脚本来像service一样，启动和关闭服务，不难的"><a href="#之后就只需要给提供一个脚本来像service一样，启动和关闭服务，不难的" class="headerlink" title="之后就只需要给提供一个脚本来像service一样，启动和关闭服务，不难的"></a>之后就只需要给提供一个脚本来像service一样，启动和关闭服务，不难的</h1><p>编译安装，在<strong>bind-9.10.1-P1</strong>源码目录下，有一个<strong>contrib</strong>目录<br>其中包含的是第三方贡献的补充增强<strong>bind</strong>的功能<br>其中有一个目录为<strong>scripts</strong>包含一些脚本，我们可以参考</p>
<p>还有一个目录为<strong>queryperf</strong>来评估查询性能的，做压测的，需要编译安装才能使用<br>编译安装<strong>queryperf</strong>，只需要在其目录下执行 <strong>.&#x2F;configure和make</strong> 即可完成<br>就会生成一个<strong>queryperf</strong>的可执行文件，执行下列操作就可以直接使用了</p>
<p>[root@localhost queryperf]# cp queryperf &#x2F;usr&#x2F;local&#x2F;bind9&#x2F;bin&#x2F;</p>
<h1 id="在测试的时候，需要指定一个测试的文件，如test"><a href="#在测试的时候，需要指定一个测试的文件，如test" class="headerlink" title="在测试的时候，需要指定一个测试的文件，如test"></a>在测试的时候，需要指定一个测试的文件，如test</h1><p>[root@localhost ~]# vim test<br><a href="http://www.wsescape.com/">www.wsescape.com</a> A<br>wsescape.com NS</p>
<p>[root@localhost ~]# queryperf -d test -s 172.16.100.11</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>DNS</category>
        <category>BIND</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>安装</tag>
        <tag>Bind</tag>
        <tag>named</tag>
        <tag>bind9</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透_FRP代理工具内网渗透教程</title>
    <url>/2021/08/19/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-frp%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-16.png"></p>
<h3 id="FRP工具介绍"><a href="#FRP工具介绍" class="headerlink" title="FRP工具介绍"></a>FRP工具介绍</h3><hr>
<p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持TCP、UDP协议，为HTTP和HTTPS应用协议提供了额外的能力，且尝试性支持了点对点穿透。frp 采用go语言开发。更多的人使用 frp 是为了进行反向代理，满足通过公网服务器访问处于内网的服务，如访问内网web服务，远程ssh内网服务器，远程控制内网NAS等，实现类似花生壳、ngrok等功能。而对于内网渗透来讲，这种功能恰好能够满足我们进行内网渗透的流量转发。FRP最大的一个特点是使用SOCKS代理，而SOCKS是加密通信的，类似于做了一个加密的隧道，可以把外网的流量，通过加密隧道穿透到内网。效果有些类似于VPN。</p>
<h3 id="为什么使用FRP"><a href="#为什么使用FRP" class="headerlink" title="为什么使用FRP"></a>为什么使用FRP</h3><hr>
<p>FRP通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p>
<ul>
<li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li>
<li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li>
<li>代理组间的负载均衡。</li>
<li>端口复用，多个服务通过同一个服务端端口暴露。</li>
<li>多个原生支持的客户端插件(静态文件查看，HTTP、SOCK5 代理等)，便于独立使用 frp 客户端完成某些工作。</li>
<li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li>
<li>服务端和客户端 UI 页面。</li>
</ul>
<p>下面提供FRP工具的下载和官方使用文档：</p>
<p>FRP官方文档:<a href="https://gofrp.org/docs">https://gofrp.org/docs</a><br>FRP下载地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>
<h3 id="FRP配置文件（Windows-amp-Linux）"><a href="#FRP配置文件（Windows-amp-Linux）" class="headerlink" title="FRP配置文件（Windows&amp;Linux）"></a>FRP配置文件（Windows&amp;Linux）</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/dc1f5cd079d542f2aae72b2459545fb9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<p><img src="https://img-blog.csdnimg.cn/862b6913a6684357b7c38044e8f31d8a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="实战环境"><a href="#实战环境" class="headerlink" title="实战环境"></a>实战环境</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/86d546dba751483a875374007d52dc17.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<pre><code>攻击机：Windows10

 IP地址：192.168.92.11

FRPS服务器端：Windows Server 2016
公网IP：42.1X2.204.XX
靶机：windows server2008
FRPC客户端
IP：10.130.2.33
靶机内网存在多个服务器网段：
    10.130.1.0/16
    10.131.10.0/16
    10.133.3.0/24
    10.128.1.0/24 
</code></pre>
<h3 id="服务器端frps-ini的配置"><a href="#服务器端frps-ini的配置" class="headerlink" title="服务器端frps.ini的配置"></a>服务器端frps.ini的配置</h3><hr>
<p>[common]<br>bind_port &#x3D; 7000 #表示用于客户端和服务端连接的端口，这个端口号我们之后在配置客户端的时候要用到。<br>dashboard_port &#x3D; 7500 #是服务端仪表板的端口，若使用7500端口，在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为VPS的IP）查看frp服务运行信息。<br>token &#x3D; 815093110 #是用于客户端和服务端连接的口令，请自行设置并记录，稍后会用到。<br>dashboard_user &#x3D; bmzgaq<br>dashboard_pwd &#x3D; bmzgaq.com #此两项表示打开仪表板页面登录的用户名和密码，自行设置即可。<br>vhost_http_port &#x3D; 1080<br>vhost_https_port &#x3D; 10443 #此两项用于反向代理HTTP主机时使用，本文不涉及HTTP协议，因而照抄或者删除这两条均可</p>
<p><img src="https://img-blog.csdnimg.cn/7ee0802a3caa4f5f9989656f1deeaf30.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>配置好frps.ini文件后就可以在命令行运行frps了，在windows环境下命令行输入以下命令：</p>
<p>frps.exe -c frps.ini</p>
<p><img src="https://img-blog.csdnimg.cn/a12ab962469e49d69db31d9d8019b5c3.png" alt="在这里插入图片描述"></p>
<p>如果是linux环境的话则执行如下命令：</p>
<p>.&#x2F;frps -c frps.ini</p>
<p><img src="https://img-blog.csdnimg.cn/ee194c30d2484b5f8e3ac5e864bdbeeb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果看到屏幕输出内容如上，即表示运行正常，如果出现错误提示，请检查上面的步骤。没有问题的话，我们就可以访问使用浏览器访问42.1X2.204.XX:7500 并使用自己设置的用户名密码登录，即可看到仪表板界面。</p>
<p><img src="https://img-blog.csdnimg.cn/d7c43799e202447aa07562ccafdab156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来我们就要开始配置客户端了，我们将靶机内网的3389端口映射到frps服务器7333端口。到时候我们输入42.1X2.204.XX:7333就可以远程连接靶机的桌面了。</p>
<p>server_addr &#x3D; 42.1X2.204.XX #VPS服务器的IP<br>server_port &#x3D; 7000 #服务端服务器设置frps.ini中的端口<br>token &#x3D; 815093110 #服务端服务器设置frps.ini中的密码</p>
<p>[RDP] #服务器名（可以填写web、ssh、ftp等）<br>type &#x3D; tcp #连接协议类型<br>local_ip &#x3D; 127.0.0.1 #访问的ip可以是内网任何一个ip！<br>local_port &#x3D; 3389 #本地端口（根据协议修改）<br>remote_port &#x3D; 7333 #远程服务器的ip端口</p>
<p>配置好以上内容呢，我们就可以运行frpc客户端程序了。</p>
<p><img src="https://img-blog.csdnimg.cn/958b6de9f9fd405b8e8350e4b7bfbcf2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="实战渗透"><a href="#实战渗透" class="headerlink" title="实战渗透"></a>实战渗透</h3><hr>
<p>将如上工作配置好以后我们就可以直接在本地对靶机内网进行渗透了！例如我们直接远程登录到靶机，打开mstsc，输入frps的公网地址:映射的内网端口。</p>
<p><img src="https://img-blog.csdnimg.cn/2fcc0519934948e8905b1e78ead73c45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/cd1a6751d75f4c4e94e49215e95e8bda.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来我们就可以进行内网渗透啦</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>运维</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>FRP</tag>
        <tag>代理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>又拍云如何配置图片水印</title>
    <url>/2021/04/27/%E5%8F%88%E6%8B%8D%E4%BA%91%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/</url>
    <content><![CDATA[<p>为啥要配置图片水印，就俩原因<br>1、防盗链<br>一些小型网站空间不大，没地方放图片，还有很多网上的人想使用某一个大型网站的图片或是没地方上传图片。<br>因此，就会产生很多需要那个图片链接的要求。<br>于是，那个网站就会产生额外的负担，(这些负担对那些小型网站的负担尤其重哦。只要其中一些图片能被大型搜索引擎收录到，而没有做好防盗链工作，那他的网站恐怕就负荷不来了。)<br>2、声明版权，防伪<br>有很多图片的作者不想自己辛辛苦苦弄的图片那么容易就被别人使用了，(因为剽窃一张图片实在是太容易了，只要没加水印，他就可以说是他的图)，加了水印，就有效防止图片滥用。</p>
<p>我们来说一说使用又拍云存储图片时，如何给图片添加水印<br>这是我存在又拍云的一个图片 <a href="https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png">https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png</a><br><img src="https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png"><br>看到我的图片上有“码404 <a href="http://www.code404.icu”的水印字样/">www.code404.icu”的水印字样</a><br>根据又拍云官方 又拍云处理（图片处理）文案说明，可以加图片水印和文字水印</p>
<p>图片水印</p>
<p>参数</p>
<p>值</p>
<p>说明</p>
<p>&#x2F;watermark&#x2F;url&#x2F;<url></p>
<p>Base64 编码字符串</p>
<p>水印相对路径的 Base64 编码，相对路径包含 &#x2F;，比如 &#x2F;path&#x2F;to&#x2F;watermark.png。水印需要上传到待处理图片的服务下。详见[注]</p>
<p>&#x2F;align&#x2F;<align></p>
<p>位置，如 north</p>
<p><a href="https://help.upyun.com/knowledge-base/image/#align_gravity">水印图片放置方位，默认 northwest，详见方位说明</a></p>
<p>&#x2F;margin&#x2F;<x>x<y></p>
<p>横偏移x纵偏移，如 15×10</p>
<p>水印图片横纵相对偏移，默认 20x20</p>
<p>&#x2F;opacity&#x2F;<opacity></p>
<p>透明度，如 90</p>
<p>水印图片透明度，默认 100，取值范围 [0-100]，值越大越不透明，0 完全透明，100 完全不透明</p>
<p>&#x2F;percent&#x2F;<integer></p>
<p>百分比值，如 50</p>
<p>水印图片自适应原图短边的比例，默认 0，表示不设置该参数，详见[注]</p>
<p>&#x2F;repeat&#x2F;<boolean></p>
<p>TRUE</p>
<p>水印图片是否重复铺满原图，默认 false</p>
<p>&#x2F;animate&#x2F;<boolean></p>
<p>TRUE</p>
<p>允许对动态图片加水印，默认 false</p>
<p>文字水印</p>
<p>参数</p>
<p>值</p>
<p>说明</p>
<p><code>/watermark/text/&lt;text&gt;</code></p>
<p>文字内容，如 <code>5L2g5aW977yB</code></p>
<p>文字内容的 Base64 编码字符串，示例为 <code>你好！</code></p>
<p><code>/size/&lt;size&gt;</code></p>
<p>大小，如 16</p>
<p>文字大小，单位 px，默认 <code>32</code></p>
<p><code>/font/&lt;font&gt;</code></p>
<p>字体，如 simsun（宋体）</p>
<p>文字字体，默认 <code>simsun</code>。字体使用时，需要用参数名。参数名见<a href="https://help.upyun.com/knowledge-base/image/#font_list">字体列表</a></p>
<p><code>/color/&lt;color&gt;</code></p>
<p>RRGGBB，如 FF0000（红色）</p>
<p>字体颜色，默认 <code>000000（黑色）</code></p>
<p><code>/border/&lt;border&gt;</code></p>
<p>RRGGBBAA，如 FF000000（不透明红色）</p>
<p>文字描边，默认 <code>FFFFFFFF（透明白色）</code>，详见 <a href="https://help.upyun.com/knowledge-base/image/#border">border 说明</a></p>
<p><code>/align/&lt;align&gt;</code></p>
<p>位置，如 north</p>
<p>文字放置方位，默认 <code>northwest</code>，详见<a href="https://help.upyun.com/knowledge-base/image/#align_gravity">方位说明</a></p>
<p><code>/margin/&lt;x&gt;x&lt;y&gt;</code></p>
<p>横偏移x纵偏移，如 15×10</p>
<p>文字横纵相对偏移，默认 <code>20x20</code></p>
<p><code>/opacity/&lt;opacity&gt;</code></p>
<p>透明度，如 90</p>
<p>文字透明度，默认 <code>100</code>，取值范围 <code>[0-100]</code>，值越大越不透明，<code>0</code> 完全透明，<code>100</code> 完全不透明</p>
<p><code>/animate/&lt;boolean&gt;</code></p>
<p>true</p>
<p>允许对动态图片加水印，默认 <code>false</code></p>
<p>把图片水印或文字水印参数重复。例如，一个文字水印 + 一个图片水印：</p>
<p>&#x2F;watermark&#x2F;text&#x2F;d3d3LmNvZGU0MDQuaWN1&#x2F;font&#x2F;simhei&#x2F;watermark&#x2F;url&#x2F;L2RvY3MvY2xvdWQvdXB5dW4tbG9nby5wbmc&#x3D;&#x2F;align&#x2F;southeast</p>
<p>特别地，水印个数越多，处理耗时越长，建议不要超过 3 个。</p>
<p><strong>注</strong></p>
<ul>
<li>水印需要上传到待处理图片的服务下，水印 URL 使用的是相对路径，不包含 Domain（域名）。</li>
<li>水印的 <code>url</code> 需要 base64 编码，编码后的字符串中如果包含 <code>/</code>（斜杠），需要替换成 （竖线）。</li>
<li><code>align</code> 或 <code>gravity</code> 的 9 个方位：</li>
</ul>
<p><img src="https://upyun-assets.b0.upaiyun.com/docs/process/wmgravity.png"></p>
<ul>
<li>图片水印的 <code>percent</code> 取值范围 <code>[0-100]</code>。当水印没有出现时，可以尝试设置 <code>/margin/0x0</code>。</li>
<li>文字水印的 <code>text</code> 需要 base64 编码，并把编码后的字符串中的 <code>/</code>（斜杠）替换成 （竖线）。</li>
<li>文字水印的中含中文内容（<code>text</code>）时，字体（<code>font</code>）请使用中文字体，否则会乱码。</li>
<li>字体列表：</li>
</ul>
<p>名称</p>
<p>类型</p>
<p>参数名</p>
<p>宋体</p>
<p>中文字体</p>
<p>simsun</p>
<p>黑体</p>
<p>中文字体</p>
<p>simhei</p>
<p>楷体</p>
<p>中文字体</p>
<p>simkai</p>
<p>隶书</p>
<p>中文字体</p>
<p>simli</p>
<p>幼圆</p>
<p>中文字体</p>
<p>simyou</p>
<p>仿宋</p>
<p>中文字体</p>
<p>simfang</p>
<p>简体中文</p>
<p>中文字体</p>
<p>sc</p>
<p>繁体中文</p>
<p>中文字体</p>
<p>tc</p>
<p>Arial</p>
<p>英文字体</p>
<p>arial</p>
<p>Georgia</p>
<p>英文字体</p>
<p>georgia</p>
<p>Helvetica</p>
<p>英文字体</p>
<p>helvetica</p>
<p>Times-New-Roman</p>
<p>英文字体</p>
<p>roman</p>
<ul>
<li><code>border</code> 的值 <code>RRGGBBAA</code>，<code>RRGGBB</code> 表示边框颜色；<code>AA</code> 表示不透明度，取值 <code>[0-255]</code>，值越大越透明，<code>00</code> 表示完全不透明，<code>FF</code> 表示完全透明。</li>
<li><code>&lt;x&gt;x&lt;y&gt;</code> 中，连接 <code>&lt;x&gt;</code>与<code>&lt;y&gt;</code>是小写字母 x，不是乘号。</li>
</ul>
<p>根据说明配置我们的水印：</p>
<p><a href="https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png!/format/webp/watermark/url/L3NodWl5aW4vc3kyLnBuZw==/align/center/percent/100/opacity/70">https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png!/format/webp/watermark/url/L3NodWl5aW4vc3kyLnBuZw==/align/center/percent/100/opacity/70</a></p>
<p>url调用说明：<br><a href="https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png">https://code404.icu/img/moveypu/2021/03/2021032808023151-480x300.png</a> #我们的图片地址<br>! #图片地址和参数的分割符 叹号<br>&#x2F;format&#x2F;webp #压缩图片<br>&#x2F;watermark&#x2F;url&#x2F;L3NodWl5aW4vc3kyLnBuZw&#x3D;&#x3D; #配置图片水印，图片要提前做好上传到又拍云<br>&#x2F;align&#x2F;center #居中显示水印图片<br>&#x2F;percent&#x2F;100 #水印图片自适应原图短边的比例<br>&#x2F;opacity&#x2F;70 #水印图片透明度</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>水印</tag>
        <tag>又拍云</tag>
        <tag>图片</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全最详细Nginx源码编译安装的方法步骤</title>
    <url>/2021/04/04/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%9C%80%E8%AF%A6%E7%BB%86nginx%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>nginx作为现在最热门的web服务应用软件，日常安装及升级经常会使用</p>
<h1 id="linux环境下安装nginx步骤"><a href="#linux环境下安装nginx步骤" class="headerlink" title="linux环境下安装nginx步骤"></a>linux环境下安装nginx步骤</h1><p>最新及历史版本下载地址： <a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
<h2 id="下载完成后上传到服务器"><a href="#下载完成后上传到服务器" class="headerlink" title="下载完成后上传到服务器"></a>下载完成后上传到服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@haproxy2 opt]# rz -e #上传到服务器</span><br><span class="line">[root@haproxy2 opt]# ll</span><br><span class="line">total 1036</span><br><span class="line">-rw-r--r-- 1 root root 1060580 Apr  1 12:40 nginx-1.19.9.tar.gz</span><br><span class="line">[root@haproxy2 opt]# tar -zxf nginx-1.19.9.tar.gz </span><br><span class="line">[root@haproxy2 opt]# ll</span><br><span class="line">total 1036</span><br><span class="line">drwxr-xr-x 8 mockbuild mockbuild     158 Mar 30 22:47 nginx-1.19.9</span><br><span class="line">-rw-r--r-- 1 root      root      1060580 Apr  1 12:40 nginx-1.19.9.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖-不安装依赖完法完成安装nginx"><a href="#安装依赖-不安装依赖完法完成安装nginx" class="headerlink" title="安装依赖(不安装依赖完法完成安装nginx)"></a>安装依赖(<code>不安装依赖完法完成安装nginx</code>)</h2><h4 id="步骤需要服务器可以联网或者有自建yum源"><a href="#步骤需要服务器可以联网或者有自建yum源" class="headerlink" title="步骤需要服务器可以联网或者有自建yum源"></a>步骤需要服务器可以联网或者有<a href="https://www.code404.icu/151.html">自建yum源</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@haproxy2 opt]# yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel </span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line"> * webtatic: us-east.repo.webtatic.com</span><br><span class="line">base                                                                                                                                                                     3.6 kB  00:00:00     </span><br><span class="line">extras                                                                                                                                                                   2.9 kB  00:00:00     </span><br><span class="line">updates                                                                                                                                                                  2.9 kB  00:00:00     </span><br><span class="line">webtatic                                                                                                                                                                 3.6 kB  00:00:00     </span><br><span class="line">(1/2): extras/7/x86_64/primary_db                                                                                                                                        230 kB  00:00:00     </span><br><span class="line">(2/2): updates/7/x86_64/primary_db                                                                                                                                       6.5 MB  00:00:00     </span><br><span class="line">软件包 gcc-4.8.5-44.el7.x86_64 已安装并且是最新版本</span><br><span class="line">软件包 pcre-8.32-17.el7.x86_64 已安装并且是最新版本</span><br><span class="line">软件包 pcre-devel-8.32-17.el7.x86_64 已安装并且是最新版本</span><br><span class="line">软件包 zlib-1.2.7-19.el7_9.x86_64 已安装并且是最新版本</span><br><span class="line">软件包 zlib-devel-1.2.7-19.el7_9.x86_64 已安装并且是最新版本</span><br><span class="line">软件包 1:openssl-1.0.2k-21.el7_9.x86_64 已安装并且是最新版本</span><br><span class="line">软件包 1:openssl-devel-1.0.2k-21.el7_9.x86_64 已安装并且是最新版本</span><br><span class="line">无须任何处理</span><br></pre></td></tr></table></figure>

<h2 id="配置nginx安装路径及需要的模块-如果不需要额外模块则去掉add-module"><a href="#配置nginx安装路径及需要的模块-如果不需要额外模块则去掉add-module" class="headerlink" title="配置nginx安装路径及需要的模块(如果不需要额外模块则去掉add-module)"></a>配置nginx安装路径及需要的模块(<code>如果不需要额外模块则去掉add-module</code>)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost opt]# cd nginx-1.19.9</span><br><span class="line">[root@localhost nginx-1.19.9]# ./configure --prefix=/opt/nginx/ --add-module=/opt/nginx-module-vts</span><br><span class="line">checking for OS</span><br><span class="line"> + Linux 3.10.0-1160.el7.x86_64 x86_64</span><br><span class="line">checking for C compiler ... found</span><br><span class="line"> + using GNU C compiler</span><br><span class="line"> + gcc version: 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span><br><span class="line">checking for gcc -pipe switch ... found</span><br><span class="line">checking for getaddrinfo() ... found</span><br><span class="line">configuring additional modules</span><br><span class="line">adding module in /opt/nginx-module-vts</span><br><span class="line"> + ngx_http_vhost_traffic_status_module was configured</span><br><span class="line">checking for PCRE library ... found</span><br><span class="line">checking for PCRE JIT support ... found</span><br><span class="line">checking for zlib library ... found</span><br><span class="line">creating objs/Makefile</span><br><span class="line"></span><br><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + OpenSSL library is not used</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/opt/nginx/&quot;</span><br><span class="line">  nginx binary file: &quot;/opt/nginx//sbin/nginx&quot;</span><br><span class="line">  nginx modules path: &quot;/opt/nginx//modules&quot;</span><br><span class="line">  nginx configuration prefix: &quot;/opt/nginx//conf&quot;</span><br><span class="line">  nginx configuration file: &quot;/opt/nginx//conf/nginx.conf&quot;</span><br><span class="line">  nginx pid file: &quot;/opt/nginx//logs/nginx.pid&quot;</span><br><span class="line">  nginx error log file: &quot;/opt/nginx//logs/error.log&quot;</span><br><span class="line">  nginx http access log file: &quot;/opt/nginx//logs/access.log&quot;</span><br><span class="line">  nginx http client request body temporary files: &quot;client_body_temp&quot;</span><br><span class="line">  nginx http proxy temporary files: &quot;proxy_temp&quot;</span><br><span class="line">  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;</span><br><span class="line">  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;scgi_temp&quot;</span><br><span class="line"></span><br><span class="line">[root@localhost nginx-1.19.9]# </span><br></pre></td></tr></table></figure>

<h3 id="把nginx编译成二进制文件"><a href="#把nginx编译成二进制文件" class="headerlink" title="把nginx编译成二进制文件"></a>把nginx编译成二进制文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.19.9]# make -j 4</span><br></pre></td></tr></table></figure>

<h3 id="把编译好的nginx文件安装到上面指定-prefix-的目录"><a href="#把编译好的nginx文件安装到上面指定-prefix-的目录" class="headerlink" title="把编译好的nginx文件安装到上面指定(--prefix)的目录"></a>把编译好的nginx文件安装到上面指定<code>(--prefix)</code>的目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.19.9]# make install</span><br></pre></td></tr></table></figure>

<h3 id="查看nginx版本"><a href="#查看nginx版本" class="headerlink" title="查看nginx版本"></a>查看nginx版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.19.9]# cd /opt/nginx/sbin</span><br><span class="line">[root@localhost sbin]# ./nginx -V</span><br><span class="line">nginx version: nginx/1.19.9</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) </span><br><span class="line">configure arguments: --prefix=/opt/nginx/ --add-module=/opt/nginx-module-vts</span><br></pre></td></tr></table></figure>

<h3 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<h4 id="测试页面-http-192-168-93-131"><a href="#测试页面-http-192-168-93-131" class="headerlink" title="测试页面 http://192.168.93.131/"></a>测试页面 <a href="http://192.168.93.131/">http://192.168.93.131/</a></h4><p><img src="https://code404.icu/img/moveypu/2021/04/2021040105275411-1024x371.png"></p>
<h3 id="测试nginx配置文件是否正确"><a href="#测试nginx配置文件是否正确" class="headerlink" title="测试nginx配置文件是否正确"></a>测试nginx配置文件是否正确</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf -t</span><br><span class="line">nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /opt/nginx/conf/nginx.conf test is successful</span><br><span class="line">[root@localhost sbin]# </span><br></pre></td></tr></table></figure>

<h3 id="停止nginx"><a href="#停止nginx" class="headerlink" title="停止nginx"></a>停止nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf -s stop</span><br></pre></td></tr></table></figure>

<h3 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf -s reload</span><br></pre></td></tr></table></figure>

<h5 id="到此nginx安装完成"><a href="#到此nginx安装完成" class="headerlink" title="到此nginx安装完成"></a>到此nginx安装完成</h5><h5 id="本此安装附带了nginx-module-vts模块-模块使用方法"><a href="#本此安装附带了nginx-module-vts模块-模块使用方法" class="headerlink" title="本此安装附带了nginx-module-vts模块,模块使用方法"></a>本此安装附带了nginx-module-vts模块,模块<a href="https://www.code404.icu/169.html">使用方法</a></h5>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>安装</tag>
        <tag>模块</tag>
        <tag>源码安装</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>后台任务稳定运行方案--不受终端关闭或者远程（ssh等）连接失败影响</title>
    <url>/2021/07/18/%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C%E6%96%B9%E6%A1%88-%E4%B8%8D%E5%8F%97%E7%BB%88%E7%AB%AF%E5%85%B3%E9%97%AD%E6%88%96%E8%80%85%E8%BF%9C%E7%A8%8B%EF%BC%88ssh/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-45.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我们经常会碰到这样的问题，用 ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口&#x2F;网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。</p>
<p>从Linux知识可以看出，at的单次任务提交以后，就脱离了该终端的控制，是一种方案，其实例行任务方案crontab也可以，不过它是循环执行的，如果实在想不起来其他方案，crontab运行以后，再注释掉改任务也是一种方法。</p>
<h3 id="nohup-使用方式"><a href="#nohup-使用方式" class="headerlink" title="nohup 使用方式"></a>nohup 使用方式</h3><hr>
<p>方法有很多，这里先只讲 nohup 这种方式。</p>
<p>nohup 是 Linux 的一个常用命令，当你想要在退出账户或者关闭终端后进程仍在运行时，就可以使用 nohup 命令。nohup 就是不挂断的意思（no hang up）。</p>
<h3 id="hangup-名称的来由"><a href="#hangup-名称的来由" class="headerlink" title="hangup 名称的来由"></a>hangup 名称的来由</h3><hr>
<p>在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。</p>
<p>顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：</p>
<p>nohup –help<br>Usage: nohup COMMAND [ARG]…<br>  or:  nohup OPTION<br>Run COMMAND, ignoring hangup signals.</p>
<pre><code>  --help     display this help and exit
  --version  output version information and exit
</code></pre>
<p>If standard input is a terminal, redirect it from an unreadable file.<br>If standard output is a terminal, append output to ‘nohup.out’ if possible,<br>‘$HOME&#x2F;nohup.out’ otherwise.<br>If standard error is a terminal, redirect it to standard output.<br>To save output to FILE, use ‘nohup COMMAND &gt; FILE’.</p>
<p>NOTE: your shell may have its own version of nohup, which usually supersedes<br>the version described here.  Please refer to your shell’s documentation<br>for details about the options it supports.</p>
<p>GNU coreutils online help: <a href="https://www.gnu.org/software/coreutils/">https://www.gnu.org/software/coreutils/</a><br>Report nohup translation bugs to <a href="https://translationproject.org/team/">https://translationproject.org/team/</a><br>Full documentation at: <a href="https://www.gnu.org/software/coreutils/nohup">https://www.gnu.org/software/coreutils/nohup</a><br>or available locally via: info ‘(coreutils) nohup invocation’</p>
<p>可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上”&amp;“来将命令同时放入后台运行，也可用”&gt;filename 2&gt;&amp;1”来更改缺省的重定向文件名。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><hr>
<p>[root@somehost test]# nohup ping <a href="http://www.code404.icu/">www.code404.icu</a> &amp;<br>[1] 416<br>[root@somehost test]# nohup: ignoring input and appending output to ‘nohup.out’<br>[root@somehost test]# ps -ef grep 416<br>leenhem    416     9  0 16:32 tty1     00:00:00 ping <a href="http://www.code404.icu/">www.code404.icu</a><br>leenhem    418     9  0 16:32 tty1     00:00:00 grep –color&#x3D;auto 416</p>
<p>可见我们把 ping <a href="http://www.baidu.com/">www.baidu.com</a> 放到后台执行了，由于没有指定重定向，默认情况下标准输出和标准错误缺省会被重定向到当前目录的 nohup.out 文件中：</p>
<p>[root@somehost test]#  tail -f nohup.out<br>PING <a href="http://www.code404.icu/">www.code404.icu</a> (182.92.75.185) 56(84) bytes of data.<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;1 ttl&#x3D;44 time&#x3D;6.01 ms<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;2 ttl&#x3D;44 time&#x3D;6.65 ms</p>
<p>— <a href="http://www.code404.icu/">www.code404.icu</a> ping statistics —<br>2 packets transmitted, 2 received, 0% packet loss, time 1002ms<br>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 6.012&#x2F;6.332&#x2F;6.652&#x2F;0.320 ms<br>PING <a href="http://www.code404.icu/">www.code404.icu</a> (182.92.75.185) 56(84) bytes of data.<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;1 ttl&#x3D;44 time&#x3D;6.11 ms<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;2 ttl&#x3D;44 time&#x3D;6.49 ms<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;3 ttl&#x3D;44 time&#x3D;6.71 ms</p>
<h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><hr>
<p>[root@somehost test]# nohup ping <a href="http://www.code404.icu/">www.code404.icu</a> &gt; ping.txt &amp;<br>[2] 429<br>[root@somehost test]# nohup: ignoring input and redirecting stderr to stdout<br>[root@somehost test]# tail -f ping.txt<br>PING <a href="http://www.code404.icu/">www.code404.icu</a> (182.92.75.185) 56(84) bytes of data.<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;1 ttl&#x3D;44 time&#x3D;6.10 ms<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;2 ttl&#x3D;44 time&#x3D;6.55 ms<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;3 ttl&#x3D;44 time&#x3D;6.56 ms</p>
<h3 id="重定向标准输出和标准错误"><a href="#重定向标准输出和标准错误" class="headerlink" title="重定向标准输出和标准错误"></a>重定向标准输出和标准错误</h3><hr>
<p>[root@somehost test]# nohup ping <a href="http://www.code404.icu/">www.code404.icu</a> &gt; ping.txt 2&gt;&amp;1 &amp;<br>[1] 4441<br>[root@somehost test]# ttail -f ping.txt<br>nohup: ignoring input<br>PING <a href="http://www.code404.icu/">www.code404.icu</a> (182.92.75.185) 56(84) bytes of data.<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;1 ttl&#x3D;44 time&#x3D;6.05 ms<br>64 bytes from 182.92.75.185 (182.92.75.185): icmp_seq&#x3D;2 ttl&#x3D;44 time&#x3D;6.50 ms</p>
<p>与示例二相比，多了2&gt;&amp;1，下面来解释下这是什么意思。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><hr>
<p>基本符号的含义</p>
<ul>
<li>0 表示 stdin 标准输入</li>
<li>1 表示 stdout 标准输出</li>
<li>2 表示 stderr 标准错误</li>
</ul>
<p>command &gt; file 命令其实是一个缩写，实际上是 command 产生的标准输出重定向到 file 中，也就是说相当于执行了 command 1 &gt; file。</p>
<p>2&gt;&amp;1</p>
<p>2 是标准错误，1是标准输出，&amp;1可以理解为用标准输出的引用。实际就是把标准错误也重定向到file中。</p>
<p>综上，nohup ping <a href="http://www.code404.icu/">www.code404.icu</a> &gt; ping.txt 2&gt;&amp;1 &amp; 的意思是后台执行ping命令，把标准输出和错误标准错误都重定向ping.txt文件里。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Linux中如何后台运行脚本 nohup 命令</title>
    <url>/2021/11/18/%E5%9C%A8-linux%E4%B8%AD%E5%A6%82%E4%BD%95%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC-nohup-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021111802263952.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>nohup命令 可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端</p>
<p>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME&#x2F;nohup.out文件中。如果没有文件能创建或打开以用于追加，那么 command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><hr>
<p>nohup Command [ Arg … ] [　&amp; ]</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><hr>
<p>Command：要执行的命令。<br>Arg：一些参数，可以指定输出文件。<br>&amp;：让命令在后台执行，终端退出后命令仍旧执行。<br>命令后台执行,正常输出和错误输出到a.log文件</p>
<p>nohup command &gt; a.log 2&gt;&amp;1 &amp;</p>
<h3 id="2-gt-amp-1-解释"><a href="#2-gt-amp-1-解释" class="headerlink" title="2&gt;&amp;1 解释"></a>2&gt;&amp;1 解释</h3><hr>
<p>将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。</p>
<p>0 – stdin (standard input，标准输入)<br>1 – stdout (standard output，标准输出)<br>2 – stderr (standard error，标准错误输出)</p>
<h3 id="后台下载文件"><a href="#后台下载文件" class="headerlink" title="后台下载文件"></a>后台下载文件</h3><hr>
<p>nohup wget <a href="https://repo.huaweicloud.com/java/jdk/8u172-b11/jdk-8u172-linux-x64.tar.gz">https://repo.huaweicloud.com/java/jdk/8u172-b11/jdk-8u172-linux-x64.tar.gz</a> &amp;</p>
<h1 id="查看后台的进程"><a href="#查看后台的进程" class="headerlink" title="查看后台的进程"></a>查看后台的进程</h1><p>jobs<br>[1]+  Running                 nohup wget <a href="https://repo.huaweicloud.com/java/jdk/8u172-b11/jdk-8u172-linux-x64.tar.gz">https://repo.huaweicloud.com/java/jdk/8u172-b11/jdk-8u172-linux-x64.tar.gz</a> &amp;</p>
<p>下载过程中,输出在nohup.out文件中,可以使用tail -f nohup.out动态查看</p>
<h3 id="后台运行SpringBoot项目"><a href="#后台运行SpringBoot项目" class="headerlink" title="后台运行SpringBoot项目"></a>后台运行SpringBoot项目</h3><hr>
<p>nohup java -jar rumenz.jar &amp;</p>
<h3 id="后台执行bash命令"><a href="#后台执行bash命令" class="headerlink" title="后台执行bash命令"></a>后台执行bash命令</h3><hr>
<p>nohup bash -c ‘cal &amp;&amp; ls’ &gt; output.txt</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nohup</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title>在 WSL 上忘记了 Linux 密码？如何重置WSL密码？</title>
    <url>/2021/07/07/%E5%9C%A8-wsl-%E4%B8%8A%E5%BF%98%E8%AE%B0%E4%BA%86-linux-%E5%AF%86%E7%A0%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEwsl%E5%AF%86%E7%A0%81%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-22.png"></p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><hr>
<p>对于那些想从舒适的 Windows 中享受 Linux 命令行的人来说，WSL（Windows Subsystem for Linux） 是一个方便的工具。</p>
<p>当你 在 Windows 上使用 WSL 安装 Linux 时，会要求你创建一个用户名和密码。当你在 WSL 上启动 Linux 时，这个用户会自动登录。</p>
<p>现在的问题是，如果你有一段时间没有使用它，你可能会忘记 WSL 的账户密码。而如果你要使用 sudo 的命令，这将成为一个问题，因为这里你需要输入密码。</p>
<p>不要担心。你可以很容易地重置它。</p>
<h3 id="在-Ubuntu-或任何其他-Linux-发行版上重置遗忘的-WSL-密码"><a href="#在-Ubuntu-或任何其他-Linux-发行版上重置遗忘的-WSL-密码" class="headerlink" title="在 Ubuntu 或任何其他 Linux 发行版上重置遗忘的 WSL 密码"></a>在 Ubuntu 或任何其他 Linux 发行版上重置遗忘的 WSL 密码</h3><hr>
<p>要在 WSL 中重设 Linux 密码，你需要：</p>
<p>◈ 将默认用户切换为 root<br>◈ 重置普通用户的密码<br>◈ 将默认用户切换回普通用户<br>让我向你展示详细的步骤和截图。</p>
<h3 id="步骤-1：将默认用户切换为-root"><a href="#步骤-1：将默认用户切换为-root" class="headerlink" title="步骤 1：将默认用户切换为 root"></a>步骤 1：将默认用户切换为 root</h3><hr>
<p>记下你的普通&#x2F;常规用户名将是明智之举。如你所见，我的普通帐户的用户名是 code404。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-23.png"></p>
<p>WSL 中的 root 用户是无锁的，没有设置密码。这意味着你可以切换到 root 用户，然后利用 root 的能力来重置密码。</p>
<p>由于你不记得帐户密码，切换到 root 用户是通过改变你的 Linux WSL 应用的配置，使其默认使用 root 用户来完成。</p>
<p>这是通过 Windows 命令提示符完成的，你需要知道你的 Linux 发行版需要运行哪个命令。</p>
<p>这个信息通常在 Windows 商店 中的发行版应用的描述中提供。这是你首次下载发行版的地方。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-24.png"></p>
<p>从 Windows 菜单中，启动命令提示符：</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-25.png"></p>
<p>在这里，以这种方式使用你的发行版的命令。如果你使用的是 Windows 商店中的 Ubuntu 应用，那么该命令将是：</p>
<p>ubuntu config –default-user root</p>
<p>截图中，我正在使用 Windows 商店中的 Ubuntu 20.04 应用。所以，我使用了 ubuntu2004 命令。</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-26.png"></p>
<p>为了减少你的麻烦，我在这个表格中列出了一些发行版和它们各自的命令：</p>
<p>发行版应用</p>
<p>Windows 命令</p>
<p>Ubuntu</p>
<p>ubuntu config –default-user root</p>
<p>Ubuntu 20.04</p>
<p>ubuntu2004 config –default-user root</p>
<p>Ubuntu 18.04</p>
<p>ubuntu1804 config –default-user root</p>
<p>Debian</p>
<p>debian config –default-user root</p>
<p>Kali Linux</p>
<p>kali config –default-user root</p>
<h3 id="步骤-2：重设帐户密码"><a href="#步骤-2：重设帐户密码" class="headerlink" title="步骤 2：重设帐户密码"></a>步骤 2：重设帐户密码</h3><hr>
<p>现在，如果你启动 Linux 发行程序，你应该是以root 身份登录。你可以重新设置普通用户帐户的密码。</p>
<p>你还记得 WSL 中的用户名吗？（LCTT 译注：请使用你的“用户名”替换下列命令中的 username）如果没有，你可以随时检查 &#x2F;home 目录的内容。当你有了用户名后，使用这个命令：</p>
<p>passwd username</p>
<p>它将要求你输入一个新的密码。**当你输入时，屏幕上将不会显示任何内容。这很正常。只要输入新的密码，然后点击回车就可以了。**你必须重新输入新的密码来确认，当你输入密码时，屏幕上也不会显示任何东西。</p>
<p>root@DESKTOP-I6DTQAI:<del># passwd code404<br>New password:<br>Retype new password:<br>passwd: password updated successfully<br>root@DESKTOP-I6DTQAI:</del>#</p>
<p>恭喜你。用户账户的密码已经被重置。但你还没有完成。默认用户仍然是 root。你应该把它改回你的普通用户帐户，否则它将一直以 root 用户的身份登录。</p>
<h3 id="步骤-3：再次将普通用户设置为默认用户"><a href="#步骤-3：再次将普通用户设置为默认用户" class="headerlink" title="步骤 3：再次将普通用户设置为默认用户"></a>步骤 3：再次将普通用户设置为默认用户</h3><hr>
<p>你需要你在上一步中用 passwd 命令 使用的普通帐户用户名。</p>
<p>再次启动 Windows 命令提示符。使用你的发行版命令，方式与第 1 步中类似。然而，这一次，用普通用户代替 root。</p>
<p>ubuntu config –default-user <username></p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-27.png"></p>
<p>现在，当你在 WSL 中启动你的 Linux 发行版时，你将以普通用户的身份登录。你已经重新设置了密码，可以用它来运行 sudo 命令。</p>
<p>如果你将来再次忘记了密码，你知道重置密码的步骤。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>WSL</tag>
        <tag>重置</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux中执行.sh脚本，异常/bin/sh^M: bad interpreter: No such file or directory 编码错误</title>
    <url>/2021/09/18/%E5%9C%A8linux%E4%B8%AD%E6%89%A7%E8%A1%8C-sh%E8%84%9A%E6%9C%AC%EF%BC%8C%E5%BC%82%E5%B8%B8-bin-shm-bad-interpreter-no-such-file-or-directory-%E7%BC%96%E7%A0%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-15.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我们很多的网友玩Linux脚本修改和撰写的时候都基于Windows系统，所以我们在编辑的脚本文件执行的时候容易出现”&#x2F;bin&#x2F;sh^M: bad interpreter: No such file or directory”错误问题。遇到问题，我们就来解决问题</p>
<p>分析：这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。</p>
<h3 id="1）在windows下转换"><a href="#1）在windows下转换" class="headerlink" title="1）在windows下转换"></a>1）在windows下转换</h3><hr>
<p>利用一些编辑器如UltraEdit或EditPlus等工具先将脚本编码转换，再放到Linux中执行。转换方式如下（UltraEdit）：File–&gt;Conversions–&gt;DOS-&gt;UNIX即可。</p>
<h3 id="2）也可在Linux中转换"><a href="#2）也可在Linux中转换" class="headerlink" title="2）也可在Linux中转换"></a>2）也可在Linux中转换</h3><hr>
<p>首先要确保文件有可执行权限</p>
<p>chmod a+x filename</p>
<p>然后修改文件格式</p>
<p>vi filename</p>
<p>利用如下命令查看文件格式</p>
<p>:set ff 或 :set fileformat</p>
<p>可以看到如下信息</p>
<p>fileformat&#x3D;dos 或 fileformat&#x3D;unix</p>
<p>利用如下命令修改文件格式</p>
<p>:set ff&#x3D;unix 或 :set fileformat&#x3D;unix<br>:wq (存盘退出)</p>
<p>最后再执行文件</p>
<p>sh .&#x2F;filename</p>
<h3 id="3）使用dos2unix-转换文件编码"><a href="#3）使用dos2unix-转换文件编码" class="headerlink" title="3）使用dos2unix 转换文件编码"></a>3）使用dos2unix 转换文件编码</h3><hr>
<p>安装 dos2unix</p>
<p>yum -y install dos2unix #CentOS<br>apt-get install -y dos2unix #Debian</p>
<p>我们需要安装dos2unix组件用来将我们的脚本转换格式。</p>
<p>执行转换</p>
<p>dos2unix code404.icu.sh</p>
<p>我们需要将已有的SH脚本传到对应的目录中，然后执行脚本转换。<br>这样转换完毕之后，我们就可以去执行自己的脚本文件。</p>
<h3 id="4）终极大招转换linux文件编码"><a href="#4）终极大招转换linux文件编码" class="headerlink" title="4）终极大招转换linux文件编码"></a>4）终极大招转换linux文件编码</h3><hr>
<p>使用cat查看文件内容，ctrl+c复制脚本文件内容</p>
<p>cat sh .&#x2F;filename</p>
<p>vim编辑脚本文件，把内容粘贴到脚本文件</p>
<p>vim .&#x2F;filename1.sh<br>i<br>ctrl+v</p>
<p>这个方法是linux上创建一个脚本文件，把内容粘贴里到里面<br>在linux上创建文件，文件编码就是unix了</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>编码</tag>
        <tag>脚本</tag>
        <tag>doc</tag>
        <tag>dos2unix</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>在反向代理NGINX_HAProxy_IIS_Traefik后面运行Grafana</title>
    <url>/2021/07/15/%E5%9C%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86nginx-haproxy-iis-traefik%E5%90%8E%E9%9D%A2%E8%BF%90%E8%A1%8Cgrafana/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-42.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在此教程中，您将配置 Grafana 以运行反向代理后面。</p>
<p>在代理后面运行 Grafana 时，您需要配置域名，以便让 Grafana 知道如何正确渲染链接和重定向。</p>
<ul>
<li>在 Grafana 配置文件中，更改为将要使用的域名：<code>server.domain</code></li>
</ul>
<p>[server]<br>domain &#x3D; example.com</p>
<p>重新启动Grafana，以便新更改生效。</p>
<hr>
<p>您也可以在子路径后面为Grafana服务，例如:<code>http://example.com/grafana</code><br>在子路径后面为Grafana服务：</p>
<ul>
<li>包括在 末尾的子路径:<code>root_url</code></li>
<li>设置为:<code>serve_from_sub_path = true</code></li>
</ul>
<p>[server]<br>domain &#x3D; example.com<br>root_url &#x3D; %(protocol)s:&#x2F;&#x2F;%(domain)s:%(http_port)s&#x2F;grafana&#x2F;<br>serve_from_sub_path &#x3D; true</p>
<p>接下来，您需要配置反向代理。</p>
<h3 id="配置-NGINX"><a href="#配置-NGINX" class="headerlink" title="配置 NGINX"></a>配置 NGINX</h3><hr>
<p>NGINX是一种高性能负载均衡器、Web 服务器和反向代理。</p>
<p>在您的 NGINX 配置文件中，添加一个新块：server</p>
<p>server {<br>  listen 80;<br>  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>  index index.html index.htm;</p>
<p>  location &#x2F; {<br>   proxy_pass <a href="http://localhost:3000/">http://localhost:3000/</a>;<br>  }<br>}</p>
<p>重新加载 NGINX 配置。</p>
<p>导航到机器上的端口 80 NGINX 正在运行。您受到Grafana登录页面的欢迎。<br>要配置 NGINX 在子路径下为Grafana服务，请更新块，确保此块是第一个块：location location</p>
<p>server {<br>  listen 80;<br>  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;www;<br>  index index.html index.htm;</p>
<p>  location ~&#x2F;grafana&#x2F; {<br>   proxy_pass <a href="http://localhost:3000/">http://localhost:3000/</a>;<br>  }<br>}</p>
<h3 id="配置HAProxy"><a href="#配置HAProxy" class="headerlink" title="配置HAProxy"></a>配置HAProxy</h3><hr>
<p>配置HAProxy在子路径下为Grafana服务：</p>
<p>frontend http-in<br>  bind *:80<br>  use_backend grafana_backend if { path &#x2F;grafana } or { path_beg &#x2F;grafana&#x2F; }</p>
<p>backend grafana_backend</p>
<h1 id="Requires-haproxy-gt-x3D-1-6"><a href="#Requires-haproxy-gt-x3D-1-6" class="headerlink" title="Requires haproxy &gt;&#x3D; 1.6"></a>Requires haproxy &gt;&#x3D; 1.6</h1><p>  http-request set-path %[path,regsub(^&#x2F;grafana&#x2F;?,&#x2F;)]</p>
<h1 id="Works-for-haproxy-lt-1-6"><a href="#Works-for-haproxy-lt-1-6" class="headerlink" title="Works for haproxy &lt; 1.6"></a>Works for haproxy &lt; 1.6</h1><h1 id="reqrep-x2F-grafana-x2F-1-2"><a href="#reqrep-x2F-grafana-x2F-1-2" class="headerlink" title="reqrep ^([^\ ]*\ &#x2F;)grafana[&#x2F;]?(.*) \1\2"></a>reqrep ^([^\ ]*\ &#x2F;)grafana[&#x2F;]?(.*) \1\2</h1><p>  server grafana localhost:3000</p>
<h3 id="配置-IIS"><a href="#配置-IIS" class="headerlink" title="配置 IIS"></a>配置 IIS</h3><hr>
<p>IIS 要求安装 URL 重写模块。</p>
<p>要配置 IIS 在子路径下为 Grafana 服务，在 IIS 管理器中为父网站创建一个入站规则，其设置如下：</p>
<ul>
<li>模式：grafana(&#x2F;)?(.*)</li>
<li>检查复选框 Ignore case</li>
<li>重写网址设置为 <a href="http://localhost:3000/%7BR:2%7D">http://localhost:3000/{R:2}</a></li>
<li>检查复选框 Append query string</li>
<li>检查复选框 Stop processing of subsequent rules</li>
</ul>
<p>这是在中<code>web.config</code>生成的重写规则</p>
  <rewrite>
      <rules>
          <rule name="Grafana" enabled="true" stopProcessing="true">
              <match url="grafana(/)?(.\*)" />
              <action type="Rewrite" url="http://localhost:3000/{R:2}" logRewrittenUrl="false" />
          </rule>
      </rules>
  </rewrite>

<p>有关更深入的说明，请<a href="https://grafana.com/tutorials/iis/">参阅IIS URL 重写教程</a>。</p>
<h3 id="配置Traefik"><a href="#配置Traefik" class="headerlink" title="配置Traefik"></a>配置Traefik</h3><hr>
<p>Traefik云原生反向代理 &#x2F; 负载平衡器 &#x2F; 边缘路由器</p>
<p>使用码头供应商，以下标签将配置路由器和服务的域或子域路由。</p>
<p>  labels:<br>      traefik.http.routers.grafana.rule: Host(`grafana.example.com`)<br>      traefik.http.services.grafana.loadbalancer.server.port: 3000</p>
<p>部署在子路径上</p>
<p>  labels:<br>      traefik.http.routers.grafana.rule: Host(`example.com`) &amp;&amp; PathPrefix(`&#x2F;grafana`)<br>      traefik.http.services.grafana.loadbalancer.server.port: 3000</p>
<p>使用文件提供商的示例。</p>
<p>http:<br>  routers:<br>    grafana:<br>      rule: Host(`grafana.example.com`)<br>      service: grafana<br>  services:<br>    grafana:<br>      loadBalancer:<br>        servers:<br>          - url: <a href="http://192.168.30.10:3000/">http://192.168.30.10:3000</a><br>http:<br>  routers:</p>
]]></content>
      <categories>
        <category>Grafana</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>grafana</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 CentOS 搭建 WordPress 个人博客</title>
    <url>/2021/05/21/%E5%9F%BA%E4%BA%8E-centos-%E6%90%AD%E5%BB%BA-wordpress-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-42.png"></p>
<h2 id="准备-LNMP-环境"><a href="#准备-LNMP-环境" class="headerlink" title="准备 LNMP 环境"></a>准备 LNMP 环境</h2><p>LNMP 是 Linux、Nginx、MySQL 和 PHP 的缩写，是 WordPress 博客系统依赖的基础运行环境。我们先来准备 LNMP 环境 <a href="https://www.code404.icu/630.html">LNMP环境安装</a></p>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>使用 yum 安装 Nginx：</p>
<p>yum install nginx -y</p>
<p>修改 <code>/etc/nginx/conf.d/default.conf</code>，去除对 IPv6 地址的监听，可参考下面的示例：</p>
<p>示例代码：<code>/etc/nginx/conf.d/default.conf</code></p>
<p>server {<br>    listen       80 default_server;<br>    # listen       [::]:80 default_server;<br>    server_name  _;<br>    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</p>
<pre><code># Load configuration files for the default server block.
include /etc/nginx/default.d/\*.conf;

location / &#123;
&#125;

error\_page 404 /404.html;
    location = /40x.html &#123;
&#125;

error\_page 500 502 503 504 /50x.html;
    location = /50x.html &#123;
&#125;
</code></pre>
<p>}</p>
<p>修改完成后，启动 <code>Nginx</code>：</p>
<p>nginx</p>
<p>此时，可访问服务器器外网 HTTP 服务（http:&#x2F;&#x2F;&lt; IP 地址&gt;）来确认是否已经安装成功。</p>
<p>将 Nginx 设置为开机自动启动：</p>
<p>chkconfig nginx on</p>
<p>CentOS 6 不支持 IPv6，需要取消对 IPv6 地址的监听，否则 Nginx 不能成功启动。</p>
<h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><p>使用 yum 安装 MySQL：</p>
<p>yum install mysql-server -y</p>
<p>安装完成后，启动 MySQL 服务：</p>
<p>service mysqld restart</p>
<p>设置 MySQL 账户 root 密码：[?]</p>
<p>&#x2F;usr&#x2F;bin&#x2F;mysqladmin -u root password ‘MyPas$word4Word_Press’</p>
<p>将 MySQL 设置为开机自动启动：</p>
<p>chkconfig mysqld on</p>
<p>下面命令中的密码是教程为您自动生成的，为了方便实验的进行，不建议使用其它密码。如果设置其它密码，请把密码记住，在后续的步骤会使用到。</p>
<h3 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 PHP</h3><p>使用 yum 安装 PHP：</p>
<p>yum install php-fpm php-mysql -y</p>
<p>安装之后，启动 PHP-FPM 进程：</p>
<p>service php-fpm start</p>
<p>启动之后，可以使用下面的命令查看 PHP-FPM 进程监听哪个端口</p>
<p>netstat -nlpt  grep php-fpm</p>
<p>把 PHP-FPM 也设置成开机自动启动：</p>
<p>chkconfig php-fpm on</p>
<p>CentOs 6 默认已经安装了 PHP-FPM 及 PHP-MYSQL，下面命令执行的可能会提示已经安装。</p>
<p><code>PHP-FPM</code> 默认监听 <code>9000</code> 端口</p>
<h3 id="安装并配置-WordPress"><a href="#安装并配置-WordPress" class="headerlink" title="安装并配置 WordPress"></a>安装并配置 WordPress</h3><p>安装 WordPress<br>配置好 LNMP 环境后，继续使用 yum 来安装 WordPress：</p>
<p>yum install wordpress -y</p>
<p>安装完成后，就可以在 <code>/usr/share/wordpress</code> 看到 WordPress 的源代码了。</p>
<h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><h4 id="进入-MySQL："><a href="#进入-MySQL：" class="headerlink" title="进入 MySQL："></a>进入 MySQL：</h4><p>mysql -uroot –password&#x3D;’MyPas$word4Word_Press’</p>
<h4 id="为-WordPress-创建一个数据库："><a href="#为-WordPress-创建一个数据库：" class="headerlink" title="为 WordPress 创建一个数据库："></a>为 WordPress 创建一个数据库：</h4><p>CREATE DATABASE wordpress;</p>
<p>MySQL 部分设置完了，我们退出 MySQL 环境：</p>
<p>exit</p>
<p>把上述的 DB 配置同步到 WordPress 的配置文件中，可参考下面的配置：</p>
<p>示例代码：<code>/etc/wordpress/wp-config.php</code></p>
<?php
/\*\*
 \* The base configuration for WordPress
 \*
 \* The wp-config.php creation script uses this file during the
 \* installation. You don't have to use the web site, you can
 \* copy this file to "wp-config.php" and fill in the values.
 \*
 \* This file contains the following configurations:
 \*
 \* \* MySQL settings
 \* \* Secret keys
 \* \* Database table prefix
 \* \* ABSPATH
 \*
 \* @link https://codex.wordpress.org/Editing\_wp-config.php
 \*
 \* @package WordPress
 \*/

// \*\* MySQL settings - You can get this info from your web host \*\* //
/\*\* The name of the database for WordPress \*/
define('DB\_NAME', 'wordpress');

/\*\* MySQL database username \*/
define('DB\_USER', 'root');

/\*\* MySQL database password \*/
define('DB\_PASSWORD', 'MyPas$word4Word\_Press');

/\*\* MySQL hostname \*/
define('DB\_HOST', 'localhost');

/\*\* Database Charset to use in creating database tables. \*/
define('DB\_CHARSET', 'utf8');

/\*\* The Database Collate type. Don't change this if in doubt. \*/
define('DB\_COLLATE', '');

/\*\*#@+
 \* Authentication Unique Keys and Salts.
 \*
 \* Change these to different unique phrases!
 \* You can generate these using the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service}
 \* You can change these at any point in time to invalidate all existing cookies. This will force all users to have to log in again.
 \*
 \* @since 2.6.0
 \*/
define('AUTH\_KEY',         'put your unique phrase here');
define('SECURE\_AUTH\_KEY',  'put your unique phrase here');
define('LOGGED\_IN\_KEY',    'put your unique phrase here');
define('NONCE\_KEY',        'put your unique phrase here');
define('AUTH\_SALT',        'put your unique phrase here');
define('SECURE\_AUTH\_SALT', 'put your unique phrase here');
define('LOGGED\_IN\_SALT',   'put your unique phrase here');
define('NONCE\_SALT',       'put your unique phrase here');

/\*\*#@-\*/

/\*\*
 \* WordPress Database Table prefix.
 \*
 \* You can have multiple installations in one database if you give each
 \* a unique prefix. Only numbers, letters, and underscores please!
 \*/
$table\_prefix  = 'wp\_';

/\*\*
 \* See http://make.wordpress.org/core/2013/10/25/the-definitive-guide-to-disabling-auto-updates-in-wordpress-3-7
 \*/

/\* Disable all file change, as RPM base installation are read-only \*/
define('DISALLOW\_FILE\_MODS', true);

/\* Disable automatic updater, in case you want to allow
   above FILE\_MODS for plugins, themes, ... \*/
define('AUTOMATIC\_UPDATER\_DISABLED', true);

/\* Core update is always disabled, WP\_AUTO\_UPDATE\_CORE value is ignore \*/

/\*\*
 \* For developers: WordPress debugging mode.
 \*
 \* Change this to true to enable the display of notices during development.
 \* It is strongly recommended that plugin and theme developers use WP\_DEBUG
 \* in their development environments.
 \*
 \* For information on other constants that can be used for debugging,
 \* visit the Codex.
 \*
 \* @link https://codex.wordpress.org/Debugging\_in\_WordPress
 \*/
define('WP\_DEBUG', false);

/\* That's all, stop editing! Happy blogging. \*/

/\*\* Absolute path to the WordPress directory. \*/
if ( !defined('ABSPATH') )
    define('ABSPATH', '/usr/share/wordpress');

/\*\* Sets up WordPress vars and included files. \*/
require\_once(ABSPATH . 'wp-settings.php');

如果你上面的步骤没有使用教程创建的密码，请修改下面命令中的密码登录

### 配置 Nginx

WordPress 已经安装完毕，我们配置 Nginx 把请求转发给 PHP-FPM 来处理

首先，重命名默认的配置文件：

cd /etc/nginx/conf.d/
mv default.conf defaut.conf.bak

在 /etc/nginx/conf.d 创建 wordpress.conf 配置，参考下面的内容：

示例代码：`/etc/nginx/conf.d/wordpress.conf`

server {
    listen 80;
    root /usr/share/wordpress;
    location / {
        index index.php index.html index.htm;
        try\_files $uri $uri/ /index.php index.php;
    }
    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    location ~ .php$ {
        fastcgi\_pass   127.0.0.1:9000;
        fastcgi\_index  index.php;
        fastcgi\_param  SCRIPT\_FILENAME  $document\_root$fastcgi\_script\_name;
        include        fastcgi\_params;
    }
}

配置后，通知 Nginx 进程重新加载：

nginx -s reload

默认的 Server 监听 80 端口，与 WordPress 的服务端口冲突，将其重命名为 .bak 后缀以禁用默认配置]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>centos</tag>
        <tag>nginx</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>奥鹏_21春《HTML5开发基础与应用》离线作业1</title>
    <url>/2021/08/08/%E5%A5%A5%E9%B9%8F-21%E6%98%A5%E3%80%8Ahtml5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%A6%BB%E7%BA%BF%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-8-1024x576.png"></p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><hr>
<p>在本文档中的题目下作答，在所写的代码下面粘贴运行后的网页截图，提交本word文档即可。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><hr>
<p>小明的女朋友和小明生气了，他想哄女朋友开心。他在想为他女朋友做点儿什么呢？一天他看女朋友最近经常浏览淘宝、京东、新浪、百度这些网站，灵机一动，就给他做了一个简单的页面，下面是小明写的部分代码：</p>
<DOCTYPE html>
<html>
<head></head>
<body>
    <ol>
        <li>百度</li>
    </ol>
</body>
</html>

<h3 id="1、请同学们将其转为无序列表，并将其补充完整。"><a href="#1、请同学们将其转为无序列表，并将其补充完整。" class="headerlink" title="1、请同学们将其转为无序列表，并将其补充完整。"></a>1、请同学们将其转为无序列表，并将其补充完整。</h3><hr>
<DOCTYPE html>
    <html>

<pre><code>&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;百度&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/8610b8d015fe45eb99135984c092bc37.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2、小明同学想获取列表中第一个li元素节点，并设置其颜色为红色。他该怎么做呢？"><a href="#2、小明同学想获取列表中第一个li元素节点，并设置其颜色为红色。他该怎么做呢？" class="headerlink" title="2、小明同学想获取列表中第一个li元素节点，并设置其颜色为红色。他该怎么做呢？"></a>2、小明同学想获取列表中第一个li元素节点，并设置其颜色为红色。他该怎么做呢？</h3><hr>
<DOCTYPE html>
    <html>

<pre><code>&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;百度&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;style&gt;
    li:first-child &#123;
        background: rgb(255, 0, 0);
    &#125;
&lt;/style&gt;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/c7800be948a24b44a37c05f5635370cb.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>奥鹏</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>奥鹏_21春《Web网页开发基础》离线作业1</title>
    <url>/2021/08/09/%E5%A5%A5%E9%B9%8F-21%E6%98%A5%E3%80%8Aweb%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E3%80%8B%E7%A6%BB%E7%BA%BF%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-8-1024x576.png"></p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><hr>
<p>在本文档中的题目下作答，在所写的代码下面粘贴运行后的网页截图，提交本word文档即可。</p>
<p>距离元旦还有10天，距离春节还有35天，距离情人节还有55天……你已经开始在着手准备礼物了吗？想要给你女&#x2F;男朋友一个惊喜吗？亦或者是向心仪已久的女孩&#x2F;男孩表白吗？</p>
<p>请你先做一个简单的页面，记录你们的日常及恩爱瞬间。通过H5课程内容的逐步深入，来不断完善和丰富页面的内容。实践见真知，用心见真爱，你准备好了吗? Let’t go!</p>
<h3 id="题目一、用H5语义化标签做个简单的页面布局，要有头部、导航、内容（左右布局）、底部（如下图）"><a href="#题目一、用H5语义化标签做个简单的页面布局，要有头部、导航、内容（左右布局）、底部（如下图）" class="headerlink" title="题目一、用H5语义化标签做个简单的页面布局，要有头部、导航、内容（左右布局）、底部（如下图）"></a>题目一、用H5语义化标签做个简单的页面布局，要有头部、导航、内容（左右布局）、底部（如下图）</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/a1aef971fb1342459ce01fac12bbeb19.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h3><hr>
<!DOCTYPE html>
<html>
<header>这是我们的头部区域</header>
<nav>
    这是我们的导航区域
</nav>
<div>
    <aside>
        这是侧边区域
    </aside>
    <article>
        这是我们的主要内容区域
    </article>
</div>

<footer>
    这是我们的底部区域
</footer>
<html>
<style>
    header {
        background-color: darkgrey;
        width: 100%;
        font-size: 30px;
        height: auto;
        text-align: center;
        margin: 3px auto;
    }
    nav {
        background-color: darkgrey;
        width: 100%;
        text-align: center;
        margin: 3px auto;
        font-size: 20px;
        height: auto;
    }
    div {
        width: 100%;
        height: 100px;
        margin-bottom: 3px;
    }
    aside {
        width: calc((100% - 3px) \* 0.2);
        text-align: center;
        height: 100%;
        background-color: darkgrey;
        float: left;
    }
    article {
        background-color: darkgrey;
        text-align: center;
        margin-left: 3px;
        width: calc((100% - 3px) \* 0.8);
        height: 100%;
        float: right;
    }
    footer {
        background-color: darkkhaki;
        text-align: center;
        margin-top: 3px;
    }
</style>

<p><img src="https://img-blog.csdnimg.cn/d2b36c14d8e9439eaab8dc50d2187a51.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="题目二、寒冷时的一杯热咖啡，难过时的相互依偎，开心时的彼此分享。show-time-在以后的学习中，我们会逐渐丰富内容，给你的心上人一个惊喜。用HTML5语义化标签写一个文章布局（如下图）"><a href="#题目二、寒冷时的一杯热咖啡，难过时的相互依偎，开心时的彼此分享。show-time-在以后的学习中，我们会逐渐丰富内容，给你的心上人一个惊喜。用HTML5语义化标签写一个文章布局（如下图）" class="headerlink" title="题目二、寒冷时的一杯热咖啡，难过时的相互依偎，开心时的彼此分享。show time! 在以后的学习中，我们会逐渐丰富内容，给你的心上人一个惊喜。用HTML5语义化标签写一个文章布局（如下图）"></a>题目二、寒冷时的一杯热咖啡，难过时的相互依偎，开心时的彼此分享。show time! 在以后的学习中，我们会逐渐丰富内容，给你的心上人一个惊喜。用HTML5语义化标签写一个文章布局（如下图）</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/3f742caf4e4a4c94be3860b56991e6ac.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h3><hr>
<!DOCTYPE html>
<html>
<header>这是我们的头部区域</header>
<nav>
    这是我们的导航区域
</nav>
<div>
    <section>
        <article>
            <a1>这里是文档标题</a1>
            <HR align=center width=30% color=#987cb9 SIZE=2>
            <a3>作者:李贺    发布时间:2021-08</a3>
            <br>
            <br>
            <a2>这是我们的主要内容区域</a2>
        </article>
    </section>
</div>

<footer>
    这是我们的底部区域
</footer>
<html>

<style>
    header {
        background-color: darkgrey;
        width: 100%;
        font-size: 30px;
        height: auto;
        text-align: center;
        margin: 3px auto;
    }
    nav {
        background-color: darkgrey;
        width: 100%;
        text-align: center;
        margin: 3px auto;
        font-size: 20px;
        height: auto;
    }
    div {
        width: 100%;
        height: 200px;
        margin-bottom: 3px;
        background-color: rgb(220, 223, 207);
    }
    article {
        text-align: center;
        width: 100%;
        height: 100%;
    }
    a1 {
        width: 100%;
        font-size: 20px;
        font-weight: bold;
    }
    a3 {
        margin-bottom: 50px;
    }
    a2 {
        width: 100%;
        margin-top: 50px;
    }
    footer {
        background-color: darkkhaki;
        text-align: center;
        margin-top: 3px;
        
    }
</style>

<p><img src="https://img-blog.csdnimg.cn/7851f2185b6845139d57b145c9a93a86.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>网页开发</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>奥鹏</tag>
        <tag>网页开发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何 汉化 Postman 中文版？</title>
    <url>/2021/10/28/%E5%A6%82%E4%BD%95-%E6%B1%89%E5%8C%96-postman-%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-24-1024x450.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>好多小伙伴，尤其是刚入门软件测试的，对英文版本的 Postman 很抵触，希望有个中文版的，不过很遗憾的是 Postman 只有英文版本，但凡事都有例外，某天在逛 github 的时候，无意间发现了一个 star 2.4k 的开源项目 Postman-cn,今天我们就来看看这个开源项目如何将英文版本的 Postman 汉化成中文版。</p>
<h3 id="github-地址"><a href="#github-地址" class="headerlink" title="github 地址"></a>github 地址</h3><hr>
<p> <a href="https://github.com/hlmd/Postman-cn">https://github.com/hlmd/Postman-cn</a></p>
<h3 id="下载并安装-Postman"><a href="#下载并安装-Postman" class="headerlink" title="下载并安装 Postman"></a>下载并安装 Postman</h3><hr>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><hr>
<p> <a href="https://dl.pstmn.io/download/latest/win64">https://dl.pstmn.io/download/latest/win64</a><br> <a href="https://dl.pstmn.io/download/latest/win32">https://dl.pstmn.io/download/latest/win32</a></p>
<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><hr>
<p> <a href="https://dl.pstmn.io/download/latest/osx">https://dl.pstmn.io/download/latest/osx</a></p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><hr>
<p> <a href="https://dl.pstmn.io/download/latest/linux64">https://dl.pstmn.io/download/latest/linux64</a></p>
<h4 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h4><hr>
<p> <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p>
<p><img src="https://img-blog.csdnimg.cn/db8fbeb95df94adba9e0f851744d37ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="安装-Postman-下载好后直接操作安装即可"><a href="#安装-Postman-下载好后直接操作安装即可" class="headerlink" title="安装 Postman,下载好后直接操作安装即可"></a>安装 Postman,下载好后直接操作安装即可</h3><hr>
<h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><h4 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h4><hr>
<p>下载Postman对应版本的汉化包app.zip文件，下载地址：<a href="https://github.com/hlmd/Postman-cn/releases">https://github.com/hlmd/Postman-cn/releases</a><br>解压 app.zip，将解压后的app文件夹复制到C:\Users\D1M\AppData\Local\Postman\app-8.11.1\resources目录下，并重启Postman<br><img src="https://img-blog.csdnimg.cn/c6911adb79c34f1087b301aaca6b710c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h4><hr>
<p>下载Postman对应版本的汉化包app.zip文件，下载地址：<a href="https://github.com/hlmd/Postman-cn/releases">https://github.com/hlmd/Postman-cn/releases</a><br>解压app.zip，将解压后的app文件夹复制到&#x2F;Applications&#x2F;Postman.app&#x2F;Contents&#x2F;Resources目录下，并重启Postman<br><img src="https://img-blog.csdnimg.cn/baf9f74fa82a460093005aa0a1b7b3fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/8f20330250be484b89eab5a4a623f838.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>你以为已经汉化成功了吗，No,还缺了最重要的一步</p>
<h3 id="设置禁止更新-打死不要更新"><a href="#设置禁止更新-打死不要更新" class="headerlink" title="设置禁止更新,打死不要更新"></a>设置禁止更新,打死不要更新</h3><hr>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><hr>
<p>直接删除根目录下的Update.exe文件即可<br>修改 hosts 文件，在 hosts 文件中加入0.0.0.0 dl.pstmn.io</p>
<p><img src="https://img-blog.csdnimg.cn/ad3531c1aa9e482b8bebd8ed862042d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="Mac-2"><a href="#Mac-2" class="headerlink" title="Mac"></a>Mac</h4><hr>
<p>点击设置，将更新下的自动下载主要更新设置为禁用<br><img src="https://img-blog.csdnimg.cn/5d503a6948df492b9a0b438d0818a7c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>修改 hosts 文件，终端执行 vim &#x2F;etc&#x2F;hosts,添加0.0.0.0 dl.pstmn.io保存并退出</p>
<p><img src="https://img-blog.csdnimg.cn/d5968e21211b4db9a49b4eb5de3df6ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Postman</category>
      </categories>
      <tags>
        <tag>Postman</tag>
        <tag>中文版</tag>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>如何nginx-ingress对外提供服务_nginx-ingress原理?</title>
    <url>/2021/11/29/%E5%A6%82%E4%BD%95nginx-ingress%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1-nginx-ingress%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-14.png"></p>
<h3 id="主机-nginx"><a href="#主机-nginx" class="headerlink" title="主机 nginx"></a>主机 nginx</h3><hr>
<p>一般 nginx 做主机反向代理（网关）有以下配置</p>
<p>upstream order{<br>    server 192.168.1.10:5001;<br>    server 192.168.1.11:5001;<br>}</p>
<p>server {<br>    listen 80;<br>    server_name  order.example.com;<br>    access_log     &#x2F;var&#x2F;log&#x2F;nginx&#x2F;order.example.com-access.log;<br>    error_log     &#x2F;var&#x2F;log&#x2F;nginx&#x2F;order.example.com-error.log;<br>    location &#x2F; {<br>        proxy_pass_header Server;<br>        proxy_set_header Host $http_host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Scheme $scheme;<br>        proxy_pass <a href="http://order/">http://order</a>;<br>    }<br>}</p>
<p>其中 192.168.1.10:5001，192.168.1.10:5001 我们把他们称为 Endpoint，就是所谓的具体的服务，比如 order 订单服务。</p>
<h3 id="pod-nginx-ingress"><a href="#pod-nginx-ingress" class="headerlink" title="pod nginx-ingress"></a>pod nginx-ingress</h3><hr>
<p>nginx-ingress也是一种代理，是一个pod，外部的数据统一经过（必经）这个pod，然后通过该pod内部的nginx方向代理到各各服务（Endpoint）。nginx-ingress是ingress控制器插件的一种，这些插件有很多，比如istio-ingressgateway。</p>
<h3 id="1、Pod"><a href="#1、Pod" class="headerlink" title="1、Pod"></a>1、Pod</h3><p>nginx-ingress pod有两个功能，controller 和 nginx：</p>
<p>controller：和kubernetes api通讯实时更新nginx配置（就是ingress yaml资源了）<br>nginx：正常的反向代理</p>
<p>与主机nginx的区别是，该pod nginx-ingress是运行在pod里。主机在定义反向代理配置文件时，需要监听一个对外开放的端口，比如上边的80端口。那么pod中的nginx端口是如何配置的呢？<br>我们在github上找到了nginx-ingress的deployment.yaml</p>
<p><a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml">https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml</a></p>
<p>其中一段</p>
<p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: nginx-ingress-controller<br>  namespace: ingress-nginx<br>  labels:<br>    app.kubernetes.io&#x2F;name: ingress-nginx<br>    app.kubernetes.io&#x2F;part-of: ingress-nginx<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      app.kubernetes.io&#x2F;name: ingress-nginx<br>      app.kubernetes.io&#x2F;part-of: ingress-nginx<br>  template:<br>    metadata:<br>      labels:<br>        app.kubernetes.io&#x2F;name: ingress-nginx<br>        app.kubernetes.io&#x2F;part-of: ingress-nginx<br>      annotations:<br>        prometheus.io&#x2F;port: “10254”<br>        prometheus.io&#x2F;scrape: “true”<br>    spec:<br>      # wait up to five minutes for the drain of connections<br>      terminationGracePeriodSeconds: 300<br>      serviceAccountName: nginx-ingress-serviceaccount<br>      containers:<br>        - name: nginx-ingress-controller<br>          image: quay.io&#x2F;kubernetes-ingress-controller&#x2F;nginx-ingress-controller:0.26.1<br>          …<br>          …<br>          …<br>          ports:<br>            - name: http<br>              containerPort: 80<br>            - name: https<br>              containerPort: 443</p>
<p>我们看到</p>
<p>- name: http<br>  containerPort: 80</p>
<ul>
<li>name: https<br>containerPort: 443</li>
</ul>
<p>默认对外监听了两个端口80和443，也就是说，有这两个端口对外就可以web服务了。</p>
<h3 id="2、ingress-资源"><a href="#2、ingress-资源" class="headerlink" title="2、ingress 资源"></a>2、ingress 资源</h3><hr>
<p>ingress 资源通过yaml进行管理的，比如以下：</p>
<p>apiVersion: extensions&#x2F;v1beta1<br>kind: Ingress<br>metadata:<br>  name: order<br>spec:<br>  rules:</p>
<ul>
<li>host: order.example.com<br>http:<br>  paths: &#x2F;<br>  backend:<br>serviceName: order<br>servicePort: 80</li>
</ul>
<p>以上我们定义了一个单一规则的ingress，该pod（nginx-ingress）接收到外部所有的请求，将被发送到内部order服务的80端口上。接下来我们看pod（nginx-ingress）如何把ingress资源转化为该pod中的nginx反向代理配置文件</p>
<p>upstream order{<br>    server order:80;<br>}</p>
<p>server {<br>    listen 80;<br>    server_name  order.example.com;<br>    …<br>    …<br>    location &#x2F; {<br>        proxy_pass_header Server;<br>        proxy_set_header Host $http_host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Scheme $scheme;<br>        proxy_pass <a href="http://order/">http://order</a>; # 对应ingress 资源 name: order<br>    }<br>}</p>
<p>当然ingress如果包含https，那么会转化nginx对应的443端口及证书的配置文件内容，这里就不写了。</p>
<p>那么，单一个规则的ingress资源代理多个服务（比如order服务，product服务）或者多个ingress资源文件如何转化为nginx配置？ 猜测，其实就是转化成了多个。</p>
<p>upstream order{<br>    server order:80;<br>}</p>
<p>当然，被转化的nginx配置文件要比这些复杂的多，据说还是用lua脚本写的，灵活如openresty。</p>
<h3 id="3、nginx-ingress对外提供服务"><a href="#3、nginx-ingress对外提供服务" class="headerlink" title="3、nginx-ingress对外提供服务"></a>3、nginx-ingress对外提供服务</h3><hr>
<p>一般来讲，pod直接对外提供服务就只有两种方式：</p>
<ul>
<li>create一个service，该service暴漏nodePort</li>
<li>forward 映射</li>
</ul>
<p>我们一般采用第一种。<br>nginx-ingress也是一个pod，所以，为了能使外部通过该pod代理访问，还需要nginx-ingress对外提供一个nodePort的service。这个service这里也不再写了。</p>
<h3 id="4、nginx-ingress工作流程"><a href="#4、nginx-ingress工作流程" class="headerlink" title="4、nginx-ingress工作流程"></a>4、nginx-ingress工作流程</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/7a950ad154854fd2bbb1698134ef1909.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们可以看到，因为 nginx-ingress 这个pod做了所有service的代理，在高并发情况下将承受巨大压力，我们可以增加多个pod实例。</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
        <category>Nginx</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Kubernetes</tag>
        <tag>nginx</tag>
        <tag>ingress</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Jenkins 发布 Android 项目？</title>
    <url>/2021/10/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-jenkins-%E5%8F%91%E5%B8%83-android-%E9%A1%B9%E7%9B%AE%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-8.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>本文的主要目的就是实现使用 Jenkins 发布 Android 项目，整体流程比较简单，就是打包 Android 项目的 Docker 安装完 sdk 这些镜像就变的非常大，差不多达到了 1G，这就是到目前位置制作的最大的镜像了。</p>
<p>随着自动化越来越普及，越来越多的公司都会将应用发版自动化，前端、后端项目相对较多一点，我们公司就是这样，移动端目前还没有一个是通过自动化打包，现在团队为了提升效率，需要将移动端也进行自动化，下面就是在整个过程中的操作步骤，具体思路是先手动测试，再想办法在此基础上实现自动，流程比较简单，实现的功能也比较少，在这里做一个总结整理，也方便有需要的人。</p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><hr>
<h4 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h4><hr>
<p>下载地址：<a href="https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html</a></p>
<p>安装：</p>
<p># tar xf jdk-8u291-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</p>
<h1 id="vim-x2F-etc-x2F-profile"><a href="#vim-x2F-etc-x2F-profile" class="headerlink" title="vim &#x2F;etc&#x2F;profile"></a>vim &#x2F;etc&#x2F;profile</h1><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_291<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</p>
<h1 id="source-x2F-etc-x2F-profile"><a href="#source-x2F-etc-x2F-profile" class="headerlink" title="source &#x2F;etc&#x2F;profile"></a>source &#x2F;etc&#x2F;profile</h1><h1 id="java-version"><a href="#java-version" class="headerlink" title="java -version"></a>java -version</h1><p>java version “1.8.0_291”<br>Java(TM) SE Runtime Environment (build 1.8.0_291-b10)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)</p>
<h4 id="安装-Android-SDK"><a href="#安装-Android-SDK" class="headerlink" title="安装 Android SDK"></a>安装 Android SDK</h4><hr>
<p>下载地址：<a href="https://developer.android.google.cn/studio?hl=zh-cn#downloads">https://developer.android.google.cn/studio?hl=zh-cn#downloads</a></p>
<p>安装：</p>
<p># unzip commandlinetools-linux-7302050_latest.zip -d &#x2F;usr&#x2F;local&#x2F;</p>
<h1 id="vim-x2F-etc-x2F-profile-1"><a href="#vim-x2F-etc-x2F-profile-1" class="headerlink" title="vim &#x2F;etc&#x2F;profile"></a>vim &#x2F;etc&#x2F;profile</h1><p>export ANDROID_HOME&#x3D;&#x2F;usr&#x2F;local<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$ANDROID_HOME&#x2F;cmdline-tools&#x2F;bin</p>
<h1 id="source-x2F-etc-x2F-profile-1"><a href="#source-x2F-etc-x2F-profile-1" class="headerlink" title="source &#x2F;etc&#x2F;profile"></a>source &#x2F;etc&#x2F;profile</h1><h1 id="sdkmanager-–list"><a href="#sdkmanager-–list" class="headerlink" title="sdkmanager –list"></a>sdkmanager –list</h1><h1 id="安装对应版本的-SDK"><a href="#安装对应版本的-SDK" class="headerlink" title="安装对应版本的 SDK"></a>安装对应版本的 SDK</h1><h1 id="sdkmanager-“platforms-android-29”"><a href="#sdkmanager-“platforms-android-29”" class="headerlink" title="sdkmanager  “platforms;android-29”"></a>sdkmanager  “platforms;android-29”</h1><p>如果报一下错误：</p>
<p>Error: Could not determine SDK root.<br>Error: Either specify it explicitly with –sdk_root&#x3D; or move this package into its expected location: <sdk>&#x2F;cmdline-tools&#x2F;latest&#x2F;</p>
<p>则直接在 cmdline-tools 目录下创建 latest 目录，然后将 bin、lib、source.properties 文件和目录移动到 latest 目录下。</p>
<p>latest&#x2F;<br>├── bin<br>├── lib<br>├── NOTICE.txt<br>└── source.properties</p>
<p>然后重新配置环境变量，如下：</p>
<p># vim &#x2F;etc&#x2F;profile<br>export ANDROID_HOME&#x3D;&#x2F;usr&#x2F;local<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$ANDROID_HOME&#x2F;cmdline-tools&#x2F;latest&#x2F;bin</p>
<h4 id="安装-Gradle"><a href="#安装-Gradle" class="headerlink" title="安装 Gradle"></a>安装 Gradle</h4><hr>
<p>下载地址：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p>
<p>安装：</p>
<p># unzip gradle-7.1.1-bin.zip -d &#x2F;usr&#x2F;local&#x2F;</p>
<h1 id="vim-x2F-etc-x2F-profile-2"><a href="#vim-x2F-etc-x2F-profile-2" class="headerlink" title="vim &#x2F;etc&#x2F;profile"></a>vim &#x2F;etc&#x2F;profile</h1><p>export GRADLE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;gradle-7.1.1<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$ANDROID_HOME&#x2F;cmdline-tools&#x2F;latest&#x2F;bin:$GRADLE_HOME&#x2F;bin</p>
<h1 id="source-x2F-etc-x2F-profile-2"><a href="#source-x2F-etc-x2F-profile-2" class="headerlink" title="source &#x2F;etc&#x2F;profile"></a>source &#x2F;etc&#x2F;profile</h1><h1 id="gradle-v"><a href="#gradle-v" class="headerlink" title="gradle -v"></a>gradle -v</h1><p>Welcome to Gradle 7.1.1!</p>
<p>Here are the highlights of this release:</p>
<ul>
<li>Faster incremental Java compilation</li>
<li>Easier source set configuration in the Kotlin DSL</li>
</ul>
<h3 id="手动打包测试"><a href="#手动打包测试" class="headerlink" title="手动打包测试"></a>手动打包测试</h3><hr>
<h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><hr>
<p># git clone <a href="http://192.168.100.180/app/android/newcrm1.0.git">http://192.168.100.180/app/android/newcrm1.0.git</a></p>
<h4 id="构建打包"><a href="#构建打包" class="headerlink" title="构建打包"></a>构建打包</h4><hr>
<p># gradle build &amp; gradle assemble</p>
<h1 id="curl-F-“file-x3D-x2F-tmp-x2F-example-ipa”-F-“uKey-x3D-aa18132c4d9afedfa9cd2c054213c867”-F-“-api-key-x3D-bb66fdd1c5a4c247b016e0ab88a54fdd”-https-upload-pgyer-com-apiv1-app-upload"><a href="#curl-F-“file-x3D-x2F-tmp-x2F-example-ipa”-F-“uKey-x3D-aa18132c4d9afedfa9cd2c054213c867”-F-“-api-key-x3D-bb66fdd1c5a4c247b016e0ab88a54fdd”-https-upload-pgyer-com-apiv1-app-upload" class="headerlink" title="curl -F “file&#x3D;@&#x2F;tmp&#x2F;example.ipa” -F “uKey&#x3D;aa18132c4d9afedfa9cd2c054213c867” -F “_api_key&#x3D;bb66fdd1c5a4c247b016e0ab88a54fdd” https://upload.pgyer.com/apiv1/app/upload"></a>curl -F “file&#x3D;@&#x2F;tmp&#x2F;example.ipa” -F “uKey&#x3D;aa18132c4d9afedfa9cd2c054213c867” -F “_api_key&#x3D;bb66fdd1c5a4c247b016e0ab88a54fdd” <a href="https://upload.pgyer.com/apiv1/app/upload">https://upload.pgyer.com/apiv1/app/upload</a></h1><h3 id="使用-Jenkins-打包"><a href="#使用-Jenkins-打包" class="headerlink" title="使用 Jenkins 打包"></a>使用 Jenkins 打包</h3><hr>
<p>Jenkins 部署在 Kubernetes 中，打包安卓包可以直接使用 jenkins-slave 方式进行。</p>
<p>整理流程如下：<br><img src="https://img-blog.csdnimg.cn/3d49f59bf0e9421fb3b9acbda1f757ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>整个流程非常简单，基本上只要打包成功，都不会有啥问题。</p>
<h4 id="制作打包的-Docker-镜像"><a href="#制作打包的-Docker-镜像" class="headerlink" title="制作打包的 Docker 镜像"></a>制作打包的 Docker 镜像</h4><hr>
<p>这一步主要是制作打包 Android 项目的 Docker，由于网络原因，Android 工具是手动下载再添加到 Docker 中。</p>
<p>Dockerfile 如下（sdk 版本需要根据公司情况进行更改）：</p>
<p>FROM gradle:5.6.4-jdk8<br>ADD cmdline-tools.tar.gz &#x2F;usr&#x2F;local<br>ENV ANDROID_HOME &#x2F;usr&#x2F;local<br>ENV PATH ${ANDROID_HOME}&#x2F;cmdline-tools&#x2F;latest&#x2F;bin:${PATH}</p>
<h4 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h4><hr>
<p>docker build -t registry.cn-hangzhou.aliyuncs.com&#x2F;rookieops&#x2F;android-sdk:v1 .</p>
<p>进入容器安装 Android SDK，主要是安装 SDK 需要交互式操作，在 Dockerfile 中不好弄，就手动去安装了。</p>
<p>docker exec -it –rm registry.cn-hangzhou.aliyuncs.com&#x2F;rookieops&#x2F;android-sdk:v1 bash</p>
<h1 id="sdkmanager-“platforms-android-29”-“platform-tools”-“build-tools-29-0-2”"><a href="#sdkmanager-“platforms-android-29”-“platform-tools”-“build-tools-29-0-2”" class="headerlink" title="sdkmanager  “platforms;android-29” “platform-tools” “build-tools;29.0.2”"></a>sdkmanager  “platforms;android-29” “platform-tools” “build-tools;29.0.2”</h1><p>安装完成后，另起一个终端，将上面的容器重新 commit 成一个新的镜像，如下：</p>
<p># 获取容器的 ID<br>docker ps  grep android</p>
<h1 id="生成新的镜像"><a href="#生成新的镜像" class="headerlink" title="生成新的镜像"></a>生成新的镜像</h1><p>docker commit e0e0a7387c35 registry.cn-hangzhou.aliyuncs.com&#x2F;rookieops&#x2F;android-sdk:v2</p>
<h1 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h1><p>docker push registry.cn-hangzhou.aliyuncs.com&#x2F;rookieops&#x2F;android-sdk:v2</p>
<h4 id="制作-Jenkinsfile"><a href="#制作-Jenkinsfile" class="headerlink" title="制作 Jenkinsfile"></a>制作 Jenkinsfile</h4><hr>
<p>知道流程了，Jenkinsfile 只需要按流程办事即可，如下：</p>
<p>#!groovy</p>
<p>@Library(‘lotbrick’) _ </p>
<p>&#x2F;&#x2F; 引入方法<br>def dingmes &#x3D; new org.devops.sendDingTalk()</p>
<p>pipeline {<br>    agent {<br>        kubernetes {<br>            label “jenkins-slave-${UUID.randomUUID().toString()}”<br>            yaml “””<br>apiVersion: v1<br>kind: Pod<br>spec:<br>  containers:</p>
<ul>
<li><p>name: gradle<br>image: registry.cn-hangzhou.aliyuncs.com&#x2F;rookieops&#x2F;android-sdk:v2<br>command: [‘cat’]<br>tty: true<br>volumeMounts:</p>
<ul>
<li>name: caches<br>mountPath: &#x2F;home&#x2F;gradle&#x2F;.gradle&#x2F;caches&#x2F;<br>  volumes:</li>
<li>name: caches<br>hostPath:<br>  path: “&#x2F;data&#x2F;jenkins-job&#x2F;${JOB_NAME}&#x2F;gradle&#x2F;“<br>“””<br>  }<br>}</li>
</ul>
<p>environment {<br>    GIT_CREDENTIAL_ID &#x3D; ‘git-token’<br>    UKEY &#x3D; “xxxx”<br>    API_KEY &#x3D; “xxx”<br>    UPLOAD_URL &#x3D; “<a href="https://upload.pgyer.com/apiv1/app/upload&quot;">https://upload.pgyer.com/apiv1/app/upload&quot;</a><br>    DINGTALKHOOK &#x3D; “<a href="https://oapi.dingtalk.com/robot/send?access%5C_token=xxx&quot;">https://oapi.dingtalk.com/robot/send?access\_token=xxx&quot;</a><br>}</p>
<p>&#x2F;&#x2F; 配置触发器<br>triggers {<br>    GenericTrigger(<br>        genericVariables: [<br>            [key: ‘ref’, value: ‘$.ref’],<br>            [key: ‘before’, value: ‘$.before’],<br>            [key: ‘after’, value: ‘$.after’],<br>            [key: ‘hook_name’, value: ‘$.hook_name’]<br>        ],<br>        causeString: ‘Triggered on $ref’,<br>        token: env.JOB_NAME,<br>        printContributedVariables: true,<br>        printPostContent: true,<br>        regexpFilterText: ‘$ref’,<br>        regexpFilterExpression: ‘refs&#x2F;heads&#x2F;(premaster)’,<br>    )</p>
</li>
</ul>
<p>   }<br>    options {<br>        timeout(time: 25, unit: ‘MINUTES’)<br>    }<br>    stages {<br>        stage(‘Checkout SCM’) {<br>            steps {<br>                checkout(scm)<br>            }<br>        }</p>
<pre><code>    // 编译
    stage(&#39;Build &amp; Push&#39;) &#123;
        steps &#123;
            container(&#39;gradle&#39;) &#123;
                script &#123;
                    sh &quot;&quot;&quot;
                     gradle build &amp; gradle assemble
                     ls app/build/outputs/apk/release/\*.apk
                    &quot;&quot;&quot;
                    PACKAGE\_DIR=sh(script: &quot;ls app/build/outputs/apk/release/\*.apk&quot;, returnStdout: true).trim()
                    FULL\_DIR=&quot;$&#123;WORKSPACE&#125;/$&#123;PACKAGE\_DIR&#125;&quot;
                    sh &quot;&quot;&quot;
                    curl -F &quot;file=@$&#123;FULL\_DIR&#125;&quot; -F &quot;uKey=$&#123;UKEY&#125;&quot; -F &quot;\_api\_key=$&#123;API\_KEY&#125;&quot; $&#123;UPLOAD\_URL&#125;
                    &quot;&quot;&quot;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
// 构建后的操作
</code></pre>
<p> post {<br>  success {<br>   script{<br>    println(“success:只有构建成功才会执行”)<br>    dingmes.SendDingTalk(“构建成功 ✅”)<br>   }<br>  }<br>  failure {<br>   script{<br>    println(“failure:只有构建失败才会执行”)<br>    dingmes.SendDingTalk(“构建失败 ❌”)<br>   }<br>  }<br> }<br>}</p>
<h3 id="配置流水线"><a href="#配置流水线" class="headerlink" title="配置流水线"></a>配置流水线</h3><hr>
<p>由于我这里使用的是 Kubesphere 管理 DevOps 工程，所以就直接在 Kubesphere 中进行配置，如果是直接使用的 Jenkins，配置即可，都很简单。</p>
<p>（1）添加项目<br><img src="https://img-blog.csdnimg.cn/c6641f31a8e545f1b2d4eb91cfa87370.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>（2）配置分支以及路径<br><img src="https://img-blog.csdnimg.cn/b03dc407115a44be8b09c5d2ef4a661b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>到这里配置就完成了，下面就是打包测试。项目打包完成，钉钉会收到如下信息：<br><img src="https://img-blog.csdnimg.cn/22fa5d1905cf4f53b521fa5d34611d77.png" alt="在这里插入图片描述"></p>
<p>也可以在 DevOps 工程中查看具体的信息，如下：<br><img src="https://img-blog.csdnimg.cn/19ee0d106103437bbbc2e4d2d3bad64b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>总结<br>本文的主要目的就是实现使用 Jenkins 发布 Android 项目，整体流程比较简单，就是打包 Android 项目的 Docker 安装完 sdk 这些镜像就变的非常大，差不多达到了 1G，这就是到目前位置制作的最大的镜像了。</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>打包</tag>
        <tag>编译</tag>
        <tag>Android</tag>
        <tag>Android SDK</tag>
        <tag>Gradle</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Keepalived+HAProxy 实现高可用负载均衡？</title>
    <url>/2021/11/01/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-keepalivedhaproxy-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-1.png"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><hr>
<p>负载均衡是分布式系统中不可或缺的重要环节，通过负载均衡按照指定的调度算法将请求分发至网络中多个节点进行处理。本文将介绍基于开源软件HAProxy实现负载均衡并且通过Keepalived实现高可用的配置方法，希望读者通过参考本文的探索成果可以快速实现高可用的软件负载均衡，也希望读者能够举一反三、触类旁通，通过自我驱动进行更深入的研究来配置更多的功能来满足自身需求。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><hr>
<p>软件负载均衡技术是指可以为多个后端服务器节点提供前端IP流量分发调度服务的软件技术。Keepalived和HAProxy是众多软负载技术中的两种，其中Keepalived既可以实现负载均衡也可以实现高可用，而HAProxy则更加专注于提供高性能TCP和HTTP反向代理和负载均衡能力。</p>
<h3 id="1-1-Keepalived"><a href="#1-1-Keepalived" class="headerlink" title="1.1 Keepalived"></a>1.1 Keepalived</h3><hr>
<p>Keepalived工作在OSI模型中的四层传输层。最初它是为了管理并监控Linux虚拟服务器（LVS）集群中各服务节点的状态，后来又加入了路由冗余协议（VRRP）来实现高可用功能，所以Keepalived除了可以管理配置LVS外，还可以作为Nginx、HAProxy等的高可用解决方案。</p>
<p>Keepalived同时运行于主服务器（Master）和备服务器（Backup）之上，所有的服务器上运行的Keepalived之间通过VRRP交互，VRRP设计目的是为了解决静态路由单点故障问题，保证个别节点宕机时，整个网络可以不间断的运行。</p>
<p>Keepalived不但可以实现主备服务器的高可用性，同时还可以管理LVS实现后端服务器的负载均衡并进行后端服务器节点的健康检查。它启动核心进程时读取keepalived.conf配置文件。在主服务器上keepalived进程按照配置文件配置的负载均衡策略开启LVS转发并对后端服务进行健康检查。利用VRRP协议主服务器周期性的发送广播至备服务器，备服务器将会判断主器服务器的状态，如果在配置的同步超时时间内主服务器节点未能发出广播，那么keepalived将启动高可用切换机制选出新的主服务器。切换过程中，原有主服务器上的虚拟地址（VIP）及负载能力将由新的主服务器来接替承载。</p>
<h3 id="1-2-HAProxy"><a href="#1-2-HAProxy" class="headerlink" title="1.2 HAProxy"></a>1.2 HAProxy</h3><hr>
<p>HAProxy 是一款TCP&#x2F;HTTP 反向代理负载均衡服务器软件，可工作在OSI模型中的四层传输层以及七层应用层。HAProxy特别适用于那些负载压力大的web站点，这些站点通常需要会话保持或七层处理。HAProxy运行在时下的服务器上，可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全地整合进现有的系统架构中，同时可以保护web服务器不被暴露到网络上。HAproxy允许用户定义多组服务代理，代理由前端和后端组成，前端定义了服务监听的IP及端口，后端则定义了一组服务器及负载均衡的算法。通过服务代理将流量由前端负载均衡至后端服务器节点上。</p>
<h3 id="1-3-Keepalived和HAProxy组合"><a href="#1-3-Keepalived和HAProxy组合" class="headerlink" title="1.3 Keepalived和HAProxy组合"></a>1.3 Keepalived和HAProxy组合</h3><hr>
<p>由于HAProxy会存在单点故障问题，可以由Keepalived来为HAProxy提供高可用服务，而HAProxy提供四层或七层高性能负载均衡及反向代理服务，两者共同实现高可用负载均衡，结构如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/f3c7df28d6474b15942ca2aa0898cb13.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="Keepalived+HAProxy"></p>
<h2 id="2-Keepalived功能及安装配置"><a href="#2-Keepalived功能及安装配置" class="headerlink" title="2. Keepalived功能及安装配置"></a>2. Keepalived功能及安装配置</h2><hr>
<h3 id="2-1-核心功能"><a href="#2-1-核心功能" class="headerlink" title="2.1 核心功能"></a>2.1 核心功能</h3><hr>
<h4 id="1-管理LVS负载均衡软件"><a href="#1-管理LVS负载均衡软件" class="headerlink" title="1. 管理LVS负载均衡软件"></a>1. 管理LVS负载均衡软件</h4><p>Keepalived最初是专为解决LVS的问题而诞生的。因此，Keepalived和LVS可紧密结合。</p>
<h4 id="2．实现对LVS集群节点健康检查"><a href="#2．实现对LVS集群节点健康检查" class="headerlink" title="2．实现对LVS集群节点健康检查"></a>2．实现对LVS集群节点健康检查</h4><p>当LVS集群中某个节点服务器发生故障时，Keepalived服务会自动将失效的节点从正常队列中剔除，并将请求调度到别的正常的节点服务器上，从而保证用户访问不受影响。当故障节点被修复后，Keepalived服务又会自动切换回来。</p>
<h4 id="3．网络服务高可用功能"><a href="#3．网络服务高可用功能" class="headerlink" title="3．网络服务高可用功能"></a>3．网络服务高可用功能</h4><p>Keepalived可以实现任意两台主机之间，如Master服务器和Backup服务器间的故障转移和自动切换。假设某个服务是不能停机的，如LVS负载均衡、Nginx反向代理服务器等，可以利用Keepalived保证其高可用性。</p>
<h3 id="2-2-高可用原理"><a href="#2-2-高可用原理" class="headerlink" title="2.2 高可用原理"></a>2.2 高可用原理</h3><hr>
<p>Keepalived高可用服务的故障切换转移是通过VRRP机制来实现的。在Keepalived服务正常运行时，Master节点会不断向Backup节点发送（多播方式）心跳信息，用以通知Master节点的存活状态。当Master节点发生故障时，就无法发送心跳信息，Backup节点也就无法检测到来自Master的心跳信息，于是调用自身的接管程序，接管Master的资源和服务。当Master恢复时，Backup又会释放Master故障时自身接管的资源和服务，恢复到原来的备用角色。无论Master如何切换，对外都应该提供相同的服务IP地址，该IP也称作虚拟地址VIP。客户端并不需要因Master的改变而修改自己的配置，对他们来说这种切换是透明的。</p>
<p>路由冗余协议VRRP（Virtual Router Redundancy Protocol）早期是用来解决交换机、路由器等设备单点故障。VRRP通过竞选机制来实现虚拟路由器的功能，所有的协议报文都是通过IP多播（Multicast）包形式来发送。在一组VRRP路由器集群中，有多台物理路由器，但并不是同时工作，而是由一台Master路由器负责路由工作，其他都是Backup，Master有一些特权，比如拥有VIP地址等，拥有系统资源的Master负责转发发送给网关地址的包和响应ARP请求。只有Master路由器会一直发送心跳信息，此时Backup不会抢占Master。当Master不可用时，Backup就收不到来自Master的心跳信息，此时多台Backup中优先级最高的路由器会抢占为Master，这种抢占非常快速，以保证服务的连续性。</p>
<h3 id="2-3-安装与配置"><a href="#2-3-安装与配置" class="headerlink" title="2.3 安装与配置"></a>2.3 安装与配置</h3><hr>
<p>由于本文引用的技术构架中Keepalived将仅为HAProxy提供高可用服务，所以管理配置LVS负载均衡及节点健康检查功能将不准备展开篇幅，仅对高可用功能进行介绍演示。</p>
<h4 id="2-3-1-安装"><a href="#2-3-1-安装" class="headerlink" title="2.3.1 安装"></a>2.3.1 安装</h4><p>Keepalived支持源码安装，同时也可以通过不同操作系统安装工具进行安装，本文以CentOS的yum工具为例进行安装介绍。此时应该准备两台服务器分别作为Master节点和Backup节点，分别在两台服务器上执行以下命令进行安装。</p>
<p>yum install -y keepalived</p>
<h4 id="2-3-2-高可用配置"><a href="#2-3-2-高可用配置" class="headerlink" title="2.3.2 高可用配置"></a>2.3.2 高可用配置</h4><p>yum安装后，Keepalived将生成配置文件：&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf，可利用文本编辑器进行配置修改。</p>
<p>vi &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</p>
<p>配置文件中主要由全局段、VRRP实例段、脚本段组成。</p>
<h5 id="1．全局段定义（global-defs）"><a href="#1．全局段定义（global-defs）" class="headerlink" title="1．全局段定义（global_defs）"></a>1．全局段定义（global_defs）</h5><p>全局段定义允许用户设置全局相关信息，例如通知信息、关键参数配置等，该段配置在Master节点和Backup节点上应当一致。</p>
<p>global_defs {<br>   notification_email {<br>     <a href="mailto:&#115;&#x79;&#115;&#97;&#100;&#109;&#x69;&#110;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#111;&#x6d;">&#115;&#x79;&#115;&#97;&#100;&#109;&#x69;&#110;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a><br>   }<br>   notification_email_from  <a href="mailto:&#110;&#111;&#x72;&#101;&#x70;&#108;&#x79;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#110;&#111;&#x72;&#101;&#x70;&#108;&#x79;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a><br>   smtp_server  127.0.0.1<br>   smtp_connect_timeout  60<br>   vrrp_mcast_group4  224.0.0.18<br>}</p>
<p><strong>notification_email</strong>定义报警邮件地址，当服务切换时发送报警邮件。<br><strong>notification_email_from</strong>定义发件人信息，<br><strong>smtp_server</strong>和<strong>smtp_connect_timeout</strong>分别定义了SMTP服务器及相应的连接超时时间，<br><strong>vrrp_mcast_group4</strong>为VRRP IPv4多播地址，默认为224.0.0.18，如果同一局域网内有多组Keepalived时需要指定不同多播地址。</p>
<h5 id="2．VRRP实例段定义（vrrp-instance）"><a href="#2．VRRP实例段定义（vrrp-instance）" class="headerlink" title="2．VRRP实例段定义（vrrp_instance）"></a>2．VRRP实例段定义（vrrp_instance）</h5><p>这部分主要用来定义具体服务的实例配置，包括Keepalived主备状态、接口、优先级、认证方式和VIP信息等,每个VRRP实例可以认为是Keepalived服务的一个实例或作为一个业务服务，在一组Keepalived服务配置中，VRRP实例可以有多个。</p>
<p>注意，存在于Master节点中的VRRP实例配置在Backup节点中也要有一致的配置（除了节点角色、优先级不同），这样才能实现故障切换转移。</p>
<p>vrrp_instance R1{<br>state  MASTER<br>interface  eth0<br>virtual_router_id  50<br>priority  100<br>    advert_int  1<br>    authentication {<br>        auth_type PASS<br>        auth_pass passwd<br>    }<br>    virtual_ipaddress {<br>        10.230.137.100<br>}<br>    track_script {<br>        chk_haproxy<br>    }<br>nopreempt<br>preempt_delay 2<br>}</p>
<p><strong>vrrp_instance</strong>配置段定义了一个VRRP实例并设定实例名称；</p>
<p><strong>state</strong>设定初始VRRP实例角色，配置先要为该实例所在的Keepalived服务器设定其角色，在Master服务器上设置为“MASTER”，在Backup服务器上则设置为“BACKUP”；</p>
<p><strong>priority</strong>优先级设定，范围1-254，数字越大，表示实例优先级越高，在同一个VRRP实例里，Master节点优先级要高于Backup节点；</p>
<p><strong>virtual_router_id</strong>虚拟路由ID标识，范围0-255，Master和Backup节点配置中相同VRRP实例的虚拟路由ID标识必须一致，否则将出现脑裂问题；</p>
<p><strong>advert_int</strong>用来同步通知间隔，Master节点和Backup节点之间通信检查的时间间隔，单位是秒。</p>
<p>角色相关信息设定完毕后就要开始配置VIP并绑定至指定的网络接口上，在<strong>virtual_ipaddress</strong>中配置VIP，可以配置多个VIP，VIP将绑定至interface参数配置的网络接口上。</p>
<p><strong>authentication</strong>认证配置段作用于同一个VRRP实例的MASTER和BACKUP之前的通信，具体的配置内容有auth_type认证类型，auth_pass认证密码，认证类型有PASS(Simple Passwd)和AH(IPSEC)，官方推荐PASS，验证密码为明文方式，最多8位。同一个VRRP实例的MASTER和BACKUP使用相同的密码才能正常通信。</p>
<p>当添加<strong>nopreemp</strong>关键字时表示设置高可用模式为非抢占模式，如果去掉此关键字则为默认的抢占模式。抢占模式是指当高优先级节点恢复后会抢占低优先级节点成为MASTER，非抢占模式允许低优先级节点继续担任MASTER，preempt_delay用来设置抢占延迟，单位秒，范围0~1000，发现低优先级MASTER后多少秒开始抢占。</p>
<p><strong>track_script</strong>配置段是用于调用指定脚本，脚本相关配置请参考下一节。</p>
<h5 id="3．脚本段定义（vrrp-script）"><a href="#3．脚本段定义（vrrp-script）" class="headerlink" title="3．脚本段定义（vrrp_script）"></a>3．脚本段定义（vrrp_script）</h5><p>默认情况下，Keepalived仅仅在节点宕机或Keepalived进程停掉的时候才会启动切换机制。但在实际工作中，有业务服务停止而Keepalived服务还存在的情况，这就会导致用户访问的VIP无法找到对应的服务，这时可以利用Keepalived触发预制的监测脚本，实现VIP漂移来继续提供服务。</p>
<p>vrrp_script chk_haproxy {<br>script  “killall -0 haproxy”<br>interval  2<br>weight  -2<br>fall  3<br>rise  1<br>}</p>
<p><strong>vrrp_script</strong>配置段定义一段脚本配置并设定脚本段名称。script用双引号设置引用的shell语句或者shell脚本，通过该语句或脚本执行结果来判断是否触发指定动作，成功的结果不会触发动作，执行失败会触发动作。interval设置监控间隔时间，单位为秒，weight设置当监控脚本执行结果为失败时触发priority值调整，正数为增加优先级，负数为降低优先级，范围-255~255，fall设置认定结果为失败时的执行失败次数，rise设置判定结果为成功时的执行成功次数。</p>
<h4 id="2-3-3-启动"><a href="#2-3-3-启动" class="headerlink" title="2.3.3 启动"></a>2.3.3 启动</h4><p>Keepalived配置完成后，在Master节点和Backup节点上使用以下命令开启Keepalived服务。</p>
<p>systemctl start keepalived</p>
<p>如果需要设置开机启动，则执行以下命令。</p>
<p>systemctl enable keepalived</p>
<h2 id="3-HAProxy功能及安装配置"><a href="#3-HAProxy功能及安装配置" class="headerlink" title="3. HAProxy功能及安装配置"></a>3. HAProxy功能及安装配置</h2><hr>
<h3 id="3-1-核心功能"><a href="#3-1-核心功能" class="headerlink" title="3.1 核心功能"></a>3.1 核心功能</h3><hr>
<h4 id="1．负载均衡、会话保持"><a href="#1．负载均衡、会话保持" class="headerlink" title="1．负载均衡、会话保持"></a>1．负载均衡、会话保持</h4><p>在多个服务器间实现四层或七层负载均衡，支持多种负载均衡算法，并且根据Hash或者cookies方式实现会话保持。</p>
<h4 id="2．健康检查"><a href="#2．健康检查" class="headerlink" title="2．健康检查"></a>2．健康检查</h4><p>支持TCP、HTTP两种后端服务器健康检查模式。</p>
<h4 id="3．统计监控"><a href="#3．统计监控" class="headerlink" title="3．统计监控"></a>3．统计监控</h4><p>接受访问特定端口实现服务监控，并提供带有用户认证机制的服务状态报告页面。</p>
<h4 id="4．SSL卸载"><a href="#4．SSL卸载" class="headerlink" title="4．SSL卸载"></a>4．SSL卸载</h4><p>可以解析HTTPS报文并将请求解密为HTTP向后端服务器传输。</p>
<h4 id="5．其他功能"><a href="#5．其他功能" class="headerlink" title="5．其他功能"></a>5．其他功能</h4><p>在HTTP请求或响应报文中添加、修改、删除首部信息；HTTP请求重写与重定向；根据访问控制路由或阻断请求。</p>
<h3 id="3-2-负载均衡调度算法"><a href="#3-2-负载均衡调度算法" class="headerlink" title="3.2 负载均衡调度算法"></a>3.2 负载均衡调度算法</h3><hr>
<p>HAProxy负载均衡调度算法可以在HAProxy配置文件中设定。支持配置多组后端服务组，每个组可以分别指定一种调度算法。以下是HAProxy支持的几种调度算法。</p>
<h4 id="1．轮询"><a href="#1．轮询" class="headerlink" title="1．轮询"></a>1．轮询</h4><p>带有权重的轮询调度算法。支持权重的运行时调整，支持慢启动（在刚启动时缓慢接收大量请求），仅支持最大4095个后端活动主机。</p>
<h4 id="2．静态轮询"><a href="#2．静态轮询" class="headerlink" title="2．静态轮询"></a>2．静态轮询</h4><p>静态轮询算法，不支持权重的运行时调整及慢启动，但后端主机数量无限制。</p>
<h4 id="3．最少连接"><a href="#3．最少连接" class="headerlink" title="3．最少连接"></a>3．最少连接</h4><p>带权重的最少连接调度算法，将访问请求动态调度至连接数较少的后端服务节点上。</p>
<h4 id="4．源地址哈希"><a href="#4．源地址哈希" class="headerlink" title="4．源地址哈希"></a>4．源地址哈希</h4><p>该算法保证在后端服务器组没有减少或增加的情况下，能将来自同一客户端IP的请求分配至同一个服务端，该算法适合在无法使用cookie插入的四层模式下使用。</p>
<h4 id="5．URI哈希"><a href="#5．URI哈希" class="headerlink" title="5．URI哈希"></a>5．URI哈希</h4><p>该算法保证访问同一URI请求分配至同一服务端，适用于后端为缓存服务器的情况，以提高缓存命中率。</p>
<h4 id="6．URL参数哈希"><a href="#6．URL参数哈希" class="headerlink" title="6．URL参数哈希"></a>6．URL参数哈希</h4><p>该算法对请求URL中的指定的参数的值作哈希计算。该算法适用于有用户识别参数的URL ，例如保证同一用户ID的请求分配至同一服务节点。如果指定的参数没有值，则降级至轮询调度算法。</p>
<h4 id="7．HTTP-首部哈希"><a href="#7．HTTP-首部哈希" class="headerlink" title="7．HTTP 首部哈希"></a>7．HTTP 首部哈希</h4><p>该算法将HTTP首部中指定的字段取出做哈希计算。如果HTTP首部字段缺失，则降级至轮询调度算法。</p>
<h3 id="3-3-安装与配置"><a href="#3-3-安装与配置" class="headerlink" title="3.3 安装与配置"></a>3.3 安装与配置</h3><hr>
<h4 id="3-3-1-安装"><a href="#3-3-1-安装" class="headerlink" title="3.3.1 安装"></a>3.3.1 安装</h4><p>HAProxy支持源码安装，同时也可以通过不同操作系统安装工具进行安装，本文以CentOS的yum工具为例进行安装介绍，分别在两台已安装并配置好kkeepalived的服务器上执行以下命令进行安装。</p>
<p>yum install -y haproxy</p>
<h4 id="3-3-2-基本配置"><a href="#3-3-2-基本配置" class="headerlink" title="3.3.2 基本配置"></a>3.3.2 基本配置</h4><p>yum安装后，HAProxy将生成配置文件：&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg，利用文本编辑器进行配置修改。</p>
<p>vi &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</p>
<h5 id="1．全局段定义（global）"><a href="#1．全局段定义（global）" class="headerlink" title="1．全局段定义（global）"></a>1．全局段定义（global）</h5><p>全局参数配置将配置于所有HAProxy服务器上。</p>
<p>global<br>log  &#x2F;dev&#x2F;log local0 info<br>chroot    &#x2F;var&#x2F;lib&#x2F;haproxy<br>pidfile    &#x2F;var&#x2F;run&#x2F;haproxy.pid<br>maxconn     4000<br>user      haproxy<br>group     haproxy<br>daemon                                   </p>
<p>log设置全局日志配置，语法为log，上例中指定使用本机上的syslog服务中的local0日志设备，记录日志等级为info的日志。chroot设置HAProxy工作目录，pidfile设置HAProxy的pid文件位置，maxconn设置每个HAProxy进程可用的最大连接数，user及group设置HAProxy进程所属的用户及用户组，daemon关键字表示以守护进程方式运行haproxy。</p>
<h5 id="2．默认段定义（defaults）"><a href="#2．默认段定义（defaults）" class="headerlink" title="2．默认段定义（defaults）"></a>2．默认段定义（defaults）</h5><p>默认段的作用是为后续前端代理及后端代理设置默认值。</p>
<p>defaults<br>mode      http<br>log        global<br>option      httplog<br>option      dontlognull<br>    option      http-server-close<br>    option forwardfor   except 127.0.0.0&#x2F;8<br>    option     redispatch<br>    retries     3<br>timeout http-request        10s<br>timeout queue             1m<br>timeout connect           10s<br>timeout client             1m<br>timeout server             1m<br>timeout http-keep-alive      10s<br>timeout check             10s</p>
<p><strong>mode</strong>表示HAProxy的工作模式，设置tcp时为4层模式，设置http时为7层模式。log设置日志输出方式，配置为global表示将采用全局段log的配置。</p>
<p><strong>option httplog</strong>关键字表示记录HTTP详细日志，包括HTTP请求、session状态、连接数等。</p>
<p><strong>option dontlognull</strong>关键字表示日志中将不会记录空连接。所谓空连接就是在上游的负载均衡器或者监控系统为了探测该服务是否存活可用时，需要定期的连接或者获取某一固定的组件或页面，或者探测扫描端口是否在监听或开放等动作被称为空连接，官方文档中标注，如果该服务上游没有其他的负载均衡器的话，建议不要设置该参数，因为设置后互联网上的恶意扫描或其他动作就不会被记录下来。</p>
<p><strong>option http-server-close</strong>关键字表示每次请求完毕后主动关闭HTTP通道。</p>
<p><strong>option forwardfor</strong>关键字表示应用程序想记录发起请求的客户端的IP地址，需要在HAProxy上配置此选项，这样HAProxy会把客户端的IP信息发送给服务器，在HTTP请求中添加”X-Forwarded-For”字段启用 X-Forwarded-For，在requests头部插入客户端IP发送给后端的server，使后端server获取到客户端的真实IP。</p>
<p><strong>option redispatch</strong>关键字表示当使用了cookie时，HAProxy将会将其请求的后端服务器信息插入到cookie中，以保证会话的持久性，如果后端的服务器服务不可用，但客户端的cookie是不会刷新的，设置此参数会将客户的请求强制定向到另外一个后端服务器上，以保证服务的正常。</p>
<p><strong>retries</strong>定义连接后端服务器的失败重连次数，连接失败次数超过此值后将会将对应后端服务器标记为不可用。</p>
<p><strong>timeout</strong>为前缀的关键字指定了一些关于请求、连接、响应的最大超时时间，单位默认为毫秒，也可以加入后缀s(秒)，m(分钟)，h(小时)，d(天)来指定。http-request设置HTTP请求超时时长，queue设置一个请求在队列里的超时时间，connect设置最大与服务端建立连接的时长，client设置客户端最大非活动时长，server设置服务端最大非活动时长，http-keep-alive设置最大等待新请求的空闲时长，check设置检测超时时长。</p>
<h5 id="3．前端代理定义（frontend）"><a href="#3．前端代理定义（frontend）" class="headerlink" title="3．前端代理定义（frontend）"></a>3．前端代理定义（frontend）</h5><p>前端代理配置定义一个服务监听，用于接收用户请求并将请求转发给后端代理，可以定义多个前端代理。</p>
<p>frontend  main<br>mode  http<br>bind  :80<br>    default_backend  nginx</p>
<p><strong>frontend</strong>前端代理配置段定义一组前端服务并启动服务监听，同时设置代理名称。mode设置工作模式，如果此参数未被设定则引用默认配置段配置的模式。bind设置监听地址及端口，地址为空或者表示绑定至所有服务器的网络接口。<strong>default_backend</strong>指定默认后端代理进行流量转发。</p>
<h5 id="4．后端代理定义（backend）"><a href="#4．后端代理定义（backend）" class="headerlink" title="4．后端代理定义（backend）"></a>4．后端代理定义（backend）</h5><p>用于接收前端代理请求并根据设置的负载均衡策略将流量转发至指定后端并对后端执行健康检查，一个前端可以指向多个后端；同时一个后端可以被多个调用。</p>
<p>backend  nginx<br>mode    http<br>balance   roundrobin<br>server   web1 host1:80 check inter 3s rise 1 fall 2<br>server   web2 host2:80 check</p>
<p><strong>backend</strong>后端代理配置段定义一组后端服务器，同时设置代理名称。mode设置工作模式如果此参数未被设定则引用默认配置段的模式。balance设置后端负载均衡转发策略，策略取值请参考下表。</p>
<p>算法名称</p>
<p>Balance值</p>
<p>轮询</p>
<p>roundrobin</p>
<p>静态轮询</p>
<p>static-rr</p>
<p>最少连接</p>
<p>leastconn</p>
<p>源地址哈希</p>
<p>source</p>
<p>URI哈希</p>
<p>uri</p>
<p>URL参数哈希</p>
<p>url_param</p>
<p>HTTP首部哈希</p>
<p>hdr</p>
<p>server配置了相应的后端服务集群地址，是真实的服务器，一个backend对应一个或者多个实体服务器。配置依次为节点名称、节点IP和端口、启用四层健康检查，在上述示例中web1服务器还设定了检查的相关参数表示每3秒(inter)检查一次，执行两次(fall)失败认为故障，执行一次(rise)成功即为服务可用。</p>
<h4 id="3-3-3-启动"><a href="#3-3-3-启动" class="headerlink" title="3.3.3 启动"></a>3.3.3 启动</h4><p>HAProxy配置完成后，使用以下命令开启HAProxy服务。</p>
<p>systemctl start haproxy</p>
<p>如果需要设置开机启动，则执行以下命令。</p>
<p>systemctl enable haproxy</p>
<p>修改配置文件后可以通过刷新配置的方式热加载配置。</p>
<p>systemctl reload haproxy</p>
<h4 id="3-3-4-会话保持"><a href="#3-3-4-会话保持" class="headerlink" title="3.3.4 会话保持"></a>3.3.4 会话保持</h4><p>HAProxy在会话保持功能上可以分为四层会话保持和七层会话保持。四层会话保持是基于源地址的会话保持，是指HAProxy在负载均衡时根据访问请求的源地址作为判断关联会话的依据，对于同一IP地址的所有访问请求在作负载均衡时均会被保持到后端的同一台服务器上。七层会话保持是基于cookie的会话保持，当客户端HTTP请求进入HAProxy时，根据负载均衡策略选择后端的一台服务器，后端服务器将HTTP响应返回HAProxy，此时HAproxy会插入该服务器的cookie并将插入cookie的HTTP响应返回至客户端，当该客户端再次发出请求时，带有上次插入cookie的HTTP请求进入HAProxy，HAProxy解析出cookie中服务器信息并将请求发送至相同的后端服务器。</p>
<p>四层会话保持的配置方式实际只需要将配置文件中后端代理段的负载均衡策略设置为基于源地址哈希并将工作模式设置为tcp即可，配置文件如下。</p>
<p>backend  nginx<br>mode    tcp<br>balance  source<br>    server   web1 10.230.150.68:80 check cookie web1<br>server   web3 10.230.150.70:80 check cookie web3 </p>
<p>七层会话保持配置方式则需要在配置文件后端代理段中设置cookie并确保工作模式为http，配置文件如下。</p>
<p>backend  nginx<br>    mode    http<br>    balance  roundrobin<br>    cookie  WEBSRV insert indirect nocache<br>    server   web1 10.230.150.68:80 check cookie web1<br>    server   web3 10.230.150.70:80 check cookie web3</p>
<p>以上配置文件中的cookie设置了以WEBSRV为名称的cookie，然后在server配置中分别定义了不同的cookie值，通过浏览器访问HAProxy前端代理地址可以看到该cookie，利用该cookie实现会话保持，如图。</p>
<p><img src="https://img-blog.csdnimg.cn/30dded53508f4ba1ab89dd1dc795eeed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="3-3-5-SSL卸载"><a href="#3-3-5-SSL卸载" class="headerlink" title="3.3.5 SSL卸载"></a>3.3.5 SSL卸载</h4><p>利用HAProxy可以实现SSL卸载功能，从而使客户端到HAProxy的访问采用SSL封装后的HTTPS，而HAProxy至后端服务器之间的通信则采用HTTP，从而消除服务器端的SSL加密运算开销。<br><img src="https://img-blog.csdnimg.cn/4c215a903bf04466b41501c0b9eaf761.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>实现SSL卸载需要在配置文件全局定义段加入SSL参数调整，以及在前端代理段加入SSL配置，涉及的配置如下。</p>
<p>global<br>    maxconn     20000<br>    log         127.0.0.1 local0 info<br>    chroot      &#x2F;var&#x2F;lib&#x2F;haproxy<br>    pidfile     &#x2F;var&#x2F;run&#x2F;haproxy.pid<br>    user        haproxy<br>    group       haproxy<br>    daemon<br>    tune.ssl.default-dh-param 2048<br>stats socket &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats</p>
<p>frontend main<br>    bind :80<br>    bind :443 ssl crt &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;web.pem<br>    redirect scheme https if !{ ssl_fc }<br>    default_backend nginx</p>
<p>全局段配置中增加了SSL参数tune.ssl.default-dh-param，设置值为2048，表示使用2048bit加密，和SSL秘钥加密位数保持一致。</p>
<p>前端代理配置bind加入443端口、SSL支持并绑定指定证书，证书文件内容为网站的证书和私钥通过命令（cat web.crt web.key tee web.pem）拼接合成。配置段中还加入了HTTP到HTTPS的自动跳转功能（redirect scheme https if !{ ssl_fc }），在浏览器中输入域名或者IP地址，无需指定协议类型，如果导入根证书后的浏览器显示的状态是安全的则表示配置成功。<br><img src="https://img-blog.csdnimg.cn/c71c7621b40144fdb10ad5f265c27ecb.png" alt="在这里插入图片描述"></p>
<h4 id="3-3-6-流量路由"><a href="#3-3-6-流量路由" class="headerlink" title="3.3.6 流量路由"></a>3.3.6 流量路由</h4><p>HAProxy可以为数据库、邮件、页面等服务提供四层负载均衡机制，也可以从HTTP请求报文中提取指定数据并通过特定的访问控制列表（ACL）提供基于七层的流量转发机制。</p>
<p>1．基于URL路径转发。HAProxy可以根据请求的URL路径做路由，通过配置不同的路径将不同的URL路径分发至不同的后端服务器，在以下的例子中我们在两个页面服务器上分别配置了两个测试页面test1.html、test2.html，页面内容简单标识了所在服务器的信息，并利用转发机制实现基于URL的路径分发，涉及的相关配置如下。</p>
<p>frontend main<br>bind :80<br>bind :443 ssl crt &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;web.pem<br>redirect scheme https if !{ ssl_fc }<br>    acl is_test1  path_beg  &#x2F;test1<br>    acl is_test2  path_beg  &#x2F;test2<br>    use_backend test1  if  is_test1<br>    use_backend test2  if  is_test2<br>    default_backend nginx</p>
<p>backend nginx<br>    balance roundrobin<br>    server  web1 10.230.150.68:80 check</p>
<p>backend test1<br>    balance roundrobin<br>    server  web2 10.230.150.69:80 check</p>
<p>backend test2<br>    balance roundrobin<br>    server  web3 10.230.150.70:80 check</p>
<p>前端代理配置段中加入acl配置，设置的路由规则为匹配路径的前缀（path_beg）test1及test2，并配置use_backend参数将指定acl作用于指定后端服务器，is_test1规则匹配后路由至test1，is_test2规则匹配后路由至test2。</p>
<p>定义两组后端代理配置，分别配置test1及test2后端代理，指向相应的页面服务器。通过访问不同的路径HAProxy可以正确路由转发到指定后端页面服务器，没有命中acl的请求将转发至默认后端服务器，如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/c49060da052e408ab29e32f45bb93b5d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>2．基于HTTP首部信息转发。HAProxy可以根据HTTP首部信息来执行路由分发操作，例如通过首部信息中的User-Agent来判断请求方的设备类型是iPhone还是Android，以此作为依据进行路由分发至不同的后端服务器上，或者通过首部信息中的Host字段实现以域名为依据进行路由分发。以Host为例，涉及的相关配置如下。</p>
<p>frontend main<br>    bind :80<br>    bind :443 ssl crt &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;web.pem<br>    redirect scheme https if !{ ssl_fc }<br>    acl  is_test1  hdr_beg(host)  <a href="http://www.test1.com/">www.test1.com</a><br>    acl  is_test2  hdr_beg(host)  <a href="http://www.test2.com/">www.test2.com</a><br>    use_backend test1  if  is_test1<br>    use_backend test2  if  is_test2<br>    default_backend nginx</p>
<p>backend nginx<br>    balance roundrobin<br>    cookie WEBSRV insert indirect nocache<br>    server   web1 10.230.150.68:80 check cookie web1</p>
<p>backend test1<br>    balance roundrobin<br>    server   web2 10.230.150.69:80 check</p>
<p>backend test2<br>    balance roundrobin<br>    server   web2 10.230.150.70:80 check</p>
<p>前端代理配置段中加入acl配置，通过hdr_beg(host)关键字设置的路由规则匹配HTTP首部信息中Host前缀<a href="http://www.test1.com及www.test2.com,并配置use/_backend%E5%8F%82%E6%95%B0%E5%B0%86%E6%8C%87%E5%AE%9Aacl%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8Cis/_test1%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D%E5%90%8E%E8%B7%AF%E7%94%B1%E8%87%B3test1%EF%BC%8Cis/_test2%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D%E5%90%8E%E8%B7%AF%E7%94%B1%E8%87%B3test2%E3%80%82">www.test1.com及www.test2.com，并配置use\_backend参数将指定acl作用于指定后端服务器，is\_test1规则匹配后路由至test1，is\_test2规则匹配后路由至test2。</a></p>
<p>定义两组后端代理配置，分别配置test1及test2后端代理，指向相应的页面服务器。通过不同的域名访问可以正确路由转发到指定后端页面服务器，没有命中acl的请求将转发至默认后端服务器，如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2683fbfcd1ad47fc93d2df0e1d728d29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><hr>
<p>负载均衡可以由专业硬件设备提供，由服务器集群服务节点之上架设专业负载均衡器来完成集群节点的负载均衡工作。硬件负载均衡优势明显，设备独立于操作系统、强大的性能、丰富的功能、多样化的负载均衡策略、智能化流量管理，由专业维护团队提供维护，缺点是价格昂贵、配置复杂，部署难度大时间长，不适于中小规模的网络服务。</p>
<p>软负载则在一台或多台服务器操作系统之上安装附加软件来实现负载均衡。采用软负载方案后系统构架内无需额外部署专用于负载均衡的硬件设备以降低成本，同时能够更好地根据系统与应用的状态来分配负载，无缝的嵌入系统架构中，也可以根据实际需求灵活扩展，互联网公司大多都有自己的软负载方案。相比硬件负载来说软件负载具有配置简单、快速部署、使用灵活、成本低廉、高性价比等诸多优势。</p>
<p>在建设某银行应用基础云PaaS平台的实践中，采用Keepalived+HAproxy组合搭建了高可用软负载方案，为平台内多组控制节点、多组工作节点、以及双副本镜像仓库提供服务接口聚合负载和高可用性保障。首先，平台的业务流量入口指向Keepalived高可用VIP地址，经过Haproxy负载调度至后端工作节点中，这样一旦其中任意一个负载均衡节点或者后端工作节点宕机，高可用VIP地址和剩余存活的后端工作节点仍可对外提供服务。其次，随着后期业务流量的上升，后端工作节点出现负载压力时，可以根据实际需要灵活配置Haproxy，扩展后端工作节点数量，降低整体工作节点负载压力。从现有的实践经验来看，该软负载方案具备了良好的稳定性、灵活性和可扩展性。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>keepalived</category>
        <category>haproxy</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>高可用</tag>
        <tag>负载均衡</tag>
        <tag>haproxy</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 logrotate 命令轮转和归档日志?</title>
    <url>/2021/10/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-logrotate-%E5%91%BD%E4%BB%A4%E8%BD%AE%E8%BD%AC%E5%92%8C%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-22.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>日志非常适合找出应用程序在做什么或对可能的问题进行故障排除。几乎我们处理的每个应用程序都会生成日志，我们希望我们自己开发的应用程序也生成日志。日志越详细，我们拥有的信息就越多。但放任不管，日志可能会增长到无法管理的大小，反过来，它们可能会成为它们自己的问题。因此，最好将它们进行裁剪，保留我们需要的那些，并将其余的归档。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><hr>
<p>logrotate 实用程序在管理日志方面非常出色。它可以轮转日志、压缩日志、通过电子邮件发送日志、删除日志、归档日志，并在你需要时开始记录最新的。</p>
<p>运行 logrotate 非常简单——只需要运行 logrotate -vs state-file config-file。在上面的命令中，v 选项开启详细模式，s 指定一个状态文件，最后的 config-file 是配置文件，你可以指定需要做什么。</p>
<h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><hr>
<p>让我们看看在我们的系统上静默运行的 logrotate 配置，它管理我们在 &#x2F;var&#x2F;log 目录中找到的大量日志。查看该目录中的当前文件。你是否看到很多 *.[number].gz 文件？这就是 logrotate 正在做的。你可以在 &#x2F;etc&#x2F;logrotate.d&#x2F;rsyslog 下找到此配置文件。我的配置文件如下：</p>
<p>&#x2F;var&#x2F;log&#x2F;syslog<br>{<br>        rotate 7<br>        daily<br>        missingok<br>        notifempty<br>        delaycompress<br>        compress<br>        postrotate<br>                reload rsyslog &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1  true<br>        endscript<br>}<br>&#x2F;var&#x2F;log&#x2F;mail.info<br>&#x2F;var&#x2F;log&#x2F;mail.warn<br>&#x2F;var&#x2F;log&#x2F;mail.err<br>&#x2F;var&#x2F;log&#x2F;mail.log<br>&#x2F;var&#x2F;log&#x2F;daemon.log<br>&#x2F;var&#x2F;log&#x2F;kern.log<br>&#x2F;var&#x2F;log&#x2F;auth.log<br>&#x2F;var&#x2F;log&#x2F;user.log<br>&#x2F;var&#x2F;log&#x2F;lpr.log<br>&#x2F;var&#x2F;log&#x2F;cron.log<br>&#x2F;var&#x2F;log&#x2F;debug<br>&#x2F;var&#x2F;log&#x2F;messages<br>{<br>        rotate 4<br>        weekly<br>        missingok<br>        notifempty<br>        compress<br>        delaycompress<br>        sharedscripts<br>        postrotate<br>                reload rsyslog &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1  true<br>        endscript<br>}</p>
<p>该文件首先定义了轮转 &#x2F;var&#x2F;log&#x2F;syslog 文件的说明，这些说明包含在后面的花括号中。以下是它们的含义：</p>
<p>◈ rotate 7: 保留最近 7 次轮转的日志。然后开始删除超出的。<br>◈ daily: 每天轮转日志，与 rotate 7 一起使用，这意味着日志将保留过去 7 天。其它选项是每周、每月、每年。还有一个大小参数，如果日志文件的大小增加超过指定的限制（例如，大小 10k、大小 10M、大小 10G 等），则将轮转日志文件。如果未指定任何内容，日志将在运行 logrotate 时轮转。你甚至可以在 cron 中运行 logrotate 以便在更具体的时间间隔内使用它。<br>◈ missingok: 如果日志文件缺失也没关系。不要惊慌。<br>◈ notifempty: 日志文件为空时不轮转。<br>◈ compress: 开启压缩，使用 nocompress 关闭它。<br>◈ delaycompress: 如果压缩已打开，则将压缩延迟到下一次轮转。这允许至少存在一个轮转但未压缩的文件。如果你希望昨天的日志保持未压缩以便进行故障排除，那么此配置会很有用。如果某些程序在重新启动&#x2F;重新加载之前可能仍然写入旧文件，这也很有帮助，例如 Apache。<br>◈ postrotate&#x2F;endscript: 轮转后运行此部分中的脚本。有助于做清理工作。还有一个 prerotate&#x2F;endscript 用于在轮转开始之前执行操作。</p>
<p>你能弄清楚下一节对上面配置中提到的所有文件做了什么吗？第二节中唯一多出的参数是 sharedscripts，它告诉 logrotate 在所有日志轮转完成之前不要运行 postrotate&#x2F;endscript 中的部分。它可以防止脚本在每一次轮转时执行，只在最后一次轮转完成时执行。</p>
<h3 id="看logrotate详细模式指定一个状态文件"><a href="#看logrotate详细模式指定一个状态文件" class="headerlink" title="看logrotate详细模式指定一个状态文件"></a>看logrotate详细模式指定一个状态文件</h3><hr>
<p>我使用下面的配置来处理我系统上的 Nginx 的访问和错误日志。</p>
<p>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log  {<br>        size 1<br>        missingok<br>        notifempty<br>        create 544 www-data adm<br>        rotate 30<br>        compress<br>        delaycompress<br>        dateext<br>        dateformat -%Y-%m-%d-%s<br>        sharedscripts<br>        extension .log<br>        postrotate<br>                service nginx reload<br>        endscript<br>}</p>
<p>上面的脚本可以使用如下命令运行：</p>
<p>logrotate -vs state-file &#x2F;tmp&#x2F;logrotate</p>
<p>第一次运行该命令会给出以下输出：</p>
<p>reading config file &#x2F;tmp&#x2F;logrotate<br>extension is now .log<br>Handling 1 logs<br>rotating pattern: &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log   1 bytes (30 rotations)<br>empty log files are not rotated, old logs are removed<br>considering log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>  log needs rotating<br>considering log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<br>  log does not need rotating<br>rotating log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log, log-&gt;rotateCount is 30<br>Converted ‘ -%Y-%m-%d-%s’ -&gt; ‘-%Y-%m-%d-%s’<br>dateext suffix ‘-2021-08-27-1485508250’<br>glob pattern ‘-[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]‘<br>glob finding logs to compress failed<br>glob finding old rotated logs failed<br>renaming &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log to &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access-2021-08-27-1485508250.log<br>creating new &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log mode &#x3D; 0544 uid &#x3D; 33 gid &#x3D; 4<br>running postrotate script<br>* Reloading nginx configuration nginx</p>
<p>第二次运行它：</p>
<p>reading config file &#x2F;tmp&#x2F;logrotate<br>extension is now .log<br>Handling 1 logs<br>rotating pattern: &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log   1 bytes (30 rotations)<br>empty log files are not rotated, old logs are removed<br>considering log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>  log needs rotating<br>considering log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<br>  log does not need rotating<br>rotating log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log, log-&gt;rotateCount is 30<br>Converted ‘ -%Y-%m-%d-%s’ -&gt; ‘-%Y-%m-%d-%s’<br>dateext suffix ‘-2021-08-27-1485508280’<br>glob pattern ‘-[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]‘<br>compressing log with: &#x2F;bin&#x2F;gzip<br>renaming &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log to &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access-2021-08-27-1485508280.log<br>creating new &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log mode &#x3D; 0544 uid &#x3D; 33 gid &#x3D; 4<br>running postrotate script<br>* Reloading nginx configuration nginx</p>
<p>第三次运行它：</p>
<p>reading config file &#x2F;tmp&#x2F;logrotate<br>extension is now .log<br>Handling 1 logs<br>rotating pattern: &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log   1 bytes (30 rotations)<br>empty log files are not rotated, old logs are removed<br>considering log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>  log needs rotating<br>considering log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<br>  log does not need rotating<br>rotating log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log, log-&gt;rotateCount is 30<br>Converted ‘ -%Y-%m-%d-%s’ -&gt; ‘-%Y-%m-%d-%s’<br>dateext suffix ‘-2021-08-27-1485508316’<br>glob pattern ‘-[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]‘<br>compressing log with: &#x2F;bin&#x2F;gzip<br>renaming &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log to &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access-2021-08-27-1485508316.log<br>creating new &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log mode &#x3D; 0544 uid &#x3D; 33 gid &#x3D; 4<br>running postrotate script<br>* Reloading nginx configuration nginx</p>
<p>状态文件的内容如下所示：</p>
<p>logrotate state – version 2<br>“&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log” 2021-08-27-9:0:0<br>“&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log” 2021-08-27-9:11:56</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>Logrotate</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Python 多线程 爬虫？</title>
    <url>/2021/10/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-python-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%88%AC%E8%99%AB%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-5.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在 Python 中，多线程最常见的一个场景就是爬虫，例如这样一个需求，有多个结构一样的页面需要爬取，例如下方的URL（豆瓣阿凡达影评，以10个为例）</p>
<p>  url_list &#x3D; [<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=0&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=0&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=20&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=20&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=40&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=40&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=60&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=60&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=80&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=80&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=100&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=100&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=120&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=120&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=140&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=140&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=160&#39;">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=160&#39;</a>,<br>      ‘<a href="https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=180&#39;\]">https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=180&#39;\]</a></p>
<p>如果依次爬取，请求第一个页面——得到返回数据——解析数据——提取、存储数据——请求第二个页面，按照这样的思路，那么大量时间都会浪费在请求、返回数据上，如果在等待第一个页面返回数据时去请求第二个页面，就能有效的提高效率，多线程就可以实现这样的功能。</p>
<p>在Python中实现多线程的方法也很多，我将基于 threading 模块一点一点介绍，注意本文不会太注重于多线程背后的技术概念（面试常问），仅希望用最少的话教会大家如何实现。当然会在最后介绍如何使用threading模块来解决上面的爬虫问题。</p>
<h3 id="threading基本使用"><a href="#threading基本使用" class="headerlink" title="threading基本使用"></a>threading基本使用</h3><hr>
<p>让我们先从一个简单的例子开始，定义do_something函数，执行该函数需要消耗1秒</p>
<p>import time</p>
<p>start &#x3D; time.perf_counter()</p>
<p>def do_something():<br>    print(“-&gt; 线程启动”)<br>    time.sleep(1)<br>    print(“-&gt; 线程结束”)</p>
<p>do_something()</p>
<p>finish &#x3D; time.perf_counter()</p>
<p>print(f”全部任务执行完成，耗时 {round(finish - start,2)} 秒”)</p>
<p>上面的代码不难理解，执行do_something并计算耗时，结果很明显应该是1s</p>
<p>-&gt; 线程启动<br>-&gt; 线程结束<br>全部任务执行完成，耗时 1.01 秒</p>
<p>现在如果需要执行两次do_something，按照最基本的思路</p>
<p>import time</p>
<p>start &#x3D; time.perf_counter()</p>
<p>def do_something():<br>    print(“-&gt; 线程启动”)<br>    time.sleep(1)<br>    print(“-&gt; 线程结束”)</p>
<p>do_something()<br>do_something()</p>
<p>finish &#x3D; time.perf_counter()</p>
<p>print(f”全部任务执行完成，耗时 {round(finish - start,2)} 秒”)</p>
<p>执行上面代码结果也很容易猜到是2秒</p>
<p>-&gt; 线程启动<br>-&gt; 线程结束<br>-&gt; 线程启动<br>-&gt; 线程结束<br>全部任务执行完成，耗时 2.01 秒</p>
<p>这就是最常规的 同步 思路，在CPU执行第一个函数，也就是等待1s的时间内，什么也不干，<br><strong>等第一个函数执行完毕后再执行第二个函数</strong><br><img src="https://img-blog.csdnimg.cn/e220aae9da5c4d3b88d8864a239c4968.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>很明显，这样让CPU干等着啥也不干并不是一个很好的选择，而<strong>多线程</strong>就是解决这一问题的方法之一，<strong>让CPU在等待某个任务完成时去执行更多的操作</strong>，将整个过程简化为下图流程，这样就能充分节省时间图片</p>
<p>现在使用threading来通过多线程的方式实现上面的过程，非常简单，定义两个线程并依次启动即可👇</p>
<p>import time<br>import threading</p>
<p>start &#x3D; time.perf_counter()</p>
<p>def do_something():<br>    print(“-&gt; 线程启动”)<br>    time.sleep(1)<br>    print(“-&gt; 线程结束”)</p>
<p>thread1 &#x3D; threading.Thread(target&#x3D;do_something)<br>thread2 &#x3D; threading.Thread(target&#x3D;do_something)</p>
<p>thread1.start()<br>thread2.start()</p>
<p>finish &#x3D; time.perf_counter()</p>
<p>print(f”全部任务执行完成，耗时 {round(finish - start,2)} 秒”)</p>
<p>执行上面的代码，结果如下</p>
<p>-&gt; 线程启动<br>-&gt; 线程启动<br>全部任务执行完成，耗时 0.0 秒<br>-&gt; 线程结束<br>-&gt; 线程结束</p>
<p>可以看到，<strong>两个子线程确实同时启动，但是主线程并未等待两个子线程执行完毕就直接结束</strong>。</p>
<p>为了解决这个问题，我们可以使用threading.join()方法，意思是在子线程完成运行之前，这个子线程的父线程将一直被阻塞</p>
<p>换成人话就是<strong>让主线程挂起，等待所有子线程结束再执行</strong>，体现到代码上也很简单，只需要添加两行即可</p>
<p>import time<br>import threading</p>
<p>start &#x3D; time.perf_counter()</p>
<p>def do_something():<br>    print(“-&gt; 线程启动”)<br>    time.sleep(1)<br>    print(“-&gt; 线程结束”)</p>
<p>thread1 &#x3D; threading.Thread(target&#x3D;do_something)<br>thread2 &#x3D; threading.Thread(target&#x3D;do_something)</p>
<p>thread1.start()<br>thread2.start()</p>
<p>thread1.join()<br>thread2.join()</p>
<p>finish &#x3D; time.perf_counter()</p>
<p>print(f”全部任务执行完成，耗时 {round(finish - start,2)} 秒”)</p>
<p>运行结果如下，全部代码在1秒内运行完毕</p>
<p>-&gt; 线程启动<br>-&gt; 线程启动<br>-&gt; 线程结束<br>-&gt; 线程结束<br>全部任务执行完成，耗时 1.01 秒</p>
<p>至此，我们就得到了第一个有效的多线程代码，相信你也能大致明白threading的基本使用流程。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><hr>
<p>现在来看看如何在多线程之间传递参数，让我们升级代码：do_something函数来接受一个参数，控制他睡眠等待的时间</p>
<p>def do_something(num):<br>    print(f”-&gt; 线程{num} 启动，睡眠 {num} 秒”)<br>    time.sleep(num)<br>    print(f”-&gt; 线程{num} 结束”)</p>
<p>在 threading 中，创建线程时可以使用 args 来传递参数，例如现在接收一个参数，则上一小节的代码可以如下修改</p>
<p>import time<br>import threading</p>
<p>start &#x3D; time.perf_counter()</p>
<p>def do_something(num):<br>    print(f”-&gt; 线程{num} 启动，睡眠 {num} 秒”)<br>    time.sleep(num)<br>    print(f”-&gt; 线程{num} 结束”)</p>
<p>thread1 &#x3D; threading.Thread(target&#x3D;do_something,args &#x3D; [1])<br>thread2 &#x3D; threading.Thread(target&#x3D;do_something,args &#x3D; [2])</p>
<p>thread1.start()<br>thread2.start()</p>
<p>thread1.join()<br>thread2.join()</p>
<p>finish &#x3D; time.perf_counter()</p>
<p>print(f”全部任务执行完成，耗时 {round(finish - start,2)} 秒”)</p>
<p>这段代码中，我分别让两个线程等待1、2秒，运行结果显然应该是2秒</p>
<p>-&gt; 线程1 启动，睡眠 1 秒<br>-&gt; 线程2 启动，睡眠 2 秒<br>-&gt; 线程1 结束<br>-&gt; 线程2 结束<br>全部任务执行完成，耗时 2.01 秒</p>
<p>如果你的线程函数需要更多的参数，只需要依次向args中追加即可。</p>
<h3 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h3><hr>
<p>上面的案例中，我们仅开启了两个线程，<strong>如果是更多个线程的话，再依次重复定义、启动就会显得十分繁琐，此时我们可以使用循环来处理</strong>。</p>
<p>例如开启10个线程，依次睡眠1-10秒，可以先创建一个 list 用于存储每个线程，接着利用循环依次创建线程，启动后追加到刚刚创建的 list 中，之后再依次等待每个线程执行完毕，代码如下</p>
<p>import time<br>import threading</p>
<p>start &#x3D; time.perf_counter()</p>
<p>def do_something(num):<br>    print(f”-&gt; 线程{num} 启动，睡眠 {num} 秒”)<br>    time.sleep(num)<br>    print(f”-&gt; 线程{num} 结束”)</p>
<p>thread_list &#x3D; []</p>
<p>for i in range(1,11):</p>
<pre><code>thread = threading.Thread(target=do\_something, args=\[i\])
thread.start()
thread\_list.append(thread)
</code></pre>
<p>for t in thread_list:</p>
<pre><code>t.join()
</code></pre>
<p>finish &#x3D; time.perf_counter()</p>
<p>print(f”全部任务执行完成，耗时 {round(finish - start,2)} 秒”)</p>
<p>结果是显然的，虽然我们执行了十次do_something，每次用时1-10秒，但总耗时应该为10秒</p>
<p>-&gt; 线程1 启动，睡眠 1 秒<br>-&gt; 线程2 启动，睡眠 2 秒<br>-&gt; 线程3 启动，睡眠 3 秒<br>-&gt; 线程4 启动，睡眠 4 秒<br>-&gt; 线程5 启动，睡眠 5 秒<br>-&gt; 线程6 启动，睡眠 6 秒<br>-&gt; 线程7 启动，睡眠 7 秒<br>-&gt; 线程8 启动，睡眠 8 秒<br>-&gt; 线程9 启动，睡眠 9 秒<br>-&gt; 线程10 启动，睡眠 10 秒<br>-&gt; 线程1 结束<br>-&gt; 线程2 结束<br>-&gt; 线程3 结束<br>-&gt; 线程4 结束<br>-&gt; 线程5 结束<br>-&gt; 线程6 结束<br>-&gt; 线程7 结束<br>-&gt; 线程8 结束<br>-&gt; 线程9 结束<br>-&gt; 线程10 结束<br>全部任务执行完成，耗时 10.01 秒</p>
<h3 id="共享变量锁的问题"><a href="#共享变量锁的问题" class="headerlink" title="共享变量锁的问题"></a>共享变量锁的问题</h3><hr>
<p>现在，你应该已经了解 threading 最基本的用法，只需要将 do_somthing 函数进行修改即可，但是如果你深入使用，还会有其他的问题出现，例如共享变量的问题，让我们继续探讨。</p>
<p>多线程很常见的一个应用就是爬虫，回到开头的爬虫问题，如果我们希望爬取10个网页的评论，可能会先定一个空dataframe，然后使用多线程都往这个dataframe中写入数据，但由于多个线程同时操作这一个变量，可能会导致评论并不是按照顺序写入的。</p>
<p>例如第一个页面有10条评论，第一个线程写入了2条后，第二个线程将第二个页面的前两条写入，最终导致十个页面的评论是乱序存储！</p>
<p>让我们把这个问题抽象出来，还是之前的代码，稍微修改一下<br><img src="https://img-blog.csdnimg.cn/dc95baddc64b4e81b59b867bae77a381.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们先定义了一个空list，线程函数会将传入的数字添加到该list中，在未加锁的情况下，由于线程竞争，虽然我们线程是按照顺序开启，但是最终数字并不是按照顺序写入。</p>
<p>有没有办法解决呢？当然有，很自然的想法就是<strong>当第一个线程操作该变量时，其他线程等着，写完了再释放，这就是锁</strong>！</p>
<p>先看代码<br><img src="https://img-blog.csdnimg.cn/3e4a2b8e6b5048ae9659ba5c34adf646.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>在上面的代码中，我们使用 threding.Lock 创建了一个线程锁，之后在线程函数操作 result 前，首先使用 lock.acquire() 加上锁，之后操作 results ，在修改完后使用 lock.relese() 释放，此时其他线程若想操作 results 则会阻塞，等该线程释放后才能拿走操作中，这样我们就保证了线程是“安全的”！</p>
<p>最基本的线程锁用法就如上面代码所示，<strong>定义锁 –&gt; 上锁 –&gt; 解锁</strong>，但是一定要注意，lock.acquire() 和 lock.relese()，<strong>如果加了锁但是没有释放，后面的线程将会全部阻塞</strong>！</p>
<h3 id="限制线程数量"><a href="#限制线程数量" class="headerlink" title="限制线程数量"></a>限制线程数量</h3><hr>
<p>最后还有一个常见的问题，上面我们需要<strong>执行几次线程函数就开了几个线程</strong>，但是如果需要爬成千上万个网页，开这么多线程cpu一定不同意，代码也会在开启的线程达到一定数量后报错。</p>
<p>所以如何让程序只启动我们指定的线程数量，例如一次开五个线程，结束一个再添加一个，直到全部任务完成？</p>
<p>还是锁！在 threading 模块中有一个 BoundedSemaphore（信号量）类，我们可以给他一个初始的信号量（最大线程数），之后每次有线程获得信号量的时候（即 acquire() ）计数器－1，释放信号量时候(release())计数器＋1，计数器为0的时候其它线程就被阻塞无法获得信号量。当计数器为设定好的上限的时候 BoundedSemaphore 就无法进行 release() 操作了。</p>
<p>体现到代码上则比较简单，还是基于上面的例子修改<br><img src="https://img-blog.csdnimg.cn/8d46c91f13a94ddaaeed1087a059092c.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>总共需要运行十次，我们定义最大线程数为3，并在线程启动前调用acquire方法增加一个计数，在线程最后释放。</p>
<p>此时程序一次只能启动三个线程，如图中所示，首先启动123，之后完成123，启动456，当第四个线程结束启动第七个线程······直到全部线程结束。</p>
<p>这里我们同时使用了上一节说的线程锁来保护变量，用 BoundedSemaphore 锁来控制最大线程数，<strong>在实际写代码时就需要小心检查锁是否正确释放，否则就会报错</strong>！</p>
<h3 id="一个真实的多线程爬虫案例"><a href="#一个真实的多线程爬虫案例" class="headerlink" title="一个真实的多线程爬虫案例"></a>一个真实的多线程爬虫案例</h3><hr>
<p>至此，threading 模块最常见的用法就介绍完毕，现在让我们回到本文一开始的问题，有多个（以十个为例）URL需要爬取，既然每个页面需要执行的操作一样，如果等待一个页面爬取完毕再爬第二页面就太浪费时间了。这时就可以仿照上面的思路去使用多线程加速。</p>
<p>我们只需要将上面的do_something函数修改为对也面的爬取操作，之后的创建启动线程操作不变即可，代码如下</p>
<p>import time<br>import threading<br>import requests<br>import pandas as pd<br>from faker import Faker<br>from bs4 import BeautifulSoup</p>
<p>def craw_url(url):<br>    global df<br>    fake &#x3D; Faker()<br>    headers &#x3D; {‘User-Agent’: fake.user_agent()}<br>    r &#x3D; requests.get(url, headers&#x3D;headers)<br>    soup &#x3D; BeautifulSoup(r.content, ‘html.parser’)<br>    review_list &#x3D; soup.find_all(class_&#x3D;”main review-item”)</p>
<pre><code>for i in range(len(review\_list)):

    rank = review\_list\[i\].select(&#39;span&#39;)\[0\].get(&#39;title&#39;)
    time1 = review\_list\[i\].select(&#39;span&#39;)\[1\].get(&#39;content&#39;)
    title = review\_list\[i\].select(&#39;h2&gt;a&#39;)\[0\].text
    df = df.append(&#123;&#39;时间&#39;: time1,
                    &#39;评分&#39;: rank,
                    &#39;标题&#39;: title, &#125;, ignore\_index=True)

print(&quot;-&gt; 爬取完成&quot;)
</code></pre>
<p>if __name__ &#x3D;&#x3D; ‘__main__‘:</p>
<pre><code>start = time.perf\_counter()
df = pd.DataFrame(columns=\[&#39;时间&#39;, &#39;评分&#39;, &#39;标题&#39;\])

url\_list = \[
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=0&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=20&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=40&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=60&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=80&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=100&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=120&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=140&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=160&#39;,
    &#39;https://movie.douban.com/subject/1652587/reviews?sort=time&amp;start=180&#39;\]
thread\_list = \[\]
for i in url\_list:

    thread = threading.Thread(target=craw\_url, args=\[i\])
    thread.start()
    thread\_list.append(thread)

for t in thread\_list:

    t.join()

finish = time.perf\_counter()

print(f&quot;全部任务执行完成，耗时 &#123;round(finish - start,2)&#125; 秒&quot;)
</code></pre>
<p>执行这段代码，差不多仅用了1秒就将全部内容爬取并存储到 dataframe 中，比同步的代码块了近十倍！如果感兴趣的话可以自己尝试一下。</p>
<p>至此，有关 Python 多线程模块 threading 的基本用法与需要注意的几点就介绍完毕，如果全部认真看完的话，我相信你一定能照猫画虎写出第一个多线程爬虫脚本。</p>
<p>当然有关 Python 多线程还有很多饱受诟病的争议（GIL），多线程的实现方法也远不止 threading 模块，例如更常见的写法是通过 concurrent.futures 模块以及多进程、协程，这些都留在本系列后续文章中再进一步讨论！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>共享变量</tag>
        <tag>多线程</tag>
        <tag>爬虫</tag>
        <tag>线程数</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 tcpdump 命令抓包 ？常用选项</title>
    <url>/2021/11/22/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-tcpdump-%E5%91%BD%E4%BB%A4%E6%8A%93%E5%8C%85-%EF%BC%9F%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021112208115219.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>tcpdump用于捕获和分析网络流量。系统管理员可以使用它来查看实时流量或将输出保存到文件中并在以后进行分析。下面列出6个常用选项</p>
<h3 id="tcpdump-D-选项"><a href="#tcpdump-D-选项" class="headerlink" title="tcpdump -D 选项"></a>tcpdump -D 选项</h3><hr>
<p>tcpdump的-D获取接口设备列表。看到此列表后，可以决定要在哪个接口上捕获流量。它还告诉你接口是否已启动、正在运行，以及它是否是环回接口，如下所示：</p>
<p>[root@localhost ~]# tcpdump -D<br>1.ens160 [Up, Running]<br>2.lo [Up, Running, Loopback]<br>3.any (Pseudo-device that captures on all interfaces) [Up, Running]<br>4.bluetooth-monitor (Bluetooth Linux Monitor) [none]<br>5.nflog (Linux netfilter log (NFLOG) interface) [none]<br>6.nfqueue (Linux netfilter queue (NFQUEUE) interface) [none]<br>7.usbmon0 (All USB buses) [none]<br>8.usbmon1 (USB bus number 1)<br>9.usbmon2 (USB bus number 2)</p>
<h3 id="tcpdump-c-数字-选项"><a href="#tcpdump-c-数字-选项" class="headerlink" title="tcpdump -c [数字]选项"></a>tcpdump -c [数字]选项</h3><hr>
<p>-c 选项捕获 X 个数据包，然后停止。否则，tcpdump 将无限地继续运行。因此，当只想捕获一小部分数据包样本时，可以使用此选项。但是如果接口上没有数据流量，tcpdump 会一直等待。</p>
<p>[root@localhost ~]# tcpdump -c 5 -i any<br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes<br>17:33:47.713379 IP localhost.localdomain.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 714380127:714380371, ack 1854022435, win 388, length 244<br>17:33:47.713785 IP localhost.localdomain.36821 &gt; _gateway.domain: 36365+ PTR? 1.43.168.192.in-addr.arpa. (43)<br>17:33:47.713939 IP 192.168.43.1.39970 &gt; localhost.localdomain.ssh: Flags [.], ack 244, win 4104, length 0<br>17:33:47.716053 IP _gateway.domain &gt; localhost.localdomain.36821: 36365 NXDomain 0&#x2F;1&#x2F;0 (78)<br>17:33:47.716543 IP localhost.localdomain.57441 &gt; _gateway.domain: 61445+ PTR? 131.43.168.192.in-addr.arpa. (45)<br>5 packets captured<br>9 packets received by filter<br>0 packets dropped by kernel</p>
<h3 id="tcpdump-n-选项"><a href="#tcpdump-n-选项" class="headerlink" title="tcpdump -n 选项"></a>tcpdump -n 选项</h3><hr>
<p>-n选项不将IP地址解析为域名，直接以IP地址显示：</p>
<p>[root@localhost ~]# tcpdump -c 5 -i any -n<br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes<br>17:36:38.980756 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 714383039:714383283, ack 1854024303, win 388, length 244<br>17:36:38.981032 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 244:440, ack 1, win 388, length 196<br>17:36:38.981096 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 440:604, ack 1, win 388, length 164<br>17:36:38.981153 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 604:768, ack 1, win 388, length 164<br>17:36:38.981208 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 768:932, ack 1, win 388, length 164<br>5 packets captured<br>5 packets received by filter<br>0 packets dropped by kernel</p>
<h3 id="tcpdump-s-选项"><a href="#tcpdump-s-选项" class="headerlink" title="tcpdump -s 选项"></a>tcpdump -s 选项</h3><hr>
<p>带有-sXXX 的 tcpdump 可帮助你控制捕获数据包的大小。在上一个输出的第三行中，可以看到它表示捕获大小 262144 字节。可以使用-s选项更改捕获数据大小。如果你只想检查数据包标头，则可以使用较小的大小进行捕获：</p>
<p>[root@localhost ~]# tcpdump -c 5 -i any -n -s64<br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on any, link-type LINUX_SLL (Linux cooked), capture size 64 bytes<br>17:47:44.437891 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 714405271:714405515, ack 1854033767, win 388, length 244<br>17:47:44.438153 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 244:440, ack 1, win 388, length 196<br>17:47:44.438220 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 440:604, ack 1, win 388, length 164<br>17:47:44.438301 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 604:768, ack 1, win 388, length 164<br>17:47:44.438361 IP 192.168.43.131.ssh &gt; 192.168.43.1.39970: Flags [P.], seq 768:932, ack 1, win 388, length 164<br>5 packets captured<br>5 packets received by filter<br>0 packets dropped by kernel</p>
<h3 id="tcpdump-端口捕获"><a href="#tcpdump-端口捕获" class="headerlink" title="tcpdump 端口捕获"></a>tcpdump 端口捕获</h3><hr>
<p>tcpdump 允许你指定使用某个端口作为源或目标的网络数据包。例如，要捕获 DNS 流量，你可以使用端口 53。可以在 port选项前加上 src&#x2F;dst。如 src port 53 或 dst port 53 并进一步过滤它。</p>
<p>[root@localhost ~]# tcpdump -i any port 53 -n<br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes<br>17:50:48.158109 IP 192.168.43.131.47054 &gt; 192.168.43.2.domain: 58704+ A? <a href="http://www.baidu.com/">www.baidu.com</a>. (31)<br>17:50:48.158152 IP 192.168.43.131.47054 &gt; 192.168.43.2.domain: 60504+ AAAA? <a href="http://www.baidu.com/">www.baidu.com</a>. (31)<br>17:50:48.159180 IP 192.168.43.2.domain &gt; 192.168.43.131.47054: 60504 1&#x2F;1&#x2F;0 CNAME <a href="http://www.a.shifen.com/">www.a.shifen.com</a>. (115)<br>17:50:48.162018 IP 192.168.43.2.domain &gt; 192.168.43.131.47054: 58704 3&#x2F;0&#x2F;0 CNAME <a href="http://www.a.shifen.com/">www.a.shifen.com</a>., A 180.101.49.11, A 180.101.49.12 (90)</p>
<p>下面只获取源端口为53的数据包，其中-nn选项表示不解析IP地址和端口：</p>
<p>[root@localhost ~]# tcpdump -c 5 -i any src port 53 -nn -s64<br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on any, link-type LINUX_SLL (Linux cooked), capture size 64 bytes<br>18:00:41.604216 IP 192.168.43.2.53 &gt; 192.168.43.131.48245: 50676[domain]<br>18:00:41.606390 IP 192.168.43.2.53 &gt; 192.168.43.131.48245: 19947[domain]<br>18:00:41.631001 IP 192.168.43.2.53 &gt; 192.168.43.131.54536: 31350 NXDomain[domain]<br>18:00:46.110591 IP 192.168.43.2.53 &gt; 192.168.43.131.42379: 17512[domain]<br>18:00:46.110603 IP 192.168.43.2.53 &gt; 192.168.43.131.42379: 40562[domain]<br>5 packets captured<br>5 packets received by filter<br>0 packets dropped by kernel</p>
<p>下面只获取目的端口为53的数据包：</p>
<p>[root@localhost ~]# tcpdump -c 5 -i any dst port 53 -nn -s64<br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on any, link-type LINUX_SLL (Linux cooked), capture size 64 bytes<br>18:01:22.568585 IP 192.168.43.131.49444 &gt; 192.168.43.2.53: 27625+[domain]<br>18:01:22.568623 IP 192.168.43.131.49444 &gt; 192.168.43.2.53: 42481+[domain]<br>18:01:22.595257 IP 192.168.43.131.45790 &gt; 192.168.43.2.53: 28116+[domain]<br>18:01:23.850730 IP 192.168.43.131.34861 &gt; 192.168.43.2.53: 23444+[domain]<br>18:01:23.850762 IP 192.168.43.131.34861 &gt; 192.168.43.2.53: 23964+[domain]<br>5 packets captured<br>5 packets received by filter<br>0 packets dropped by kernel</p>
<h3 id="tcpdump-w-选项"><a href="#tcpdump-w-选项" class="headerlink" title="tcpdump -w 选项"></a>tcpdump -w 选项</h3><hr>
<p>如果要将 tcpdump 的输出写入文件，请使用选项-w选项写入文件。如果想查看写了多少数据包，可以加-v选项。</p>
<p>[root@localhost ~]# tcpdump -c 4 -i any port 53 -nn -w dns.pcap -v<br>dropped privs to tcpdump<br>tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes<br>4 packets captured<br>6 packets received by filter<br>0 packets dropped by kernel</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>tcpdump 用于收集有关网络流量数据的出色工具。数据包捕获为故障排除和安全分析提供了有用的信息</p>
]]></content>
      <categories>
        <category>Tcpdump</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tcpdump</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用find命令查找系统文件?</title>
    <url>/2021/11/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8find%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-11.png"></p>
<h3 id="1、通过扩展名查找文件"><a href="#1、通过扩展名查找文件" class="headerlink" title="1、通过扩展名查找文件"></a>1、通过扩展名查找文件</h3><hr>
<p>find . -name “*.txt”<br>find &#x2F; -name “*.log”</p>
<h3 id="2、按文件名查找"><a href="#2、按文件名查找" class="headerlink" title="2、按文件名查找"></a>2、按文件名查找</h3><hr>
<p>find &#x2F; -name error.log<br>find &#x2F; -name nginx.conf</p>
<h3 id="3、按所属组所有者查找文件"><a href="#3、按所属组所有者查找文件" class="headerlink" title="3、按所属组所有者查找文件"></a>3、按所属组所有者查找文件</h3><hr>
<p>查找~目录下所属组为code404的文件</p>
<p>find ~ -group code404 -print</p>
<p>查找~目录下所属者为code404的文件</p>
<p>find ~ -user code404 -print</p>
<p>查找属主账户已经被删除的文件，查找在&#x2F;etc&#x2F;passwd不存在的账户</p>
<p>find &#x2F;home -nouser -print</p>
<h3 id="4、按权限查找文件"><a href="#4、按权限查找文件" class="headerlink" title="4、按权限查找文件"></a>4、按权限查找文件</h3><hr>
<p>find . -perm 755  -print  #查找当前目录下755权限的文件 </p>
<h3 id="5、按类型查找文件"><a href="#5、按类型查找文件" class="headerlink" title="5、按类型查找文件"></a>5、按类型查找文件</h3><hr>
<p>find . -type d -print   #查找当前目录下的所有目录<br>find . ! -type d -print #查找当前目录下除了目录的其他所有类型文件</p>
<h3 id="6、按修改日期查找文件"><a href="#6、按修改日期查找文件" class="headerlink" title="6、按修改日期查找文件"></a>6、按修改日期查找文件</h3><hr>
<p>find . -mtime -3 -print  #查找更改时间在3天之内的文件<br>find . -mtime -2 -print  #查找更改时间在2天之前的文件</p>
<h3 id="7、按大小查找文件"><a href="#7、按大小查找文件" class="headerlink" title="7、按大小查找文件"></a>7、按大小查找文件</h3><hr>
<p>find . -size 100c -print #查找当前目录下文件长度为100字节的文件<br>find . -size +10 -print  #查找当前目录下超过10块的文件（1块&#x3D;512字节）<br>find &#x2F; -size +100M       #查找系统中文件大小超过100M的文件</p>
<h3 id="8、排除某个目录"><a href="#8、排除某个目录" class="headerlink" title="8、排除某个目录"></a>8、排除某个目录</h3><hr>
<p>查找在&#x2F;code404目录下除了src目录的其他文件</p>
<p>find &#x2F;code404 -path “&#x2F;code404&#x2F;src” -prune -o -print     </p>
<p>查找在&#x2F;code404目录下除了src目录的txt文件</p>
<p>find &#x2F;code404 -path “&#x2F;code404&#x2F;src” -prune -o -name “*.txt” -print</p>
<h3 id="9、目录与文件查找顺序"><a href="#9、目录与文件查找顺序" class="headerlink" title="9、目录与文件查找顺序"></a>9、目录与文件查找顺序</h3><hr>
<p>find &#x2F;code404 -depth -print</p>
<p>有dept：先处理目录下的子内容，再处理目录本身</p>
<p>无dept：先处理目录本身，然后处理目录下的子内容</p>
<h3 id="10、正则查找"><a href="#10、正则查找" class="headerlink" title="10、正则查找"></a>10、正则查找</h3><hr>
<p>查找当前目录及子目录中查找文件名以大写字母开头的文件</p>
<p>find . -name “[A-Z]*“ -print    </p>
<p>查找某个文件夹下面的哪些具体文件包含某一个字段</p>
<p>find .  xargs grep “YZS”</p>
<h3 id="11、查找并对结果做相关操作"><a href="#11、查找并对结果做相关操作" class="headerlink" title="11、查找并对结果做相关操作"></a>11、查找并对结果做相关操作</h3><hr>
<p>找到为文件类型为软连接的文件</p>
<p>find . -type l -exec ls -l {} \;</p>
<p>找到后删除</p>
<p>find . -name “*.txt” -print0  xargs -0 rm -rf</p>
<p>找到后拷贝</p>
<p>find &#x2F; -path ‘&#x2F;etc&#x2F;ssl&#x2F;certs’ -prune -o -name *.pem  xargs -i cp {} .&#x2F;pem</p>
<p>文件分类</p>
<p>find . -type f -print  xargs file</p>
<h3 id="12、匹配多个文件"><a href="#12、匹配多个文件" class="headerlink" title="12、匹配多个文件"></a>12、匹配多个文件</h3><hr>
<p>find . \(  -name “*.txt” -o -name “*.pdf” \)</p>
<p>-o 为 or的意思</p>
<h3 id="13、find排除某个目录"><a href="#13、find排除某个目录" class="headerlink" title="13、find排除某个目录"></a>13、find排除某个目录</h3><hr>
<p>find 查找路径 -path排除目录路径</p>
<p>find . -path ‘.&#x2F;home’ -prune -o -name *.log</p>
<p>find后面的第一个英文点号.表示当前根路径，-path .&#x2F;home表示匹配路径为.&#x2F;home的文件夹，-prune表示把前面命令所匹配到的路径排除，不再进入该路径下面继续查找，-o表示或，-name表示查找log后缀的文件，-print表示打印查找结果到命令行终端。</p>
<p><img src="https://img-blog.csdnimg.cn/ce3457b93dd4433abdcf6bda708dea7c.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>最右边为当前时，+5 代表大于等于 6 天前的档案名， -5 代表小于等于 5 天内的档案名，5 则是代表 5-6 那一天的档案名。</p>
<p>find与时间有关的选项有-atime（访问时间）、-ctime（改变时间）、-mtime（属性修改时间），参数为后面跟的时间n;</p>
<p>find . -atime n     这里的n表示n天之前的“一天之内”被访问过的文件<br>find . -atime +n   列出在n天之前（不包含n天本身）被访问过的文件<br>find . -atime -n    列出在n天之内（包含n天本身）被访问过的文件</p>
<h3 id="1：创建文件"><a href="#1：创建文件" class="headerlink" title="1：创建文件"></a>1：创建文件</h3><hr>
<p>touch -a -d “2021-01-01 15:00” a.txt<br>touch -a -d “2021-01-02 15:00” b.txt<br>touch -a -d “2021-01-03 15:00” c.txt<br>touch -a -d “2021-01-04 15:00” d.txt<br>touch -a -d “2021-01-05 15:00” e.txt<br>touch -a -d “2021-01-06 15:00” f.txt<br>touch -a -d “2021-01-07 15:00” g.txt<br>touch -a -d “2021-01-08 15:00” h.txt</p>
<h3 id="2：以下三条命令得到的结果分别为："><a href="#2：以下三条命令得到的结果分别为：" class="headerlink" title="2：以下三条命令得到的结果分别为："></a>2：以下三条命令得到的结果分别为：</h3><hr>
<p>找出两天之前的一天内被访问文件（距离现在的-72小时 -48小时之间）</p>
<p>find . -atime 2 </p>
<p>找出距离此时两天之内的被访问的文件（距离现在的前48小时之内）</p>
<p>find . -atime -2  </p>
<p>找出两天之前，不包括两天之前的一天（也就是不包括-2和2的）之前的被访问的文件（离此时72小时之前）</p>
<p>find . -atime +2</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>find</tag>
        <tag>日期</tag>
        <tag>时间</tag>
        <tag>查找文件</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Jenkins 流水线自动化部署 Go 项目?</title>
    <url>/2021/10/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8jenkins-%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-go-%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-12.png"></p>
<h3 id="自动化流程介绍"><a href="#自动化流程介绍" class="headerlink" title="自动化流程介绍"></a>自动化流程介绍</h3><hr>
<p>企业里常见的项目自动化流程应该构建机从代码仓拉取代码进行构建，构建完成后会将产物推送到制品库中，比如镜像仓， 然后中间会有测试环境，用于进行自动化测试或人工测试，最后进行远程部署。<br><img src="https://img-blog.csdnimg.cn/8729d8e47b0d48c68c7490d103ed037c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/451f179190df4856835554a583e45b92.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><hr>
<p>这里我们用的 Go 的项目结构，它大概的结构应该是下面这样的：</p>
<p>-- my-app<br>    – .gitignore<br>    – README.md<br>    – LICENSE<br>    – go.mod<br>    – go.sum<br>    – main.go<br>    – pkg<br>        – …</p>
<h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><hr>
<p>因为这里构建的是 Go 的项目，如果用到私有库，在 go mod tidy 时会要求提供 Git 凭证，我们可以现在 Jenkins 的凭证管理中创建 Username with password 类型的凭证，其中 Username 就是 GitHub 的用户名，password 则是 GitHub 的 AccessToken，这里主要用到的是 AccessToken，Username 其实并不需要。但在 Jenkins Pipeline 中使用 usernamePassword 时要求同时定义用户名变量名 usernameVariable 和 密码变量名 passwordVariable 。</p>
<p>stage(‘Build’) {<br>    steps {<br>        withCredentials(bindings: [<br>            usernamePassword(credentialsId: ‘GITHUB_CREDENTIAL’,                usernameVariable: ‘GITHUB_USER’,                passwordVariable: ‘GITHUB_ACCESS_TOKEN’<br>            )<br>        ]) {<br>            sh ‘’’<br>            git config –global url.”https:&#x2F;&#x2F;${GITHUB_ACCESS_TOKEN}:<a href="mailto:&#120;&#x2d;&#111;&#x61;&#x75;&#116;&#104;&#x2d;&#x62;&#x61;&#x73;&#x69;&#x63;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#120;&#x2d;&#111;&#x61;&#x75;&#116;&#104;&#x2d;&#x62;&#x61;&#x73;&#x69;&#x63;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>&#x2F;“.insteadOf “<a href="https://github.com/&quot;">https://github.com/&quot;</a></p>
<pre><code>        go mod tidy
        go build -o bin/my-app main.go
        &#39;&#39;&#39;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h3 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h3><hr>
<p>在构建完成后，我们会将构建产物推送到制品库，然后我们可以从制品库中拉取构建产物进行部署测试环境并进行测试，在验证通过后，会从制品库中拉取验证通过的产物进行部署上线。</p>
<p>但在本文中，我们的应用相对简单，可以忽略推送产物到制品库以及中间的测试验证环节，目标是实现构建后立即部署上线。</p>
<p>一般来说，线上环境和构建环境不会是同一台机器，所以这个时候我们需要将构建产物复制到另一台服务器上，然后在另一台服务器上进行部署。</p>
<p>由于需要对另一台服务器进行操作，所以我们需要在 Jenkins 上配置 DEPLOY_HOST、DEPLOY_PORT 和 SSH_CREDENTIAL 三个凭证，其中 DEPLOY_HOST 和 DEPLOY_PORT 是 Secret text 类型的凭证，SSH_CREDENTIAL 是 SSH Username with private key 类型的凭证。</p>
<p>stage(‘Deploy’) {<br>    environment {<br>        DEPLOY_HOST &#x3D; credentials(‘DEPLOY_HOST’)<br>        DEPLOY_PORT &#x3D; credentials(‘DEPLOY_PORT’)<br>    }<br>    steps {<br>        withCredentials([<br>            sshUserPrivateKey(credentialsId: ‘SSH_CREDENTIAL’,                keyFileVariable: ‘SSH_KEY’,                usernameVariable: ‘SSH_USERNAME’),<br>        ]) {<br>            sh “””<br>            mkdir -p ~&#x2F;.ssh &amp;&amp; chmod 700 ~&#x2F;.ssh<br>            echo ‘StrictHostKeyChecking no’ &gt;&gt; &#x2F;etc&#x2F;ssh&#x2F;ssh_config<br>            cat ${SSH_KEY} &gt; ~&#x2F;.ssh&#x2F;id_rsa &amp;&amp; chmod 400 ~&#x2F;.ssh&#x2F;id_rsa</p>
<pre><code>        scp -P $&#123;DEPLOY\_PORT&#125; bin/my-app $&#123;SSH\_USER&#125;@$&#123;DEPLOY\_HOST&#125;:/data/my-app
        ssh -p $&#123;DEPLOY\_PORT&#125; $&#123;SSH\_USER&#125;@$&#123;DEPLOY\_HOST&#125; \\&quot;nohup /data/my-app &gt;&gt; /data/my-app.log 2&gt;&amp;1 &amp;\\&quot;
        &quot;&quot;&quot;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h3 id="部署的步骤主要包括："><a href="#部署的步骤主要包括：" class="headerlink" title="部署的步骤主要包括："></a>部署的步骤主要包括：</h3><hr>
<ul>
<li>复制构建产物到部署服务器</li>
<li>在部署服务器上执行部署命令，比如 nohup &#x2F;data&#x2F;my-app &gt;&gt; &#x2F;data&#x2F;my-app.log 2&gt;&amp;1 &amp;</li>
</ul>
<p>其中简化了一些细节，比如在部署前，我们需要先备份数据。所以这里我们可以写一个复杂的部署脚本 deploy.sh 放在项目中，然后在 Jenkins Pipeline 中使用 scp 将部署脚本文件复制到部署服务器，假设放在 &#x2F;data&#x2F;deploy.sh，最后只需 ssh -p ${DEPLOY_PORT} {DEPLOY_HOST} &#x2F;bin&#x2F;bash &#x2F;data&#x2F;deploy.sh 即可。</p>
<p>完整的 Jenkins Pipeline</p>
<p>pipeline {<br>    agent {<br>        docker {<br>            image ‘golang:1.15-alpine’<br>            args ‘-v &#x2F;data&#x2F;my-app-cache:&#x2F;go&#x2F;.cache’<br>        }<br>    }</p>
<pre><code>options &#123;
    timeout(time: 20, unit: &#39;MINUTES&#39;)
    disableConcurrentBuilds()
&#125;

stages &#123;
    stage(&#39;Build&#39;) &#123;
        steps &#123;
            withCredentials(bindings: \[
                usernamePassword(credentialsId: &#39;GITHUB\_CREDENTIAL&#39;,                        usernameVariable: &#39;GITHUB\_USER&#39;,                        passwordVariable: &#39;GITHUB\_ACCESS\_TOKEN&#39;
                )
            \]) &#123;
                sh &#39;&#39;&#39;
                git config --global url.&quot;https://$&#123;GITHUB\_ACCESS\_TOKEN&#125;:x-oauth-basic@github.com/&quot;.insteadOf &quot;https://github.com/&quot;

                go mod tidy
                go build -o bin/my-app main.go
                &#39;&#39;&#39;
            &#125;
        &#125;
    &#125;

    stage(&#39;Deploy&#39;) &#123;
        environment &#123;
            DEPLOY\_HOST = credentials(&#39;DEPLOY\_HOST&#39;)
            DEPLOY\_PORT = credentials(&#39;DEPLOY\_PORT&#39;)
        &#125;
        steps &#123;
            withCredentials(\[
                sshUserPrivateKey(credentialsId: &#39;SSH\_CREDENTIAL&#39;,                        keyFileVariable: &#39;SSH\_KEY&#39;,                        usernameVariable: &#39;SSH\_USERNAME&#39;),
            \]) &#123;
                sh &quot;&quot;&quot;
                mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh
                echo &#39;StrictHostKeyChecking no&#39; &gt;&gt; /etc/ssh/ssh\_config
                cat $&#123;SSH\_KEY&#125; &gt; ~/.ssh/id\_rsa &amp;&amp; chmod 400 ~/.ssh/id\_rsa

                scp -P $&#123;DEPLOY\_PORT&#125; bin/my-app $&#123;SSH\_USER&#125;@$&#123;DEPLOY\_HOST&#125;:/data/my-app
                ssh -p $&#123;DEPLOY\_PORT&#125; $&#123;SSH\_USER&#125;@$&#123;DEPLOY\_HOST&#125; \\&quot;nohup /data/my-app &gt;&gt; /data/my-app.log 2&gt;&amp;1 &amp;\\&quot;
                &quot;&quot;&quot;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>pipeline</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用python从马赛克中恢复原始内容</title>
    <url>/2021/06/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8python%E4%BB%8E%E9%A9%AC%E8%B5%9B%E5%85%8B%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%8E%9F%E5%A7%8B%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-50.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Depix 是用于将数字、字母从像素化的图片中还原的Python工具，简单点说，就是从马赛克中恢复原始内容，目前有它的一些限制，仅适用于使用线性滤波器创建的像素化图像。</p>
<p>许多领域都使用像素化来混淆图片中的信息，像素化描述了部分降低图片分辨率以审查信息的过程，Depix的算法使用了线性滤波器的原理，线性滤波器采用一组像素，并用这组像素中所有像素的平均值覆盖这些像素。线性滤波器是一种确定性算法，因此对相同值进行像素化将始终产生相同的结果。</p>
<p>项目地址是：</p>
<p><a href="https://github.com/beurtschipper/Depix">https://github.com/beurtschipper/Depix</a></p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><ul>
<li>Clone仓库源码：</li>
</ul>
<p>git clone <a href="https://github.com/beurtschipper/Depix.gitcd">https://github.com/beurtschipper/Depix.gitcd</a> Depix</p>
<ul>
<li>安装依赖：</li>
</ul>
<p>python -m pip install -r requirements.txt</p>
<ul>
<li>运行：</li>
</ul>
<p>python depix.py -p &#x2F;path&#x2F;to&#x2F;your&#x2F;input&#x2F;image.png -s images&#x2F;searchimages&#x2F;debruinseq_notepad_Windows10_closeAndSpaced.png -o &#x2F;path&#x2F;to&#x2F;your&#x2F;output.png</p>
<ul>
<li>对使用Notepad创建并使用Greenshot像素化的示例图像进行去像素化：</li>
</ul>
<p>python3 depix.py -p images&#x2F;testimages&#x2F;testimage3_pixels.png -s images&#x2F;searchimages&#x2F;debruinseq_notepad_Windows10_closeAndSpaced.png</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-47.png"></p>
<ul>
<li>对使用Sublime创建并使用Gimp像素化的示例图像进行去像素化：</li>
</ul>
<p>python3 depix.py -p images&#x2F;testimages&#x2F;sublime_screenshot_pixels_gimp.png -s images&#x2F;searchimages&#x2F;debruin_sublime_Linux_</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-48.png"></p>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><ol>
<li>使用与马赛克图相同的字体设置，包括字体、颜色、大小等，将debruinseq.txt（在源码仓库中有）的内容放到编辑器（例如上面介绍的两个例子，就是分别放到Notepad和Sublime Text）中并截图，截图的结果作为识别搜索的训练数据，用于识别马赛克图中的内容。</li>
<li>算法利用线性滤波器单独处理每个马赛克块。对于每个块，它将搜索图像中的所有像素化块以检查直接匹配。</li>
<li>对于大多数像素化图像，Depix设法找到单一匹配结果。算法将周围多个匹配块的进行几何比较，重复该过程输出最终结果。</li>
<li>限制：该算法通过整数块边界匹配。因此，它有一个基本假设，对于所有渲染的字符，文本定位都是在像素级别完成的。</li>
</ol>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-49.png"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>还原</tag>
        <tag>马赛克</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Python程序做 微服务项目_微服务架构？</title>
    <url>/2021/10/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8python%E7%A8%8B%E5%BA%8F%E5%81%9A-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-6.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>考虑到 Python 性能及效率性，Python Web 端一直不温不火，JAVA 和 Golang 的微服务生态一直很繁荣，也被广泛用于企业级应用开发当中</p>
<p>本篇文章将介绍一款 Python 微服务框架：「 Nameko 」</p>
<h3 id="Nameko-介绍"><a href="#Nameko-介绍" class="headerlink" title="Nameko 介绍"></a>Nameko 介绍</h3><hr>
<p>Nameko 是一款小巧、简洁的、异步通信方式的微服务架构</p>
<p>它采用 RabbitMQ 消息队列作为消息中间件，基于发布者、订阅者模式</p>
<p>其中，消费者与生产者基于 RPC 进行通讯</p>
<p>项目地址：<a href="https://github.com/nameko/nameko">https://github.com/nameko/nameko</a></p>
<h3 id="实战一下"><a href="#实战一下" class="headerlink" title="实战一下"></a>实战一下</h3><hr>
<p>下面以 Flask 为例聊聊搭建 Python 微服务的步骤</p>
<h4 id="安装-RabbitMQ-及启动"><a href="#安装-RabbitMQ-及启动" class="headerlink" title="安装 RabbitMQ 及启动"></a>安装 RabbitMQ 及启动</h4><hr>
<p>这里推荐利用 Docker 安装 RabbitMQ，以 Centos 为例</p>
<p># 1、下载某个版本的RabbitMQ的镜像</p>
<h1 id="MQ版本号：3-9-5"><a href="#MQ版本号：3-9-5" class="headerlink" title="MQ版本号：3.9.5"></a>MQ版本号：3.9.5</h1><p>docker pull rabbitmq:3.9.5-management</p>
<h1 id="2、查看镜像"><a href="#2、查看镜像" class="headerlink" title="2、查看镜像"></a>2、查看镜像</h1><p>docker images</p>
<h1 id="3、启动MQ容器"><a href="#3、启动MQ容器" class="headerlink" title="3、启动MQ容器"></a>3、启动MQ容器</h1><h1 id="p：指定应用端口及Web控制台端口"><a href="#p：指定应用端口及Web控制台端口" class="headerlink" title="p：指定应用端口及Web控制台端口"></a>p：指定应用端口及Web控制台端口</h1><h1 id="hostname：主机名"><a href="#hostname：主机名" class="headerlink" title="hostname：主机名"></a>hostname：主机名</h1><h1 id="e：环境变量"><a href="#e：环境变量" class="headerlink" title="e：环境变量"></a>e：环境变量</h1><h1 id="RABBITMQ-DEFAULT-VHOST：虚拟机名称"><a href="#RABBITMQ-DEFAULT-VHOST：虚拟机名称" class="headerlink" title="RABBITMQ_DEFAULT_VHOST：虚拟机名称"></a>RABBITMQ_DEFAULT_VHOST：虚拟机名称</h1><h1 id="RABBITMQ-DEFAULT-USER：用户名"><a href="#RABBITMQ-DEFAULT-USER：用户名" class="headerlink" title="RABBITMQ_DEFAULT_USER：用户名"></a>RABBITMQ_DEFAULT_USER：用户名</h1><h1 id="RABBITMQ-DEFAULT-PASS：密码"><a href="#RABBITMQ-DEFAULT-PASS：密码" class="headerlink" title="RABBITMQ_DEFAULT_PASS：密码"></a>RABBITMQ_DEFAULT_PASS：密码</h1><h1 id="3e83da0dc938：MQ镜像ID"><a href="#3e83da0dc938：MQ镜像ID" class="headerlink" title="3e83da0dc938：MQ镜像ID"></a>3e83da0dc938：MQ镜像ID</h1><p>docker run -d –name rabbitmq3.9.5 -p 5672:5672 -p 15672:15672 -v `pwd`&#x2F;data:&#x2F;var&#x2F;lib&#x2F;rabbitmq –hostname myRabbit -e RABBITMQ_DEFAULT_VHOST&#x3D;my_vhost  -e RABBITMQ_DEFAULT_USER&#x3D;admin -e RABBITMQ_DEFAULT_PASS&#x3D;admin 3e83da0dc938</p>
<p>需要注意的是，启动 MQ 容器时，利用 -p 指定了两个端口</p>
<ul>
<li>5672<br>应用访问端口</li>
<li>15672<br>控制台 Web 访问端口号</li>
</ul>
<p>然后，开放防火墙的 5672、15672 端口号</p>
<p>PS：<strong>如果是云服务器，需要另外配置安全组</strong></p>
<p>最后，在浏览器中通过下面的连接进入到 MQ 后台 Web 管理页面</p>
<p>地址：<a href="http://ip地址:15672/">http://ip地址:15672</a></p>
<h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><hr>
<p>使用 pip 命令在虚拟环境下安装 nameko、flask 依赖包</p>
<p># 安装依赖包</p>
<h1 id="nameko"><a href="#nameko" class="headerlink" title="nameko"></a>nameko</h1><p>pip3 install nameko</p>
<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>pip3 install flask</p>
<h4 id="创建服务生产者-Producer"><a href="#创建服务生产者-Producer" class="headerlink" title="创建服务生产者 Producer"></a>创建服务生产者 Producer</h4><hr>
<p>自定一个类，使用 name 属性定义服务的名称为「 generate_service 」</p>
<p>然后使用装饰器「 rpc 」注册服务中具体的方法</p>
<p># producer_service.py</p>
<p>from nameko.rpc import rpc</p>
<p>class GenerateService(object):<br>    # 定义微服务名称<br>    name &#x3D; “generate_service”</p>
<pre><code>@rpc
def hello\_world(self, msg):
    print(&#39;hello,i am been called by customer（消费者）,返回消息：&#123;&#125;&#39;.format(msg))

    # 返回结果
    return &quot;Hello World!I Am a msg from producer!&quot;
</code></pre>
<h4 id="发布注册服务"><a href="#发布注册服务" class="headerlink" title="发布注册服务"></a>发布注册服务</h4><hr>
<p>使用 nameko 命令在终端将目标文件中的服务注册到 MQ 中</p>
<p># 注册服务</p>
<h1 id="producer-service：目标文件"><a href="#producer-service：目标文件" class="headerlink" title="producer_service：目标文件"></a>producer_service：目标文件</h1><h1 id="admin-admin：MQ用户名及密码"><a href="#admin-admin：MQ用户名及密码" class="headerlink" title="admin:admin：MQ用户名及密码"></a>admin:admin：MQ用户名及密码</h1><h1 id="ip地址-5672：MQ服务器ip地址及应用端口号"><a href="#ip地址-5672：MQ服务器ip地址及应用端口号" class="headerlink" title="ip地址:5672：MQ服务器ip地址及应用端口号"></a>ip地址:5672：MQ服务器ip地址及应用端口号</h1><h1 id="my-vhost：虚拟机名"><a href="#my-vhost：虚拟机名" class="headerlink" title="my_vhost：虚拟机名"></a>my_vhost：虚拟机名</h1><p>nameko run producer_service –broker amqp:&#x2F;&#x2F;admin:admin@ip地址:5672&#x2F;my_vhost<br>其中，my_vhost 对应 MQ 容器启动时配置的虚拟机名</p>
<h4 id="Flask-定义-API-及消费者调用服务"><a href="#Flask-定义-API-及消费者调用服务" class="headerlink" title="Flask 定义 API 及消费者调用服务"></a>Flask 定义 API 及消费者调用服务</h4><hr>
<p>为了演示方便，这里使用 Flask 编写一个简单的 API</p>
<p>首先，定义 MQ 连接信息</p>
<p>然后，编写一个 API 接口，请求方式为 GET</p>
<p>最后，使用 nameko 中的「 ClusterRpcProxy 」拿到消费者对象去调用服务中的具体方法</p>
<p>from flask import Flask<br>from nameko.standalone.rpc import ClusterRpcProxy</p>
<p>app &#x3D; Flask(__name__)</p>
<h1 id="MQ配置"><a href="#MQ配置" class="headerlink" title="MQ配置"></a>MQ配置</h1><p>config_mq &#x3D; {‘AMQP_URI’: “amqp:&#x2F;&#x2F;admin:admin@ip地址:5672&#x2F;my_vhost”}</p>
<p>@app.route(‘&#x2F;hello_world’, methods&#x3D;[‘GET’])<br>def call_service():<br>    with ClusterRpcProxy(config_mq) as rpc:<br>        # 消费者调用微服务(生产者)，获取服务（生产者）的返回值<br>        result &#x3D; rpc.generate_service.hello_world(msg&#x3D;”xag msg”)</p>
<pre><code>    # 返回结果
    return result, 200
</code></pre>
<p>app.run(debug&#x3D;True)</p>
<h4 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h4><hr>
<p>使用 Postman 调用上面的 API 接口，就能完成消费者调用生成者服务中的方法，拿到返回结果的完整流程</p>
<p># 调用API接口<br><a href="http://127.0.0.1:5000/hello/_world">http://127.0.0.1:5000/hello\_world</a><br>Method：GET</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><hr>
<p>上面以 Flask 为例讲解了微服务的搭建的完整流程</p>
<p>如果是其他 Web 框架（ 比如 Django、FastAPI 等 ）集成微服务流程是类似的，只需要修改生成 API 部分的逻辑即可，更多进阶内容大家可以参考官方文档</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>RabbitMQ</tag>
        <tag>微服务</tag>
        <tag>Nameko</tag>
        <tag>RPC</tag>
        <tag>微服务架构</tag>
        <tag>注册服务</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用python自动识别验证码？</title>
    <url>/2021/11/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8python%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/5d074a2d818ca505.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在很久之前，分享过一次Python 代码实现验证码识别的办法。</p>
<p>当时采用的是pillow+pytesseract，优点是免费，较为易用。但其识别精度一般，若想要更高要求的验证码识别，初学者就只能去选择使用百度API接口了。</p>
<p>但其实百度API接口和pytesseract其实都需要进行前期配置，对于初学者来说就不太友好了。</p>
<p>而且百度API必须要联网，对于某些机器不能联网的朋友而言，就得pass了</p>
<p>最近群里有位群友分享了一个新库，试用一下发现非常实用，特意今天分享给大家。</p>
<p>Github地址：<a href="https://github.com/sml2h3/ddddocr">https://github.com/sml2h3/ddddocr</a></p>
<p>该库名也是非常有趣 —— ddddocr（谐音带带弟弟OCR）</p>
<h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><hr>
<p>python &gt;&#x3D; 3.8<br>Windows&#x2F;Linux&#x2F;Macox..</p>
<h3 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h3><hr>
<p>pip install ddddocr</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><hr>
<p>DdddOcr 接受两个参数</p>
<p>参数名</p>
<p>默认值</p>
<p>说明</p>
<p>use_gpu</p>
<p>False</p>
<p>Bool 是否使用gpu进行推理，如果该值为False则device_id不生效</p>
<p>device_id</p>
<p>0</p>
<p>int cuda设备号，目前仅支持单张显卡</p>
<p>classification</p>
<p>参数名</p>
<p>默认值</p>
<p>说明</p>
<p>img</p>
<p>0</p>
<p>bytes 图片的bytes格式</p>
<h3 id="图形验证码识别"><a href="#图形验证码识别" class="headerlink" title="图形验证码识别"></a>图形验证码识别</h3><hr>
<p>在网上随机寻找了一个验证码图片，使用这个库来实战一下。<br><img src="https://img-blog.csdnimg.cn/1b162fdd64434de9960981b5c1742e03.png" alt="在这里插入图片描述"></p>
<p>import ddddocr</p>
<p>ocr &#x3D; ddddocr.DdddOcr()<br>with open(‘1.png’, ‘rb’) as f:<br>    img_bytes &#x3D; f.read()<br>res &#x3D; ocr.classification(img_bytes)</p>
<p>print(res)</p>
<p><img src="https://img-blog.csdnimg.cn/ae4162f955424e129bc033c7b2cb5c81.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>成功识别出来了验证码文字！</p>
<p>而且优点也非常明显：首先代码非常精简，对比前文提到的两种方法，不需要额外设置环境变量等等，5行代码即可轻松识别验证码图片。另一方面，我们使用魔法命令%%time也测试出来吗，这段代码识别速度非常快。</p>
<p>下面用更多的验证码图片继续测试：<br><img src="https://img-blog.csdnimg.cn/92adc4ddfa21446c9c2b0ec9c9c13a49.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我又找了6个验证码图片来测试，观察结果，发现这类简单的验证码基本可以进行快速识别。但也有部分结果有问题——字母大小写没有进行区分（比如第6张图片）。</p>
<p>总而言之，如果你需要进行验证码识别，且对精度要求不是过高。</p>
<p>那么，带带弟弟OCR（ddddocr）这个库是一个不错的选择~</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>验证码</tag>
        <tag>ddddocr</tag>
        <tag>图形</tag>
        <tag>识别</tag>
      </tags>
  </entry>
  <entry>
    <title>如何内网穿透_NPS内网穿透工具使用教程</title>
    <url>/2021/08/18/%E5%A6%82%E4%BD%95%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-15.png"></p>
<h3 id="NPS工具介绍"><a href="#NPS工具介绍" class="headerlink" title="NPS工具介绍"></a>NPS工具介绍</h3><hr>
<p>NPS工具是一款使用go语言编写的轻量级、功能强大的内网穿透工具。支持TCP、UDP流量转发，支持内网HTTP、SOCKS5代理，同时支持snappy压缩(节省带宽和流量)、站点保护、加密传输、多路复用、header修改等。同时还支持web图形化管理。该工具使用简单，相比于FRP，NPS是图形化界面，因此配置更加简单。</p>
<h3 id="NPS工具原理"><a href="#NPS工具原理" class="headerlink" title="NPS工具原理"></a>NPS工具原理</h3><hr>
<p>注意:NPS工具的工作原理和FRP工具的工作原理相似，因此我们只需要对其中某一款工具的原理十分熟悉即可，由于之前写过一篇十分详细的FRP的工作原理和使用方法，大家可以去看<a href="https://www.code404.icu/1094.html">内网穿透_FRP代理工具内网渗透教程</a><br>下面提供NPS的使用文档和下载地址：</p>
<p>NPS官方使用文档：<a href="https://ehang-io.github.io/nps/#/api">https://ehang-io.github.io/nps/#/api</a><br>NPS下载地址：<a href="https://github.com/ehang-io/nps/releases/tag/v0.26.9">https://github.com/ehang-io/nps/releases/tag/v0.26.9</a></p>
<h3 id="NPS服务器端（Linux-amp-Windows）："><a href="#NPS服务器端（Linux-amp-Windows）：" class="headerlink" title="NPS服务器端（Linux&amp;Windows）："></a>NPS服务器端（Linux&amp;Windows）：</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/5d6b54e5d8904d2fb85c67f93957b3e9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/c83036a92a854bd9bce3077c6d2ff0c2.png" alt="在这里插入图片描述"></p>
<h3 id="安装NPS服务器端"><a href="#安装NPS服务器端" class="headerlink" title="安装NPS服务器端"></a>安装NPS服务器端</h3><hr>
<p>.&#x2F;nps install   #linux<br>nps.exe install #windows</p>
<p><img src="https://img-blog.csdnimg.cn/f9a1bd94a4374d54a60e370ac95256b4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1d166bed7ef64e0381ecf9d9fb1aa0fe.png" alt="在这里插入图片描述"><br>进入到conf文件夹中查看nps.conf</p>
<p>appname &#x3D; nps<br>#Boot mode(devpro)<br>runmode &#x3D; dev</p>
<p>#HTTP(S) proxy port, no startup if empty<br>http_proxy_ip&#x3D;0.0.0.0<br>http_proxy_port&#x3D;80     #域名代理http代理监听端口<br>https_proxy_port&#x3D;443   #域名代理https代理监听端口(一般会修改这两个端口，避免端口冲突)<br>https_just_proxy&#x3D;true<br>#default https certificate setting<br>https_default_cert_file&#x3D;conf&#x2F;server.pem<br>https_default_key_file&#x3D;conf&#x2F;server.key</p>
<p>##bridge<br>bridge_type&#x3D;tcp      #客户端与服务端连接方式kcp或tcp<br>bridge_port&#x3D;8024     #服务端客户端通信端口，也就是说客户端通过访问服务端的这个端口可以进行连接<br>bridge_ip&#x3D;0.0.0.0</p>
<h1 id="Public-password-which-clients-can-use-to-connect-to-the-server"><a href="#Public-password-which-clients-can-use-to-connect-to-the-server" class="headerlink" title="Public password, which clients can use to connect to the server"></a>Public password, which clients can use to connect to the server</h1><h1 id="After-the-connection-the-server-will-be-able-to-open-relevant-ports-and-parse-related-domain-names-according-to-its-own-configuration-file"><a href="#After-the-connection-the-server-will-be-able-to-open-relevant-ports-and-parse-related-domain-names-according-to-its-own-configuration-file" class="headerlink" title="After the connection, the server will be able to open relevant ports and parse related domain names according to its own configuration file."></a>After the connection, the server will be able to open relevant ports and parse related domain names according to its own configuration file.</h1><p>public_vkey&#x3D;123      #客户端以配置文件模式启动时的密钥，设置为空表示关闭客户端配置文件连接模式</p>
<p>#Traffic data persistence interval(minute)<br>#Ignorance means no persistence<br>#flow_store_interval&#x3D;1   #服务端流量数据持久化间隔，单位分钟，忽略表示不持久化</p>
<h1 id="log-level-LevelEmergency-gt-0-LevelAlert-gt-1-LevelCritical-gt-2-LevelError-gt-3-LevelWarning-gt-4-LevelNotice-gt-5-LevelInformational-gt-6-LevelDebug-gt-7"><a href="#log-level-LevelEmergency-gt-0-LevelAlert-gt-1-LevelCritical-gt-2-LevelError-gt-3-LevelWarning-gt-4-LevelNotice-gt-5-LevelInformational-gt-6-LevelDebug-gt-7" class="headerlink" title="log level LevelEmergency-&gt;0  LevelAlert-&gt;1 LevelCritical-&gt;2 LevelError-&gt;3 LevelWarning-&gt;4 LevelNotice-&gt;5 LevelInformational-&gt;6 LevelDebug-&gt;7"></a>log level LevelEmergency-&gt;0  LevelAlert-&gt;1 LevelCritical-&gt;2 LevelError-&gt;3 LevelWarning-&gt;4 LevelNotice-&gt;5 LevelInformational-&gt;6 LevelDebug-&gt;7</h1><p>log_level&#x3D;7         #日志输出级别<br>#log_path&#x3D;nps.log</p>
<p>#Whether to restrict IP access, true or false or ignore<br>#ip_limit&#x3D;true      #是否限制ip访问，true或false或忽略</p>
<p>#p2p<br>#p2p_ip&#x3D;127.0.0.1    #服务端IP，使用p2p模式必填<br>#p2p_port&#x3D;6000       #p2p模式开启的udp端口</p>
<p>#web<br>web_host&#x3D;a.o.com<br>web_username&#x3D;admin   #web界面管理账号<br>web_password&#x3D;123     #web界面管理密码<br>web_port &#x3D; 8080      #web管理端口，通过访问该端口可以访问NPS后台<br>web_ip&#x3D;0.0.0.0<br>web_base_url&#x3D;        #web管理主路径,用于将web管理置于代理子路径后面<br>web_open_ssl&#x3D;false<br>web_cert_file&#x3D;conf&#x2F;server.pem<br>web_key_file&#x3D;conf&#x2F;server.key</p>
<h1 id="if-web-under-proxy-use-sub-path-like-http-host-nps-need-this"><a href="#if-web-under-proxy-use-sub-path-like-http-host-nps-need-this" class="headerlink" title="if web under proxy use sub path. like http://host/nps need this."></a>if web under proxy use sub path. like <a href="http://host/nps">http://host/nps</a> need this.</h1><p>#web_base_url&#x3D;&#x2F;nps</p>
<p>#Web API unauthenticated IP address(the len of auth_crypt_key must be 16)<br>#Remove comments if needed<br>#auth_key&#x3D;test       #web api密钥<br>auth_crypt_key &#x3D;1234567812345678    #获取服务端authKey时的aes加密密钥，16位</p>
<p>#allow_ports&#x3D;9001-9009,10001,11000-12000</p>
<p>#Web management multi-user login<br>allow_user_login&#x3D;false<br>allow_user_register&#x3D;false<br>allow_user_change_username&#x3D;false</p>
<p>#extension<br>allow_flow_limit&#x3D;false<br>allow_rate_limit&#x3D;false<br>allow_tunnel_num_limit&#x3D;false<br>allow_local_proxy&#x3D;false<br>allow_connection_num_limit&#x3D;false<br>allow_multi_ip&#x3D;false<br>system_info_display&#x3D;false</p>
<p>#cache<br>http_cache&#x3D;false<br>http_cache_length&#x3D;100</p>
<p>#get origin ip<br>http_add_origin_header&#x3D;false</p>
<p>#pprof debug options<br>#pprof_ip&#x3D;0.0.0.0       #debug pprof 服务端IP<br>#pprof_port&#x3D;9999        #debug pprof 端口</p>
<p>#client disconnect timeout<br>disconnect_timeout&#x3D;60   #客户端连接超时，单位 5s，默认值 60，即 300s &#x3D; 5mins</p>
<p>注意:在上面的配置文件中，我们主要是要注意以下方面:<br>①:一般会修改域名代理的端口，避免端口冲突<br>②:NPS的web页面默认端口是8080，默认用户名密码是admin&#x2F;123<br>③:NPS的服务端和客户端进行连接的默认端口是8024，这个端口可以进行修改，修改之后，在连接时注意使用修改后的端口<br>④:NPS服务端开启的端口(也就是我们需要访问的VPS的端口)不在配置文件中，需要我们web界面中进行配置</p>
<h3 id="NPS客户端（Linux-amp-Windows）："><a href="#NPS客户端（Linux-amp-Windows）：" class="headerlink" title="NPS客户端（Linux&amp;Windows）："></a>NPS客户端（Linux&amp;Windows）：</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/670852181d0f4216beb7dcf7e4a2aaf0.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f56168abc8ee486491d2e50a4a88ad38.png" alt="在这里插入图片描述"><br>客户端共有两种连接方式，我们都会逐一讲述<br>①:使用vkey进行连接</p>
<p>Windows：npc.exe -server&#x3D;ip:port -vkey&#x3D;服务端生成的key<br>Linux：.&#x2F;npc -server&#x3D;ip:port -vkey&#x3D;服务端生成的key</p>
<p>②使用配置文件进行连接</p>
<p>windows:   npc.exe -config&#x3D;npc配置文件路径<br>linux:     .&#x2F;npc -config&#x3D;npc配置文件路径</p>
<p>在客户端配置文件中，我们主要是修改以下三个参数</p>
<p>server_addr&#x3D;127.0.0.1:8024   #服务端ip&#x2F;域名:port<br>conn_type&#x3D;tcp       #与服务端通信模式(tcp或kcp)<br>vkey&#x3D;123           #服务端配置文件中的密钥</p>
<p>首先server_addr是需要填写NPS服务端的IP和端口，conn_type选择合适的类型(一般选择TCP)，vkey的值设置为服务端配置文件的密钥。这样服务端和客户端就可以进行连接了。</p>
<h3 id="实战环境"><a href="#实战环境" class="headerlink" title="实战环境"></a>实战环境</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/d44b6560c8514950b81e140c23951cb8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>攻击机：Windows10
 IP地址：192.168.92.11
 NPS服务器端：Linux Ubuntu
 公网IP：42.1X2.204.XX
 靶机内网存在多个服务器网段：
    10.130.1.0/16
    10.131.10.0/16
    10.133.3.0/24
    10.128.1.0/24 
</code></pre>
<p>修改服务器端配置文件中以下两行，以防端口冲突</p>
<p>http_proxy_port&#x3D;8081<br>https_proxy_port&#x3D;8443</p>
<p><img src="https://img-blog.csdnimg.cn/475b5c8b25c0429c8ed35eced3606313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="修改完配置文件后，启动nps服务"><a href="#修改完配置文件后，启动nps服务" class="headerlink" title="修改完配置文件后，启动nps服务"></a>修改完配置文件后，启动nps服务</h3><hr>
<p>.&#x2F;nps start    #启动nps服务<br>.&#x2F;nps stop     #停止nps服务<br>.&#x2F;nps restart  #重启nps服务</p>
<p><img src="https://img-blog.csdnimg.cn/4d82a006023347cba16980d9e5cb84d4.png" alt="在这里插入图片描述"></p>
<h3 id="浏览器输入42-1X2-204-XX-8080访问NPS-web管理端"><a href="#浏览器输入42-1X2-204-XX-8080访问NPS-web管理端" class="headerlink" title="浏览器输入42.1X2.204.XX:8080访问NPS web管理端"></a>浏览器输入42.1X2.204.XX:8080访问NPS web管理端</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/06fe14230df04d05ad7d87dc5a0942b4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入admin&#x2F;123登陆NPS管理界面<br><img src="https://img-blog.csdnimg.cn/e76204b3a4ae45f7ab313eb5792d8fe8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>新增一个客户端，这块新建的客户端主要是要使用生成的唯一验证密钥，通过这个唯一验证密钥才能将NPS的服务端和客户端连接起来，因此至少需要添加一个客户端。<br><img src="https://img-blog.csdnimg.cn/3c7dcba8aa5e465d886f1f997b67c1ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e3ced52ec33447a18e2aadc294b85434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>记住上面的ID为2，点击左侧SOCKS代理，再点击新增，客户端ID填上图中的ID<br><img src="https://img-blog.csdnimg.cn/abe763270faf49acbf53a8575fd7d8ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7e3ef3fdb8164e1aa25bf408e3111393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上服务器端就配置好了！</p>
<h3 id="实战渗透"><a href="#实战渗透" class="headerlink" title="实战渗透"></a>实战渗透</h3><p>我们上面介绍客户端共有两种连接方式<br>①:使用vkey进行连接，我们只需要执行以下命令</p>
<p>Windows：npc.exe -server&#x3D;ip:port -vkey&#x3D;服务端生成的key<br>Linux：.&#x2F;npc -server&#x3D;ip:port -vkey&#x3D;服务端生成的key</p>
<p><img src="https://img-blog.csdnimg.cn/e58a88bb989c48d8a721d0e69cd7b770.png" alt="在这里插入图片描述"><br>②使用配置文件进行连接<br>修改配置文件<br><img src="https://img-blog.csdnimg.cn/88d277b866784244ac4276470645edb2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行如下命令</p>
<p>windows:   npc.exe -config&#x3D;npc配置文件路径<br>linux:     .&#x2F;npc -config&#x3D;npc配置文件路径</p>
<p><img src="https://img-blog.csdnimg.cn/3aacef64ab0f427798d2a59e2d6336fb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用以上任意一种方式即可，推荐使用第一张方便快捷。<br>接下来我们配置一下Proxifier，如果不知道Proxifier的话可以看一下这篇文章<a href="https://www.code404.icu/1099.html">使用reGeorg+Proxifier进行内网穿透_内网渗透教程透</a><br><img src="https://img-blog.csdnimg.cn/f8ae2b7579c54a8c9b07a4b67b8bb8f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置完成好我们就可以进行远程连接啦<br><img src="https://img-blog.csdnimg.cn/a9782ec0f7004b7d99b06bd4edff560f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f3078d1d7e374720989df5cd46bee652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们就可以进行内网渗透啦，扩大自己的资产，请开始你的表演吧！</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>NPS</tag>
        <tag>NPS内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用 nginx 实现生产和灰度环境流量切换？</title>
    <url>/2021/10/11/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-nginx-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E5%92%8C%E7%81%B0%E5%BA%A6%E7%8E%AF%E5%A2%83%E6%B5%81%E9%87%8F%E5%88%87%E6%8D%A2%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-7.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A&#x2F;B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p>
<h3 id="根据-cookie-实现灰度配置"><a href="#根据-cookie-实现灰度配置" class="headerlink" title="根据 cookie 实现灰度配置"></a>根据 cookie 实现灰度配置</h3><hr>
<p>查询 cookie 键为 version 的值，如果该 cookie 值为 V1 则转发到 server_01，为 V2 则转发到 server_02，cookie 值都不匹配的情况下默认走 server_01 所对应的服务器。</p>
<p>使用 if 指令实现</p>
<p>upstream server_01 {<br>    server 192.168.1.100:8080 max_fails&#x3D;1 fail_timeout&#x3D;60;<br>}<br>upstream server_02 {<br>    server 192.168.1.101:8080 max_fails&#x3D;1 fail_timeout&#x3D;60;<br>}<br>server {<br>    listen 80;<br>    server_name <a href="http://www.server.com/">www.server.com</a>;</p>
<pre><code>#match cookie
set $server &quot;server\_01&quot;;
if ($http\_cookie ~\* &quot;version=V1&quot;)&#123;
    set $server server\_01;
&#125;
if ($http\_cookie ~\* &quot;version=V2&quot;)&#123;
    set $server server\_02;
&#125;
location / &#123;
    proxy\_pass http://$server;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
    index index.html index.htm;
&#125;
</code></pre>
<p>}</p>
<h3 id="使用-map-指令实现"><a href="#使用-map-指令实现" class="headerlink" title="使用 map 指令实现"></a>使用 map 指令实现</h3><hr>
<p>upstream server_01 {<br>    server 192.168.1.100:8080 max_fails&#x3D;1 fail_timeout&#x3D;60;<br>}<br>upstream server_02 {<br>    server 192.168.1.101:8080 max_fails&#x3D;1 fail_timeout&#x3D;60;<br>}<br>map $COOKIE_version $server {<br>    ~*V1$ server_01;<br>    ~*V2$ server_02;<br>    default server_01;<br>}<br>server {<br>    listen 80;<br>    server_name <a href="http://www.server.com/">www.server.com</a>;</p>
<pre><code>location / &#123;
    proxy\_pass http://$server;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
    index index.html index.htm;
&#125;
</code></pre>
<p>}</p>
<h3 id="根据权重实现灰度配置"><a href="#根据权重实现灰度配置" class="headerlink" title="根据权重实现灰度配置"></a>根据权重实现灰度配置</h3><hr>
<p>upstream server {<br>    server 192.168.1.100:8080 max_fails&#x3D;1 fail_timeout&#x3D;60 weight&#x3D;5;<br>    server 192.168.1.101:8080 max_fails&#x3D;1 fail_timeout&#x3D;60 weight&#x3D;1;<br>}<br>server {<br>    listen 80;<br>    server_name <a href="http://www.server.com/">www.server.com</a>;</p>
<pre><code>location / &#123;
    proxy\_pass http://server;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
    index index.html index.htm;
&#125;
</code></pre>
<p>}</p>
<h3 id="根据来路-IP-实现灰度配置"><a href="#根据来路-IP-实现灰度配置" class="headerlink" title="根据来路 IP 实现灰度配置"></a>根据来路 IP 实现灰度配置</h3><hr>
<h4 id="资源在不同服务器上"><a href="#资源在不同服务器上" class="headerlink" title="资源在不同服务器上"></a>资源在不同服务器上</h4><hr>
<p>upstream server_01 {<br>    server 192.168.1.100:8080 max_fails&#x3D;1 fail_timeout&#x3D;60;<br>}<br>upstream server_02 {<br>    server 192.168.1.101:8080 max_fails&#x3D;1 fail_timeout&#x3D;60;<br>}<br>server {<br>    listen 80;<br>    server_name <a href="http://www.server.com/">www.server.com</a>;</p>
<pre><code>set $server &quot;server\_01&quot;;
if ($remote\_addr ~ &quot;211.118.119.11&quot;)&#123;
    set $server server\_02;
&#125;
location / &#123;
    proxy\_pass http://$server;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
    index index.html index.htm;
&#125;
</code></pre>
<p>}</p>
<h4 id="资源在同一服务器上"><a href="#资源在同一服务器上" class="headerlink" title="资源在同一服务器上"></a>资源在同一服务器上</h4><hr>
<p>server {<br>    listen 80;<br>    server_name <a href="http://www.server.com/">www.server.com</a>;</p>
<pre><code>set $rootdir &quot;/var/www/html&quot;;
if ($remote\_addr ~ &quot;211.118.119.11&quot;)&#123;
    set $rootdir &quot;/var/www/test&quot;;
&#125;
location / &#123;
    root $rootdir;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
    index index.html index.htm;
&#125;
</code></pre>
<p>}</p>
<h3 id="Nginx-Lua-实现灰度配置"><a href="#Nginx-Lua-实现灰度配置" class="headerlink" title="Nginx+Lua 实现灰度配置"></a>Nginx+Lua 实现灰度配置</h3><hr>
<p>如果来源 IP 地址是 ipList.conf 中的地址，那么就定位到 test_env，如果来源 IP 地址不在 ipList.conf 中（即有效用户 IP），那么就定位到 product_env。</p>
<p>local ip_config &#x3D; ngx.shared.config;<br>ClienIP&#x3D;ngx.req.get_headers()[“X-Real-IP”]<br>if ClientIP &#x3D;&#x3D; nil then<br>    ClientIP &#x3D; ngx.req.get_headers()[“x_forworded_for”]<br>end<br>if ClientIP &#x3D;&#x3D; nil then<br>    ClientIP &#x3D; ngx.var.remote_addr<br>end<br>for line in io.lines(“&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;lua&#x2F;ipList.conf”) do<br>    if not ip_config:get(line) then<br>        ip_config:set(line, “0”)<br>    end<br>end<br>if ip_config:get(ClientIP) &#x3D;&#x3D; “0” then<br>    ngx.exec(“@test_env”)<br>else<br>    ngx.exec(“@product_env”)<br>end</p>
<p>ipList.conf 内容格式</p>
<p>lua_code_cache on;<br>lua_shared_dict config 1m;</p>
<p>upstream MyServer {<br>    server 192.168.1.199:8099 max_fails&#x3D;3 fail_timeout&#x3D;30s;<br>    server 192.168.1.200:8099 max_fails&#x3D;3 fail_timeout&#x3D;30s;<br>    ip_hash;<br>}<br>server {<br>    listen 80;<br>    server_name jokerzhang.cn;<br>    access_log off;<br>    #access_log logs&#x2F;jokerzhang.log;</p>
<pre><code>location / &#123;
    access\_by\_lua\_file /usr/local/nginx/conf/lua/ip\_gray.lua;
&#125;
location @test\_env &#123;
    proxy\_pass http://192.168.1.199:8099;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
&#125;
location @product\_env &#123;
    proxy\_pass http://MyServer;
    proxy\_set\_header Host $host;
    proxy\_set\_header X-Real-IP $remote\_addr;
    proxy\_set\_header X-Forwarded-For $proxy\_add\_x\_forwarded\_for;
&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>lua</tag>
        <tag>cookie</tag>
        <tag>map</tag>
        <tag>weight</tag>
        <tag>灰度发布</tag>
        <tag>金丝雀发布</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用Python去除图片水印？</title>
    <url>/2021/09/15/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8python%E5%8E%BB%E9%99%A4%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-13.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/4e14e304cb114eafa1d9c3b77663153e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>即上图中的这类水印，这种水印存在白色背景上的文档里，水印是灰色，需要保留的文字是黑色。</p>
<p>这种通常可以进行简单的亮度&#x2F;对比度转换，直到水印消失并降低亮度以进行补偿。参考别人的方法，我发现可以用多种方法去除水印。大致原理比较相似，下面先讲itertools的方法。</p>
<h3 id="PIL-itertools"><a href="#PIL-itertools" class="headerlink" title="PIL + itertools"></a>PIL + itertools</h3><hr>
<p>PIL也是一个Python 图像处理库，其中Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。</p>
<p>itertools 之前更是被我们称为一个 零差评的 Python 内置库。其中itertools.product用来产生多个列表和迭代器的(积)。</p>
<h3 id="水印部分RGB颜色为179-179-179"><a href="#水印部分RGB颜色为179-179-179" class="headerlink" title="水印部分RGB颜色为179,179,179"></a>水印部分RGB颜色为179,179,179</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/a41d88d0ff3d48a6b415aec5e8285be4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="白色部分RGB为255，255，255"><a href="#白色部分RGB为255，255，255" class="headerlink" title="白色部分RGB为255，255，255"></a>白色部分RGB为255，255，255</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/02642dfe5d504736af879c42c9f2eb3a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>原理，我们希望将图片中[179,179,179]的像素点转换成[255,255,255]。</p>
<p>那就简单粗暴一点，也就是像素值相加大概500（179,179,179）以上的像素点，都改成[255,255,255]就好了。</p>
<p>from itertools import product<br>from PIL import Image</p>
<p>img &#x3D; Image.open(‘1.png’)<br>width, height &#x3D; img.size<br>for pos in product(range(width), range(height)):<br>    if sum(img.getpixel(pos)[:3]) &gt; 500:<br>        img.putpixel(pos, (255,255,255))<br>img.save(‘removed_1.png’)</p>
<h3 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/e8e79c185b1e443a8ef885b5d73a0266.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itretools</tag>
        <tag>PIL</tag>
        <tag>RGB</tag>
        <tag>去除水印</tag>
      </tags>
  </entry>
  <entry>
    <title>如何半Jmeter性能测试响应结果保存到本地？</title>
    <url>/2021/12/12/%E5%A6%82%E4%BD%95%E5%8D%8Ajmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-2-1024x361.png" alt="jmeter"></p>
<p>jmeter</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在性能测试过程中，为了模拟真实用户场景，我们需要对请求的参数进行参数化。<br>例如：查询用户信息的前提条件是登录，登录之后获取token，请求查询用户信息接口时，请求头需要带上token，不带token时请求会报错。<br><img src="https://img-blog.csdnimg.cn/05c0a66b95124283a3b5ab74df2352a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>Ok，进入正题，我们的需求是对用户数据列表接口进行基准性能测试，所以首先需要造一批token数据，造数据的方式有很多，今天我们主要介绍Jmeter如何将响应结果保存到本地文件。</p>
<h3 id="token数据保存到本地文件"><a href="#token数据保存到本地文件" class="headerlink" title="token数据保存到本地文件"></a>token数据保存到本地文件</h3><hr>
<h4 id="首先准备一批用户数据，用于登录，在本地有一份数据文件users-csv，保存了10组登录账号。"><a href="#首先准备一批用户数据，用于登录，在本地有一份数据文件users-csv，保存了10组登录账号。" class="headerlink" title="首先准备一批用户数据，用于登录，在本地有一份数据文件users.csv，保存了10组登录账号。"></a>首先准备一批用户数据，用于登录，在本地有一份数据文件users.csv，保存了10组登录账号。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/576660e8be8e4397a5af8ea8e05e2f20.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="Jmeter添加CSV-Data-Set-Config，读取username，password。"><a href="#Jmeter添加CSV-Data-Set-Config，读取username，password。" class="headerlink" title="Jmeter添加CSV Data Set Config，读取username，password。"></a>Jmeter添加CSV Data Set Config，读取username，password。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/ad888155c2014a2b9c45c50669c0f676.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="添加登录请求，配置如下"><a href="#添加登录请求，配置如下" class="headerlink" title="添加登录请求，配置如下"></a>添加登录请求，配置如下</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/c53ce92f9f05405aa571f3d2b325719b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="在本地新建一个文件：token-csv，响应结果中的token值将存入此文件。"><a href="#在本地新建一个文件：token-csv，响应结果中的token值将存入此文件。" class="headerlink" title="在本地新建一个文件：token.csv，响应结果中的token值将存入此文件。"></a>在本地新建一个文件：token.csv，响应结果中的token值将存入此文件。</h4><hr>
<p>提取登录响应结果中的token。登录响应结果内容如下</p>
<p><img src="https://img-blog.csdnimg.cn/f82f9fce2da1407d8ce1bc3dcd168165.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="添加正则表达式提取器，提取token，配置如下"><a href="#添加正则表达式提取器，提取token，配置如下" class="headerlink" title="添加正则表达式提取器，提取token，配置如下"></a>添加正则表达式提取器，提取token，配置如下</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/49d2de309aac40a1b2b645183cfdc23d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="添加BeanShell-后置处理器，编写Java代码，将提取的token值写入token-csv文件。"><a href="#添加BeanShell-后置处理器，编写Java代码，将提取的token值写入token-csv文件。" class="headerlink" title="添加BeanShell 后置处理器，编写Java代码，将提取的token值写入token.csv文件。"></a>添加BeanShell 后置处理器，编写Java代码，将提取的token值写入token.csv文件。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/643e5ac87a11424184c3bfbdaeed9ac4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="最后将线程数改为10，也就是和登录账号数一致。"><a href="#最后将线程数改为10，也就是和登录账号数一致。" class="headerlink" title="最后将线程数改为10，也就是和登录账号数一致。"></a>最后将线程数改为10，也就是和登录账号数一致。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/c1e3e4e93eba4a5393b05e922b2a849d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="运行之后，打开token-csv，有10条token信息写入文件。"><a href="#运行之后，打开token-csv，有10条token信息写入文件。" class="headerlink" title="运行之后，打开token.csv，有10条token信息写入文件。"></a>运行之后，打开token.csv，有10条token信息写入文件。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/d8831a17fab84540b922969287c22e02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="用户数据列表接口基准测试脚本编写"><a href="#用户数据列表接口基准测试脚本编写" class="headerlink" title="用户数据列表接口基准测试脚本编写"></a>用户数据列表接口基准测试脚本编写</h3><hr>
<h4 id="添加CSV-Data-Set-Config，读取文件中的token。"><a href="#添加CSV-Data-Set-Config，读取文件中的token。" class="headerlink" title="添加CSV Data Set Config，读取文件中的token。"></a>添加CSV Data Set Config，读取文件中的token。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/9e3040387c2d48a081a3dc34399d453c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="添加请求头管理器，新增授权信息。"><a href="#添加请求头管理器，新增授权信息。" class="headerlink" title="添加请求头管理器，新增授权信息。"></a>添加请求头管理器，新增授权信息。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/58c04d80a50447d1ab84e6671a9934c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="添加用户数据列表请求，配置如下。"><a href="#添加用户数据列表请求，配置如下。" class="headerlink" title="添加用户数据列表请求，配置如下。"></a>添加用户数据列表请求，配置如下。</h4><hr>
<p><img src="https://img-blog.csdnimg.cn/9585b24d87a24f078536e79b2cb6824f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jmeter</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>接口测试</tag>
        <tag>保存到本地</tag>
        <tag>响应结果</tag>
        <tag>基准测试</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Linux 中使用 grep 命令的排除功能_排除多个关键字</title>
    <url>/2021/07/14/%E5%A6%82%E4%BD%95%E5%9C%A8-linux-%E4%B8%AD%E4%BD%BF%E7%94%A8-grep-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8E%92%E9%99%A4%E5%8A%9F%E8%83%BD-%E6%8E%92%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-41.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>grep 是一种强大的命令行工具，用于在一个或多个输入文件中搜索与正则表达式匹配的行，并将匹配的行标准输出。在本文中介绍如何在使用 grep 搜索时排除一个或多个单词或目录。</p>
<h3 id="排除单词或多个条件"><a href="#排除单词或多个条件" class="headerlink" title="排除单词或多个条件"></a>排除单词或多个条件</h3><hr>
<p>要仅显示与搜索模式不匹配的行，请使用-v选项。例如，显示不包含nologin的行，使用下面命令：</p>
<p>[root@localhost ~]# grep -wv nologin &#x2F;etc&#x2F;passwd<br>root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync<br>shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown<br>halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt<br>bob:x:1000:1000::&#x2F;home&#x2F;bob:&#x2F;bin&#x2F;bash<br>user01:x:1001:1001::&#x2F;home&#x2F;user01:&#x2F;bin&#x2F;bash<br>postgres:x:26:26:PostgreSQL Server:&#x2F;var&#x2F;lib&#x2F;pgsql:&#x2F;bin&#x2F;bash</p>
<p>-w选项告诉 grep 仅返回-w选项后面包含单词的行。</p>
<p>默认情况下grep 区分大小写。这意味着大写和小写字符被视为不同的。若要在搜索时忽略大小写，请使用-i 选项调用 grep。</p>
<p>如果搜索字符串中包含空格，则需要将内容放在单引号或者双引号内。</p>
<p>若要排除两个或多个搜索条件，请使用-e选项，可根据需要多次使用-e选项：</p>
<p>[root@localhost ~]# grep -wv -e nologin -e bash &#x2F;etc&#x2F;passwd<br>sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync<br>shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown<br>halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt</p>
<p>排除多个搜索条件的另一个方式是使用运算符 ，以下示例打印不包含字符串nologin和bash的行：</p>
<p>[root@localhost ~]# grep -wv ‘nologin\bash’ &#x2F;etc&#x2F;passwd<br>sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync<br>shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown<br>halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt</p>
<p>还可以使用扩展正则表达式，使用选项 -E参数后，运算符就不需要被转义了，如下图：</p>
<p>[root@localhost ~]# grep -Ewv ‘nologinbash’ &#x2F;etc&#x2F;passwd<br>sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync<br>shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown<br>halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt</p>
<p>下面一个实例，是排除&#x2F;etc&#x2F;ssh&#x2F;sshd_config配置文件中的以#和 空格 开头的行：</p>
<p>[root@localhost ~]# cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config grep -Ev ‘(^#^$)’</p>
<p>下面的实例，要打印出系统上所有正在运行的进程，除了以“root”用户身份运行的进程：</p>
<p>[root@localhost ~]# ps -efgrep -wv root</p>
<h3 id="排除目录或文件"><a href="#排除目录或文件" class="headerlink" title="排除目录或文件"></a>排除目录或文件</h3><hr>
<p>要从grep搜索中排除目录，请使用–exclude-dir选项。排除目录的路径是相对于后面指定的搜索目录。</p>
<p>下面实例，显示如何在&#x2F;etc目录中的所有文件中搜索单词keys，不包括 &#x2F;etc&#x2F;pki 目录：</p>
<p>[root@localhost ~]# grep -Rw –exclude-dir&#x3D;pki keys &#x2F;etc&#x2F;</p>
<p>要排除多个目录，请将排除的目录括在大括号中，并使用逗号分隔，不要有空格。</p>
<p>例如，要在系统中查找包含字符串 gnu 的文件，不包括 proc、boot 和 sys 目录，需要运行下面命令：</p>
<p>[root@localhost ~]# grep -r –exclude-dir&#x3D;{proc,boot,sys} gnu &#x2F;</p>
<p>下面实例，使用–exclude选项排除多个文件，我们在当前工作目录中搜索字符串 linuxprobe，不包括以 .png 和 .jpg 结尾的文件：</p>
<p>[root@localhost ~]# grep -rl –exclude&#x3D;*.{png,jpg} linuxprobe *</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>grep 是一种强大的命令行工具，用于在一个或多个输入文件中搜索与正则表达式匹配的行，并将匹配的行标准输出。在本文中介绍如何在使用 grep 搜索时排除一个或多个单词或目录。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Unix 和 DOS 格式之间转换文本文件?</title>
    <url>/2021/10/19/%E5%A6%82%E4%BD%95%E5%9C%A8-unix-%E5%92%8C-dos-%E6%A0%BC%E5%BC%8F%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/10/image-15-1024x436.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>本文介绍如何在 Unix 和 DOS 格式之间转换文本文件。DOS 文本文件带有回车符（ \r ）和换行符（ \n ）作为它们的换行符，而 Unix 文本文件只有（ \n ）换行符作为换行符。<br>有多种方法可以将 DOS 文本文件转换为 Unix 格式。但建议使用一个名为 dos2unix &#x2F; unix2dos 的工具在 DOS 和 Unix 格式之间转换文本文件。</p>
<ul>
<li>dos2unix</li>
<li>unix2dos</li>
<li>tr, awk, sed</li>
</ul>
<p>你可以使用od命令识别文件是 DOS 格式还是 Unix 格式，如下所示。</p>
<p>[root@server1 ~]# od -bc windows.txt<br>0000000 141 163 144 154 146 152 015 012 141 163 144 146 141 163 144 146<br>          a   s   d   l   f   j  \r  \n   a   s   d   f   a   s   d   f<br>0000020 015 012 141 163 147 146 015 012 141 163 144 146 015 012 141 163<br>         \r  \n   a   s   g   f  \r  \n   a   s   d   f  \r  \n   a   s<br>0000040 144 146 015 012 141 163 144 146 147 144 015 012 144 147<br>          d   f  \r  \n   a   s   d   f   g   d  \r  \n   d   g<br>0000056</p>
<p><img src="https://img-blog.csdnimg.cn/8cc30ef3332841e78bdcef7da4ad1dbe.png" alt="在这里插入图片描述"></p>
<p>上面的输出表示这是一个 DOS 格式的文件，因为它包含了\r\n。<br><img src="https://img-blog.csdnimg.cn/e31daa3206764f64849fa01bb553e106.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="如何在-Linux-上安装-dos2unix"><a href="#如何在-Linux-上安装-dos2unix" class="headerlink" title="如何在 Linux 上安装 dos2unix"></a>如何在 Linux 上安装 dos2unix</h3><hr>
<p>图片</p>
<p>CentOS中安装dos2unix:</p>
<p>[root@server1 ~]# yum -y install dos2unix</p>
<p>Ubuntu中安装dos2unix:</p>
<p>$ sudo apt install dos2unix</p>
<h3 id="如何将-DOS-文件转换为-UNIX-格式"><a href="#如何将-DOS-文件转换为-UNIX-格式" class="headerlink" title="如何将 DOS 文件转换为 UNIX 格式"></a>如何将 DOS 文件转换为 UNIX 格式</h3><hr>
<p>以下命令将“windows.txt”文件从 DOS 格式转换为 Unix 格式。这个文件的修改就是把文件每一行的“\r”去掉。</p>
<p>[root@server1 ~]# dos2unix windows.txt<br>dos2unix: converting file windows.txt to Unix format…</p>
<p>使用dos2unix命令将覆盖原始文件。<br>使用od命令查看，可以看到\r\n已经转换为\n了。<br><img src="https://img-blog.csdnimg.cn/baf8f7b914d64bd5a1a47fc563d043a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>如果要保留原始文件，请使用以下命令。这会将转换后的输出保存为新文件：</p>
<p>[root@server1 ~]# dos2unix -n windows.txt unix.txt<br>dos2unix: converting file windows.txt to file unix.txt in Unix format…</p>
<p><img src="https://img-blog.csdnimg.cn/450d62c7d7fc4f329d3ff56b81d2c1b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="如何使用-tr-命令将-DOS-文件转换为-UNIX-格式"><a href="#如何使用-tr-命令将-DOS-文件转换为-UNIX-格式" class="headerlink" title="如何使用 tr 命令将 DOS 文件转换为 UNIX 格式"></a>如何使用 tr 命令将 DOS 文件转换为 UNIX 格式</h3><hr>
<p>可以使用 tr 命令将 DOS 文件转换为 Unix 格式，如下所示：</p>
<p>[root@server1 ~]# tr -d ‘\r’ &lt; windows.txt &gt; unix.txt</p>
<p>上面命令使用-d选项删除\r回车符。</p>
<p><img src="https://img-blog.csdnimg.cn/f84135b23e3341c3b53b42fe1589dcdf.png" alt="在这里插入图片描述"><br>注意：不能使用 tr 命令将文件从 Unix 格式转换为 DOS 格式。</p>
<h3 id="如何使用-awk-命令将-DOS-文件转换为-UNIX-格式"><a href="#如何使用-awk-命令将-DOS-文件转换为-UNIX-格式" class="headerlink" title="如何使用 awk 命令将 DOS 文件转换为 UNIX 格式"></a>如何使用 awk 命令将 DOS 文件转换为 UNIX 格式</h3><hr>
<p>以下使用 awk 命令格式将 DOS 文件转换为 Unix 格式：</p>
<p>[root@server1 ~]# awk ‘{ sub(“\r$”, “”); print }’ windows.txt &gt; unix.txt</p>
<p><img src="https://img-blog.csdnimg.cn/959b2b601a7e484890819856e2a88349.png" alt="在这里插入图片描述"></p>
<p>上面命令使用awk命令的sub()函数，将以\r结尾的替换为空。</p>
<h3 id="如何将-UNIX-文件转换为-DOS-格式"><a href="#如何将-UNIX-文件转换为-DOS-格式" class="headerlink" title="如何将 UNIX 文件转换为 DOS 格式"></a>如何将 UNIX 文件转换为 DOS 格式</h3><hr>
<p>当将文件从 UNIX 转换为 DOS 格式时，它会在每一行中添加一个回车符（ \r ）。</p>
<p>[root@server1 ~]# unix2dos unix.txt</p>
<p><img src="https://img-blog.csdnimg.cn/7aaf6402973c42bc814315cbd02c5193.png" alt="在这里插入图片描述"></p>
<p>上面命令操作之后，可以看到将unix格式的转换成dos格式了。<br>如果需要保留原文件，可以使用-n选项。</p>
<p>[root@server1 ~]# unix2dos -n unix.txt windows.txt<br>unix2dos: converting file unix.txt to file windows.txt in DOS format…</p>
<h3 id="如何使用-awk-命令将-UNIX-文件转换为-DOS-格式"><a href="#如何使用-awk-命令将-UNIX-文件转换为-DOS-格式" class="headerlink" title="如何使用 awk 命令将 UNIX 文件转换为 DOS 格式"></a>如何使用 awk 命令将 UNIX 文件转换为 DOS 格式</h3><hr>
<p>以下使用 awk 命令将 UNIX 文件转换为 DOS 格式。下面使用 awk 命令将“unix.txt”文件转换为 DOS 格式文件“windows.txt”。</p>
<p>[root@server1 ~]# awk ‘sub(“$”, “\r”)’ unix.txt &gt; windows.txt</p>
<p><img src="https://img-blog.csdnimg.cn/1c56632516fa4d389d335cb5d1277b93.png" alt="在这里插入图片描述"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>本文介绍如何在 Unix 和 DOS 格式之间转换文本文件</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>dos2unix</tag>
        <tag>unix</tag>
        <tag>DOS</tag>
        <tag>unix2dos</tag>
        <tag>格式转换</tag>
        <tag>编码转换</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建 Loki开源日志系统？</title>
    <url>/2021/11/25/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA-loki%E5%BC%80%E6%BA%90%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021112501292883.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Loki开源日志解决方案已经开源有一段时间了，对标EFK&#x2F;ELK，由于其轻量的设计，备受欢迎</p>
<p>Loki相比EFK&#x2F;ELK，它不对原始日志进行索引，只对日志的标签进行索引，而日志通过压缩进行存储，通常是文件系统存储，所以其操作成本更低，数量级效率更高</p>
<p>由于Loki的存储都是基于文件系统的，所以它的日志搜索时基于内容即日志行中的文本，所以它的查询支持LogQL，在搜索窗口中通过过滤标签的方式进行搜索和查询</p>
<p>Loki分两部分，Loki是日志引擎部分，Promtail是收集日志端，然后通过Grafana进行展示</p>
<p><img src="https://img-blog.csdnimg.cn/c60a99dc870f4dc4965c8e10469b4707.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>Loki的官方文档很全</p>
<p><a href="https://grafana.com/docs/loki/latest/installation">https://grafana.com/docs/loki/latest/installation</a></p>
<h3 id="Loki·安装"><a href="#Loki·安装" class="headerlink" title="Loki·安装"></a>Loki·安装</h3><hr>
<p>从官方文档看，Loki支持源码安装、Docker、Helm、Local、Tanka</p>
<p>我选择local，就是编译好的二进制可执行文件</p>
<p>安装步骤：<br>下载：<a href="https://github.com/grafana/loki/releases/">https://github.com/grafana/loki/releases/</a></p>
<p>curl -O -L “<a href="https://github.com/grafana/loki/releases/download/v2.2.1/loki-linux-amd64.zip&quot;">https://github.com/grafana/loki/releases/download/v2.2.1/loki-linux-amd64.zip&quot;</a></p>
<p>通过unzip解压得到可执行文件</p>
<p>下载配置文件</p>
<p>wget <a href="https://raw.githubusercontent.com/grafana/loki/master/cmd/loki/loki-local-config.yaml">https://raw.githubusercontent.com/grafana/loki/master/cmd/loki/loki-local-config.yaml</a></p>
<h3 id="Loki·配置"><a href="#Loki·配置" class="headerlink" title="Loki·配置"></a>Loki·配置</h3><hr>
<p>Loki的配置文件是loki-local-config.yaml，支持YAML语法</p>
<p>auth_enabled: false</p>
<p>server:<br>  http_listen_port: 3100<br>  grpc_listen_port: 9096</p>
<p>ingester:</p>
<h1 id="wal"><a href="#wal" class="headerlink" title="wal:"></a>wal:</h1><h1 id="enabled-true"><a href="#enabled-true" class="headerlink" title="enabled: true"></a>enabled: true</h1><h1 id="dir-x2F-tmp-x2F-wal"><a href="#dir-x2F-tmp-x2F-wal" class="headerlink" title="dir: &#x2F;tmp&#x2F;wal"></a>dir: &#x2F;tmp&#x2F;wal</h1><h1 id="recover-true"><a href="#recover-true" class="headerlink" title="recover: true"></a>recover: true</h1><p>  lifecycler:<br>    address: 192.168.80.144<br>    ring:<br>      kvstore:<br>        store: inmemory<br>      replication_factor: 1<br>    final_sleep: 0s<br>  chunk_idle_period: 1h       # Any chunk not receiving new logs in this time will be flushed<br>  max_chunk_age: 1h           # All chunks will be flushed when they hit this age, default is 1h<br>  chunk_target_size: 10485760  # Loki will attempt to build chunks up to 1.5MB, flushing first if chunk_idle_period or max_chunk_age is reached first<br>  chunk_retain_period: 30s    # Must be greater than index read cache TTL if using an index cache (Default index read cache TTL is 5m)<br>  max_transfer_retries: 0     # Chunk transfers disabled</p>
<p>schema_config:<br>  configs:<br>    - from: 2020-10-24<br>      store: boltdb-shipper<br>      object_store: filesystem<br>      schema: v11<br>      index:<br>        prefix: index_<br>        period: 24h #每张表的时间范围24小时</p>
<p>storage_config:<br>  boltdb_shipper:  #索引文件存储地址<br>    active_index_directory: &#x2F;tmp&#x2F;loki&#x2F;boltdb-shipper-active<br>    cache_location: &#x2F;tmp&#x2F;loki&#x2F;boltdb-shipper-cache<br>    cache_ttl: 24h         # Can be increased for faster performance over longer query periods, uses more disk space<br>    shared_store: filesystem<br>  filesystem:<br>    directory: &#x2F;tmp&#x2F;loki&#x2F;chunks #块存储地址</p>
<p>compactor:<br>  working_directory: &#x2F;tmp&#x2F;loki&#x2F;boltdb-shipper-compactor<br>  shared_store: filesystem</p>
<p>limits_config:<br>  reject_old_samples: true<br>  reject_old_samples_max_age: 168h<br>  ingestion_rate_mb: 32<br>  ingestion_burst_size_mb: 64</p>
<p>chunk_store_config:<br>#最大可查询历史日期90天</p>
<h1 id="max-look-back-period-2160h"><a href="#max-look-back-period-2160h" class="headerlink" title="max_look_back_period: 2160h"></a>max_look_back_period: 2160h</h1><h1 id="max-look-back-period-0s"><a href="#max-look-back-period-0s" class="headerlink" title="max_look_back_period: 0s"></a>max_look_back_period: 0s</h1><p>  max_look_back_period: 168h</p>
<p>#表的保留期为90天<br>#table_manager:</p>
<h1 id="retention-deletes-enabled-true"><a href="#retention-deletes-enabled-true" class="headerlink" title="retention_deletes_enabled: true"></a>retention_deletes_enabled: true</h1><h1 id="retention-period-2160h"><a href="#retention-period-2160h" class="headerlink" title="retention_period: 2160h"></a>retention_period: 2160h</h1><p>table_manager:<br>  retention_deletes_enabled: true<br>  retention_period: 168h</p>
<p>loki提供http和grpc两种接口，在配置文件中可以看到对应端口，分别是3100和9096，启动后，就可以通过http接口看到数据</p>
<p>配置完成后，就可以启动loki了，二进制可执行文件，通过 –config.file指定配置文件启动即可</p>
<h3 id="promtail·安装"><a href="#promtail·安装" class="headerlink" title="promtail·安装"></a>promtail·安装</h3><hr>
<p>Promtail安装也很简单</p>
<p>下载可执行文件</p>
<p>curl -O -L <a href="https://github.com/grafana/loki/releases/download/v2.2.1/promtail-linux-amd64.zip">https://github.com/grafana/loki/releases/download/v2.2.1/promtail-linux-amd64.zip</a></p>
<p>通过unzip解压得到可执行文件即可</p>
<p>同样下载配置文件</p>
<p>wget <a href="https://raw.githubusercontent.com/grafana/loki/main/clients/cmd/promtail/promtail-local-config.yaml">https://raw.githubusercontent.com/grafana/loki/main/clients/cmd/promtail/promtail-local-config.yaml</a></p>
<p>之后，就可以直接可执行文件指定配置文件启动了</p>
<p># Promtail Server Config<br>server:<br>  http_listen_port: 9080<br>  grpc_listen_port: 0</p>
<h1 id="Positions"><a href="#Positions" class="headerlink" title="Positions"></a>Positions</h1><p>positions:<br>  filename: &#x2F;tmp&#x2F;positions.yaml</p>
<h1 id="Loki服务器的地址"><a href="#Loki服务器的地址" class="headerlink" title="Loki服务器的地址"></a>Loki服务器的地址</h1><p>clients:</p>
<ul>
<li>url: <a href="http://192.168.80.144:3100/loki/api/v1/push">http://192.168.80.144:3100/loki/api/v1/push</a></li>
</ul>
<p>scrape_configs:</p>
<ul>
<li>job_name: bjj<br>static_configs:<ul>
<li>targets:<ul>
<li>192.168.80.176targetsa<br>labels:<br>  job: tomcat<br>  host: 192.168.80.176<br>  __path__: &#x2F;data&#x2F;tomcat-*&#x2F;logs&#x2F;catalina.out</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>前面三部分很简单，server部分定义监听端口，positions定义读取的文件偏移量存储位置，clients定义loki接口地址，最后一部分scrape_configs是重点部分</p>
<ul>
<li>promtail通过scrape_configs部分配置收集日志的相关信息，以测试配置文件为例：</li>
<li>job_name 用来区分日志组</li>
<li>static_configs 收集日志的静态配置</li>
<li>targets 收集日志的节点，这个参数其实是在自动发现的时候使用的</li>
<li>labels 定义一个要收集的日志文件和一组可选的附加标签</li>
<li>job 标签名称，在grafana索引的时候用到的标签名称</li>
<li><strong>path</strong> 定义日志收集的文件或路径，支持正则</li>
</ul>
<p>配置文件修改完成后，就可以启动promtail了，和loki启动方法一样，通过 –config.file指定配置文件启动</p>
<p><img src="https://img-blog.csdnimg.cn/caaba66273a54accb6a7cfd8f5a6fa7f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>promtail，类似于tail，它只监听新增日志，不会像filebeat一样，读取日志所有内容，这是和filebeat的一个区别</p>
<h3 id="Grafana·展示"><a href="#Grafana·展示" class="headerlink" title="Grafana·展示"></a>Grafana·展示</h3><hr>
<p>好了，promtail和Loki都配置好了，需要展示，6.0以上版本的grafana就支持loki的展示了<br>grafana配置很简单，登录后，在设置——数据源中，选择添加数据源，下来列表中直接选择Loki即可<br><img src="https://img-blog.csdnimg.cn/9be69c05214e49aeb3b2accc842d01b9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>接着配置数据源，只需要修改URL即可，其他可以根据自己的需要<br><img src="https://img-blog.csdnimg.cn/a962ea8ed9b042118d4d35b09e040b53.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>因为我的loki是没有做认证的，所以这里不需要认证配置，直接填写loki的地址即可，完成后保存<br>保存完成后，在Explore中查看日志<br><img src="https://img-blog.csdnimg.cn/b9ee4bfeb2b8432cb9424bbc856177ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里支持LogQL语法，默认情况下，如果不添加规则，是没有日志展示的，在Log browser中添加query，根据在promtail中定义的label，比如我的promtail的job是nginx，我这里填写{job&#x3D;“nginx”}，然后run query<br><img src="https://img-blog.csdnimg.cn/5355cbe5b2324b80a47cce3f196f25c2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就可以看到nginx的日志<br>日志界面很清爽，保留了日志原有的样子，通过颜色区分日志级别，这里info是绿色，error是红色，可以很直观的看到日志的类别，也可以通过点击日志级别，只展示该级别的日志</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>相对于EFK&#x2F;ELK，专为日志而生的Loki，结合Grafana生态，对于中小企业，或者说只是作为日志系统而言，我更倾向于选择Loki代替EFK&#x2F;ELK</p>
]]></content>
      <categories>
        <category>Grafana</category>
        <category>日志系统</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>EFK</tag>
        <tag>ELK</tag>
        <tag>Loki</tag>
        <tag>promtail</tag>
        <tag>日志系统</tag>
      </tags>
  </entry>
  <entry>
    <title>如何更新 Linux 的符号链接？</title>
    <url>/2021/11/16/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0-linux-%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021111509535610.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>UNIX 和 Linux 用户发现链接有很多用途，特别是符号链接。我喜欢使用符号链接的一种方式是管理各种 IT 设备的配置备份。</p>
<p>我有一个目录结构，用来存放我的文档、更新及网络上其他和计算机和设备有关的文件。设备可以包括路由器、接入点、NAS 服务器和笔记本电脑，通常有不同的品牌和版本。配置备份本身可能在目录树的深处，例如 &#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;NetgearRL5000&#x2F;config。</p>
<p>为了简化备份过程，我在主目录中有一个名为 Configuration 的目录。我使用这个目录的符号链接来指向特定的设备目录：</p>
<p>:~&#x2F;Configuration&#x2F; $ ls -F1<br>Router@<br>Accesspoint@<br>NAS@</p>
<p>注意：ls 命令的 -F 选项在每个文件名上附加特殊字符以表示其类型。如上所示，@ 符号表示这些是链接。</p>
<h3 id="创建一个链接"><a href="#创建一个链接" class="headerlink" title="创建一个链接"></a>创建一个链接</h3><hr>
<p>符号链接 Router 指向我的 Netgear RL5000 的 config 目录。创建它的命令是 ln -s：</p>
<p>$ ln -s &#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;NetgearRL5000&#x2F;config Router</p>
<p>然后，用 ls -l 看一下并确认：</p>
<p>:~&#x2F;Configuration&#x2F; $ ls -l<br>Router -&gt; &#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;NetgearRL5000&#x2F;config<br>NAS -&gt; &#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;NFSBox&#x2F;config<br>…</p>
<p>这样做的好处是，当对这个设备进行维护时，我只需进入 ~&#x2F;Configuration&#x2F;Router。</p>
<p>如果我决定用一个新的型号替换这个路由器，使用符号链接的第二个好处就很明显了。我可能会把旧的路由器改成一个接入点。因此，它的目录并没有被删除。相反，我有一个新的目录，对应于新的路由器，也许是华硕 DF-3760。我创建这个目录并确认它的存在：</p>
<p>$ mkdir -p <del>&#x2F;Documents&#x2F;network&#x2F;device&#x2F;ASUSDF-3760&#x2F;config<br>:</del>&#x2F;Documents&#x2F;network&#x2F;device&#x2F; $ ls<br>NetgearRL5000<br>ASUSDF-3760<br>NFSBox<br>…</p>
<p>另一个例子是，如果你的办公室里有几个接入点。你可以使用符号链接在逻辑上代表每一个，用一个通用的名字，如 ap1，ap2，等等，或者你可以使用描述性的词语，如 ap_floor2，ap_floor3，等等。这样，当物理设备随时间变化时，你不必持续更新任何可能管理它们的进程，因为它们是在处理链接而不是实际的设备目录。</p>
<h3 id="更新一个链接"><a href="#更新一个链接" class="headerlink" title="更新一个链接"></a>更新一个链接</h3><hr>
<p>由于我的主路由器已经改变，我想让路由器的符号链接指向它的目录。我可以使用 rm 和 ln 命令来删除和创建一个新的符号链接，但是有一种方法可以只用 ln 命令和几个选项就可以一步完成：</p>
<p>:<del>&#x2F;Configuration&#x2F; $ ln -vfns ~&#x2F;Documents&#x2F;network&#x2F;device&#x2F;ASUSDF-3760&#x2F;config&#x2F; Router<br>‘Router’ -&gt; ‘&#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;ASUSDF-3760&#x2F;config&#x2F;‘<br>:</del>&#x2F;Configuration&#x2F; $ ls -l<br>Router -&gt; &#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;ASUSDF-3760&#x2F;config<br>NAS -&gt; &#x2F;home&#x2F;alan&#x2F;Documents&#x2F;network&#x2F;device&#x2F;NFSBox&#x2F;config</p>
<p>根据手册页，这些选项如下：</p>
<p>◈ -v、–verbose：打印每个链接文件的名称<br>◈ -f、–force：删除目标文件（有必要，因为已经存在一个链接）<br>◈ -n、–no-dereference：如果链接名是一个目录的符号链接，就把它当作一个正常的文件<br>◈ -s、–symbolic：制作符号链接而不是硬链接</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>链接是 UNIX 和 Linux 文件系统中最强大的功能之一。其他操作系统也曾试图模仿这种能力，但由于他们的文件系统缺乏基本的链接设计，这些系统从来没有工作得那么好，也没有那么可用。</p>
<p>上面的演示只是利用链接在生活生产环境中无缝浏览不断变化的目录结构的众多可能性中的一种。链接提供了一个永远不会长期静态的组织所需的灵活性。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>symlink</tag>
        <tag>更新</tag>
        <tag>符号链接</tag>
      </tags>
  </entry>
  <entry>
    <title>如何清除Linux历史记录？</title>
    <url>/2021/11/02/%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4linux%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-2.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在linux操作系统中，会执行很多条命令，有的命令很长，如果重复敲会很麻烦。linux可以记住历史命令，并且也可以设置历史命令的长度。</p>
<p>另外，如果在操作中输入过密码等信息，如果不想保存到历史纪录中是可以删除的。</p>
<h3 id="1-隐藏远程SSH登陆记录"><a href="#1-隐藏远程SSH登陆记录" class="headerlink" title="1. 隐藏远程SSH登陆记录"></a>1. 隐藏远程SSH登陆记录</h3><hr>
<p>隐身登录系统，不会被w、last等指令检测到。</p>
<p>ssh -T <a href="mailto:&#114;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#x30;&#46;&#48;&#46;&#x31;">&#114;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#x30;&#46;&#48;&#46;&#x31;</a> &#x2F;bin&#x2F;bash -i</p>
<p>-T表示不分配伪终端，&#x2F;usr&#x2F;bin&#x2F;bash 表示在登录后调用bash命令 -i 表示是交互式shell</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><hr>
<p>w&#x2F;last命令日志&#x2F;var&#x2F;log&#x2F;wtmp 是utmp和wtmp的日志接口产生的，而这俩接口是正常登陆分配伪终端（tty）之后才调用的，ssh -T <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#48;&#46;&#x30;&#x2e;&#49;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#48;&#46;&#x30;&#x2e;&#49;</a> &#x2F;usr&#x2F;bin&#x2F;bash表示登陆后调用bash命令。不是一个完整的会话 类似执行一个临时命令,系统不会分配伪终端</p>
<p>伪终端(pseudo terminal有时也被称为pty)应用场景:</p>
<ol>
<li>在图形界面下打开的命令行终端</li>
<li>基于ssh协议或telnet协议等远程打开的命令行界面</li>
</ol>
<h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><hr>
<p>登录后先用 echo $PPID 获取自己的PID,netstat\lsof 都可以排查到</p>
<p><img src="https://img-blog.csdnimg.cn/a2adf5e6dd5846619dc28f6c33aa9d7a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="2-清除当前的history记录"><a href="#2-清除当前的history记录" class="headerlink" title="2. 清除当前的history记录"></a>2. 清除当前的history记录</h3><hr>
<p>如果我们不希望命令被记录，在退出会话前直接执行：</p>
<p># 清除当前会话的命令历史记录<br>history -r  </p>
<h1 id="或者-不给当前的shell留时间去处理，内存的命令也就没时间写入到文件"><a href="#或者-不给当前的shell留时间去处理，内存的命令也就没时间写入到文件" class="headerlink" title="或者 不给当前的shell留时间去处理，内存的命令也就没时间写入到文件"></a>或者 不给当前的shell留时间去处理，内存的命令也就没时间写入到文件</h1><p>kill -9 $$</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><hr>
<p><strong>history -r</strong>将历史命令文件中的命令(&#x2F;.bash_history) 读入当前历史命令缓冲区.</p>
<p><strong>history -r</strong> 把历史文件(&#x2F;.bash_history）附加到内存数据中了</p>
<h3 id="3-隐藏Vim的操作记录"><a href="#3-隐藏Vim的操作记录" class="headerlink" title="3. 隐藏Vim的操作记录"></a>3. 隐藏Vim的操作记录</h3><hr>
<p>当我们使用 vim时候,会在 ~&#x2F;.viminfo留下操作记录，建议使用 vi 。或者在vim中使用命令关闭记录。</p>
<p>:set history&#x3D;0 :!command</p>
<h3 id="4-隐藏文件修改时间"><a href="#4-隐藏文件修改时间" class="headerlink" title="4. 隐藏文件修改时间"></a>4. 隐藏文件修改时间</h3><hr>
<p>一般管理员会查看一个文件的修改时间，我们可以把我们的后门文件时间修改成几天之前创建的效果。使用如下命令。</p>
<p># touch -r A B 使B文件时间变得和A文件相同<br>touch -r index.html shell.php</p>
<p><img src="https://img-blog.csdnimg.cn/b062fec70e604aaf99f687e144ca7473.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>但是稍微有经验的管理员使用stat或者 find .&#x2F; -ctime 0 -name “*.php” 就会发现这里的问题</p>
<p># 查找24小时内被创建的php文件<br>find .&#x2F; -ctime 0 -name “*.php”</p>
<p><img src="https://img-blog.csdnimg.cn/afc8a4d9c3ca4b2d905341f05e84e58e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>stat中的三个属性意思是</p>
<p>最近访问(<strong>access time</strong>)：表示我们最后一次访问（仅仅是访问，没有改动）文件的时间<br>最近更改(<strong>modify time</strong>)：表示我们最后一次修改文件的时间<br>最近改动(<strong>change time</strong>)：表示我们最后一次对文件属性改变的时间，包括权限，大小，属性等等<br>比如 最近访问(<strong>access time</strong>)。我们用cat访问下，发现 最近访问 变了</p>
<p><img src="https://img-blog.csdnimg.cn/905d03dbccec4e2d859a66dc4cb6df89.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>那么如果再绕过 stat的检测呢？修改系统时间后再 touch -r A B 就可以了。最后记得把系统时间改回来啊</p>
<h3 id="5-锁定文件"><a href="#5-锁定文件" class="headerlink" title="5. 锁定文件"></a>5. 锁定文件</h3><hr>
<p>有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。此权限用ls -l是查看不出来的，从而达到隐藏权限的目的。chattr命令不能保护&#x2F;、&#x2F;dev、&#x2F;tmp、&#x2F;var目录。lsattr命令是显示chattr命令设置的文件属性。</p>
<p>chattr +i shell.php  #锁定文件<br>rm -rf shell.php     #提示禁止删除</p>
<p>lsattr  shell.php    #属性查看<br>chattr -i shell.php  #解除锁定<br>rm -rf shell.php     #删除文件</p>
<p><img src="https://img-blog.csdnimg.cn/210d58d7712d4b4084a80900742b212e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件</p>
<p># chattr +a &#x2F;var&#x2F;log&#x2F;messages</p>
<h3 id="6-清除系统日志痕迹"><a href="#6-清除系统日志痕迹" class="headerlink" title="6. 清除系统日志痕迹"></a>6. 清除系统日志痕迹</h3><hr>
<p>Linux 系统存在多种日志文件，来记录系统运行过程中产生的日志</p>
<h4 id="清除系统日志痕迹"><a href="#清除系统日志痕迹" class="headerlink" title="清除系统日志痕迹"></a>清除系统日志痕迹</h4><hr>
<p>&#x2F;var&#x2F;log&#x2F;btmp   记录所有登录失败信息，使用lastb命令查看<br>&#x2F;var&#x2F;log&#x2F;lastlog 记录所有用户最后一次登录时间的日志，使用lastlog命令查看<br>&#x2F;var&#x2F;log&#x2F;wtmp    记录所有用户的登录、注销信息，使用last命令查看<br>&#x2F;var&#x2F;log&#x2F;utmp    记录当前已经登录的用户信息，使用w,who,users等命令查看<br>&#x2F;var&#x2F;log&#x2F;secure   记录与安全相关的日志信息<br>&#x2F;var&#x2F;log&#x2F;message  记录系统启动后的信息和错误日志</p>
<h1 id="直接覆盖日志文件"><a href="#直接覆盖日志文件" class="headerlink" title="直接覆盖日志文件"></a>直接覆盖日志文件</h1><p>echo &gt; &#x2F;var&#x2F;log&#x2F;btmp<br>cat &#x2F;dev&#x2F;null &gt;  &#x2F;var&#x2F;log&#x2F;secure</p>
<h1 id="删除所有匹配到字符串的行-比如以当天日期或者自己的登录ip"><a href="#删除所有匹配到字符串的行-比如以当天日期或者自己的登录ip" class="headerlink" title="删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip"></a>删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip</h1><p>sed  -i ‘&#x2F;自己的ip&#x2F;‘d  &#x2F;var&#x2F;log&#x2F;messages</p>
<h1 id="全局替换登录IP地址："><a href="#全局替换登录IP地址：" class="headerlink" title="全局替换登录IP地址："></a>全局替换登录IP地址：</h1><p>sed -i ‘s&#x2F;192.168.166.85&#x2F;192.168.1.1&#x2F;g’ secure</p>
<h4 id="清除web日志入侵痕迹"><a href="#清除web日志入侵痕迹" class="headerlink" title="清除web日志入侵痕迹"></a>清除web日志入侵痕迹</h4><hr>
<p># 直接替换日志ip地址<br>sed -i ‘s&#x2F;192.168.166.85&#x2F;192.168.1.1&#x2F;g’ access.log</p>
<h1 id="清除部分相关日志"><a href="#清除部分相关日志" class="headerlink" title="清除部分相关日志"></a>清除部分相关日志</h1><p>cat &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  grep -v evil.php &gt; tmp.log</p>
<h1 id="把修改过的日志覆盖到原日志文件"><a href="#把修改过的日志覆盖到原日志文件" class="headerlink" title="把修改过的日志覆盖到原日志文件"></a>把修改过的日志覆盖到原日志文件</h1><p>cat tmp.log &gt; &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&#x2F;</p>
<h4 id="文件安全删除工具"><a href="#文件安全删除工具" class="headerlink" title="文件安全删除工具"></a>文件安全删除工具</h4><hr>
<p># shred 命令 安全的从硬盘上擦除数据，默认覆盖3次，通过 -n指定数据覆盖次数<br>[root@centos]# shred -f -u -z -v -n 8 1.txt </p>
<h1 id="wipe-使用特殊的模式来重复地写文件，从磁性介质中安全擦除文件"><a href="#wipe-使用特殊的模式来重复地写文件，从磁性介质中安全擦除文件" class="headerlink" title="wipe 使用特殊的模式来重复地写文件，从磁性介质中安全擦除文件"></a>wipe 使用特殊的模式来重复地写文件，从磁性介质中安全擦除文件</h1><p>[root@centos]# wipe filename</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>history</tag>
        <tag>历史记录</tag>
        <tag>清除</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用Python实现验证码识别_识别验证码</title>
    <url>/2021/08/24/%E5%A6%82%E4%BD%95%E7%94%A8python%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB-%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-21.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>在很久之前，分享过一次Python代码实现验证码识别的办法。</p>
<p>当时采用的是pillow+pytesseract，优点是免费，较为易用。但其识别精度一般，若想要更高要求的验证码识别，初学者就只能去选择使用百度API接口了。</p>
<p>但其实百度API接口和pytesseract其实都需要进行前期配置，对于初学者来说就不太友好了。</p>
<blockquote>
<p>而且百度API必须要联网，对于某些机器不能联网的朋友而言，就得pass了</p>
</blockquote>
<p>最近群里有位群友分享了一个新库，试用一下发现非常实用，特意今天分享给大家。</p>
<p>Github地址：<a href="https://github.com/sml2h3/ddddocr">https://github.com/sml2h3/ddddocr</a></p>
<p>该库名也是非常有趣 —— ddddocr（谐音带带弟弟OCR）</p>
<h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><hr>
<p>python &gt;&#x3D; 3.8<br>Windows&#x2F;Linux&#x2F;Macox..</p>
<p>可以通过以下命令安装</p>
<p>pip install ddddocr</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><hr>
<p>DdddOcr 接受两个参数</p>
<p>参数名</p>
<p>默认值</p>
<p>说明</p>
<p>use_gpu</p>
<p>False</p>
<p>Bool 是否使用gpu进行推理，如果该值为False则device_id不生效</p>
<p>device_id</p>
<p>0</p>
<p>int cuda设备号，目前仅支持单张显卡</p>
<p>classification</p>
<p>参数名</p>
<p>默认值</p>
<p>说明</p>
<p>img</p>
<p>0</p>
<p>bytes 图片的bytes格式</p>
<p>在网上随机寻找了</p>
<p>一个验证码图片，使用这个库来实战一下。</p>
<p><img src="https://img-blog.csdnimg.cn/ac7df27ab9604a7686473d83192884b5.png" alt="在这里插入图片描述"></p>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><hr>
<p>import ddddocr</p>
<p>ocr &#x3D; ddddocr.DdddOcr()<br>with open(‘1.png’, ‘rb’) as f:<br>    img_bytes &#x3D; f.read()<br>res &#x3D; ocr.classification(img_bytes)</p>
<p>print(res)</p>
<p><img src="https://img-blog.csdnimg.cn/fbc8f17c9cf74242b4e2b7840c443867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<p>成功识别出来了验证码文字！</p>
<p>而且优点也非常明显：首先代码非常精简，对比前文提到的两种方法，不需要额外设置环境变量等等，5行代码即可轻松识别验证码图片。另一方面，我们使用魔法命令<code>%%time</code>也测试出来吗，这段代码识别速度非常快。</p>
<p>下面用更多的验证码图片继续测试：</p>
<p><img src="https://img-blog.csdnimg.cn/e9bf2bf70dbb447da417725aa879aa22.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>我又找了6个验证码图片来测试，观察结果，发现这类简单的验证码基本可以进行快速识别。但也有部分结果有问题——字母大小写没有进行区分（比如第6张图片）。</p>
<p>总而言之，如果你需要进行验证码识别，且对精度要求不是过高。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>验证码</tag>
        <tag>识别</tag>
        <tag>OCR</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获取k8s admin token?</title>
    <url>/2021/11/12/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96k8s-admin-token/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/2021111106404964.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我们用程序调用Kubernetes API 时,需要使用Kubernetes的Token<br>Service Account 对象的作用，就是 Kubernetes 系统内置的一种“服务账户”，它是 Kubernetes 进行权限分配的对象。比如， Service Account A，可以只被允许对 Kubernetes API 进行 GET 操作，而 Service Account B，则可以有 Kubernetes API 的所有操作权限。</p>
<h3 id="创建-kubernetes-io-x2F-service-account-token"><a href="#创建-kubernetes-io-x2F-service-account-token" class="headerlink" title="创建 kubernetes.io&#x2F;service-account-token"></a>创建 kubernetes.io&#x2F;service-account-token</h3><hr>
<p>创建一个k8s-admin.yaml</p>
<p>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: dashboard-admin<br>  namespace: kube-system</p>
<hr>
<p>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1<br>metadata:<br>  name: dashboard-admin<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: dashboard-admin<br>namespace: kube-system<br>roleRef:<br>  kind: ClusterRole<br>  name: cluster-admin<br>  apiGroup: rbac.authorization.k8s.io</li>
</ul>
<h3 id="应用k8s-admin-yaml配置"><a href="#应用k8s-admin-yaml配置" class="headerlink" title="应用k8s-admin.yaml配置"></a>应用k8s-admin.yaml配置</h3><hr>
<p>kubectl apply -f k8s-admin.yaml</p>
<h3 id="获取admin-token名字"><a href="#获取admin-token名字" class="headerlink" title="获取admin-token名字"></a>获取admin-token名字</h3><p>[root@k8s-master01 token]# kubectl get secret -n kube-systemgrep admin<br>dashboard-admin-token-slc8x                      kubernetes.io&#x2F;service-account-token   3      2m</p>
<h3 id="查询token内容"><a href="#查询token内容" class="headerlink" title="查询token内容"></a>查询token内容</h3><hr>
<p>kubectl describe secret dashboard-admin-token-slc8x -n kube-system<br>Name:         dashboard-admin-token-slc8x<br>Namespace:    kube-system<br>Labels:       <none><br>Annotations:  kubernetes.io&#x2F;service-account.name: dashboard-admin<br>              kubernetes.io&#x2F;service-account.uid: c1b01bec-c8a8-49b8-8199-c609d525e555</p>
<p>Type:  kubernetes.io&#x2F;service-account-token</p>
<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><p>ca.crt:     1066 bytes<br>namespace:  11 bytes<br>token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IlE3MDhCbHxxxxxxxxxx</p>
<p>token: eyJhbGciOiJSUzI1NiIsImtpZCI6IlE3MDhCbHxxxxxxxxxx<br>由于token过长，这里用xxx代替</p>
<p>最后将token与APISERVER地址返回内容复制到程序主机内, 供脚本使用.</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Kubernetes</tag>
        <tag>token</tag>
        <tag>secret</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获取服务器机器码_dmidecode命令详解(获取硬件信息)</title>
    <url>/2021/07/11/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%BA%E5%99%A8%E7%A0%81-dmidecode%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E8%8E%B7%E5%8F%96%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-38.png"></p>
<h3 id="零、获取linux服务器机器码"><a href="#零、获取linux服务器机器码" class="headerlink" title="零、获取linux服务器机器码"></a>零、获取linux服务器机器码</h3><hr>
<p>dmidecode -t 1grep UUID</p>
<p>上面可以获取机器码，下面是此命令的详细说明</p>
<h3 id="一、dmidecode简介"><a href="#一、dmidecode简介" class="headerlink" title="一、dmidecode简介"></a>一、dmidecode简介</h3><hr>
<p>dmidecode允许你在Linux系统下获取有关硬件方面的信息。dmidecode遵循SMBIOS&#x2F;DMI标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。</p>
<p>DMI（Desktop Management Interface,DMI）就是帮助收集电脑系统信息的管理系统，DMI信息的收集必须在严格遵照SMBIOS规范的前提下进行。SMBIOS（System Management BIOS）是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范。SMBIOS和DMI是由行业指导机构Desktop Management Task Force(DMTF)起草的开放性的技术标准，其中DMI设计适用于任何的平台和操作系统。</p>
<p>DMI充当了管理工具和系统层之间接口的角色。它建立了标准的可管理系统更加方便了电脑厂商和用户对系统的了解。DMI的主要组成部分是Management Information Format(MIF)数据库。这个数据库包括了所有有关电脑系统和配件的信息。通过DMI，用户可以获取序列号、电脑厂商、串口信息以及其它系统配件信息。</p>
<h3 id="二、dmidecode的作用"><a href="#二、dmidecode的作用" class="headerlink" title="二、dmidecode的作用"></a>二、dmidecode的作用</h3><hr>
<p>dmidecode的作用是将DMI数据库中的信息解码，以可读的文本方式显示。由于DMI信息可以人为修改，因此里面的信息不一定是系统准确的信息。</p>
<h3 id="三、dmidecode命令用法"><a href="#三、dmidecode命令用法" class="headerlink" title="三、dmidecode命令用法"></a>三、dmidecode命令用法</h3><hr>
<p>不带选项执行dmidecode通常会输出所有的硬件信息。dmidecode有个很有用的选项-t，可以指定类型输出相关信息。假如要获得处理器方面的信息，则可以执行：dmidecode -t processor</p>
<p>Usage: dmidecode [OPTIONS]</p>
<p>Options are:</p>
<p>-d：(default:&#x2F;dev&#x2F;mem)从设备文件读取信息，输出内容与不加参数标准输出相同。</p>
<p>-h：显示帮助信息。</p>
<p>-s：只显示指定DMI字符串的信息。(string)</p>
<p>-t：只显示指定条目的信息。(type)</p>
<p>-u：显示未解码的原始条目内容。</p>
<p>– dump-bin FILE: Dump the DMI data to a binary file.</p>
<p>– from-dump FILE: Read the DMI data from a binary file.</p>
<p>-V：显示版本信息</p>
<h3 id="dmidecode的输出格式一般如下"><a href="#dmidecode的输出格式一般如下" class="headerlink" title="dmidecode的输出格式一般如下"></a>dmidecode的输出格式一般如下</h3><hr>
<p>Handle 0x0002, DMI type 2, 95 bytes.</p>
<p>Base Board Information</p>
<pre><code>Manufacturer: IBM

Product Name: Node1 Processor Card

Version: Not Specified

Serial Number: Not Specified
</code></pre>
<h3 id="其中记录头（recode-header）包括了"><a href="#其中记录头（recode-header）包括了" class="headerlink" title="其中记录头（recode header）包括了"></a>其中记录头（recode header）包括了</h3><hr>
<ul>
<li>recode id(Handle)：DMI表中的记录标识符，这是唯一的，比如上例中的Handle 0x0002.</li>
<li>DMI type id：记录的类型，譬如说：BIOS，Memory，上例是type 2，即“Base Board Information”.</li>
<li>recode size：DMI表中对应记录的大小，上例为95 bytes。（不包括文本信息，所有实际输出的内容比这个size要更大）。记录头之后就是记录的值。</li>
<li>recoded values：记录值可以是多行的，比如上例显示了主板的制造商（Manufacturer）、Product Name、Version以及Serial Number。</li>
</ul>
<h3 id="最简单的的显示全部dmi信息"><a href="#最简单的的显示全部dmi信息" class="headerlink" title="最简单的的显示全部dmi信息"></a>最简单的的显示全部dmi信息</h3><hr>
<p>[root@BAIYU_180 ~]# dmidecode<br>[root@BAIYU_180 ~]# dmidecodewc -l<br>11938</p>
<p>这样将输出所有的dmi信息，你可能会被一大堆的信息吓坏，通常可以使用下面的方法。</p>
<h3 id="显示指定类型的信息"><a href="#显示指定类型的信息" class="headerlink" title="显示指定类型的信息"></a>显示指定类型的信息</h3><hr>
<p>通常我只想查看某类型，比如CPU，内存或者磁盘的信息而不是全部的。这可以使用 -t ( - -type TYPE) 来指定信息类型：</p>
<p>dmidecode -t bios<br>dmidecode -t bios, processor (这种方式好像不可以用，必须用下面的数字的方式)<br>dmidecode -t 0,4 (显示bios和processor)</p>
<h3 id="dmidecode到底支持哪些type"><a href="#dmidecode到底支持哪些type" class="headerlink" title="dmidecode到底支持哪些type"></a>dmidecode到底支持哪些type</h3><hr>
<p>这些可以在man dmidecode里面看到：<br>文本参数支持：<br>bios, system, baseboard, chassis, processor, memory, cache, connector, slot<br>数字参数支持很多：（见附录）</p>
<h3 id="通过关键字查看信息"><a href="#通过关键字查看信息" class="headerlink" title="通过关键字查看信息"></a>通过关键字查看信息</h3><hr>
<p>比如只想查看序列号，可以使用:</p>
<p># dmidecode -s system-serial-number</p>
<p>-s (–string keyword)支持的keyword包括：<br>bios-vendor,bios-version,bios-release-date,<br>system-manufacturer,system-product-name,system-version,system-serial-number,<br>baseboard-manu-facturer,baseboard-product-name,baseboard-version,baseboard-serial-number,baseboard-asset-tag,<br>chassis-manufacturer,chas-sis-version,chassis-serial-number,chassis-asset-tag,<br>processor-manufacturer,processor-version.</p>
<h3 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h3><hr>
<p>查看当前内存和支持的最大内存<br>Linux下，可以使用free或者查看meminfo来获得当前的物理内存：</p>
<p>[root@SC4304 ~]# free<br>            total      used      free    shared    buffers    cached<br>Mem:    132091660    5649612  126442048          0    224492    4052384<br>-&#x2F;+ buffers&#x2F;cache:    1372736  130718924<br>Swap:    209715192          0  209715192<br>[root@SC4305 ~]# free -m<br>            total      used      free    shared    buffers    cached<br>Mem:        128995      6230    122765          0        259      4615<br>-&#x2F;+ buffers&#x2F;cache:      1354    127640<br>Swap:      204799          0    204799</p>
<p>这里显示了当前服务器的物理内存是128GB。<br>服务器到底能扩展到多大的内存？</p>
<p>[root@SC4304 ~]# dmidecode -t 16</p>
<h1 id="dmidecode-2-11"><a href="#dmidecode-2-11" class="headerlink" title="dmidecode 2.11"></a>dmidecode 2.11</h1><h1 id="SMBIOS-entry-point-at-0xb89a5000"><a href="#SMBIOS-entry-point-at-0xb89a5000" class="headerlink" title="SMBIOS entry point at 0xb89a5000"></a>SMBIOS entry point at 0xb89a5000</h1><p>SMBIOS 2.7 present.</p>
<p>Handle 0x1000, DMI type 16, 23 bytes<br>Physical Memory Array<br>    Location: System Board Or Motherboard<br>    Use: System Memory<br>    Error Correction Type: Multi-bit ECC<br>    Maximum Capacity: 1536 GB<br>    Error Information Handle: Not Provided<br>    Number Of Devices: 24</p>
<p>从上面的信息我们可以看出：</p>
<p>内存插槽数：24个<br>最大扩展内存：1536G<br>单跟内存条最大：64G<br>现在内存为：128G</p>
<p>但是，我们还必须查清这里的128G到底是16_8GB, 2_64GB还是其他？就是查看已使用的插槽数<br>如果是2*64GB，那么可以扩展到1536GB，但是如果插槽已经插满，无法扩展了</p>
<h3 id="查看内存槽数、哪个槽位插了内存，大小是多少"><a href="#查看内存槽数、哪个槽位插了内存，大小是多少" class="headerlink" title="查看内存槽数、哪个槽位插了内存，大小是多少"></a>查看内存槽数、哪个槽位插了内存，大小是多少</h3><hr>
<p> [root@SC4305 ~]# dmidecodegrep -A5 ‘Memory Device’grep Size<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed<br>    Size: No Module Installed</p>
<h3 id="查看最大支持内存数"><a href="#查看最大支持内存数" class="headerlink" title="查看最大支持内存数"></a>查看最大支持内存数</h3><hr>
<p> [root@SC4305 ~]# dmidecodegrep ‘Maximum Capacity’<br>    Maximum Capacity: 1536 GB</p>
<h3 id="查看槽位上内存的速率，没插就是unknown"><a href="#查看槽位上内存的速率，没插就是unknown" class="headerlink" title="查看槽位上内存的速率，没插就是unknown"></a>查看槽位上内存的速率，没插就是unknown</h3><hr>
<p> [root@SC4305 ~]# dmidecodegrep -A16 ‘Memory Device’grep ‘Speed’<br>    Speed: 1600 MHz<br>    Speed: 1600 MHz<br>    Speed: 1600 MHz<br>    Speed: 1600 MHz<br>    Speed: Unknown<br>    Speed: Unknown<br>    Speed: 1600 MHz<br>    Speed: 1600 MHz<br>    Speed: 1600 MHz<br>    Speed: 1600 MHz<br>    Speed: Unknown<br>    Speed: Unknown</p>
<h3 id="一个查看基本硬件信息的shell脚本"><a href="#一个查看基本硬件信息的shell脚本" class="headerlink" title="一个查看基本硬件信息的shell脚本"></a>一个查看基本硬件信息的shell脚本</h3><hr>
<p>脚本适用于centos6</p>
<p>[root@SC4306 test]# cat test.sh<br>#!&#x2F;bin&#x2F;bash<br>echo “IP:”<br>ifconfig grep “inet addr”grep -v 127.0.0.1awk ‘{print $2}’awk -F ‘:’ ‘{print $2}’<br>echo “Product Name:”<br>dmidecode grep Name<br>echo “CPU Info:”<br>dmidecode grep -i cpugrep -i versionawk -F ‘:’ ‘{print $2}’<br>echo “Disk Info:”<br>parted -lgrep ‘Disk &#x2F;dev&#x2F;sd’awk -F ‘,’ ‘{print “  “,$1}’<br>echo “Network Info:”<br>lspci grep Ethernet<br>echo “Memory Info:”<br>dmidecodegrep -A5 “Memory Device”grep Sizegrep -v No<br>echo “Memory number:”`dmidecodegrep -A5 “Memory Device”grep Sizegrep -v Nowc -l`</p>
<p>输出结果：</p>
<p>[root@SC4306 test]# bash test.sh<br>IP:<br>10.0.17.6<br>10.0.250.6<br>Product Name:<br>    Product Name: PowerEdge R720<br>    SKU Number: SKU&#x3D;NotProvided;ModelName&#x3D;PowerEdge R720<br>    Product Name: 0DCWD1<br>CPU Info:<br>      Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz<br>      Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz<br>Disk Info:<br>    Disk &#x2F;dev&#x2F;sda: 1074GB<br>    Disk &#x2F;dev&#x2F;sdb: 18.9TB<br>Network Info:<br>01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5720 Gigabit Ethernet PCIe<br>01:00.1 Ethernet controller: Broadcom Corporation NetXtreme BCM5720 Gigabit Ethernet PCIe<br>02:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5720 Gigabit Ethernet PCIe<br>02:00.1 Ethernet controller: Broadcom Corporation NetXtreme BCM5720 Gigabit Ethernet PCIe<br>Memory Info:<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>    Size: 16384 MB<br>Memory number:8</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>UUID</tag>
        <tag>机器码</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置 Nessus 漏洞扫描策略？</title>
    <url>/2021/12/21/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-nessus-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%AD%96%E7%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-13-1024x439.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Nessus 是一种用于发现漏洞的强大扫描工具，它由 Tenable Network Security Inc 开发和维护，曾在 Nmap Software LLC 的安全工具清单中排名第一，虽然现在已经跌到了榜单的第三位，但它仍然是一款强大的远程安全扫描工具。</p>
<p>本文，我们将探讨如何在 Nessus 上配置扫描策略，稍后我们还将使用此策略创建扫描，然后我们将选择一个目标系统进行扫描，我们在本教程中使用 Kali Linux。让我们现在开始吧。</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><hr>
<ul>
<li>具有管理凭据的用户帐户。</li>
<li>网络安全与漏洞评估的基本思想。</li>
<li>Nessus Essential 应该安装在您的系统上。</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><hr>
<p>启动 Nessus 扫描的第一步是选择一个扫描模板，可以使用 Nessus 提供的扫描模板或创建自定义策略，后者创建用户定义的扫描模板，可在用户定义的扫描模板部分下找到该模板，我们在此策略中设置的每个设置都将自动应用于该策略下的任何扫描。</p>
<h3 id="步骤-1-让我们继续创建一个扫描策略。"><a href="#步骤-1-让我们继续创建一个扫描策略。" class="headerlink" title="步骤 1. 让我们继续创建一个扫描策略。"></a>步骤 1. 让我们继续创建一个扫描策略。</h3><hr>
<p>首先通过导航到 <a href="https://www.code404.icu:8834/">https://www.code404.icu:8834</a> 登录 Nessus 的 Web 界面，在登录页面上，点击左侧垂直面板上的 Policies 标签，单击右上角的 New Policy 按钮。<br><img src="https://img-blog.csdnimg.cn/5ce2efc498784170b460cf15784103ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="步骤-2-我们可以选择许多扫描仪模板。"><a href="#步骤-2-我们可以选择许多扫描仪模板。" class="headerlink" title="步骤 2. 我们可以选择许多扫描仪模板。"></a>步骤 2. 我们可以选择许多扫描仪模板。</h3><hr>
<p>总的来说，有三大类：发现、漏洞和合规性，由于我们正在制定漏洞扫描策略，因此我们将从该标题中选择一个，让我们从基本网络扫描策略开始，此策略用于完整系统扫描，这意味着它会搜索我们系统上的任何漏洞。</p>
<p>在这个新屏幕上，选择 Basic Network Scan 选项。<br><img src="https://img-blog.csdnimg.cn/f4de77765bdf4e1aac12a9e752ce822d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="步骤-3-现在我们已经选择了一个扫描策略，给它一个合适的名称，现在保留其余的设置。"><a href="#步骤-3-现在我们已经选择了一个扫描策略，给它一个合适的名称，现在保留其余的设置。" class="headerlink" title="步骤 3. 现在我们已经选择了一个扫描策略，给它一个合适的名称，现在保留其余的设置。"></a>步骤 3. 现在我们已经选择了一个扫描策略，给它一个合适的名称，现在保留其余的设置。</h3><hr>
<p>在我们的案例中，策略的名称是 Policy1_code404 。</p>
<p><img src="https://img-blog.csdnimg.cn/e7b4d12c6838428e80dd29e2c914c1d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="步骤-4-保存策略后，我们都准备在此策略下-New-Scan。"><a href="#步骤-4-保存策略后，我们都准备在此策略下-New-Scan。" class="headerlink" title="步骤 4. 保存策略后，我们都准备在此策略下 New Scan。"></a>步骤 4. 保存策略后，我们都准备在此策略下 New Scan。</h3><p>现在选择左上角文件夹部分下的 My Scans 标签 ，然后点击 New Scan 按钮。请参阅下图以供参考。</p>
<p><img src="https://img-blog.csdnimg.cn/62d939d016a54bb7950843b1ae330df3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="步骤-5-在新页面上，转到-User-Defined-选项卡并选择我们创建的自定义策略-Policy1-code404-。"><a href="#步骤-5-在新页面上，转到-User-Defined-选项卡并选择我们创建的自定义策略-Policy1-code404-。" class="headerlink" title="步骤 5. 在新页面上，转到 User Defined 选项卡并选择我们创建的自定义策略 (Policy1_code404)。"></a>步骤 5. 在新页面上，转到 User Defined 选项卡并选择我们创建的自定义策略 (Policy1_code404)。</h3><p><img src="https://img-blog.csdnimg.cn/69fb0e351d5947459454e572256bbb81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="步骤-6-新扫描的名称与我们的自定义策略的名称相同"><a href="#步骤-6-新扫描的名称与我们的自定义策略的名称相同" class="headerlink" title="步骤 6. 新扫描的名称与我们的自定义策略的名称相同"></a>步骤 6. 新扫描的名称与我们的自定义策略的名称相同</h3><hr>
<p>如下所示：<br><img src="https://img-blog.csdnimg.cn/e4f1110d3b134a8aa5e084cf0970ca74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们将此名称更改为 My Scan1 以避免任何混淆。您还可以为此扫描提供可选的描述，我们将其留空。在与标签 Targets 相对应的文本字段中，输入要扫描的目标系统的主机名或 IP 地址。保存文件以继续。<br><img src="https://img-blog.csdnimg.cn/57a62af6bfd14d56a07b190e7a49d343.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="步骤-7-现在所有配置都已完成。"><a href="#步骤-7-现在所有配置都已完成。" class="headerlink" title="步骤 7. 现在所有配置都已完成。"></a>步骤 7. 现在所有配置都已完成。</h3><hr>
<p>我们现在只需要启动扫描以查看它是否正常工作。在新窗口中，您会看到一个播放按钮，点击它开始扫描。<br><img src="https://img-blog.csdnimg.cn/67c1dc456b9441e4949c52b2ce851c6b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>播放图标将变为两个圆形旋转箭头，表示扫描正在运行，扫描完成需要一些时间。<br><img src="https://img-blog.csdnimg.cn/03f713c835ac4268bc9a2f5b69e49c60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>旋转箭头现在更改为复选标记符号，这意味着我们的扫描过程成功。<br><img src="https://img-blog.csdnimg.cn/ac762e39a8b847f9a8fab8b77e2d0c38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们现在可以检查目标系统的扫描报告，单击扫描名称 My Scan1。<br><img src="https://img-blog.csdnimg.cn/8816a67a5db44c0ea27a0a9d40f8b945.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>在新窗口中，单击“漏洞”选项卡以查看报告摘要。我们还可以将这些扫描导出为 Nessus 文件或 Nessus DB 文件格式，并且可以生成 HTML、CSV 或 PDF 格式的扫描报告。</p>
<p><img src="https://img-blog.csdnimg.cn/088933df6d104729977815d3c2b5c12a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>我们现在已经完成了今天的 Nessus 扫描工具指南，我们已经了解了如何创建策略并使用它来扫描目标系统，要解释 Nessus 报告，需要深入了解该工具以及更好地理解网络安全概念，Tenable 还提供按需培训以有效使用其产品。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>漏洞扫描</tag>
        <tag>端口扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>安装fastdfs-nginx-module /usr/bin/ld: cannot find -lfdfsclient collect2: error: ld returned 1 exit status</title>
    <url>/2021/12/01/%E5%AE%89%E8%A3%85fastdfs-nginx-module-usr-bin-ld-cannot-find-lfdfsclient-collect2-error-ld-returned-1-exit-status/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-16.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>nginx编译安装fastdfs-nginx-module时报错</p>
<p>objs&#x2F;ngx_modules.o \<br>-ldl -lpthread -lcrypt -lfastcommon -lfdfsclient -lpcre -lcrypto -lcrypto -lz \<br>-Wl,-E<br>&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lfdfsclient<br>collect2: error: ld returned 1 exit status<br>make[1]: *** [objs&#x2F;nginx] Error 1<br>make[1]: Leaving directory `&#x2F;data&#x2F;soft&#x2F;nginx-1.9.11’`<br>make: *** [build] Error 2</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><hr>
<p>由于安装fastdfs时改变了安装目录，导致fastdfs-nginx-module不能找到fdfsclient的库文件</p>
<h3 id="解决方法-把xx-so文件复制到-x2F-usr-x2F-lib"><a href="#解决方法-把xx-so文件复制到-x2F-usr-x2F-lib" class="headerlink" title="解决方法 把xx.so文件复制到&#x2F;usr&#x2F;lib"></a>解决方法 把xx.so文件复制到&#x2F;usr&#x2F;lib</h3><hr>
<p>本次报错只需要把libfdfsclient.so的软链接做好就行了</p>
<p>ln -sv &#x2F;data&#x2F;fastdfs&#x2F;usr&#x2F;lib&#x2F;libfdfsclient.so &#x2F;usr&#x2F;lib&#x2F;</p>
<h3 id="Linux系统中提示-x2F-usr-x2F-bin-x2F-ld-cannot-find-lxxx错误的通用解决"><a href="#Linux系统中提示-x2F-usr-x2F-bin-x2F-ld-cannot-find-lxxx错误的通用解决" class="headerlink" title="Linux系统中提示&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lxxx错误的通用解决"></a>Linux系统中提示&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lxxx错误的通用解决</h3><hr>
<ol>
<li>先判断在&#x2F;usr&#x2F;lib下的相对应的函式库文件(.so)的symbolic link是否正确，若不正确改成正确的连结目标即可解决问题。</li>
<li>若不是symbolic link的问题引起，而是系统缺少相对应的lib安装lib即可解决。</li>
<li>如何安装缺少的lib：</li>
</ol>
<p>以上面三个错误讯息为例：</p>
<ul>
<li>复制代码代码如下:</li>
<li>错误1缺少libc的LIB</li>
<li>错误2缺少libltdl的LIB</li>
<li>错误3缺少libXtst的LIB</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
        <category>Fastdfs</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>fastdfs-nginx-module</tag>
        <tag>cannot find -lfdfsclient</tag>
      </tags>
  </entry>
  <entry>
    <title>容器启动报错: Permission denied_nfs permission denied</title>
    <url>/2021/08/25/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99-permission-denied-nfs-permission-denied/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-22.png"></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><hr>
<p>我们在 Kubernetes 中挂载 volume 后，有时会遇到容器启动报错 Permission denied，然后 Crash 并重启，一般是文件系统权限问题，本文介绍如何解决。</p>
<h3 id="修改-NFS-目录权限"><a href="#修改-NFS-目录权限" class="headerlink" title="修改 NFS 目录权限"></a>修改 NFS 目录权限</h3><hr>
<p>如果挂载的 volume 存储是 nfs ，在不改动 Kubernetes 部署的情况下，我们可以将挂载的 nfs 目录权限修改成应用启动时使用的 uid 和 gid:</p>
<p>sudo mount -t nfs -o vers&#x3D;4.0,noresvport 10.10.0.15:&#x2F; &#x2F;localfolder # 挂载 nfs 根目录到本地目录 (如&#x2F;localfolder)<br>sudo chown -R 1001:1001 &#x2F;localfolder&#x2F;mariadb # 修改挂载 volume 中使用的目录权限为指定的 uid:gid</p>
<h3 id="使用-initContainers-修改目录权限"><a href="#使用-initContainers-修改目录权限" class="headerlink" title="使用 initContainers 修改目录权限"></a>使用 initContainers 修改目录权限</h3><hr>
<p>为 Pod 加入 initContainers 来执行 chown 修改容器内挂载点目录的权限:</p>
<p>  initContainers:</p>
<ul>
<li>name: chown<br> image: debian:stable-slim<br> command:<ul>
<li>&#x2F;bin&#x2F;sh</li>
<li>-c </li>
<li>“chown -R 1001:1001 &#x2F;data&#x2F;mnt”</li>
</ul>
</li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><hr>
<p>部署Grafana时存储位置选择 nfs</p>
<p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: grafana<br>  namespace: monitor<br>spec:<br>  selector:<br>    matchLabels:<br>      app: grafana<br>  replicas: 1 # tells deployment to run 2 pods matching the template<br>  template:<br>    metadata:<br>      labels:<br>        app: grafana<br>    spec:<br>      containers:<br>      - name: grafana<br>        #image: grafana&#x2F;grafana<br>        image: hub-mirror.c.163.com&#x2F;grafana&#x2F;grafana<br>        volumeMounts:<br>        - mountPath: &#x2F;var&#x2F;lib&#x2F;grafana<br>          name: data-nfs-app-1<br>        ports:<br>        - containerPort: 8080<br>      volumes:<br>      - name: data-nfs-app-1<br>        nfs:<br>          path: &#x2F;home&#x2F;k8s-data&#x2F;grafana<br>          server: 172.25.42.242<br>          readOnly: false</p>
<p>说明<br>把172.25.42.242:&#x2F;home&#x2F;k8s-data&#x2F;grafana 挂载到容器内<br>需要把172.25.42.242上面nfs-server的目录权限改为和容器内目录一致的</p>
<p>chown -R 472:root &#x2F;home&#x2F;k8s-data&#x2F;grafana</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>nfs</tag>
        <tag>Permission denied</tag>
        <tag>挂载</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网yum仓库搭建基于apache httpd</title>
    <url>/2021/04/03/%E5%B1%80%E5%9F%9F%E7%BD%91yum%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Eapache-httpd/</url>
    <content><![CDATA[<blockquote>
<p>接上文书 <a href="https://www.code404.icu/151.html">本地yun源搭建</a> 介绍了如何在内网或者本机搭建yum源。</p>
</blockquote>
<p><strong>当我们服务器处理内网不能连接互联网，总不能每台服务器都安装yum源吧，所以在本地yum源服务器上开放内网访问，为内网提供yum源服务</strong></p>
<h3 id="第一步、安装httpd"><a href="#第一步、安装httpd" class="headerlink" title="第一步、安装httpd"></a>第一步、安装httpd</h3><p><strong><em>无法安装httpd服务的请 <a href="https://www.code404.icu/151.html">先安装本地yum源</a></em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum install httpd</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 httpd.x86_64.0.2.4.6-95.el7.centos 将被 安装</span><br><span class="line">--&gt; 正在处理依赖关系 httpd-tools = 2.4.6-95.el7.centos，它被软件包 httpd-2.4.6-95.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 /etc/mime.types，它被软件包 httpd-2.4.6-95.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 libaprutil-1.so.0()(64bit)，它被软件包 httpd-2.4.6-95.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 libapr-1.so.0()(64bit)，它被软件包 httpd-2.4.6-95.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 apr.x86_64.0.1.4.8-7.el7 将被 安装</span><br><span class="line">---&gt; 软件包 apr-util.x86_64.0.1.5.2-6.el7 将被 安装</span><br><span class="line">---&gt; 软件包 httpd-tools.x86_64.0.2.4.6-95.el7.centos 将被 安装</span><br><span class="line">---&gt; 软件包 mailcap.noarch.0.2.1.41-2.el7 将被 安装</span><br><span class="line">--&gt; 解决依赖关系完成</span><br><span class="line"></span><br><span class="line">依赖关系解决</span><br><span class="line"></span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line"> Package                                       架构                                     版本                                                     源                                       大小</span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> httpd                                         x86_64                                   2.4.6-95.el7.centos                                      local                                   2.7 M</span><br><span class="line">为依赖而安装:</span><br><span class="line"> apr                                           x86_64                                   1.4.8-7.el7                                              local                                   104 k</span><br><span class="line"> apr-util                                      x86_64                                   1.5.2-6.el7                                              local                                    92 k</span><br><span class="line"> httpd-tools                                   x86_64                                   2.4.6-95.el7.centos                                      local                                    93 k</span><br><span class="line"> mailcap                                       noarch                                   2.1.41-2.el7                                             local                                    31 k</span><br><span class="line"></span><br><span class="line">事务概要</span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line">安装  1 软件包 (+4 依赖软件包)</span><br><span class="line"></span><br><span class="line">总下载量：3.0 M</span><br><span class="line">安装大小：10 M</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">总计                                                                                                                                                            69 MB/s  3.0 MB  00:00:00     </span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  正在安装    : apr-1.4.8-7.el7.x86_64                                                                                                                                                     1/5 </span><br><span class="line">  正在安装    : apr-util-1.5.2-6.el7.x86_64                                                                                                                                                2/5 </span><br><span class="line">  正在安装    : httpd-tools-2.4.6-95.el7.centos.x86_64                                                                                                                                     3/5 </span><br><span class="line">  正在安装    : mailcap-2.1.41-2.el7.noarch                                                                                                                                                4/5 </span><br><span class="line">  正在安装    : httpd-2.4.6-95.el7.centos.x86_64                                                                                                                                           5/5 </span><br><span class="line">  验证中      : httpd-tools-2.4.6-95.el7.centos.x86_64                                                                                                                                     1/5 </span><br><span class="line">  验证中      : mailcap-2.1.41-2.el7.noarch                                                                                                                                                2/5 </span><br><span class="line">  验证中      : apr-1.4.8-7.el7.x86_64                                                                                                                                                     3/5 </span><br><span class="line">  验证中      : httpd-2.4.6-95.el7.centos.x86_64                                                                                                                                           4/5 </span><br><span class="line">  验证中      : apr-util-1.5.2-6.el7.x86_64                                                                                                                                                5/5 </span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  httpd.x86_64 0:2.4.6-95.el7.centos                                                                                                                                                           </span><br><span class="line"></span><br><span class="line">作为依赖被安装:</span><br><span class="line">  apr.x86_64 0:1.4.8-7.el7                 apr-util.x86_64 0:1.5.2-6.el7                 httpd-tools.x86_64 0:2.4.6-95.el7.centos                 mailcap.noarch 0:2.1.41-2.el7                </span><br><span class="line"></span><br><span class="line">完毕！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第二步、修改httpd配置"><a href="#第二步、修改httpd配置" class="headerlink" title="第二步、修改httpd配置"></a>第二步、修改httpd配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">DocumentRoot &quot;/var/www/html&quot;</span><br><span class="line">#这个参数修改为</span><br><span class="line">DocumentRoot &quot;/yumrepo&quot;</span><br><span class="line"></span><br><span class="line">#添加下面内容（权限）如果没有下面配置服务会报403</span><br><span class="line">&lt;Directory &quot;/yumrepo&quot;&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Listen 80 #监听端口如有冲突，自行修改 8080、8090都可以</span><br></pre></td></tr></table></figure>

<h3 id="启动httpd服务"><a href="#启动httpd服务" class="headerlink" title="启动httpd服务"></a>启动httpd服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# systemctl start httpd</span><br><span class="line">[root@localhost yum.repos.d]# systemctl enable httpd  #加入开机启动httpd服务</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.</span><br><span class="line">[root@localhost yum.repos.d]# </span><br></pre></td></tr></table></figure>

<h3 id="第三步、在客户机-192-168-93-132-配置yum仓库配置文件"><a href="#第三步、在客户机-192-168-93-132-配置yum仓库配置文件" class="headerlink" title="第三步、在客户机 [192.168.93.132] 配置yum仓库配置文件"></a>第三步、在客户机 [192.168.93.132] 配置yum仓库配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd /etc/yum.repos.d/</span><br><span class="line">[root@localhost yum.repos.d]# vim httpdyum.repo</span><br><span class="line">[httpdyum]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">baseurl=http://192.168.93.131:8080</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>

<h3 id="第四步、验证客户机-192-168-93-132-安装zip-unzip"><a href="#第四步、验证客户机-192-168-93-132-安装zip-unzip" class="headerlink" title="第四步、验证客户机 [192.168.93.132] 安装zip unzip"></a>第四步、验证客户机 [192.168.93.132] 安装zip unzip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum install zip unzip </span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">软件包 unzip-6.0-21.el7.x86_64 已安装并且是最新版本</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 zip.x86_64.0.3.0-11.el7 将被 安装</span><br><span class="line">--&gt; 解决依赖关系完成</span><br><span class="line"></span><br><span class="line">依赖关系解决</span><br><span class="line"></span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line"> Package                                   架构                                         版本                                              源                                              大小</span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> zip                                       x86_64                                       3.0-11.el7                                        httpdyum                                       260 k</span><br><span class="line"></span><br><span class="line">事务概要</span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line">安装  1 软件包</span><br><span class="line"></span><br><span class="line">总下载量：260 k</span><br><span class="line">安装大小：796 k</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">zip-3.0-11.el7.x86_64.rpm                                                                                                                                                260 kB  00:00:00     </span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  正在安装    : zip-3.0-11.el7.x86_64                                                                                                                                                      1/1 </span><br><span class="line">  验证中      : zip-3.0-11.el7.x86_64                                                                                                                                                      1/1 </span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  zip.x86_64 0:3.0-11.el7                                                                                                                                                                      </span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把客户机 httpdyum.repo copy到所有内网服务器的&#x2F;etc&#x2F;yum.repo.d&#x2F;下面，就可以直接使用yum仓库了</p>
</blockquote>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>yum源</tag>
        <tag>apache</tag>
        <tag>httpd</tag>
        <tag>本地yum仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序渗透测试技巧-小程序抓包-Charles</title>
    <url>/2021/07/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%93%E5%8C%85-charles/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-63.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>抓取数据包是小程序安全测试中最关键的一步。抓包的方式有多种，比如使用Android内核版本7.0以下的模拟器，通过XPosed+JustTrustMe抓包；使用微信版本7.0以下通过Burp CA抓包。</p>
<p>这里分享一个比较简单的方法，使用Charles进行小程序抓包。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><hr>
<p>本机电脑开启Wifi共享，将自己手机和电脑连上同一个wifi。</p>
<h3 id="Charles设置"><a href="#Charles设置" class="headerlink" title="Charles设置"></a>Charles设置</h3><hr>
<p>下载地址：</p>
<p><a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a></p>
<h3 id="第一步：配置HTTP代理"><a href="#第一步：配置HTTP代理" class="headerlink" title="第一步：配置HTTP代理"></a>第一步：配置HTTP代理</h3><hr>
<p>设置代理：主界面—Proxy—Proxy Settings</p>
<p>选择在8888端口上监听，然后确定。勾选了SOCKS proxy，还能截获到浏览器的http访问请求。<br><img src="https://img-blog.csdnimg.cn/2021072016473283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="第二步：配置SSL代理"><a href="#第二步：配置SSL代理" class="headerlink" title="第二步：配置SSL代理"></a>第二步：配置SSL代理</h3><hr>
<p>首先在charles的 Proxy选项选择SSL Proxy Settings<br><img src="https://img-blog.csdnimg.cn/20210720164846337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="第三步：为手机设置代理"><a href="#第三步：为手机设置代理" class="headerlink" title="第三步：为手机设置代理"></a>第三步：为手机设置代理</h3><hr>
<p>在手机接入电脑wifi，配置手动代理，输入安装Charles的电脑的网络地址，端口填8888。以IOS为例，在Safri上打开Charles的根证书下载网址： chls.pro&#x2F;ssl ，点击允许，开始下载。</p>
<p><img src="https://img-blog.csdnimg.cn/20210720164937731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="第四步：SSL-代理设置"><a href="#第四步：SSL-代理设置" class="headerlink" title="第四步：SSL 代理设置"></a>第四步：SSL 代理设置</h3><hr>
<p>在Proxy-SSL Proxying Settings，添加域名</p>
<p><img src="https://img-blog.csdnimg.cn/20210720165021191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>到这里完成设置，通过手机访问就可以看到获取到小程序的数据包。</p>
<p>基于小程序的数据包，我们可以看到前后端业务交互的过程，重点关注业务逻辑漏洞、API 接口可能存在的安全漏洞。</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>小程序抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序渗透测试技巧-小程序解包-反编译</title>
    <url>/2021/07/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-62.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>随着小程序数量的爆发式增长，其特有的安全风险也逐步凸显出来。本文基于微信小程序测试过程中的解包及抓包的技巧，总结下微信小程序安全测试的思路。</p>
<h3 id="安装手机模拟器，比如说夜神、MuMu"><a href="#安装手机模拟器，比如说夜神、MuMu" class="headerlink" title="安装手机模拟器，比如说夜神、MuMu"></a>安装手机模拟器，比如说夜神、MuMu</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/20210720153817836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="下载和安装两个应用，微信和RE文件管理器"><a href="#下载和安装两个应用，微信和RE文件管理器" class="headerlink" title="下载和安装两个应用，微信和RE文件管理器"></a>下载和安装两个应用，微信和RE文件管理器</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/20210720153955854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="获取root权限"><a href="#获取root权限" class="headerlink" title="获取root权限"></a>获取root权限</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/20210720154202317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="打开微信，搜索相对应的小程序，然后再打开RE文件管理器，定位到目录"><a href="#打开微信，搜索相对应的小程序，然后再打开RE文件管理器，定位到目录" class="headerlink" title="打开微信，搜索相对应的小程序，然后再打开RE文件管理器，定位到目录"></a>打开微信，搜索相对应的小程序，然后再打开RE文件管理器，定位到目录</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/20210720154310357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="下载微信小程序反编译脚本，解包"><a href="#下载微信小程序反编译脚本，解包" class="headerlink" title="下载微信小程序反编译脚本，解包"></a>下载微信小程序反编译脚本，解包</h3><hr>
<p><a href="https://github.com/xuedingmiaojun/wxappUnpacker.git">https://github.com/xuedingmiaojun/wxappUnpacker.git</a></p>
<p>解主包：</p>
<p>.&#x2F;bingo.sh 主包.wxapkg</p>
<p><img src="https://img-blog.csdnimg.cn/20210720154819274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解分包:</p>
<p>.&#x2F;bingo.sh 分包.wxapkg -s&#x3D;主包目录</p>
<p><img src="https://img-blog.csdnimg.cn/20210720155827652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>合并分包内容，成功获取小程序前端源码。</p>
<p>基于小程序的前端源码，我们可以从JS敏感信息泄露、隐藏接口漏洞等方向进行漏洞挖掘。</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么样 在 Linux 命令行中生成密码</title>
    <url>/2021/07/16/%E6%80%8E%E4%B9%88%E6%A0%B7-%E5%9C%A8-linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%94%9F%E6%88%90%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-43-1024x573.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>大多数网站或应用都要求用户创建带有安全密码的账户，以便他们能够迎合用户体验。虽然这有利于网站开发者，但肯定不会让用户的生活更轻松。</p>
<p>有时，创建密码的规则是如此严格，以至于难以生成一个强壮且合规的组合。如果有一个工具可以生成符合网站或应用程序要求的任何规则的安全密码，那就容易多了。</p>
<p>这就是 pwgen 的用武之地。根据它的 手册页：“pwgen 生成的密码是为了让人容易记住，同时又尽可能的安全。” 它返回符合你所提供的规则的多个密码选项，这样你就可以选择一个你喜欢的（而且可能更容易记住）。</p>
<h3 id="安装-pwgen"><a href="#安装-pwgen" class="headerlink" title="安装 pwgen"></a>安装 pwgen</h3><hr>
<p>在 Linux 上，你可以通过包管理器安装 pwgen。例如，在 Fedora 上：</p>
<p>$ sudo dnf install pwgen</p>
<p>在 macOS 上，可以使用 MacPorts 或 Homebrew。在 Windows 上，可以使用 Chocolatey。</p>
<h3 id="使用-pwgen-生成密码"><a href="#使用-pwgen-生成密码" class="headerlink" title="使用 pwgen 生成密码"></a>使用 pwgen 生成密码</h3><hr>
<p>有几种方式可以通过向 pwgen 传递参数来生成密码，这取决于你所需的参数。这里有一些例子。更多的参数选项请查阅手册页。</p>
<p>如果你需要一个安全的、难以记忆的特定长度的密码，请运行 pwgen –secure（或简写 -s），后面跟上你所需的密码长度：</p>
<p>$ pwgen -s 25<br>pnFBg9jB8AlKL3feOuS2ZwMGb xlmDRoaLssduXTdGV6jkQhUGY O3IUB3CH7ry2kD4ZrSoODzWez<br>dENuvhkF3mmeb4FfXd4VPU2dE EMCi1sHFKHUVmbVajXWleFBzD 4UXJIu3JztVzYz6qJktBB3KCv<br>AF9WM7hmG89cpTlg8PksI7jsL LSSaT7DD4IT8DUgRAgY8Zt06m Nths10uT0bIMGsPuE0XEHDxsj<br>6YjLRbg3VnGnrzkoQCmrneLmm Tam1Mftac5RxrZPoXJtXx1Qdy BPqePJW4LdTtFnuZOepKEj0o0<br>Ss8veqqf95zusqYPsfE7mLb93 4KuZdReO5lhKff7Xv1en1Hefs is7hjLnDrVCUJ7Hh6zYUzfppn<br>UXOfENPRJYWiroIWEt5IgAwdJ t8i4hM4cDuL8pN1rpFKHnx7yw Wr7gyuyU2br7aCbiH5M5ogvc6<br>evk90lUmK2rOUWGgnqmznn0a9 Lflyc9svJfaBRRMin24j0P9ec hIzyJIwCpklDjgOb5PrMkyPCI<br>bhYcaV7GXfUiCMZ1kvMnlmKLx v4EJew54u6s4ZCirOTAWjfPQ2 IdemhbOHOm4Qo70WGibaNTOpO<br>j6XkmdB3LBfqZf5mbL3GndliG PpZbeXfWOFCpNARyXt1FWPAb8 OLQS2HFuqkiSg56sdxNsg5vaJ<br>1g666HxJPQ6l2L0RlaDEMoi50 1t6au7VuTN9HVPpiVmd1Gurli 46OAWypvwtZZUdBEfaHSunjpw<br>0LiRj9dbtMuI4cbDES8O4gYRq 2HPiaq5AANvVT32fWqNIruu3R 3lT5B107WoUbHsELkKUjnEEih<br>gLmYUTp0XZJWvIVbA5rFvBT54 LEm6QVeTMinc056DC9c4V55cV ipV45Ewj704365byKhY8zn766</p>
<h3 id="运行-pwgen-symbols（或简写-y），再加上所需的密码长度，生成包含特殊字符的密码"><a href="#运行-pwgen-symbols（或简写-y），再加上所需的密码长度，生成包含特殊字符的密码" class="headerlink" title="运行 pwgen -symbols（或简写 -y），再加上所需的密码长度，生成包含特殊字符的密码"></a>运行 pwgen -symbols（或简写 -y），再加上所需的密码长度，生成包含特殊字符的密码</h3><hr>
<p>$ pwgen -y 25<br>Osh0chahxe0won9aech4ese?v pemoh2ohm9aim;iu4Eiy”ah0y Taiqu;o2aeSh+o4aedoagait3<br>Vei;phoh5owai5jui+tei3ot teu!w7mahxoh0Po7ohph8Iez6 quie#phooCeu2lohm5shaPaer<br>eTh5AechaexieToh9ez5eeZ;e nuloh1ico0Nool:eG&lt;aiv`ah, Heeghuo8ahzii1Iep<del>ie_ch7p<br>oe6Xee6uchei7Oroothail</del>iL ahjie!Chee.W4wah[wuu]phoo ees7ieb!i[ibahhei1xoz2Woh<br>Atei9ooLu7lo<del>sh&gt;aig@ae9No OVahh2OhNgahtu8iethaR@i7o ouFai8ahP@eil4Ieh5le5ipu5<br>eeT4tahW0ieng9fe?i5auM3ie seet0ohc4aiJei]koiGha2zu% iuh@oh4eix0Vuphi?o,hei9me<br>loh0Aeph&#x3D;eix(ohghe6chee3z ahgh2eifiew8dahG_aeph8woo oe!B4iasaeHo`ungie3taekoh<br>cei!c&lt;ung&amp;u,shee6eir7Eigo va6phou8ooYuoquohghi-n6Qu eeph4ni\chi2shohg3Die1hia<br>uCagha8Toos2bahLai7phuph` Zue2thieng9ohhoo</del>shoh6ese Aet7Lio1ailee^qu4hiech5ie<br>dee]kuwu9OhTh3shoi2eijoGe daethahH6ahV3eekoo9aep$an aehiiMaquieHee9moh`l_oh4l<br>aec#ii6Chophu3aigh*ai#le4 looleihoog:uo4Su”thiediec eeTh{o7Eechah7eeJ2uCeish!<br>oi3jaiphoof$aiy;ieriexeiP Thozool3aipicahfu0Ha~e1e az&#x2F;u8iel2Jaeph2vooshai9Wi</p>
<h3 id="运行-pwgen-–capitalize（或缩写-c），后面跟上密码长度，生成包含大写字母的密码"><a href="#运行-pwgen-–capitalize（或缩写-c），后面跟上密码长度，生成包含大写字母的密码" class="headerlink" title="运行 pwgen –capitalize（或缩写 -c），后面跟上密码长度，生成包含大写字母的密码"></a>运行 pwgen –capitalize（或缩写 -c），后面跟上密码长度，生成包含大写字母的密码</h3><hr>
<p>$ pwgen -c 25<br>pheipichusheta6ieJ4xai4ai seiLeiciev7ijoy5Uez7Iepee Foobeisheec7ooGahbicholo6<br>shenahsheevigh3pha1Ie5aev taiTheitahne3oong4joegh9d ooshieV0ooGhaelabuyahsh7t<br>ieniech0Uajeh8nieYaak0foh dohm5Pee3jeeshahm1eipei0a aemoob8Lequeesho8ahreiwee<br>keineeCh5ieZejafitith6Osh Tahn3nohl6iewaimee6oofied Aed2Woh7nae5ohgh2toh1ieph<br>le4agheeb0bieth0Ui7ielais Iunoo4lev1aiG4NohfoTh3ro5 iLai7eiQuohXosh8ooyiev6wu<br>eezib2zoh2ohsh0cooSahluK6 baekiew8bo5oeMouthi7taCee iep6Puungae0uushogah4rohw<br>chohm5leogae2zeiph1OL0uK2 oosieCaishievahvig3Iaphai ii9AemieYeepe1ahciSei8ees<br>ie3aighaiy9TaX6bae8soKe6t sooDaivi4mia8Eireech8ope9 moi9uk3bauv0ahY4to0aedie7<br>que8seHu4shu7Veib6noe7dai shuyuj9aiphoip2Ier4oole1u Thoaziebah1Ieph2Veec0Ohm8<br>auqua4Kaitie9sei6quoh7chi jeewaituH3Ohsaisahp0viequ ueh1quaibidoh6Bae6ri0Mee2<br>lae3aiJaiNgoh7yieghozev7o Di2vohfahr7uo7ohSh0voh5sh Jeurahxiedeiyoom3aechaS7d<br>thung2pheiy2tooBeenuN8ia3 foh0oge1athei0oowieZen0ai iexei0io1vohsieThuCoy5ogi<br>tohHe3uu2eXieheeQuoh7eit8 aiMieCeizeivu1ooch8aih0sh Riojei2yoah0AiWeiRoMieQu0</p>
<h3 id="让它变得简单"><a href="#让它变得简单" class="headerlink" title="让它变得简单"></a>让它变得简单</h3><hr>
<p>由于人脑更倾向于选择模式，所以强壮的随机密码难以生成。通过使用 pwgen，你可以轻松生成密码。借助于优秀的 开源密码管理器，你可以完全从易于使用但难以猜测的密码中获益。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>pwgen</tag>
        <tag>命令行</tag>
        <tag>密码生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么样使用Jmeter录制https协议脚本？</title>
    <url>/2021/10/02/%E6%80%8E%E4%B9%88%E6%A0%B7%E4%BD%BF%E7%94%A8jmeter%E5%BD%95%E5%88%B6https%E5%8D%8F%E8%AE%AE%E8%84%9A%E6%9C%AC%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-29.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>Jmeter通过浏览器录制https请求<br>Jmeter录制脚本时，跟http脚本录制主要区别是 https 录制需要添加安全证书。（如果谷歌浏览器还是录制不了时，可以先使用firefox浏览器）</p>
<h3 id="一、Jmeter代理服务器及证书配置"><a href="#一、Jmeter代理服务器及证书配置" class="headerlink" title="一、Jmeter代理服务器及证书配置"></a>一、Jmeter代理服务器及证书配置</h3><hr>
<p>1、打开Jmeter，右键测试计划添加线程组，右键测试计划-&gt;非测试元件-&gt;http代理服务器。<br><img src="https://img-blog.csdnimg.cn/3437e0a6856f4aeda7e55cdd28802679.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2、设置 HTTP 代理服务器 HTTP 代理服务器的默认端口是 8888，如果与本地 Fiddler、IDEA 等其它工具冲突，可以手动修改为其它不冲突端口。<br>目标控制器选择，意思是录制时捕获的请求放在哪个分组下，可以选择之前新增好的线程组或者 controller。<br><img src="https://img-blog.csdnimg.cn/b5c5d624156e4d1aac986d672de7c5d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>排除模式添加 ._.(jscssPNGjpgpnggif)._，过滤掉 js、css、png、jpg 等信息，这样录制后的脚本不会包含 jpg 等前端资源。<br><img src="https://img-blog.csdnimg.cn/91260a908e674a53b97436b326ed6ad8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3、启动代理服务器，会在 Jmeter 的 bin 目录下生成一个安全证书文件：ApacheJmeterTemporaryRootCA.crt<br><img src="https://img-blog.csdnimg.cn/a316ebe6fe9d4e65a783f70d3d1b5da9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点击完 OK 后，界面上会多一个 Recorder 的小框，可停止录制。其中 HTTP Sampler settings 的两个选项：</p>
<ul>
<li>Prefix 是指在请求显示的名称前加前缀，更好的标识请求的功能</li>
<li>Transaction name 是会新增一个 transaction controller，把设置之后录制到的脚本都放在 controller 中，可达到分组的效果。<br><img src="https://img-blog.csdnimg.cn/66574adaa19741e982c1e71a1b9a788f.png" alt="在这里插入图片描述"><br>4、导入 Jmeter 安全证书，在菜单选项 → ssl 管理器，导入 Jmeter&#x2F;bin 目录下的安全证书文件 ApacheJmeterTemporaryRootCA.crt，这样录制 HTTPS 的代理服务器就启动并设置成功了（只需要导入一次即可，不需要每次录制前都设置）<br><img src="https://img-blog.csdnimg.cn/8f6c920ae54d4572862c84f780ac0639.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/eaf0f5ff8e1d42a9a059d96a77863b15.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ul>
<h3 id="二、浏览器的代理服务器及证书配置"><a href="#二、浏览器的代理服务器及证书配置" class="headerlink" title="二、浏览器的代理服务器及证书配置"></a>二、浏览器的代理服务器及证书配置</h3><hr>
<p>1、以火狐浏览器为例，在浏览器的菜单中点击选项，找到隐私与安全，证书管理器→ 查看证书→ 切换到证书颁发机构页签→ 导入 Jmeter 中 bin 目录下的安全证书→确定。<img src="https://img-blog.csdnimg.cn/5c0234f3c95d4effa48c95aa1f89aadf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2、浏览器设置好代理配置，在菜单中找到常规→ 代理设置，选择手动代理配置，代理地址填写127.0.0.1或者localhost，端口8888（与Jmeter代理服务设置端口一致）；且勾选为所有协议使用相同代理服务器，点击确定。<br><img src="https://img-blog.csdnimg.cn/ccbd66fd4e9246af8b5c7030eb76f617.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3、在浏览器中输入要录制脚本的网址进行相关操作，就能在 Jmeter 中看到录制的 HTTPs 脚本了。<br>注意：Jmeter 录制完脚本后，记得停止 Jmeter 代理服务器，同时记得关闭浏览器代理配置，不然浏览器不能正常访问网站了<br>Jmeter 点击这两个停止按钮都可以。<br><img src="https://img-blog.csdnimg.cn/e329ef605a4f4255b0b8ffc116bf60de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>浏览器，勾选不使用代理服务器。<br><img src="https://img-blog.csdnimg.cn/8af1fbcc4c534131bc7ee4f18114996f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Jmeter</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>jmeter</tag>
        <tag>代理服务器</tag>
        <tag>证书配置</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么样搭建私人网盘_私人网盘_公司网盘_文件管理系统</title>
    <url>/2021/09/08/%E6%80%8E%E4%B9%88%E6%A0%B7%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E7%BD%91%E7%9B%98-%E7%A7%81%E4%BA%BA%E7%BD%91%E7%9B%98-%E5%85%AC%E5%8F%B8%E7%BD%91%E7%9B%98-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/09/image-6-1024x614.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>filebrowser 提供指定目录下的文件管理界面，可用于搭建私人网盘，在线管理各种文件资源，内置登录系统，可在线删除、编辑、创建文件，允许分配多个用户权限，在 Web 浏览器上执行自定义命令行。<br><img src="https://img-blog.csdnimg.cn/d691586f98f94161bc2388dd5beb2a50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="filebrowser-具有以下主要功能"><a href="#filebrowser-具有以下主要功能" class="headerlink" title="filebrowser 具有以下主要功能"></a>filebrowser 具有以下主要功能</h3><hr>
<ul>
<li>用户登录</li>
<li>简洁美观的管理界面</li>
<li>可以进行用户管理、权限管理<br><img src="https://img-blog.csdnimg.cn/c80058f041854f4891f88b4fa46b78c2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>在线编辑文件<br><img src="https://img-blog.csdnimg.cn/aa07f61a3129411f8096fa0deac76888.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
<li>执行自定义命令</li>
</ul>
<h3 id="项目地址是"><a href="#项目地址是" class="headerlink" title="项目地址是"></a>项目地址是</h3><hr>
<p><a href="https://github.com/filebrowser/filebrowser">https://github.com/filebrowser/filebrowser</a></p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><hr>
<p>filebrowser 是一个二进制文件，可以用作独立的可执行文件，但它也可以与 Docker 或 Caddy 一起使用，默认情况下会启用 HTTPS，安装非常简单。安装后登陆使用的默认账号密码是 admin&#x2F;admin。</p>
<h4 id="Mac-下安装"><a href="#Mac-下安装" class="headerlink" title="Mac 下安装"></a>Mac 下安装</h4><p>brew tap filebrowser&#x2F;tap<br>brew install filebrowser<br>filebrowser -r &#x2F;path&#x2F;to&#x2F;your&#x2F;files</p>
<h4 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h4><p>curl -fsSL <a href="https://raw.githubusercontent.com/filebrowser/get/master/get.sh">https://raw.githubusercontent.com/filebrowser/get/master/get.sh</a>  bash<br>filebrowser -r &#x2F;path&#x2F;to&#x2F;your&#x2F;files</p>
<h4 id="Windows-下安装"><a href="#Windows-下安装" class="headerlink" title="Windows 下安装"></a>Windows 下安装</h4><p>iwr -useb <a href="https://raw.githubusercontent.com/filebrowser/get/master/get.ps1">https://raw.githubusercontent.com/filebrowser/get/master/get.ps1</a>  iex<br>filebrowser -r &#x2F;path&#x2F;to&#x2F;your&#x2F;files</p>
<h4 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h4><p>docker run \<br>    -v &#x2F;path&#x2F;to&#x2F;root:&#x2F;srv \<br>    -v &#x2F;path&#x2F;filebrowser.db:&#x2F;database.db \<br>    -v &#x2F;path&#x2F;.filebrowser.json:&#x2F;.filebrowser.json \<br>    –user $(id -u):$(id -g)<br>    -p 80:80 \<br>    filebrowser&#x2F;filebrowser</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
        <category>个人网盘</category>
      </categories>
      <tags>
        <tag>filebrowser</tag>
        <tag>公司网盘</tag>
        <tag>文件管理系统</tag>
        <tag>私人网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样低调用Google搜索，一个插件搞定，文未送插件</title>
    <url>/2021/07/02/%E6%80%8E%E6%A0%B7%E4%BD%8E%E8%B0%83%E7%94%A8google%E6%90%9C%E7%B4%A2%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E6%90%9E%E5%AE%9A%EF%BC%8C%E6%96%87%E6%9C%AA%E9%80%81%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-6.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>Google的Chrome浏览器真的特别好用，它没有360等浏览器的那些广告，很干净，没有那些乱七八糟的东西。虽然失去Google搜索以及Google的一些原生加持，但是Chrome还是非常强大！</p>
<p>最厉害的是—扩展程序。虽然Firefox&#x2F;360之类的浏览器也有扩展插件，但是Chrome+Chrome扩展程序，绝对非常的厉害！</p>
<p>但是你想访问chrome应用商店，视乎非常的慢，或者很多人进不去，就连谷歌的搜索我们也是无法访问！</p>
<p>很多就会问了国内的搜索不好吗？</p>
<p>非要用Google的，你用过就知道了，对比下国内的广告满天飞，你试下谷歌的搜索引擎！</p>
<p>今天就给大家安利一个可以插件，安装之后可以使用谷歌搜索」、「访问chrome应用商店」、「同步chrome浏览器书签」等。</p>
<h3 id="什么样的插件"><a href="#什么样的插件" class="headerlink" title="什么样的插件"></a>什么样的插件</h3><hr>
<p>Chrome同步助手</p>
<p>当然了要用这个插件需要安装谷歌浏览器哦，这个大家自行安装哈。</p>
<p>下载好插件之后，打开浏览器右上角的三点，更多工具，扩展程序，打开，把下载好的插件</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><hr>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-2.png"></p>
<h3 id="安装完成的效果"><a href="#安装完成的效果" class="headerlink" title="安装完成的效果"></a>安装完成的效果</h3><hr>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-3.png"></p>
<h3 id="访问谷歌搜索"><a href="#访问谷歌搜索" class="headerlink" title="访问谷歌搜索"></a>访问谷歌搜索</h3><hr>
<p>来搜索一个关键词 nessus安装教程</p>
<p>nessus安装教程，<a href="https://www.code404.icu/692.html">https://www.code404.icu/692.html</a> 我们的网站被检索到了</p>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-4.png"></p>
<h3 id="打开chrome网上应用商店"><a href="#打开chrome网上应用商店" class="headerlink" title="打开chrome网上应用商店"></a>打开chrome网上应用商店</h3><hr>
<p><img src="https://code404.icu/img/moveypu/2021/07/image-5-1024x550.png"></p>
<p>好的浏览器加上好的插件那就是无敌了，这个插件搜索的速度可以说非常快了。</p>
<p>喜欢用谷歌浏览器的这个应该是必备插件了</p>
<p>插件地址：<a href="https://www.code404.icu/programmer-box">https://www.code404.icu/programmer-box</a></p>
]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>chrome</tag>
        <tag>访问google</tag>
      </tags>
  </entry>
  <entry>
    <title>救援模式挂载lvm出错-mount unknown filesystem type &#39;lvm2_member&#39;解决</title>
    <url>/2021/06/23/%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F%E6%8C%82%E8%BD%BDlvm%E5%87%BA%E9%94%99-mount-unknown-filesystem-type-lvm2-member%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-58.png"></p>
<h2 id="centos-8-救援模式挂载lvm出错："><a href="#centos-8-救援模式挂载lvm出错：" class="headerlink" title="centos 8 救援模式挂载lvm出错："></a>centos 8 救援模式挂载lvm出错：</h2><p>入系统安装引导初始界面，然后选择最后一项Troubleshooting</p>
<p>然后选择第二项Rescue a CentOS system进入系统救援模式<br>选择Continue继续进行</p>
<p>进入到系统救援模式的命令行界面，这时你可以遇到一个问题，就是 linux 系统 无法挂载到 &#x2F;mnt&#x2F;sysroot&#x2F;上面</p>
<p>you don’t have any Linux partitions,<br>Press return to get a shell.<br>Thesystem will reboot automatically when you exit from the shell.</p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>从fdisk 信息不难看出，已经加密的 “*” ,肯定是我的引导分区，而我的真实&#x2F; 安装在&#x2F;dev&#x2F;sda2上的。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-52.png"></p>
<h2 id="挂载出错lvm2-member"><a href="#挂载出错lvm2-member" class="headerlink" title="挂载出错lvm2_member"></a>挂载出错lvm2_member</h2><p>mount unknown filesystem type ‘lvm2_member’</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-53.png"></p>
<h2 id="原因分析lvm2-member"><a href="#原因分析lvm2-member" class="headerlink" title="原因分析lvm2_member"></a>原因分析lvm2_member</h2><p>问题现象：由于重装linux，并且加了固态硬盘，直接将系统装在固态硬盘中。启动服务器的时候，</p>
<p>便看不到原来机械硬盘的挂载目录了，不知如何访问机械硬盘了。直接用命令 mount &#x2F;dev&#x2F;sda3 &#x2F;store 挂载，</p>
<p>提示 mount: unknown filesystem type ‘LVM2_member’</p>
<h2 id="查看物理卷、逻辑卷：pvs"><a href="#查看物理卷、逻辑卷：pvs" class="headerlink" title="查看物理卷、逻辑卷：pvs"></a>查看物理卷、逻辑卷：pvs</h2><p><img src="https://code404.icu/img/moveypu/2021/06/image-54.png"></p>
<h2 id="查看逻辑卷：lvdisplay"><a href="#查看逻辑卷：lvdisplay" class="headerlink" title="查看逻辑卷：lvdisplay"></a>查看逻辑卷：lvdisplay</h2><p><img src="https://code404.icu/img/moveypu/2021/06/image-55.png"></p>
<h2 id="如未激活，需要激活逻辑卷"><a href="#如未激活，需要激活逻辑卷" class="headerlink" title="如未激活，需要激活逻辑卷"></a>如未激活，需要激活逻辑卷</h2><p><img src="https://code404.icu/img/moveypu/2021/06/image-56.png"></p>
<p>备注：步骤3-5的命令有时报command not found，解决</p>
<p>bash-4.1#lvm</p>
<p>lvm &gt;</p>
<p>这样再执行如上命令</p>
<h2 id="挂载逻辑卷"><a href="#挂载逻辑卷" class="headerlink" title="挂载逻辑卷"></a>挂载逻辑卷</h2><p><img src="https://code404.icu/img/moveypu/2021/06/image-57.png"></p>
<p>这里，</p>
<p>在chroot之前 bash-4.1# 目录下的&#x2F; 是内存中的 &#x2F; ，也叫伪根；</p>
<p>chroot后 sh-4.1#目录下的&#x2F; 才是系统真实的&#x2F; ，也叫真根</p>
<h2 id="恢复系统"><a href="#恢复系统" class="headerlink" title="恢复系统"></a>恢复系统</h2><p>现在就可以把bash-4.1系统下的文件复制到 &#x2F;mnt&#x2F;sysimage&#x2F;下面来恢复系统文件了</p>
]]></content>
      <categories>
        <category>Centos8</category>
      </categories>
      <tags>
        <tag>救援模式</tag>
        <tag>centos8</tag>
        <tag>lvm_member</tag>
        <tag>Troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>既然有http 请求，为什么还要用rpc调用？</title>
    <url>/2021/05/05/%E6%97%A2%E7%84%B6%E6%9C%89http-%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8rpc%E8%B0%83%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image.png"></p>
<p>该提问也确实有点问题：HTTP和RPC不是对等的概念。  </p>
<p>RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等。  </p>
<p>而HTTP只是一个通信协议，工作在OSI的第七层，不是一个完整的远程调用方案。  </p>
<p>所以，要想回答这个问题，应该拉平为一个对等的概念。例如，HTTP+Restful规范+序列化与反序列化，构成一个完整的远程调用方案，再和RPC进行比较。而单纯的HTTP，只是一个通信协议，自然无法和RPC比较。  </p>
<p>这就像是牛（HTTP）不能和马车（RPC）比较。要想比较，就应该将牛补齐为牛车，然后和马车比较。  </p>
<p>感觉题主应该是问：基于HTTP的远程调用方案（包含了接口规范、序列化反序列化等） 和 使用RPC的远程调用方案 有什么不同。有了前者，为什么还要有后者。</p>
<p>首先：</p>
<p>http 和 rpc 并不是一个并行概念。</p>
<p>http是超文本传输协议，应用层网络协议。</p>
<p>rpc不是协议，是指remote procedure call 远程过程调用，对不同应用间相互调用的一种描述。其调用协议通常包含传输协议和编码协议；支持http和tcp；</p>
<p>其次：</p>
<p>rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。</p>
<p>例如rpc框架提供的负载均衡，服务治理，自动熔断&#x2F;降级，实现二进制传输等；</p>
<p>如果把一个http server容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。</p>
<p>总结：  </p>
<p>RPC是一种编程模式，把对服务器的调用抽象为过程调用，通常伴随着框架代码自动生成等功能。使用RPC做网络服务开发时，通常只需要实现服务器端的一个处理函数，其余的客户端调用，序列化反序列化，方法派发等都由框架或者生成的代码来完成，较大地减轻了网络服务开发和调用的复杂性。RPC框架更多的在内网中应用间调用使用，http 除了内网传输，更习惯用在跨网间，跨语言间调用。</p>
<p>我们先介绍基于HTTP的远程调用方案。  </p>
<p>HTTP+Restful，其优势很大。它可读性好，且可以得到防火墙的支持、跨语言的支持。而且，在近几年的报告中，Restful大有超过RPC的趋势。  </p>
<p>但是使用该方案也有其缺点，这是与其优点相对应的：  </p>
<p>首先是有用信息占比少，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。<br>其次是效率低，还是因为第七层的缘故，必须按照HTTP协议进行层层封装。<br>还有，其可读性似乎没有必要，因为我们可以引入网关增加可读性。<br>此外，使用HTTP协议调用远程方法比较复杂，要封装各种参数名和参数值。<br>而RPC则与HTTP互补，我们详细介绍下。  </p>
<p>看完这篇回答，能让你对RPC的产生、原理、实现代码都有着清晰的了解。这样，也能在业务系统中，在RPC和HTTP之间做好抉择。  </p>
<p>但需要再说一句，不是说RPC好，也不是说HTTP好，两者各有千秋，还在比拼中。  </p>
<p>要问我站谁？我根据业务场景，灵活站位……</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>普通用户安装管理Keepalived</title>
    <url>/2021/12/08/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86keepalived/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-4.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>负载均衡(Load Balance，简称LB)是一种服务或基于硬件设备等实现的高可用反向代理技术，负载均衡将特定的业务(web服务、网络流量等)分担给指定的一个或多个后端特定的服务器或设备，从而提高了公司业务的并发处理能力、保证了业务的高可用性、方便了业务后期的水平动态扩展。<br>我经过测试，完全使用普通用户是不能安装上的，keepalived的运行需要root。下面的回答中，普通用户用到了sudo,提升权限，所以并不是完全是普通用户。<br>这篇文件使用普通用户安装keepalived，通过root用户修改系统配置，让普通用户能使用：systemctl start keepalived和systemctl stop keepalived来管理。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr>
<p>下载地址：<a href="https://www.keepalived.org/software/keepalived-2.2.4.tar.gz">https://www.keepalived.org/software/keepalived-2.2.4.tar.gz</a></p>
<p>[code404@OIS-AS ~]$ tar -xvf keepalived-2.2.4.tar.gz<br>[code404@OIS-AS ~]$ cd keepalived-2.2.4<br>[code404@OIS-AS ~]$ .&#x2F;configure –prefix&#x3D;&#x2F;data&#x2F;keepalived<br>*** WARNING - this build will not support IPVS with IPv6. Please install libnl&#x2F;libnl-3 dev libraries to support IPv6 with IPVS.</p>
<p>报错：*** WARNING - this build will not support IPVS with IPv6. Please install libnl&#x2F;libnl-3 dev libraries to support IPv6 with IPVS.</p>
<p>切到root用户把libnl-devel 安装上，然后用root编译安装</p>
<p>[root@OIS-AS ~]# yum install libnl-devel<br>[root@OIS-AS ~]# cd keepalived-2.2.4<br>[root@OIS-AS ~]# .&#x2F;configure –prefix&#x3D;&#x2F;data&#x2F;keepalived<br>[root@OIS-AS ~]# make install</p>
<h3 id="授权给普通用户"><a href="#授权给普通用户" class="headerlink" title="授权给普通用户"></a>授权给普通用户</h3><p>安装目录&#x2F;data&#x2F;keepalived给普通用户code404授权</p>
<p>[root@OIS-AS ~]# chown -R code404.code404 &#x2F;data&#x2F;keepalived</p>
<p>systemctl 管理服务，给普通用户code404授权<br>编辑配置文件&#x2F;usr&#x2F;share&#x2F;polkit-1&#x2F;actions&#x2F;org.freedesktop.systemd1.policy</p>
<p>vim &#x2F;usr&#x2F;share&#x2F;polkit-1&#x2F;actions&#x2F;org.freedesktop.systemd1.policy<br>        <action id="org.freedesktop.systemd1.manage-units"><br>                <defaults><br>                        &lt;allow_any&gt;yes&lt;&#x2F;allow_any&gt;<br>                        &lt;allow_inactive&gt;yes&lt;&#x2F;allow_inactive&gt;<br>                        &lt;allow_active&gt;yes&lt;&#x2F;allow_active&gt;<br>                </defaults><br>        </action></p>
<pre><code>    &lt;action id=&quot;org.freedesktop.systemd1.manage-unit-files&quot;&gt; enable
            &lt;defaults&gt;
                    &lt;allow\_any&gt;yes&lt;/allow\_any&gt;
                    &lt;allow\_inactive&gt;yes&lt;/allow\_inactive&gt;
                    &lt;allow\_active&gt;yes&lt;/allow\_active&gt;
            &lt;/defaults&gt;
    &lt;/action&gt;

    &lt;action id=&quot;org.freedesktop.systemd1.reload-daemon&quot;&gt; enable
            &lt;defaults&gt;
                    &lt;allow\_any&gt;yes&lt;/allow\_any&gt;
                    &lt;allow\_inactive&gt;yes&lt;/allow\_inactive&gt;
                    &lt;allow\_active&gt;yes&lt;/allow\_active&gt;
            &lt;/defaults&gt;
    &lt;/action&gt;
</code></pre>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><hr>
<p>使用 root 用户修改keeepalived 服务配置，指定一下启动配置文件<br>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;keepalived.service</p>
<p>vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;keepalived.service<br>ExecStart&#x3D;&#x2F;data&#x2F;keepalived&#x2F;sbin&#x2F;keepalived -f &#x2F;data&#x2F;keepalived&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf $KEEPALIVED_OPTIONS</p>
<h3 id="keepalived-配置"><a href="#keepalived-配置" class="headerlink" title="keepalived 配置"></a>keepalived 配置</h3><hr>
<p>vim &#x2F;data&#x2F;keepalived&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</p>
<p>! Configuration File for keepalived</p>
<h1 id="全局配置，demo中配置了邮件信息，此处因为调试中，暂时没有添加"><a href="#全局配置，demo中配置了邮件信息，此处因为调试中，暂时没有添加" class="headerlink" title="全局配置，demo中配置了邮件信息，此处因为调试中，暂时没有添加"></a>全局配置，demo中配置了邮件信息，此处因为调试中，暂时没有添加</h1><p>global_defs {<br>    router_id OA-YY-T074161<br>}</p>
<h1 id="集群资源监控，组合track-script进行"><a href="#集群资源监控，组合track-script进行" class="headerlink" title="集群资源监控，组合track_script进行"></a>集群资源监控，组合track_script进行</h1><p>vrrp_script check_haproxy {<br>    script “&#x2F;data&#x2F;keepalived&#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh”<br>    interval 2 #检测间隔时间<br>    #weight -20 ##如果条件成立则权重减20<br>}<br>vrrp_instance VI_1 {<br>    # 设置当前主机为主节点，如果是备用节点，则设置为BACKUP<br>    # 备用节点时，设置为：<br>    state BACKUP<br>    # state MASTER<br>    # 指定HA监测网络接口，可以用ifconfig查看来决定设置哪一个<br>    interface ens192<br>    # 虚拟路由标识，同一个VRRP实例要使用同一个标识，主备机<br>    virtual_router_id 161<br>    #mcast_src_ip 10.3.153.67<br>    # 因为当前环境中VRRP组播有问题，改为使用单播发送VRRP报文<br>    # 这个地方需要关注，之前未做此设置，结果主备节点互相不能发现，因此主备节点都升级成了MASTER，并且绑定了VIP<br>    unicast_src_ip 10.3.153.67<br>    unicast_peer {<br>10.3.153.68<br>}<br>    # 备用节点时，内容为：<br>    priority 100 ##设置优先级（0-255）<br>    nopreempt<br>    advert_int 1 ## 组播信息发送间隔，两个节点必须配置一致，默认1s<br>    authentication {<br>        auth_type PASS<br>        auth_pass 123321<br>    }<br>    track_script {<br>        chk_haproxy<br>    }<br>    virtual_ipaddress {<br>        10.3.153.244 ##虚拟ip，可指定多个<br>    }<br>}</p>
<h3 id="检测脚本配置"><a href="#检测脚本配置" class="headerlink" title="检测脚本配置"></a>检测脚本配置</h3><hr>
<p>vim &#x2F;data&#x2F;keepalived&#x2F;etc&#x2F;keepalived&#x2F;haproxy_check.sh</p>
<p>#!&#x2F;bin&#x2F;bash<br>COUNT&#x3D;`ps -C haproxy –no-header wc -l`<br>T&#x3D;`date ‘+%Y-%m-%d %H:%M:%S’`<br>LOGF&#x3D;’&#x2F;data&#x2F;keepalived&#x2F;logs&#x2F;keepalived_healthcheckers.log’<br>echo “$T haproxy Number of processes :”$COUNT &gt;&gt; $LOGF<br>echo “$T haproxy processes :” `ps -ef grep haproxy` &gt;&gt; $LOGF<br>if [ $COUNT -eq 0 ];then<br>echo “$T Stopping keepalived:” &gt;&gt; $LOGF<br>systemctl stop keepalived<br>echo “$T Stoped keepalived :” &gt;&gt; $LOGF<br>fi</p>
<h3 id="普通用户启动keepalived"><a href="#普通用户启动keepalived" class="headerlink" title="普通用户启动keepalived"></a>普通用户启动keepalived</h3><hr>
<p>[code404@OIS-AS ~]$ systemctl start keepalived</p>
<p>查看本机监听IP</p>
<p>[tailweb@OAV2-YY-V153067 ~&#x2F;keepalived&#x2F;etc&#x2F;keepalived]$ip a<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1&#x2F;8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1&#x2F;128 scope host<br>       valid_lft forever preferred_lft forever<br>2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link&#x2F;ether 00:50:56:a6:e0:2a brd ff:ff:ff:ff:ff:ff<br>    inet 10.3.153.67&#x2F;23 brd 10.3.153.255 scope global ens192<br>       valid_lft forever preferred_lft forever<br>    inet 10.3.153.244&#x2F;32 scope global ens192<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::250:56ff:fea6:e02a&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>root</tag>
        <tag>普通用户</tag>
        <tag>haproxy</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>普通用户安装配置haproxy</title>
    <url>/2021/12/09/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEhaproxy/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-5.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。<br>HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。<br>HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr>
<p>下载包<br>下载地址：<a href="http://download.openpkg.org/components/cache/haproxy/haproxy-2.5.0.tar.gz">http://download.openpkg.org/components/cache/haproxy/haproxy-2.5.0.tar.gz</a></p>
<p>[code404@NEWCWS-AS06 data]$ tar -xvf haproxy-2.5.0.tar.gz<br>[code404@NEWCWS-AS06 haproxy-2.5.0]$ cd haproxy-2.5.0<br>[code404@NEWCWS-AS06 haproxy-2.5.0]$ uname -r<br>3.10.0-1062.el7.x86_64</p>
<p>系统版本 3.10.0-1062.el7.x86_64</p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><hr>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><hr>
<ul>
<li>TARGET&#x3D;linux26 #内核版本，使用uname -r查看内核，如：2.6.18-371.el5，此时该参数就为linux26；kernel 大于2.6.28的用： TARGET&#x3D;linux2628</li>
<li>ARCH&#x3D;x86_64 #系统位数</li>
<li>PREFIX&#x3D;&#x2F;data&#x2F;haprpxy #&#x2F;usr&#x2F;local&#x2F;haprpxy为haprpxy安装路径</li>
</ul>
<p>[code404@NEWCWS-AS06 haproxy-2.5.0]$ make TARGET&#x3D;3100 ARCH&#x3D;x86_64 PREFIX&#x3D;&#x2F;data&#x2F;haproxy<br>[code404@NEWCWS-AS06 haproxy-2.5.0]$ make install TARGET&#x3D;3100 ARCH&#x3D;x86_64 PREFIX&#x3D;&#x2F;data&#x2F;haproxy<br>install: creating directory ‘&#x2F;data&#x2F;haproxy’<br>install: creating directory ‘&#x2F;data&#x2F;haproxy&#x2F;sbin’<br>‘haproxy’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy’<br>install: creating directory ‘&#x2F;data&#x2F;haproxy&#x2F;share’<br>install: creating directory ‘&#x2F;data&#x2F;haproxy&#x2F;share&#x2F;man’<br>install: creating directory ‘&#x2F;data&#x2F;haproxy&#x2F;share&#x2F;man&#x2F;man1’<br>‘doc&#x2F;haproxy.1’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;share&#x2F;man&#x2F;man1&#x2F;haproxy.1’<br>install: creating directory ‘&#x2F;data&#x2F;haproxy&#x2F;doc’<br>install: creating directory ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy’<br>‘doc&#x2F;configuration.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;configuration.txt’<br>‘doc&#x2F;management.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;management.txt’<br>‘doc&#x2F;seamless_reload.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;seamless_reload.txt’<br>‘doc&#x2F;architecture.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;architecture.txt’<br>‘doc&#x2F;peers-v2.0.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;peers-v2.0.txt’<br>‘doc&#x2F;regression-testing.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;regression-testing.txt’<br>‘doc&#x2F;cookie-options.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;cookie-options.txt’<br>‘doc&#x2F;lua.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;lua.txt’<br>‘doc&#x2F;WURFL-device-detection.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;WURFL-device-detection.txt’<br>‘doc&#x2F;proxy-protocol.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;proxy-protocol.txt’<br>‘doc&#x2F;linux-syn-cookies.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;linux-syn-cookies.txt’<br>‘doc&#x2F;SOCKS4.protocol.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;SOCKS4.protocol.txt’<br>‘doc&#x2F;network-namespaces.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;network-namespaces.txt’<br>‘doc&#x2F;DeviceAtlas-device-detection.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;DeviceAtlas-device-detection.txt’<br>‘doc&#x2F;51Degrees-device-detection.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;51Degrees-device-detection.txt’<br>‘doc&#x2F;netscaler-client-ip-insertion-protocol.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;netscaler-client-ip-insertion-protocol.txt’<br>‘doc&#x2F;peers.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;peers.txt’<br>‘doc&#x2F;close-options.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;close-options.txt’<br>‘doc&#x2F;SPOE.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;SPOE.txt’<br>‘doc&#x2F;intro.txt’ -&gt; ‘&#x2F;data&#x2F;haproxy&#x2F;doc&#x2F;haproxy&#x2F;intro.txt’</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><hr>
<p>[code404@NEWCWS-AS06 haproxy-2.5.0]$ cd &#x2F;data&#x2F;haproxy<br>[code404@NEWCWS-AS06 haproxy]$ mkdir etc<br>[code404@NEWCWS-AS06 haproxy]$ vim etc&#x2F;haproxy.cfg</p>
<p>&#x2F;data&#x2F;haproxy&#x2F;etc&#x2F;haproxy.cfg 配置</p>
<p>#———————————————————————</p>
<h1 id="Global-settings"><a href="#Global-settings" class="headerlink" title="Global settings"></a>Global settings</h1><p>#———————————————————————<br>global<br>    # to have these messages end up in &#x2F;var&#x2F;log&#x2F;haproxy.log you will<br>    log         127.0.0.1 local2</p>
<pre><code>#chroot      /data/haproxy/chroot
pidfile     /data/haproxy.pid
maxconn     4000
uid0
gid 0
daemon

# turn on stats unix socket
stats socket /data/haproxy/stats
</code></pre>
<p>#———————————————————————</p>
<h1 id="common-defaults-that-all-the-‘listen’-and-‘backend’-sections-will"><a href="#common-defaults-that-all-the-‘listen’-and-‘backend’-sections-will" class="headerlink" title="common defaults that all the ‘listen’ and ‘backend’ sections will"></a>common defaults that all the ‘listen’ and ‘backend’ sections will</h1><h1 id="use-if-not-designated-in-their-block"><a href="#use-if-not-designated-in-their-block" class="headerlink" title="use if not designated in their block"></a>use if not designated in their block</h1><p>#———————————————————————<br>defaults<br>    mode                    http<br>    log                     global<br>    option                  httplog<br>    option                  dontlognull<br>    option http-server-close</p>
<h1 id="option-forwardfor-except-127-0-0-0-x2F-8"><a href="#option-forwardfor-except-127-0-0-0-x2F-8" class="headerlink" title="option forwardfor       except 127.0.0.0&#x2F;8"></a>option forwardfor       except 127.0.0.0&#x2F;8</h1><pre><code>option                  redispatch
retries                 3
timeout http-request    10s
timeout queue           1m
timeout connect         10s
timeout client          1m
timeout server          1m
timeout http-keep-alive 10s
timeout check           10s
maxconn                 3000
</code></pre>
<p>listen oa_rabbitmq_cluster<br>    bind *:5672<br>    #配置TCP模式<br>    mode tcp<br>    option tcplog<br>    #简单的轮询<br>    balance roundrobin<br>    #rabbitmq集群节点配置 server 每个节点的hostname ip:5672<br>    server OA-MQ1 10.3.152.68:5672 check inter 5000 rise 2 fall 2<br>    server OA-MQ2 10.3.152.69:5672 check inter 5000 rise 2 fall 2<br>    server OA-MQ3 10.3.153.69:5672 check inter 5000 rise 2 fall 2</p>
<p>listen stats<br>    bind *:15672<br>    mode http<br>    option httplog<br>    stats enable<br>    #简单的轮询<br>    balance roundrobin<br>    #rabbitmq集群节点配置 server 每个节点的hostname ip:5672<br>    server OA-MQ1 10.3.152.68:15672 check inter 5000 rise 2 fall 2<br>    server OA-MQ2 10.3.152.69:15672 check inter 5000 rise 2 fall 2<br>    server OA-MQ3 10.3.153.69:15672 check inter 5000 rise 2 fall 2</p>
<h3 id="启动-haproxy"><a href="#启动-haproxy" class="headerlink" title="启动 haproxy"></a>启动 haproxy</h3><hr>
<p>&#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;data&#x2F;haproxy&#x2F;etc&#x2F;haproxy.cfg</p>
<h3 id="报错了-x2F-data-x2F-haproxy-x2F-sbin-x2F-haproxy-main-Cannot-raise-FD-limit-to-8032-limit-is-1024"><a href="#报错了-x2F-data-x2F-haproxy-x2F-sbin-x2F-haproxy-main-Cannot-raise-FD-limit-to-8032-limit-is-1024" class="headerlink" title="报错了[&#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy.main()] Cannot raise FD limit to 8032, limit is 1024."></a>报错了[&#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy.main()] Cannot raise FD limit to 8032, limit is 1024.</h3><hr>
<p>[code404@NEWCWS-AS06 haproxy]$ &#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;data&#x2F;haproxy&#x2F;etc&#x2F;haproxy.cfg<br>[NOTICE]   (22699) : haproxy version is 2.5.0-f2e0833<br>[NOTICE]   (22699) : path to executable is &#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy<br>[ALERT]    (22699) : [&#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy.main()] Cannot raise FD limit to 8032, limit is 1024.<br>[code404@NEWCWS-AS06 haproxy]$</p>
<p>这个报错说明，系统没有优化，下面优化一下</p>
<p>vim &#x2F;etc&#x2F;security&#x2F;limits.conf<br>*        soft    nofile        65535<br>*        hard    nofile        65535</p>
<p>优化完成后，要重启一下服务器</p>
<p>reboot</p>
<h3 id="再次启动Haproxy"><a href="#再次启动Haproxy" class="headerlink" title="再次启动Haproxy"></a>再次启动Haproxy</h3><hr>
<p>[code404@NEWCWS-AS06 haproxy]$ &#x2F;data&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;data&#x2F;haproxy&#x2F;etc&#x2F;haproxy.cfg<br>[code404@NEWCWS-AS06 haproxy]$ netstat -nptl<br>(Not all processes could be identified, non-owned process info<br> will not be shown, you would have to be root to see it all.)<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name<br>tcp        0      0 0.0.0.0:15672           0.0.0.0:*               LISTEN      1887&#x2F;haproxy<br>tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      -<br>tcp        0      0 0.0.0.0:5672            0.0.0.0:*               LISTEN      1887&#x2F;haproxy<br>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -<br>tcp6       0      0 ::1:25                  :::*                    LISTEN      -<br>tcp6       0      0 :::22                   :::*                    LISTEN      -       </p>
<h3 id="检查haproxy状态，能访问了"><a href="#检查haproxy状态，能访问了" class="headerlink" title="检查haproxy状态，能访问了"></a>检查haproxy状态，能访问了</h3><hr>
<p>[code404@NEWCWS-AS06 haproxy]$ curl localhost:15672 -I<br>HTTP&#x2F;1.1 200 OK<br>content-length: 2884<br>content-security-policy: script-src ‘self’ ‘unsafe-eval’ ‘unsafe-inline’; object-src ‘self’<br>content-type: text&#x2F;html<br>date: Mon, 06 Dec 2021 06:59:07 GMT<br>etag: “3417244139”<br>last-modified: Thu, 02 Dec 2021 07:12:23 GMT<br>server: Cowboy<br>vary: origin</p>
<h3 id="外面访问，要开防火墙端口"><a href="#外面访问，要开防火墙端口" class="headerlink" title="外面访问，要开防火墙端口"></a>外面访问，要开防火墙端口</h3><hr>
<p>切换到root账号，开放端口</p>
<p>[code404@NEWCWS-AS06 haproxy]$ firewall-cmd –add-port&#x3D;15672&#x2F;tcp –add-port&#x3D;5672&#x2F;tcp –zone&#x3D;public –perman<br>success<br>[code404@NEWCWS-AS06 haproxy]$ firewall-cmd –reload<br>success<br>[code404@NEWCWS-AS06 haproxy]$</p>
]]></content>
      <categories>
        <category>haproxy</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>普通用户</tag>
        <tag>配置</tag>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器如何运行 VSCode开发工具</title>
    <url>/2021/06/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C-vscode%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-24.png"></p>
<p>程序员会通过云服务来加速软件开发效率，今天要介绍的这款开源工具让你IDE更加接地气，它可以在远程服务器上运行 VS Code ，使其通过浏览器访问，它就是——<code>code-server</code></p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-22-1024x478.png"></p>
<p>code-server本周在GitHub上十分受欢迎,（GitHub地址：<a href="https://github.com/cdr/code-server%EF%BC%89">https://github.com/cdr/code-server）</a></p>
<p>总而言之，code-server它可以让你：<br>在 Chromebook、平板电脑和笔记本电脑上使用一致的开发环境。<br>利用大型云服务器来加速测试、编辑与下载等。<br>节能减耗，保持电池寿命<br>所有密集型计算都在服务器上运行。<br>无需再运行多余的 Chrome 实例。</p>
<h2 id="安装-code-server-3-10-2-amd64-rpm"><a href="#安装-code-server-3-10-2-amd64-rpm" class="headerlink" title="安装 code-server-3.10.2-amd64.rpm"></a>安装 <code>code-server-3.10.2-amd64.rpm</code></h2><p>去Github上下载吧</p>
<p>rpm -ivh code-server-3.10.2-amd64.rpm<br>Preparing…                          ################################# [100%]<br>package code-server-0:3.10.2-1.x86_64 is already installed</p>
<h2 id="先运行一下"><a href="#先运行一下" class="headerlink" title="先运行一下"></a>先运行一下</h2><p>先执行 <code>code-server</code> 运行起来，发现监听的地址是127.0.0.1</p>
<p>code-server<br>[2021-06-04T08:46:02.581Z] info  code-server 3.10.2 387b12ef4ca404ffd39d84834e1f0776e9e3c005<br>[2021-06-04T08:46:02.583Z] info  Using user-data-dir ~&#x2F;.local&#x2F;share&#x2F;code-server<br>[2021-06-04T08:46:02.598Z] info  Using config file ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml<br>[2021-06-04T08:46:02.598Z] info  HTTP server listening on <a href="http://0.0.0.0:8088/">http://0.0.0.0:8088</a><br>[2021-06-04T08:46:02.598Z] info    - Authentication is enabled<br>[2021-06-04T08:46:02.598Z] info      - Using password from ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml<br>[2021-06-04T08:46:02.598Z] info    - Not serving HTTPS </p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在配置文件<code>~/.config/code-server/config.yaml</code> 修改密码</p>
<p>cat ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml<br>bind-addr: 0.0.0.0:8088<br>auth: password<br>password: 4dec31d18a18da2a22cae1ac<br>cert: false</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>[root@host-192-168-65-94 ~]# code-server<br>[2021-06-04T09:06:21.582Z] info  code-server 3.10.2 387b12ef4ca404ffd39d84834e1f0776e9e3c005<br>[2021-06-04T09:06:21.584Z] info  Using user-data-dir ~&#x2F;.local&#x2F;share&#x2F;code-server<br>[2021-06-04T09:06:21.600Z] info  Using config file ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml<br>[2021-06-04T09:06:21.600Z] info  HTTP server listening on <a href="http://0.0.0.0:8088/">http://0.0.0.0:8088</a><br>[2021-06-04T09:06:21.600Z] info    - Authentication is enabled<br>[2021-06-04T09:06:21.600Z] info      - Using password from ~&#x2F;.config&#x2F;code-server&#x2F;config.yaml<br>[2021-06-04T09:06:21.600Z] info    - Not serving HTTPS </p>
<h2 id="访问一下"><a href="#访问一下" class="headerlink" title="访问一下"></a>访问一下</h2><p><img src="https://code404.icu/img/moveypu/2021/06/image-23-1024x527.png"></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>远程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>本地yun源搭建安装本地yum源_yum仓库</title>
    <url>/2021/04/02/%E6%9C%AC%E5%9C%B0yun%E6%BA%90%E6%90%AD%E5%BB%BA%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0yum%E6%BA%90-yum%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>在Linux系统中，联网的情况下，软件安装会从yum源配置的路径去下载rpm包并安装。在离线情况下，我们也可以配置本地yum源来安装软件包</p>
<blockquote>
<p>注：本文只讲本地yum源安装使用</p>
</blockquote>
<blockquote>
<p>局域网yum仓库搭建请移步：<a href="https://www.code404.icu/158.html">局域网yum仓库</a></p>
</blockquote>
<h3 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h3><hr>
<blockquote>
<p>找到安装系统时所用的镜像 找不到的情况下就去官网下载</p>
</blockquote>
<p>CentOS 国内镜像下载地址：</p>
<p><a href="http://mirrors.aliyun.com/centos/">http://mirrors.aliyun.com/centos/</a> 阿里云开源镜像</p>
<p><a href="https://mirrors.cnnic.cn/centos/">https://mirrors.cnnic.cn/centos/</a> 清华大学开源镜像</p>
<p><a href="http://centos.ustc.edu.cn/centos/">http://centos.ustc.edu.cn/centos/</a> 中国科学技术大学开源镜像</p>
<p><a href="http://ftp.sjtu.edu.cn/centos/">http://ftp.sjtu.edu.cn/centos/</a> 上海交大开源镜像</p>
<p><a href="http://mirrors.163.com/centos/">http://mirrors.163.com/centos/</a> 网易开源镜像</p>
<p><a href="http://mirrors.sohu.com/centos/">http://mirrors.sohu.com/centos/</a> 搜狐开源镜像</p>
<h3 id="第一步-配置本地yum源"><a href="#第一步-配置本地yum源" class="headerlink" title="第一步(配置本地yum源)"></a>第一步(配置本地yum源)</h3><hr>
<h4 id="镜像盘插入服务器光驱-有光驱的情况下-，挂在到服务器上的-x2F-yumrepo-目录"><a href="#镜像盘插入服务器光驱-有光驱的情况下-，挂在到服务器上的-x2F-yumrepo-目录" class="headerlink" title="镜像盘插入服务器光驱(有光驱的情况下)，挂在到服务器上的 &#x2F;yumrepo 目录"></a>镜像盘插入服务器光驱(<code>有光驱的情况下</code>)，挂在到服务器上的 &#x2F;yumrepo 目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /yumrepo</span><br><span class="line">[root@localhost ~]# mount /dev/cdrom /yumrepo</span><br><span class="line">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                 475M     0  475M    0% /dev</span><br><span class="line">tmpfs                    487M     0  487M    0% /dev/shm</span><br><span class="line">tmpfs                    487M  7.6M  479M    2% /run</span><br><span class="line">tmpfs                    487M     0  487M    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   17G  3.6G   14G   22% /</span><br><span class="line">/dev/sda1               1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs                     98M     0   98M    0% /run/user/0</span><br><span class="line">/dev/sr0                 4.4G  4.4G     0  100% /yumrepo</span><br></pre></td></tr></table></figure>

<h4 id="镜像上传到服务器的某个目录，mount挂载到-x2F-yumrepo目录"><a href="#镜像上传到服务器的某个目录，mount挂载到-x2F-yumrepo目录" class="headerlink" title="镜像上传到服务器的某个目录，mount挂载到 &#x2F;yumrepo目录"></a>镜像上传到服务器的某个目录，mount挂载到 &#x2F;yumrepo目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#我上传到了 /home/software 目录里面了</span><br><span class="line">[root@localhost ~]# mount -o loop -t iso9660 /home/software/CentOS-7-x86_64-DVD-7.6.iso  /yumrepo</span><br><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   44G  3.5G   40G    8% /</span><br><span class="line">devtmpfs                 4.8G     0  4.8G    0% /dev</span><br><span class="line">tmpfs                    4.9G     0  4.9G    0% /dev/shm</span><br><span class="line">tmpfs                    4.9G  497M  4.4G   11% /run</span><br><span class="line">tmpfs                    4.9G     0  4.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1               1014M  145M  870M   15% /boot</span><br><span class="line">/dev/mapper/centos-home   22G  4.4G   17G   21% /home</span><br><span class="line">/dev/loop0               4.3G  4.3G     0  100% /yumrepo</span><br></pre></td></tr></table></figure>

<h4 id="配置yum源-本地"><a href="#配置yum源-本地" class="headerlink" title="配置yum源(本地)"></a>配置yum源(本地)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##需要把原的有repo文件都移出/etc/yum.repos.d/</span><br><span class="line">[root@localhost ~]# cd /etc/yum.repos.d/</span><br><span class="line">[root@localhost yum.repos.d]# ll</span><br><span class="line">总用量 52</span><br><span class="line">-rw-r--r--. 1 root root 1664 10月 23 22:53 CentOS-Base.repo</span><br><span class="line">-rw-r--r--. 1 root root 1309 10月 23 22:53 CentOS-CR.repo</span><br><span class="line">-rw-r--r--. 1 root root  649 10月 23 22:53 CentOS-Debuginfo.repo</span><br><span class="line">-rw-r--r--. 1 root root  314 10月 23 22:53 CentOS-fasttrack.repo</span><br><span class="line">-rw-r--r--. 1 root root  630 10月 23 22:53 CentOS-Media.repo</span><br><span class="line">-rw-r--r--. 1 root root 1331 10月 23 22:53 CentOS-Sources.repo</span><br><span class="line">-rw-r--r--. 1 root root 8515 10月 23 22:53 CentOS-Vault.repo</span><br><span class="line">-rw-r--r--. 1 root root  616 10月 23 22:53 CentOS-x86_64-kernel.repo</span><br><span class="line">-rw-r--r--. 1 root root  963 11月 13 2016 webtatic-archive.repo</span><br><span class="line">-rw-r--r--. 1 root root  865 11月 13 2016 webtatic.repo</span><br><span class="line">-rw-r--r--. 1 root root  963 11月 13 2016 webtatic-testing.repo</span><br><span class="line">[root@localhost yum.repos.d]# mkdir bak</span><br><span class="line">[root@localhost yum.repos.d]# mv * bak/</span><br><span class="line">mv: 无法将目录&quot;bak&quot; 移动至自身的子目录&quot;bak/bak&quot; 下</span><br><span class="line">[root@localhost yum.repos.d]# vim local.repo</span><br><span class="line">[local]</span><br><span class="line">name=CentOS-$releasever - Base </span><br><span class="line">baseurl=file:///yumrepo/ </span><br><span class="line">gpgcheck=0 </span><br><span class="line">enabled=1 </span><br><span class="line">[root@localhost yum.repos.d]#</span><br></pre></td></tr></table></figure>

<h3 id="验证本地yum源"><a href="#验证本地yum源" class="headerlink" title="验证本地yum源"></a>验证本地yum源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum check-update</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">local                                        3.6 kB  00:00:00     </span><br><span class="line">(1/2): local/group_gz                        153 kB  00:00:00     </span><br><span class="line">(2/2): local/primary_db                      3.3 MB  00:00:00     </span><br><span class="line">[root@localhost yum.repos.d]# yum install lrzsz</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 lrzsz.x86_64.0.0.12.20-36.el7 将被 安装</span><br><span class="line">--&gt; 解决依赖关系完成</span><br><span class="line"></span><br><span class="line">依赖关系解决</span><br><span class="line"></span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line"> Package                                    架构                                        版本                                                  源                                          大小</span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> lrzsz                                      x86_64                                      0.12.20-36.el7                                        local                                       78 k</span><br><span class="line"></span><br><span class="line">事务概要</span><br><span class="line">===============================================================================================================================================================================================</span><br><span class="line">安装  1 软件包</span><br><span class="line"></span><br><span class="line">总下载量：78 k</span><br><span class="line">安装大小：181 k</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  正在安装    : lrzsz-0.12.20-36.el7.x86_64                                                                                                                                                1/1 </span><br><span class="line">  验证中      : lrzsz-0.12.20-36.el7.x86_64                                                                                                                                                1/1 </span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  lrzsz.x86_64 0:0.12.20-36.el7                                                                                                                                                              </span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>局域网yum仓库搭建请移步：<a href="https://note.youdao.com/">局域网yum仓库</a></p>
</blockquote>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>yum源</tag>
        <tag>Linux系统</tag>
        <tag>rpm包</tag>
        <tag>yum源配置</tag>
        <tag>本地yum源</tag>
        <tag>离线yum源</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列产生严重消息堆积怎么处理？</title>
    <url>/2021/05/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E4%B8%A5%E9%87%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-38.png"></p>
<h2 id="1-为什么产生消息堆积？"><a href="#1-为什么产生消息堆积？" class="headerlink" title="1. 为什么产生消息堆积？"></a>1. 为什么产生消息堆积？</h2><p>大多是因为 Consumer 出问题了，没有及时发现，或者故障恢复需要较长的时间，导致大量消息积压在 MQ 中。</p>
<h2 id="2-消息堆积会有什么后果呢？"><a href="#2-消息堆积会有什么后果呢？" class="headerlink" title="2. 消息堆积会有什么后果呢？"></a>2. 消息堆积会有什么后果呢？</h2><h3 id="2-1-消息被丢弃"><a href="#2-1-消息被丢弃" class="headerlink" title="2.1 消息被丢弃"></a>2.1 消息被丢弃</h3><p>例如 RabbitMQ 有一个消息过期时间 TTL，过期的消息会被扔掉，这样消息就彻底没有了。</p>
<h3 id="2-2-磁盘满了"><a href="#2-2-磁盘满了" class="headerlink" title="2.2 磁盘满了"></a>2.2 磁盘满了</h3><p>如果堆积量太大，可能导致磁盘空间不足，那么新消息就进不来了。</p>
<h3 id="2-3-海量消息待处理"><a href="#2-3-海量消息待处理" class="headerlink" title="2.3 海量消息待处理"></a>2.3 海量消息待处理</h3><p>如果消息没过期，并且磁盘空间也够用，那么就是产生海量消息等待被消费，Consumer 的噩梦。</p>
<h2 id="3-如何应对呢？"><a href="#3-如何应对呢？" class="headerlink" title="3. 如何应对呢？"></a>3. 如何应对呢？</h2><h3 id="3-1-消息被丢弃的情况"><a href="#3-1-消息被丢弃的情况" class="headerlink" title="3.1 消息被丢弃的情况"></a>3.1 消息被丢弃的情况</h3><p>首先，要实现防止消息过期问题，不应该设置过期时间。<br>如果就是设置了过期时间，导致了消息丢失，怎么补救呢？<br>那就只能在夜深人静，趁着访问量最低的时候，写一个临时程序来补消息了。<br>例如有订单消息丢了，那就需要找出哪些订单消息丢了，然后重新发到队列。</p>
<h3 id="3-2-磁盘不足的情况"><a href="#3-2-磁盘不足的情况" class="headerlink" title="3.2 磁盘不足的情况"></a>3.2 磁盘不足的情况</h3><p>系统通常都是有监控的，达到空间阈值时就会发警报，这时就要马上处理了。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-36-1024x745.png"></p>
<p>例如，在其他机器上创建临时的消息队列，再写一个临时的 Consumer，作为消息的中转，把消息积压队列中的消息取出来，放到临时队列里面去。<br>快速疏散积压的消息，让磁盘空间恢复正常水平。</p>
<h3 id="3-3-快速处理海量积压消息"><a href="#3-3-快速处理海量积压消息" class="headerlink" title="3.3 快速处理海量积压消息"></a>3.3 快速处理海量积压消息</h3><p>Consumer 恢复正常之后，面对堆积如山的消息，怎么处理呢？<br>如何按照之前正常情况处理的话，猴年马月才能消费完，此过程中还有新消息在不断进来。<br>例如，积压了 100 万条，有 3 个 Consumer，每一个每秒能处理 200 条，3 个 Consumer 每秒一共能处理 600 条。<br>大概需要一个多小时才能处理完。<br>这一个多小时又会积压多少新的消息呢？<br>所以正常处理肯定不行，需要提速。<br>例如 Kafka，这个消息积压的 Topic 有 3 个 Partition，那最多就能用 3 个 Consumer，所以增加 Consumer 没有用。<br>还是可以使用临时队列的方式。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-37-1024x512.png"></p>
<p>新建一个 Topic，设置为 20 个 Partition<br>Consumer 不再处理业务逻辑了，只负责搬运，把消息放到临时 Topic 中<br>这 20 个 Partition 可以有 20个 Consumer 了，它们来处理原来的业务逻辑。<br>这 20 个 Consumer 每秒一共能处理 4000 条了，这样几分钟就可以处理完积压的 100 万条。<br>这几分钟新来的消息也不会太多，所以很快就可以恢复正常水平，之后，再把整体结构恢复为原来的形式。</p>
<p>小结一下，消息积压还是比较麻烦的，最好是提前防范，做好硬件和消息系统的健康监控。如果出现消息丢失，就要人工查找丢失的消息，然后补上。在消费不过来的时候，可以考虑使用临时队列作为中转，提升处理能力。</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>堆积</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>清理k8s_docker磁盘空间</title>
    <url>/2021/12/23/%E6%B8%85%E7%90%86k8s-docker%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-15.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>长时间运行的集群，常会面临各种资源耗尽的问题，另外磁盘不足时 Kubelet 还会主动清理镜像增加不确定因素，本文提供了一些命令片段用于清理工作。</p>
<h3 id="1-Kubernetes-基础对象清理"><a href="#1-Kubernetes-基础对象清理" class="headerlink" title="1. Kubernetes 基础对象清理"></a>1. Kubernetes 基础对象清理</h3><hr>
<p>清理 Evicted 状态的 Pod</p>
<p>kubectl get pods –all-namespaces -o wide  grep Evicted  awk ‘{print $1,$2}’  xargs -L1 kubectl delete pod -n</p>
<p>清理 Error 状态的 Pod</p>
<p>kubectl get pods –all-namespaces -o wide  grep Error  awk ‘{print $1,$2}’  xargs -L1 kubectl delete pod -n</p>
<p>清理 Completed 状态的 Pod</p>
<p>kubectl get pods –all-namespaces -o wide  grep Completed  awk ‘{print $1,$2}’  xargs -L1 kubectl delete pod -n</p>
<p>清理没有被使用的 PV</p>
<p>kubectl describe -A pvc  grep -E “^Name:.*$^Namespace:.*$^Used By:.*$”  grep -B 2 “<none>“  grep -E “^Name:.*$^Namespace:.*$”  cut -f2 -d:  paste -d “ “ - -  xargs -n2 bash -c ‘kubectl -n ${1} delete pvc ${0}’</p>
<p>清理没有被绑定的 PVC</p>
<p>kubectl get pvc –all-namespaces  tail -n +2  grep -v Bound  awk ‘{print $1,$2}’  xargs -L1 kubectl delete pvc -n</p>
<p>清理没有被绑定的 PV</p>
<p>kubectl get pv  tail -n +2  grep -v Bound  awk ‘{print $1}’  xargs -L1 kubectl delete pv</p>
<h3 id="2-Linux-清理"><a href="#2-Linux-清理" class="headerlink" title="2. Linux 清理"></a>2. Linux 清理</h3><hr>
<p>查看磁盘全部空间</p>
<p>df -hl &#x2F;</p>
<p>Filesystem      Size  Used Avail Use% Mounted on<br>&#x2F;dev&#x2F;sda2       100G   47G   54G  47% &#x2F;</p>
<p>查看指定目录占用</p>
<p>du -sh .</p>
<p>24G .</p>
<p>删除指定前缀的文件夹</p>
<p>cd &#x2F;nfsdata<br>ls  grep archived- xargs -L1 rm -r</p>
<p>清理僵尸进程</p>
<p>ps -A -ostat,ppid  grep -e ‘^[Zz]‘  awk ‘{print }’  xargs kill -HUP &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</p>
<h3 id="3-Docker-清理"><a href="#3-Docker-清理" class="headerlink" title="3. Docker 清理"></a>3. Docker 清理</h3><hr>
<p>查看磁盘使用情况</p>
<p>docker system df</p>
<p>TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE<br>Images              361                 23                  178.5GB             173.8GB (97%)<br>Containers          29                  9                   6.682GB             6.212GB (92%)<br>Local Volumes       4                   0                   3.139MB             3.139MB (100%)<br>Build Cache         0                   0                   0B                  0B</p>
<p>清理 none 镜像</p>
<p>docker images  grep none  awk ‘{print $3}’  xargs docker rmi</p>
<p>清理不再使用的数据卷</p>
<p>docker volume rm $(docker volume ls -q)</p>
<p>或者</p>
<p>docker volume prune</p>
<p>清理缓存</p>
<p>docker builder prune</p>
<p>全面清理<br>删除关闭的容器、无用的存储卷、无用的网络、dangling 镜像（无 tag 镜像）</p>
<p>docker system prune -f</p>
<p>清理正则匹配上的镜像</p>
<p>这里清理的是 master-8bcf8d7-20211206-111155163 格式的镜像。</p>
<p>docker images grep -E “([0-9a-z]*[-]){3,}[0-9]{9}” awk ‘{print $3}’  xargs docker rmi</p>
<h3 id="4-设置定时"><a href="#4-设置定时" class="headerlink" title="4. 设置定时"></a>4. 设置定时</h3><hr>
<p>查看定时任务</p>
<p>crontab -l</p>
<p>设置定时任务</p>
<p>crontab -e </p>
<p>文本新增定时任务</p>
<p>*&#x2F;35 *&#x2F;6 * * *  docker images  grep none  awk ‘{print $3}’  xargs docker rmi<br>45 1 * * * docker system prune -f</p>
<p>这里第一个任务是每隔六个小时的第 35 分钟执行，第二个任务每天的 1 时 45 分执行。</p>
<p>定时任务的格式<br>设置定时格式:</p>
<p>* * * * * shell</p>
<p>第一个星号，minute，分钟，值为 0-59 第二个星号，hour，小时，值从 0-23 第三个星号，day，天，值为从 1-31 第四个星号，month，月，值为从 1-12 月，或者简写的英文，比如 Nov、Feb 等 第五个星号，week 周，值为从 0-6 或者简写的英文，Wen、Tur 等，代表周几，其中 0 代表周末</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>Kubernetes</tag>
        <tag>对象清理</tag>
        <tag>空间清理</tag>
        <tag>镜像清理</tag>
      </tags>
  </entry>
  <entry>
    <title>百度云下载不限速_获取下载链接_突破会员限制</title>
    <url>/2021/08/03/%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD%E4%B8%8D%E9%99%90%E9%80%9F-%E8%8E%B7%E5%8F%96%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5-%E7%AA%81%E7%A0%B4%E4%BC%9A%E5%91%98%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/08/image-2.png"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>百度网盘现在有一家独大趋势，无论文件大小统统包容，特别是大体积的影视文件</p>
<p>普通会员的容量是没有问题的，关键是下载速度和超级会员相差巨大</p>
<p>只要你的账号没有充值，百度网盘限速处理，这也是很多朋友充百度网盘超级会员的缘故</p>
<p>我个人不提倡使用第三方破解加速软件，官方严格把控检测，发现定会封号处理</p>
<h3 id="解析百度云下载地址"><a href="#解析百度云下载地址" class="headerlink" title="解析百度云下载地址"></a>解析百度云下载地址</h3><hr>
<p>打开地址：<a href="https://www.kinh.cc/">https://www.kinh.cc/</a><br><img src="https://img-blog.csdnimg.cn/662bfc5999c143c5ae3204c2551b6777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择<strong>百度网盘在线解析</strong><br>这里百度网盘有一个比较大的文件，需要下载，如果在百度网盘下载就太慢了<br><img src="https://img-blog.csdnimg.cn/0acaf9ccca2443b1aee0fdd09e3bbfc1.png" alt="在这里插入图片描述"></p>
<p>地址：<a href="https://pan.baidu.com/s/1axsju9of5orZiy5uFfSRmA">https://pan.baidu.com/s/1axsju9of5orZiy5uFfSRmA</a><br>提取码：fu76</p>
<p><img src="https://img-blog.csdnimg.cn/f9ba3755f13a43eebbb363138fd1cb53.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="获取文件下载链接"><a href="#获取文件下载链接" class="headerlink" title="获取文件下载链接"></a>获取文件下载链接</h3><hr>
<p>![<img src="https://img-blog.csdnimg.cn/5a0aec8ba7b446329f8de74f48de7a70.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在"></p>
<h3 id="输入接收邮箱"><a href="#输入接收邮箱" class="headerlink" title="输入接收邮箱"></a>输入接收邮箱</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/e57942fe7029436581256d8d78ae401f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/ab9fa8d2a4574679af5056bf4827f2bb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="###"></p>
<h3 id="静静的等待几分钟"><a href="#静静的等待几分钟" class="headerlink" title="静静的等待几分钟"></a>静静的等待几分钟</h3><hr>
<p>查看邮箱<br>已经收到下载地址了<img src="https://img-blog.csdnimg.cn/b327901aa1b249e0b6c946c5979932d5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><hr>
<p>点击下载链接<br><img src="https://img-blog.csdnimg.cn/036dca9dee8147c49e2db130777acd05.png" alt="在这里插入图片描述"><br>这样就可以原速下载百度网盘的文件了</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
        <category>百度云</category>
      </categories>
      <tags>
        <tag>会员</tag>
        <tag>百度云</tag>
        <tag>百度网盘</tag>
        <tag>限速</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点常用语言http请求客户端的惊艳框架</title>
    <url>/2021/05/23/%E7%9B%98%E7%82%B9%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80http%E8%AF%B7%E6%B1%82%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%83%8A%E8%89%B3%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>对于前后端交互的应用，http请求可以说是最重要的功能，而庆幸地是各个语言对于客户端请求都有非常好用的库来使用，今天我们就来盘点一下各个语言中那些惊艳的http请求库。</p>
<h1 id="Guzzle"><a href="#Guzzle" class="headerlink" title="Guzzle"></a>Guzzle</h1><p>Guzzle是一个PHP HTTP客户端，可以轻松发送HTTP请求并轻松与Web服务集成。 它的代码非常优雅，同时它的功能也非常强大，它不仅支持同步请求，也支持异步请求，对于大型文件的下载，json数据的传输解析它都有很好的支持。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/0019d22e5eef154e.jpg"></p>
<p>它是对底层http的封装，因此对于curl和socket等没有硬性依赖。</p>
<h1 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h1><p>如果你接触过python的话，那么你就一定接触过这个库，因为很多新人接触python都是从爬虫开始的，而对于简单的爬虫来说，requests这个库足以满足，此外，即使是复杂的爬虫，它也能应付得来。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/aeeb9235c1f30b68.jpg"></p>
<p>requests可以说是最优雅的python http库了，没有之一。从认证到连接池，从多文件处理到超时处理，从流式下载到分片传输，他都能很好地支持，并且它的代码非常优雅，你只需要很少的代码就能轻松实现你想要请求的结果。</p>
<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><p>进行过android开发的人员都知道Android中有个非常好用的库叫做okhttp,而retrofit是在 okhttp上进行的封装，除了OkHttp的所有低级功能外，它还提供了一种构建Java类的方法，该类抽象了HTTP详细信息并提供了一个对于Java友好的访问API。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/f20c0b042abf2752.jpg"></p>
<h1 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h1><p>相对于开源的语言，c#的框架基本都是微软进行开发的，而对于http的请求封装，微软为我们提供了非常好用的基类HttpClient，使用它我们可以轻松地进行http的请求。有了它，我们不需要引入第三方类，我们可以直接使用它。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/3acfe3e172ea3bce-1.jpg"></p>
<h1 id="net-x2F-http"><a href="#net-x2F-http" class="headerlink" title="net&#x2F;http"></a>net&#x2F;http</h1><p>不同于其它语言，golang语言对于底层网络请求给出了非常好用的封装，你可以直接使用官方的http库就可以。虽然网络上存在着各种关于http请求的封装，有的是类似python中的requests的封装，但是这些分装有些使用过于繁琐，有些性能上有瓶颈，而官方自带的网络请求包可以说是最佳的选择。  </p>
<h1 id="cpr"><a href="#cpr" class="headerlink" title="cpr"></a>cpr</h1><p>这是一个c++的网络请求库，它的灵感来源于python的requests,当你学习过很多语言之后，你就会发现，python的网络请求库requests是多么地优雅，以至于很多语言都在学习这种优雅的请求封装。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/092f7716e67d17c5.jpg"></p>
<p>cpr是一个基于libcurl的封装，它让网络请求变得更加方便和优雅。</p>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>Axios基于Promise的简单HTTP客户端，它可以用于浏览器端和node.js端。 它可以轻松地进行扩展，并且可以非常方便地和第三方框架进行集成。 它的使用也非常简洁，很多框架都采用它进行http请求的封装。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然网络请求看似很简单，但是其实它也是最复杂的，我们几乎所有的应用都离不开网络请求，而网络上会出现各种状况，有权限的验证，有超时的处理，有弱网的加强，各种复杂的问题导致进行网络请求并不简单，但是很多前辈们用他们的智慧给了我们无数好用的框架进行了指点，我们因该珍惜这些代码，珍惜并从中有所领悟</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装 Kubernetes一键安装</title>
    <url>/2021/12/27/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-kubernetes%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-19.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>正常部署K8s时，一般情况下单位服务器是不联网的，需要离线安装。本文就讲一下在没有互联网到企业内网部署Kubernetes集群</p>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><hr>
<ul>
<li>安装并启动docker&#x2F;containerd(1.20+安装containerd),已经安装了会重启docker&#x2F;containerd. 高版本离线包自带docker&#x2F;containerd，如没安装docker&#x2F;containerd会自动安装.</li>
<li>下载kubernetes 离线安装包.</li>
<li>下载最新版本sealos.</li>
<li>务必同步服务器时间</li>
<li>主机名不可重复，需要修改主机的主机名</li>
<li>master节点CPU必须2C以上</li>
</ul>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><p>主机名</p>
<p>IP地址</p>
<p>服务器密码</p>
<p>centos7-01</p>
<p>192.168.55.101</p>
<p>123456</p>
<p>centos7-02</p>
<p>192.168.55.102</p>
<p>123456</p>
<p>centos7-03</p>
<p>192.168.55.103</p>
<p>123456</p>
<h3 id="下面离线包"><a href="#下面离线包" class="headerlink" title="下面离线包"></a>下面离线包</h3><hr>
<p>只需要准备好服务器，在任意一台服务器上执行下面命令即可</p>
<p>下载并安装sealos, sealos是个golang的二进制工具，直接下载拷贝到bin目录即可, release页面也可下载</p>
<p>$ wget -c <a href="https://sealyun.oss-cn-beijing.aliyuncs.com/latest/sealos">https://sealyun.oss-cn-beijing.aliyuncs.com/latest/sealos</a></p>
<p>下载离线资源包</p>
<p>$ wget -c <a href="https://sealyun.oss-cn-beijing.aliyuncs.com/05a3db657821277f5f3b92d834bbaf98-v1.22.0/kube1.22.0.tar.gz">https://sealyun.oss-cn-beijing.aliyuncs.com/05a3db657821277f5f3b92d834bbaf98-v1.22.0/kube1.22.0.tar.gz</a></p>
<h3 id="安装k8s"><a href="#安装k8s" class="headerlink" title="安装k8s"></a>安装k8s</h3><hr>
<p>把sealos和kube1.22.0.tar.gz都上传到服务器</p>
<p>[root@centos7-01 ~]# ls &#x2F;usr&#x2F;bin&#x2F;sealos<br>&#x2F;usr&#x2F;bin&#x2F;sealos<br>[root@centos7-01 ~]# ls kube1.22.0.tar.gz<br>kube1.22.0.tar.gz</p>
<p>执行sealos安装k8s集群</p>
<p>sealos init –passwd ‘123456’ \<br>–master 192.168.55.101 \<br>–node 192.168.55.102 \<br>–node 192.168.55.103 \<br>–pkg-url &#x2F;root&#x2F;kube1.22.0.tar.gz \<br>–version v1.22.0<br>.<br>.<br>.<br>.<br>16:07:20 [INFO] [ssh.go:13] [ssh][192.168.55.102:22] mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;manifests<br>16:07:20 [DEBG] [ssh.go:25] [ssh][192.168.55.103:22]command result is:<br>16:07:20 [DEBG] [ssh.go:25] [ssh][192.168.55.102:22]command result is:<br>16:07:21 [INFO] [scp.go:159] [ssh][192.168.55.102:22]transfer total size is: 0MB<br>16:07:21 [INFO] [scp.go:159] [ssh][192.168.55.103:22]transfer total size is: 0MB<br>16:07:21 [DEBG] [ssh.go:58] [192.168.55.103:22] rm -rf &#x2F;root&#x2F;kube<br>16:07:21 [DEBG] [ssh.go:58] [192.168.55.102:22] rm -rf &#x2F;root&#x2F;kube<br>16:07:21 [DEBG] [print.go:21] &#x3D;&#x3D;&gt;SendPackage&#x3D;&#x3D;&gt;KubeadmConfigInstall&#x3D;&#x3D;&gt;InstallMaster0&#x3D;&#x3D;&gt;JoinMasters&#x3D;&#x3D;&gt;JoinNodes<br>16:07:21 [INFO] [print.go:26] sealos install success.<br>16:07:21 [INFO] [init.go:96]<br>      ___           ___           ___           ___       ___           ___<br>     &#x2F;\  \         &#x2F;\  \         &#x2F;\  \         &#x2F;\__\     &#x2F;\  \         &#x2F;\  \<br>    &#x2F;::\  \       &#x2F;::\  \       &#x2F;::\  \       &#x2F;:&#x2F;  &#x2F;    &#x2F;::\  \       &#x2F;::\  \<br>   &#x2F;:&#x2F;\ \  \     &#x2F;:&#x2F;\:\  \     &#x2F;:&#x2F;\:\  \     &#x2F;:&#x2F;  &#x2F;    &#x2F;:&#x2F;\:\  \     &#x2F;:&#x2F;\ \  \<br>  _\:\<del>\ \  \   &#x2F;::\</del>\:\  \   &#x2F;::\<del>\:\  \   &#x2F;:&#x2F;  &#x2F;    &#x2F;:&#x2F;  \:\  \   _\:\</del>\ \  \<br> &#x2F;\ \:\ \ \__\ &#x2F;:&#x2F;\:\ \:\__\ &#x2F;:&#x2F;\:\ \:\__\ &#x2F;:&#x2F;__&#x2F;    &#x2F;:&#x2F;__&#x2F; \:\__\ &#x2F;\ \:\ \ \__\<br> \:\ \:\ \&#x2F;__&#x2F; \:\~\:\ \&#x2F;__&#x2F; \&#x2F;__\:\&#x2F;:&#x2F;  &#x2F; \:\  \    \:\  \ &#x2F;:&#x2F;  &#x2F; \:\ \:\ \&#x2F;__&#x2F;<br>  \:\ \:\__\    \:\ \:\__\        \::&#x2F;  &#x2F;   \:\  \    \:\  &#x2F;:&#x2F;  &#x2F;   \:\ \:\__\<br>   \:\&#x2F;:&#x2F;  &#x2F;     \:\ \&#x2F;__&#x2F;        &#x2F;:&#x2F;  &#x2F;     \:\  \    \:\&#x2F;:&#x2F;  &#x2F;     \:\&#x2F;:&#x2F;  &#x2F;<br>    \::&#x2F;  &#x2F;       \:\__\         &#x2F;:&#x2F;  &#x2F;       \:\__\    \::&#x2F;  &#x2F;       \::&#x2F;  &#x2F;<br>     \&#x2F;__&#x2F;         \&#x2F;__&#x2F;         \&#x2F;__&#x2F;         \&#x2F;__&#x2F;     \&#x2F;__&#x2F;         \&#x2F;__&#x2F;  </p>
<p>看到sealos的logo就带表安装成功了。</p>
<h3 id="查看k8s配置文件"><a href="#查看k8s配置文件" class="headerlink" title="查看k8s配置文件"></a>查看k8s配置文件</h3><hr>
<p>配置文件一般会在当前用户下 的 .kube目录内</p>
<p>[root@centos7-01 ~]# cat .kube&#x2F;config<br>apiVersion: v1<br>clusters:</p>
<ul>
<li>cluster:<br>  certificate-authority-data: LS0tLSxxxxxQo&#x3D;<br>  server: <a href="https://apiserver.cluster.local:6443/">https://apiserver.cluster.local:6443</a><br>name: kubernetes<br>contexts:</li>
<li>context:<br>  cluster: kubernetes<br>  user: kubernetes-admin<br>name: kubernetes-admin@kubernetes<br>current-context: kubernetes-admin@kubernetes<br>kind: Config<br>preferences: {}<br>users:</li>
<li>name: kubernetes-admin<br>user:<br>  client-certificate-data: LS0txxxxxxxS0K<br>  client-key-data: LS0tLS1CRUxxxxxxxtLQo&#x3D;</li>
</ul>
<h3 id="使用Lens链接K8s集群"><a href="#使用Lens链接K8s集群" class="headerlink" title="使用Lens链接K8s集群"></a>使用Lens链接K8s集群</h3><hr>
<p>把上面配置里的server: <a href="https://apiserver.cluster.local:6443/">https://apiserver.cluster.local:6443</a> 集群地址改成IP地址，我这里没有配置域名<br><img src="https://img-blog.csdnimg.cn/2bccdcac0881474f87ed59afe148569c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="查看k8s集群节点"><a href="#查看k8s集群节点" class="headerlink" title="查看k8s集群节点"></a>查看k8s集群节点</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/c49aaf8c4bae4b428571ce622d729ae8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>部署k8s</tag>
        <tag>Kubernetes</tag>
        <tag>k8s集群</tag>
        <tag>一键安装</tag>
        <tag>离线安装</tag>
      </tags>
  </entry>
  <entry>
    <title>程序包无效：“CRX_HEADER_INVALID“</title>
    <url>/2021/05/10/%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%97%A0%E6%95%88%EF%BC%9Acrx-header-invalid/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-13.png"></p>
<h1 id="之前在安装谷歌插件的时候遇到的问题，解决方法小技巧"><a href="#之前在安装谷歌插件的时候遇到的问题，解决方法小技巧" class="headerlink" title="之前在安装谷歌插件的时候遇到的问题，解决方法小技巧"></a>之前在安装谷歌插件的时候遇到的问题，解决方法小技巧</h1><h2 id="1、报错：程序包无效：“CRX-HEADER-INVALID”"><a href="#1、报错：程序包无效：“CRX-HEADER-INVALID”" class="headerlink" title="1、报错：程序包无效：“CRX_HEADER_INVALID”"></a>1、报错：程序包无效：“CRX_HEADER_INVALID”</h2><p>如图：</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-14.png"></p>
<p>原因是插件格式不对，谷歌无法进行解析。需要手动解压文件。</p>
<p>2、解决方法<br>将下载的<code>crx</code>文件后缀名改为<code>.zip</code> 或者后缀名 <code>.rar</code>。如果<code>zip</code>不行就改为<code>rar</code> 。然后对文件进行解压到指定文件夹，点击加载已解压的扩展程序，选定所解压的指定文件夹。</p>
<p>再次把安装zip包拖放到<code>chrome://extensions/</code>扩展程序窗口就可以了</p>
<p>上图中 谷歌访问助手 下载地址：<a href="https://www.code404.icu/programmer-box">https://www.code404.icu/programmer-box</a></p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>报错</tag>
        <tag>CRX_HEADER_INVALID</tag>
        <tag>程序包无效</tag>
        <tag>谷歌插件</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇-如何使用github.io创建自己的网站</title>
    <url>/2021/06/02/%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-io%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-7.png"></p>
<h2 id="首先要有一个Github账号"><a href="#首先要有一个Github账号" class="headerlink" title="首先要有一个Github账号"></a>首先要有一个Github账号</h2><p><strong>用户名</strong>好像不能用汉字，其它的信息自己填好就可以了</p>
<h2 id="创建Repositories"><a href="#创建Repositories" class="headerlink" title="创建Repositories"></a>创建Repositories</h2><p>登录上GitHub后，创建一个 new Repositories<br>注意：Repositorie的名称格式最好为：<strong>用户名.github.io</strong></p>
<p>如果不是，生成的网址绝对不是 https:&#x2F;&#x2F;用户名.github.io。 当 “用户名” 等于 账号的用户名的时候，才会使得blog地址为：用户名.github.io</p>
<p>然后点击create repositories.</p>
<p>随后跳转到该库界面,然后选择Settings</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>下面有个pages 下面可以选择主题。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-1024x592.png"></p>
<p>这是我随意选择的一个主题</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-1-1024x515.png"></p>
<h2 id="修改网站"><a href="#修改网站" class="headerlink" title="修改网站"></a>修改网站</h2><p>可以选择自己学用的开发工具</p>
<p>我这里用的是vscode</p>
<h3 id="使用vscode编辑网站"><a href="#使用vscode编辑网站" class="headerlink" title="使用vscode编辑网站"></a>使用vscode编辑网站</h3><p><img src="https://code404.icu/img/moveypu/2021/06/image-2.png"></p>
<p>下载自己网站仓库的代码</p>
<p><a href="https://github.com/leenhem/leenhem.github.io.git">https://github.com/leenhem/leenhem.github.io.git</a></p>
<p>添加一个首页文件 index.html</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-3.png"></p>
<p>提交代码</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-4.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-5.png"></p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>leenhem.github.io.git</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-6.png"></p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇supervisor集群管理工具cesi安装详解-如何安装supervisor</title>
    <url>/2021/05/25/%E7%AC%AC%E4%B8%80%E7%AF%87supervisor%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7cesi%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85supervisor/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-45-1024x409.png"></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>系统</p>
<p>centos7</p>
<p>python</p>
<p>默认2.7.5</p>
<p>没有外网</p>
<p>没有yum环境</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我在网上下载好了</p>
<p>python3.7.4</p>
<p>wget <a href="https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz">https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz</a></p>
<p>supervisor-4.2.2.tar.gz</p>
<p>supervisor也去官方下载吧<br><a href="https://pypi.org/project/supervisor/">https://pypi.org/project/supervisor/</a></p>
<h2 id="安装python3-7-4"><a href="#安装python3-7-4" class="headerlink" title="安装python3.7.4"></a>安装python3.7.4</h2><p>[root@host-192-168-65-94 supervisor]# tar -xf Python-3.7.4.tgz<br>[root@host-192-168-65-94 supervisor]# ll<br>total 22484<br>drwxr-xr-x. 18  501  501     4096 Jul  9  2019 Python-3.7.4<br>-rw-r–r–.  1 root root 23017663 May 24 11:08 Python-3.7.4.tgz<br>[root@host-192-168-65-94 supervisor]# cd Python-3.7.4&#x2F;<br>[root@host-192-168-65-94 Python-3.7.4]# .&#x2F;configure –prefix&#x3D;&#x2F;data&#x2F;supervisor&#x2F;python3.7<br>[root@host-192-168-65-94 Python-3.7.4]# make -j 4 &amp;&amp; make install</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>from _ctypes import Union, Structure, Array<br>ModuleNotFoundError: No module named ‘_ctypes’<br>make: *** [install] Error 1<br>如果和上面安装方式一样，python3.7在make install时会报错<br><code>from _ctypes import Union, Structure, Array ModuleNotFoundError: No module named &#39;_ctypes&#39; make: *** [install] Error 1</code></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>安装libffi-devel，没有yum源的话，可以参考<a href="https://www.code404.icu/151.html">本地yun源搭建安装本地yum源_yum仓库</a></p>
<p>yum install libffi-devel </p>
<p>安装上libffi后，再重新编译python</p>
<p>.&#x2F;configure –prefix&#x3D;&#x2F;data&#x2F;supervisor&#x2F;python3.7<br>make -j 8 &amp;&amp; make install</p>
<p>OK，python安装上了</p>
<h2 id="安装supervisor"><a href="#安装supervisor" class="headerlink" title="安装supervisor"></a>安装supervisor</h2><p>上传<code>supervisor-4.2.2.tar.gz</code></p>
<p>[root@host-192-168-65-94 supervisor]# tar -xf supervisor-4.2.2.tar.gz<br>[root@host-192-168-65-94 supervisor]# ll<br>total 22940<br>drwxr-xr-x.  6 root root        56 May 24 15:47 python3.7<br>drwxr-xr-x. 19  501   501     4096 May 24 15:53 Python-3.7.4<br>-rw-r–r–.  1 root root  23017663 May 24 11:08 Python-3.7.4.tgz<br>drwxr-xr-x.  5  501 games      224 Feb 27 04:45 supervisor-4.2.2<br>-rw-r–r–.  1 root root    463657 May 20 09:29 supervisor-4.2.2.tar.gz<br>[root@host-192-168-65-94 supervisor]#<br>[root@host-192-168-65-94 supervisor]# cd supervisor-4.2.2&#x2F;<br>[root@host-192-168-65-94 supervisor-4.2.2]# ..&#x2F;python3.7&#x2F;bin&#x2F;python3.7 setup.py build<br>[root@host-192-168-65-94 supervisor-4.2.2]# ..&#x2F;python3.7&#x2F;bin&#x2F;python3.7 setup.py install<br>[root@host-192-168-65-94 supervisor-4.2.2]# ls ..&#x2F;python3.7&#x2F;bin&#x2F; -l<br>total 27384<br>lrwxrwxrwx. 1 root root        8 May 24 16:02 2to3 -&gt; 2to3-3.7<br>-rwxr-xr-x. 1 root root      117 May 24 16:02 2to3-3.7<br>-rwxr-xr-x. 1 root root      257 May 24 16:02 easy_install-3.7<br>-rwxr-xr-x. 1 root root      443 May 24 16:16 echo_supervisord_conf<br>lrwxrwxrwx. 1 root root        7 May 24 16:02 idle3 -&gt; idle3.7<br>-rwxr-xr-x. 1 root root      115 May 24 16:02 idle3.7<br>-rwxr-xr-x. 1 root root      417 May 24 16:16 pidproxy<br>-rwxr-xr-x. 1 root root      239 May 24 16:02 pip3<br>-rwxr-xr-x. 1 root root      239 May 24 16:02 pip3.7<br>lrwxrwxrwx. 1 root root        8 May 24 16:02 pydoc3 -&gt; pydoc3.7<br>-rwxr-xr-x. 1 root root      100 May 24 16:02 pydoc3.7<br>lrwxrwxrwx. 1 root root        9 May 24 16:02 python3 -&gt; python3.7<br>-rwxr-xr-x. 2 root root 13994184 May 24 16:01 python3.7<br>lrwxrwxrwx. 1 root root       17 May 24 16:02 python3.7-config -&gt; python3.7m-config<br>-rwxr-xr-x. 2 root root 13994184 May 24 16:01 python3.7m<br>-rwxr-xr-x. 1 root root     2918 May 24 16:02 python3.7m-config<br>lrwxrwxrwx. 1 root root       16 May 24 16:02 python3-config -&gt; python3.7-config<br>lrwxrwxrwx. 1 root root       10 May 24 16:02 pyvenv -&gt; pyvenv-3.7<br>-rwxr-xr-x. 1 root root      457 May 24 16:02 pyvenv-3.7<br>-rwxr-xr-x. 1 root root      427 May 24 16:16 supervisorctl<br>-rwxr-xr-x. 1 root root      423 May 24 16:16 supervisord<br>[root@host-192-168-65-94 supervisor-4.2.2]# </p>
<p>欧了，现在我把supervisor也安装上了</p>
<h2 id="配置supervisor服务"><a href="#配置supervisor服务" class="headerlink" title="配置supervisor服务"></a>配置supervisor服务</h2><p>[root@host-192-168-65-94 supervisor]# mkdir &#x2F;var&#x2F;log&#x2F;supervisor<br>[root@host-192-168-65-94 supervisor]# mkdir -p conf&#x2F;conf.d<br>[root@host-192-168-65-94 supervisor]# cat conf&#x2F;supervisord.ini<br>; supervisor config file</p>
<p>[unix_http_server]<br>file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; (the path to the socket file)<br>chmod&#x3D;0700                       ; sockef file mode (default 0700)</p>
<p>[inet_http_server]         ; inet (TCP) server disabled by default<br>port&#x3D;192.168.65.94:9001        ; (ip_address:port specifier, *:port for all iface)<br>username&#x3D;super             ; (default is no username (open server))<br>password&#x3D;KsKFaCIX50fDv7kz               ; (default is no password (open server))</p>
<p>[supervisord]<br>logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)<br>pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)<br>childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor            ; (‘AUTO’ child log dir, default $TEMP)</p>
<p>; the below section must remain in the config file for RPC<br>; (supervisorctl&#x2F;web interface) to work, additional interfaces may be<br>; added by defining them in separate rpcinterface: sections<br>[rpcinterface:supervisor]<br>supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</p>
<p>[supervisorctl]<br>serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket</p>
<p>; The [include] section can just contain the “files” setting.  This<br>; setting can list multiple files (separated by whitespace or<br>; newlines).  It can also contain wildcards.  The filenames are<br>; interpreted as relative to this file.  Included files *cannot*<br>; include files themselves.</p>
<p>[include]<br>files &#x3D; conf.d&#x2F;*.ini</p>
<h2 id="启动supervisord"><a href="#启动supervisord" class="headerlink" title="启动supervisord"></a>启动supervisord</h2><p>[root@host-192-168-65-94 supervisor]# python3.7&#x2F;bin&#x2F;supervisord -c conf&#x2F;supervisord.ini</p>
<h2 id="添加一个服务"><a href="#添加一个服务" class="headerlink" title="添加一个服务"></a>添加一个服务</h2><p>[root@host-192-168-65-94 conf.d]# cd &#x2F;data&#x2F;supervisor&#x2F;conf&#x2F;conf.d&#x2F;<br>[root@host-192-168-65-94 conf.d]# cat gateway.ini<br>[program:gateway]<br>command&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_151&#x2F;bin&#x2F;java -jar &#x2F;pro&#x2F;gateway&#x2F;carsoa-gateway.jar<br>autostart&#x3D;true<br>autorestart&#x3D;true<br>user&#x3D;root<br>startsecs&#x3D;1<br>startretries&#x3D;3<br>redirect_stderr&#x3D;true<br>stdout_logfile&#x3D;&#x2F;pro&#x2F;gateway&#x2F;nohup.out<br>stderr_logfile&#x3D;&#x2F;pro&#x2F;gateway&#x2F;nohup.out</p>
<h2 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h2><p>[root@host-192-168-65-94 conf.d]# &#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;bin&#x2F;supervisorctl -c &#x2F;data&#x2F;supervisor&#x2F;conf&#x2F;supervisord.ini<br>supervisor&gt; start gateway<br>gateway: started<br>supervisor&gt;<br>supervisor&gt; status<br>gateway                          RUNNING   pid 11970, uptime 0:00:23</p>
<p>可以了，如果您觉得有帮忙请点赞！</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
        <tag>supervisorctl</tag>
        <tag>supervisord</tag>
        <tag>进程管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>第三篇 jenkins怎么样部署k8s项目之Jenkins-Slave补充，问题总结</title>
    <url>/2021/05/15/%E7%AC%AC%E4%B8%89%E7%AF%87-jenkins%E6%80%8E%E4%B9%88%E6%A0%B7%E9%83%A8%E7%BD%B2k8s%E9%A1%B9%E7%9B%AE%E4%B9%8Bjenkins-slave%E8%A1%A5%E5%85%85%EF%BC%8C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-31.png"></p>
<h2 id="Git下载代码报错"><a href="#Git下载代码报错" class="headerlink" title="Git下载代码报错"></a>Git下载代码报错</h2><hr>
<p>ERROR: Error cloning remote repo ‘origin’<br>hudson.plugins.git.GitException: Command “git fetch –tags –force –progress – <a href="https://gitlab.rails.cn/zhangxiangyang/CARSOA-CLOUD.git">https://gitlab.rails.cn/zhangxiangyang/CARSOA-CLOUD.git</a> +refs&#x2F;heads&#x2F;_:refs&#x2F;remotes&#x2F;origin&#x2F;_” returned status code 128:<br>stdout:<br>stderr: fatal: unable to access ‘<a href="https://gitlab.rails.cn/zhangxiangyang/CARSOA-CLOUD.git/%E2%80%99">https://gitlab.rails.cn/zhangxiangyang/CARSOA-CLOUD.git/’</a>: server certificate verification failed. CAfile: none CRLfile: none</p>
<p><code>server certificate verification failed. CAfile: none CRLfile: none</code></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>添加环境变量<br><code>export GIT_SSL_NO_VERIFY=1</code><br>在k8s部署的pipeline上需要在Jenkins上配置</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-27.png"></p>
<h2 id="如何保存构建数据"><a href="#如何保存构建数据" class="headerlink" title="如何保存构建数据"></a>如何保存构建数据</h2><hr>
<p>在<code>java</code>和<code>node</code>项目构建时，需要保留缓存的<code>maven</code>和<code>node_modules</code>依赖来保证下次快速构建，不用每次都去仓库下载</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>如图，我们只需要将仓库挂在到主机就可以了</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-28.png"></p>
<h2 id="无法打包docker镜像"><a href="#无法打包docker镜像" class="headerlink" title="无法打包docker镜像"></a>无法打包docker镜像</h2><p>Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</p>
<p>原因：Jenkins-slave节点内没有运行docker服务</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>只需要把主机的docker.sock挂载到container里就可以了</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-29.png"></p>
<h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>解决上面问题后，是可以构建打包了，但发现部署时出了问题<br><code>Error from server (Forbidden): error when deleting &quot;deployment.yaml&quot;: deployments.apps &quot;config-deployment&quot; is forbidden: User &quot;system:serviceaccount:devops:default&quot; cannot delete resource &quot;deployments&quot; in API group &quot;apps&quot; in the namespace &quot;bjj&quot;</code></p>
<p>说明一下，默认情况下pod会使用namespace中的default用户去执行，default用户是没有权限操作其它namespace中的pod的，所以我们要添加一个用户，指定其为集群权限</p>
<p>权限配置如下可以去 原文 copy</p>
<p><a href="https://www.code404.icu/520.html">https://www.code404.icu/520.html</a></p>
<p>没有部署权限</p>
<p>在Jenkins上的pod模板上配置一下用户</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-30-1024x169.png"></p>
<p>这样就可以了，不过这样配置还是比较麻烦的，我们在第四篇讲解如何把这些配置写到一个配置文件里</p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Jenkins插件</tag>
        <tag>Kubernetes Cloud</tag>
        <tag>pipeline</tag>
        <tag>部署k8s</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇 jenkins怎么样部署k8s项目之Jenkins-Slave</title>
    <url>/2021/05/14/%E7%AC%AC%E4%BA%8C%E7%AF%87-jenkins%E6%80%8E%E4%B9%88%E6%A0%B7%E9%83%A8%E7%BD%B2k8s%E9%A1%B9%E7%9B%AE%E4%B9%8Bjenkins-slave/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-26.png"></p>
<p>第一篇配置好了要连接的k8s集群<br>由于我们的Jenkins也是在k8s集群上的，使用Jenkins部署k8s服务时，需要<code>Jenkins的附属节点</code>来执行<code>构建</code>-<code>打包</code>-<code>部署</code>任务,那么就配置先配置好 <strong>Jenkins-Slave节点的Pod模板</strong></p>
<h2 id="添加-Pod-Templates"><a href="#添加-Pod-Templates" class="headerlink" title="添加 Pod Templates"></a>添加 Pod Templates</h2><p>配置路径：<br><strong>系统管理&gt;系统配置&gt;Cloud&gt;a separate configuration page&gt;配置集群</strong></p>
<p>在配置集群下面添加<code>添加Pod模板</code></p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-18.png"></p>
<p><strong>Name</strong>，输入：jenkins_deploy_maven_secondary<br><strong>Namespace</strong>，输入：devops<br><strong>Label</strong>，输入：jenkins_deploy_maven_secondary label这个会在后面pipeline调用k8s时用到。</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-19-1024x446.png"></p>
<h2 id="配置Container-Template"><a href="#配置Container-Template" class="headerlink" title="配置Container Template"></a>配置Container Template</h2><p>本教程使用到以下container images：<br>jenkins&#x2F;jnlp-slave:latest<br>maven:3.8-jdk-8<br>docker:20.10.6<br>lachlanevenson&#x2F;k8s-kubectl:latest</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-20.png"></p>
<h3 id="jenkins-x2F-jnlp-slave-latest"><a href="#jenkins-x2F-jnlp-slave-latest" class="headerlink" title="jenkins&#x2F;jnlp-slave:latest"></a>jenkins&#x2F;jnlp-slave:latest</h3><p><img src="https://code404.icu/img/moveypu/2021/05/image-21.png"></p>
<h3 id="maven-3-8-jdk-8"><a href="#maven-3-8-jdk-8" class="headerlink" title="maven:3.8-jdk-8"></a>maven:3.8-jdk-8</h3><p>jdk版本要严格跟代码开发的版本一致</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-22.png"></p>
<h3 id="docker-20-10-6"><a href="#docker-20-10-6" class="headerlink" title="docker:20.10.6"></a>docker:20.10.6</h3><p><img src="https://code404.icu/img/moveypu/2021/05/image-23.png"></p>
<h3 id="lachlanevenson-x2F-k8s-kubectl-latest"><a href="#lachlanevenson-x2F-k8s-kubectl-latest" class="headerlink" title="lachlanevenson&#x2F;k8s-kubectl:latest"></a>lachlanevenson&#x2F;k8s-kubectl:latest</h3><p><img src="https://code404.icu/img/moveypu/2021/05/image-24.png"></p>
<h2 id="一个简单的流水线"><a href="#一个简单的流水线" class="headerlink" title="一个简单的流水线"></a>一个简单的流水线</h2><p>在Jenkins创建一个pipeline Job</p>
<p>pipeline配置如下</p>
<p>pipeline {<br>    agent   {<br>        node {<br>            label ‘jenkins_deploy_maven_secondary’<br>        }<br>    }<br>    stages {<br>        stage(‘初始化’) {<br>             steps {<br>                script {<br>                    container(‘jenkins-slave’) {<br>                            sh ‘pwd’<br>                            sh ‘mkdir jenkins-slave -p’<br>                    }<br>                }<br>             }<br>        }<br>        stage(‘构建maven’) {<br>             steps {<br>                script {<br>                    container(‘maven’) {<br>                            sh ‘pwd’<br>                            sh ‘mkdir maven -p’<br>                    }<br>                }<br>             }<br>        }<br>        stage(‘部署deploy’) {<br>             steps {<br>                script {<br>                    container(‘kubectl’) {<br>                        sh ‘pwd’<br>                        sh ‘mkdir maven -p’<br>                        sh ‘ls -l’<br>                    }<br>                }<br>             }<br>        }<br>    }<br>}</p>
<p>执行一下这个Job可以看到执行结果，每个步骤都成功了</p>
<p>不过我现在的流水线配置里面没有具体内容，可以根据项目的情况修改配置内容</p>
<p>简单说一下这个Job的执行流程：</p>
<ol>
<li><strong>在指定的Pod</strong><code>jenkins_deploy_maven_secondary</code>上执行流水线。这个Pod是临时生成的Job执行完成后，pod会自动销毁</li>
<li><strong>初始化</strong>阶段选择在<code>jenkins-slave</code>上执行初始化操作</li>
<li><strong>构建maven</strong>阶段选择在<code>maven</code>上执行构建Java项目操作</li>
<li><strong>部署deploy</strong>阶段选择在<code>kubectl</code>上执行项目部署操作</li>
<li>最后Jenkins会释放<code>jenkins_deploy_maven_secondary</code>节点</li>
</ol>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-25.png"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇supervisor集群管理工具cesi安装详解-如何安装supervisor-cesiwebUI</title>
    <url>/2021/05/27/%E7%AC%AC%E4%BA%8C%E7%AF%87supervisor%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7cesi%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85supervisor-cesiwebui/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-45-1024x409.png"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>前一篇我们安装好了supervisor，supervisor自带了一个UI界面，不太好用，且不支持集群<br>CeSi 是 Supervisor 官方推荐的集中化管理 Supervisor 实例的 Web UI，该工具是用 Python 编写，基于 Flask Web 框架 。</p>
<p>Superviosr 自带的 Web UI 不支持跨机器管理<br>Supervisor 进程，功能比较简单，通过 CeSi 可以集中管理各个服务器节点的进程，在 Web 界面就可以轻松管理各个服务的启动、关闭、重启等，很方便使用。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>软件下载地址<a href="https://github.com/gamegos/cesi/releases/download/v2.7.1/cesi-extended.tar.gz">cesi-extended.tar.gz</a></p>
<p><a href="https://github.com/gamegos/cesi/releases">https://github.com/gamegos/cesi/releases</a></p>
<p>上传到服务器</p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>[root@localhost cesi]# pwd<br>&#x2F;data&#x2F;supervisor&#x2F;cesi<br>[root@localhost cesi]# tar -xf cesi-extended.tar.gz<br>[root@localhost cesi]# ll<br>总用量 9752<br>drwxr-xr-x. 5 1157137021 1123705078     164 5月  25 10:16 cesi<br>-rw-r–r–. 1 root       root       9873466 5月  20 13:14 cesi-extended.tar.gz<br>-rw-r–r–. 1 1157137021 1123705078     360 6月  28 2020 CONTRIBUTORS.md<br>drwxr-xr-x. 2 1157137021 1123705078      70 5月  25 10:16 defaults<br>-rw-r–r–. 1 1157137021 1123705078     237 6月  28 2020 DEVELOPMENT.md<br>-rw-r–r–. 1 1157137021 1123705078    1980 6月  28 2020 docker-compose.yml<br>-rw-r–r–. 1 1157137021 1123705078      62 6月  28 2020 env.sample<br>-rw-r–r–. 1 1157137021 1123705078   35146 6月  28 2020 LICENCE<br>-rw-r–r–. 1 1157137021 1123705078    1186 6月  28 2020 Makefile<br>-rw-r–r–. 1 1157137021 1123705078   38294 6月  28 2020 poetry.lock<br>-rw-r–r–. 1 1157137021 1123705078     535 6月  28 2020 pyproject.toml<br>-rw-r–r–. 1 1157137021 1123705078    3734 6月  28 2020 README.md<br>-rw-r–r–. 1 1157137021 1123705078      90 6月  28 2020 requirements.txt</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>[root@localhost cesi]# &#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;bin&#x2F;pip3 install -r requirements.txt<br>Looking in indexes: <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>Collecting flask&#x3D;&#x3D;1.1.2 (from -r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/f2/28/2a03252dfb9ebf377f40fba6a7841b47083260bf8bd8e737b0c6952df83f/Flask-1.1.2-py2.py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/f2/28/2a03252dfb9ebf377f40fba6a7841b47083260bf8bd8e737b0c6952df83f/Flask-1.1.2-py2.py3-none-any.whl</a> (94kB)<br>    100% ████████████████████████████████ 102kB 2.0MB&#x2F;s<br>Collecting flask-sqlalchemy&#x3D;&#x3D;2.4.3 (from -r requirements.txt (line 2))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/a6/b1/9da1c3c5417612b2fc4d25d55a225199c633d6492dac215b11b9021e6a8d/Flask/_SQLAlchemy-2.4.3-py2.py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/a6/b1/9da1c3c5417612b2fc4d25d55a225199c633d6492dac215b11b9021e6a8d/Flask\_SQLAlchemy-2.4.3-py2.py3-none-any.whl</a><br>Collecting psycopg2-binary&#x3D;&#x3D;2.8.5 (from -r requirements.txt (line 3))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/e6/bc/cb407e8d0301801d5f44d3f464485d9577c3bf92db13afef4d05d757ec47/psycopg2/_binary-2.8.5-cp37-cp37m-manylinux1/_x86/_64.whl">http://mirrors.aliyun.com/pypi/packages/e6/bc/cb407e8d0301801d5f44d3f464485d9577c3bf92db13afef4d05d757ec47/psycopg2\_binary-2.8.5-cp37-cp37m-manylinux1\_x86\_64.whl</a> (2.9MB)<br>    100% ████████████████████████████████ 2.9MB 1.8MB&#x2F;s<br>Collecting pymysql&#x3D;&#x3D;0.9.3 (from -r requirements.txt (line 4))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/ed/39/15045ae46f2a123019aa968dfcba0396c161c20f855f11dea6796bcaae95/PyMySQL-0.9.3-py2.py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/ed/39/15045ae46f2a123019aa968dfcba0396c161c20f855f11dea6796bcaae95/PyMySQL-0.9.3-py2.py3-none-any.whl</a> (47kB)<br>    100% ████████████████████████████████ 51kB 2.1MB&#x2F;s<br>Collecting tomlkit&#x3D;&#x3D;0.5.11 (from -r requirements.txt (line 5))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/7d/8c/c3ee9cd41b2df781b2dc39c31209724b4f04a3110b46531de2e661ace186/tomlkit-0.5.11-py2.py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/7d/8c/c3ee9cd41b2df781b2dc39c31209724b4f04a3110b46531de2e661ace186/tomlkit-0.5.11-py2.py3-none-any.whl</a><br>Collecting itsdangerous&gt;&#x3D;0.24 (from flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/9c/96/26f935afba9cd6140216da5add223a0c465b99d0f112b68a4ca426441019/itsdangerous-2.0.1-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/9c/96/26f935afba9cd6140216da5add223a0c465b99d0f112b68a4ca426441019/itsdangerous-2.0.1-py3-none-any.whl</a><br>Collecting Jinja2&gt;&#x3D;2.10.1 (from flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/80/21/ae597efc7ed8caaa43fb35062288baaf99a7d43ff0cf66452ddf47604ee6/Jinja2-3.0.1-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/80/21/ae597efc7ed8caaa43fb35062288baaf99a7d43ff0cf66452ddf47604ee6/Jinja2-3.0.1-py3-none-any.whl</a> (133kB)<br>    100% ████████████████████████████████ 143kB 1.9MB&#x2F;s<br>Collecting click&gt;&#x3D;5.1 (from flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/76/0a/b6c5f311e32aeb3b406e03c079ade51e905ea630fc19d1262a46249c1c86/click-8.0.1-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/76/0a/b6c5f311e32aeb3b406e03c079ade51e905ea630fc19d1262a46249c1c86/click-8.0.1-py3-none-any.whl</a> (97kB)<br>    100% ████████████████████████████████ 102kB 1.7MB&#x2F;s<br>Collecting Werkzeug&gt;&#x3D;0.15 (from flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/bd/24/11c3ea5a7e866bf2d97f0501d0b4b1c9bbeade102bb4b588f0d2919a5212/Werkzeug-2.0.1-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/bd/24/11c3ea5a7e866bf2d97f0501d0b4b1c9bbeade102bb4b588f0d2919a5212/Werkzeug-2.0.1-py3-none-any.whl</a> (288kB)<br>    100% ████████████████████████████████ 296kB 1.8MB&#x2F;s<br>Collecting SQLAlchemy&gt;&#x3D;0.8.0 (from flask-sqlalchemy&#x3D;&#x3D;2.4.3-&gt;-r requirements.txt (line 2))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/aa/e3/d4d75e8f04456d4b636a3dbcd20fd423878f789db3e8881dec89ea38f9b1/SQLAlchemy-1.4.15-cp37-cp37m-manylinux/_2/_5/_x86/_64.manylinux1/_x86/_64.manylinux/_2/_12/_x86/_64.manylinux2010/_x86/_64.whl">http://mirrors.aliyun.com/pypi/packages/aa/e3/d4d75e8f04456d4b636a3dbcd20fd423878f789db3e8881dec89ea38f9b1/SQLAlchemy-1.4.15-cp37-cp37m-manylinux\_2\_5\_x86\_64.manylinux1\_x86\_64.manylinux\_2\_12\_x86\_64.manylinux2010\_x86\_64.whl</a> (1.5MB)<br>    100% ████████████████████████████████ 1.5MB 2.0MB&#x2F;s<br>Collecting MarkupSafe&gt;&#x3D;2.0 (from Jinja2&gt;&#x3D;2.10.1-&gt;flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/ad/cd/650b1be2a81674939ef962b1f1b956e4a84116d69708c842667445e95408/MarkupSafe-2.0.1-cp37-cp37m-manylinux2010/_x86/_64.whl">http://mirrors.aliyun.com/pypi/packages/ad/cd/650b1be2a81674939ef962b1f1b956e4a84116d69708c842667445e95408/MarkupSafe-2.0.1-cp37-cp37m-manylinux2010\_x86\_64.whl</a><br>Collecting importlib-metadata; python_version &lt; “3.8” (from click&gt;&#x3D;5.1-&gt;flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/8e/e2/49966924c93909d47612bb47d911448140a2f6c1390aec2f4c1afbe3748f/importlib/_metadata-4.0.1-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/8e/e2/49966924c93909d47612bb47d911448140a2f6c1390aec2f4c1afbe3748f/importlib\_metadata-4.0.1-py3-none-any.whl</a><br>Collecting greenlet!&#x3D;0.4.17; python_version &gt;&#x3D; “3” (from SQLAlchemy&gt;&#x3D;0.8.0-&gt;flask-sqlalchemy&#x3D;&#x3D;2.4.3-&gt;-r requirements.txt (line 2))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/bb/ea/c838bae79013f1106092f8cc6b28a60f86fdd7ade899c636f12ff736cdd7/greenlet-1.1.0-cp37-cp37m-manylinux2010/_x86/_64.whl">http://mirrors.aliyun.com/pypi/packages/bb/ea/c838bae79013f1106092f8cc6b28a60f86fdd7ade899c636f12ff736cdd7/greenlet-1.1.0-cp37-cp37m-manylinux2010\_x86\_64.whl</a> (160kB)<br>    100% ████████████████████████████████ 163kB 1.8MB&#x2F;s<br>Collecting typing-extensions&gt;&#x3D;3.6.4; python_version &lt; “3.8” (from importlib-metadata; python_version &lt; “3.8”-&gt;click&gt;&#x3D;5.1-&gt;flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/2e/35/6c4fff5ab443b57116cb1aad46421fb719bed2825664e8fe77d66d99bcbc/typing/_extensions-3.10.0.0-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/2e/35/6c4fff5ab443b57116cb1aad46421fb719bed2825664e8fe77d66d99bcbc/typing\_extensions-3.10.0.0-py3-none-any.whl</a><br>Collecting zipp&gt;&#x3D;0.5 (from importlib-metadata; python_version &lt; “3.8”-&gt;click&gt;&#x3D;5.1-&gt;flask&#x3D;&#x3D;1.1.2-&gt;-r requirements.txt (line 1))<br>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/0f/8c/715c54e9e34c0c4820f616a913a7de3337d0cd79074dd1bed4dd840f16ae/zipp-3.4.1-py3-none-any.whl">http://mirrors.aliyun.com/pypi/packages/0f/8c/715c54e9e34c0c4820f616a913a7de3337d0cd79074dd1bed4dd840f16ae/zipp-3.4.1-py3-none-any.whl</a><br>Installing collected packages: itsdangerous, MarkupSafe, Jinja2, typing-extensions, zipp, importlib-metadata, click, Werkzeug, flask, greenlet, SQLAlchemy, flask-sqlalchemy, psycopg2-binary, pymysql, tomlkit<br>Successfully installed Jinja2-3.0.1 MarkupSafe-2.0.1 SQLAlchemy-1.4.15 Werkzeug-2.0.1 click-8.0.1 flask-1.1.2 flask-sqlalchemy-2.4.3 greenlet-1.1.0 importlib-metadata-4.0.1 itsdangerous-2.0.1 psycopg2-binary-2.8.5 pymysql-0.9.3 tomlkit-0.5.11 typing-extensions-3.10.0.0 zipp-3.4.1<br>You are using pip version 19.0.3, however version 21.1.2 is available.<br>You should consider upgrading via the ‘pip install –upgrade pip’ command.<br>[root@localhost cesi]# </p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>[root@localhost cesi]# cat defaults&#x2F;cesi.conf.toml<br> This is the main CeSI toml configuration file. It contains CeSI web application and</p>
<h1 id="supervisord-information-to-connect"><a href="#supervisord-information-to-connect" class="headerlink" title="supervisord information to connect"></a>supervisord information to connect</h1><h1 id="This-is-the-CeSI’s-own-configuration"><a href="#This-is-the-CeSI’s-own-configuration" class="headerlink" title="This is the CeSI’s own configuration."></a>This is the CeSI’s own configuration.</h1><p>[cesi]</p>
<h1 id="Database-Uri"><a href="#Database-Uri" class="headerlink" title="Database Uri"></a>Database Uri</h1><p>database &#x3D; “sqlite:&#x2F;&#x2F;&#x2F;users.db”                         # Relative path</p>
<h1 id="Etc"><a href="#Etc" class="headerlink" title="Etc"></a>Etc</h1><p>#database &#x3D; “sqlite:&#x2F;&#x2F;&#x2F;&#x2F;opt&#x2F;cesi&#x2F;&lt; version &gt;&#x2F;users.db”  # Absolute path<br>#database &#x3D; “postgres:&#x2F;&#x2F;<user>:<password>@localhost:5432&#x2F;&lt;database_name&gt;”<br>#database &#x3D; “mysql+pymysql:&#x2F;&#x2F;<user>:<password>@localhost:3306&#x2F;&lt;database_name&gt;”<br>activity_log &#x3D; “activity.log”   # File path for CeSI logs<br>admin_username &#x3D; “admin”        # Username of admin user<br>admin_password &#x3D; “admin”        # Password of admin user</p>
<h1 id="This-is-the-definition-section-for-new-supervisord-node"><a href="#This-is-the-definition-section-for-new-supervisord-node" class="headerlink" title="This is the definition section for new supervisord node."></a>This is the definition section for new supervisord node.</h1><h1 id="nodes"><a href="#nodes" class="headerlink" title="[[nodes]]"></a>[[nodes]]</h1><h1 id="name-x3D-“api”-String-Unique-name-for-supervisord-node"><a href="#name-x3D-“api”-String-Unique-name-for-supervisord-node" class="headerlink" title="name &#x3D; “api”          # (String) Unique name for supervisord node."></a>name &#x3D; “api”          # (String) Unique name for supervisord node.</h1><h1 id="environment-x3D-“”-String-The-environment-name-provides-logical-grouping-of-supervisord-nodes-It-can-be-used-as-filtering-option-in-the-UI"><a href="#environment-x3D-“”-String-The-environment-name-provides-logical-grouping-of-supervisord-nodes-It-can-be-used-as-filtering-option-in-the-UI" class="headerlink" title="environment &#x3D; “”      # (String) The environment name provides logical grouping of supervisord nodes. It can be used as filtering option in the UI."></a>environment &#x3D; “”      # (String) The environment name provides logical grouping of supervisord nodes. It can be used as filtering option in the UI.</h1><h1 id="username-x3D-“”-String-Username-of-the-XML-RPC-interface-of-supervisord-Set-nothing-if-no-username-is-configured"><a href="#username-x3D-“”-String-Username-of-the-XML-RPC-interface-of-supervisord-Set-nothing-if-no-username-is-configured" class="headerlink" title="username &#x3D; “”         # (String) Username of the XML-RPC interface of supervisord Set nothing if no username is configured"></a>username &#x3D; “”         # (String) Username of the XML-RPC interface of supervisord Set nothing if no username is configured</h1><h1 id="password-x3D-“”-String-Password-of-the-XML-RPC-interface-of-supervisord-Set-nothing-if-no-username-is-configured"><a href="#password-x3D-“”-String-Password-of-the-XML-RPC-interface-of-supervisord-Set-nothing-if-no-username-is-configured" class="headerlink" title="password &#x3D; “”         # (String) Password of the XML-RPC interface of supervisord. Set nothing if no username is configured"></a>password &#x3D; “”         # (String) Password of the XML-RPC interface of supervisord. Set nothing if no username is configured</h1><h1 id="host-x3D-“127-0-0-1”-String-Host-of-the-XML-RPC-interface-of-supervisord"><a href="#host-x3D-“127-0-0-1”-String-Host-of-the-XML-RPC-interface-of-supervisord" class="headerlink" title="host &#x3D; “127.0.0.1”    # (String) Host of the XML-RPC interface of supervisord"></a>host &#x3D; “127.0.0.1”    # (String) Host of the XML-RPC interface of supervisord</h1><h1 id="port-x3D-“9001”-String-Port-of-the-XML-RPC-interface-of-supervisord"><a href="#port-x3D-“9001”-String-Port-of-the-XML-RPC-interface-of-supervisord" class="headerlink" title="port &#x3D; “9001”         # (String) Port of the XML-RPC interface of supervisord"></a>port &#x3D; “9001”         # (String) Port of the XML-RPC interface of supervisord</h1><h1 id="Default-supervisord-nodes"><a href="#Default-supervisord-nodes" class="headerlink" title="Default supervisord nodes"></a>Default supervisord nodes</h1><p>[[nodes]]<br>name &#x3D; “192.168.80.176-server”<br>environment &#x3D; “”<br>username &#x3D; “super”<br>password &#x3D; “KsKFaCIX50fDv7kz”<br>host &#x3D; “192.168.80.176”<br>port &#x3D; “9001”</p>
<p>[[nodes]]<br>name &#x3D; “192.168.65.94-server”<br>environment &#x3D; “”<br>username &#x3D; “super”<br>password &#x3D; “KsKFaCIX50fDv7kz”<br>host &#x3D; “192.168.65.94”<br>port &#x3D; “9001”</p>
<h2 id="注册为系统服务"><a href="#注册为系统服务" class="headerlink" title="注册为系统服务"></a>注册为系统服务</h2><p>[root@localhost cesi]# cp defaults&#x2F;cesi.service &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;<br>[root@localhost cesi]# cat &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;cesi.service<br>[Unit]<br>Description&#x3D;cesi</p>
<p>[Service]<br>Environment&#x3D;<br>ExecStart&#x3D;&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;bin&#x2F;python3 &#x2F;data&#x2F;supervisor&#x2F;cesi&#x2F;cesi&#x2F;run.py –config-file &#x2F;etc&#x2F;cesi.conf.toml<br>ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID<br>KillSignal&#x3D;TERM<br>User&#x3D;root<br>WorkingDirectory&#x3D;&#x2F;data&#x2F;supervisor&#x2F;cesi</p>
<p>Restart&#x3D;on-failure</p>
<p>[Install]<br>WantedBy&#x3D;multi-user.target</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>[root@localhost cesi]# systemctl daemon-reload<br>[root@localhost cesi]# systemctl restart cesi<br>[root@localhost cesi]# systemctl status cesi<br>● cesi.service - cesi<br>   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;cesi.service; disabled; vendor preset: disabled)<br>   Active: active (running) since 二 2021-05-25 10:26:40 CST; 4s ago<br> Main PID: 111963 (python3)<br>    Tasks: 1<br>   Memory: 34.1M<br>   CGroup: &#x2F;system.slice&#x2F;cesi.service<br>           └─111963 &#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;bin&#x2F;python3 &#x2F;data&#x2F;supervisor&#x2F;cesi&#x2F;cesi&#x2F;run.py –config-file &#x2F;etc&#x2F;cesi.conf.toml</p>
<p>5月 25 10:26:41 localhost.localdomain python3[111963]: {‘admin_username’: ‘admin’, ‘database’: ‘sqlite:&#x2F;&#x2F;&#x2F;users.db’, ‘admin_password’: ‘admin’, ‘activity_log’: ‘activity.log’, ‘nodes’: [&lt;core.node.Node object at 0x7eff9df15810&gt;, &lt;core.node.Node object at 0x7eff9dbfb…<br>5月 25 10:26:41 localhost.localdomain python3[111963]: can’t set attribute<br>5月 25 10:26:41 localhost.localdomain python3[111963]: * Serving Flask app “run” (lazy loading)<br>5月 25 10:26:41 localhost.localdomain python3[111963]: * Environment: production<br>5月 25 10:26:41 localhost.localdomain python3[111963]: WARNING: This is a development server. Do not use it in a production deployment.<br>5月 25 10:26:41 localhost.localdomain python3[111963]: Use a production WSGI server instead.<br>5月 25 10:26:41 localhost.localdomain python3[111963]: * Debug mode: off<br>5月 25 10:26:41 localhost.localdomain python3[111963]: * Running on all addresses.<br>5月 25 10:26:41 localhost.localdomain python3[111963]: WARNING: This is a development server. Do not use it in a production deployment.<br>5月 25 10:26:41 localhost.localdomain python3[111963]: * Running on <a href="http://192.168.93.128:5000/">http://192.168.93.128:5000/</a> (Press CTRL+C to quit)<br>Hint: Some lines were ellipsized, use -l to show in full.<br>[root@localhost cesi]# </p>
<p>默认用户名:admin<br>密码：admin</p>
<h2 id="登录一下，发现报错了"><a href="#登录一下，发现报错了" class="headerlink" title="登录一下，发现报错了"></a>登录一下，发现报错了</h2><p><img src="https://code404.icu/img/moveypu/2021/05/image-46-1024x289.png"></p>
<p>看报错日志 &#x2F;var&#x2F;log&#x2F;message</p>
<p>May 25 10:28:39 localhost python3: [2021-05-25 10:28:39,728] ERROR in app: Exception on &#x2F;api&#x2F;v2&#x2F;auth&#x2F;login&#x2F; [POST]<br>May 25 10:28:39 localhost python3: Traceback (most recent call last):<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;sqlalchemy&#x2F;util&#x2F;_collections.py”, line 1008, in __call__<br>May 25 10:28:39 localhost python3: return self.registry[key]<br>May 25 10:28:39 localhost python3: KeyError: &lt;greenlet.greenlet object at 0x7eff9c981710 (otid&#x3D;0x7eff9c6a0f00) current active started main&gt;<br>May 25 10:28:39 localhost python3: During handling of the above exception, another exception occurred:<br>May 25 10:28:39 localhost python3: Traceback (most recent call last):<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.py”, line 2447, in wsgi_app<br>May 25 10:28:39 localhost python3: response &#x3D; self.full_dispatch_request()<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.py”, line 1952, in full_dispatch_request<br>May 25 10:28:39 localhost python3: rv &#x3D; self.handle_user_exception(e)<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.py”, line 1821, in handle_user_exception<br>May 25 10:28:39 localhost python3: reraise(exc_type, exc_value, tb)<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;_compat.py”, line 39, in reraise<br>May 25 10:28:39 localhost python3: raise value<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.py”, line 1950, in full_dispatch_request<br>May 25 10:28:39 localhost python3: rv &#x3D; self.dispatch_request()<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.py”, line 1936, in dispatch_request<br>May 25 10:28:39 localhost python3: return self.view_functions[rule.endpoint](**req.view_args)<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;cesi&#x2F;cesi&#x2F;api&#x2F;v2&#x2F;auth.py”, line 35, in login<br>May 25 10:28:39 localhost python3: result &#x3D; User.verify(user_credentials[“username”], user_credentials[“password”])<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;cesi&#x2F;cesi&#x2F;models.py”, line 37, in verify<br>May 25 10:28:39 localhost python3: user &#x3D; User.query.filter_by(username&#x3D;username).first()<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 514, in __get__<br>May 25 10:28:39 localhost python3: return type.query_class(mapper, session&#x3D;self.sa.session())<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;sqlalchemy&#x2F;orm&#x2F;scoping.py”, line 129, in __call__<br>May 25 10:28:39 localhost python3: return self.registry()<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;sqlalchemy&#x2F;util&#x2F;_collections.py”, line 1010, in __call__<br>May 25 10:28:39 localhost python3: return self.registry.setdefault(key, self.createfunc())<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;sqlalchemy&#x2F;orm&#x2F;session.py”, line 4065, in __call__<br>May 25 10:28:39 localhost python3: return self.class_(**local_kw)<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 138, in __init__<br>May 25 10:28:39 localhost python3: bind &#x3D; options.pop(‘bind’, None) or db.engine<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 943, in engine<br>May 25 10:28:39 localhost python3: return self.get_engine()<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 962, in get_engine<br>May 25 10:28:39 localhost python3: return connector.get_engine()<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 555, in get_engine<br>May 25 10:28:39 localhost python3: options &#x3D; self.get_options(sa_url, echo)<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 570, in get_options<br>May 25 10:28:39 localhost python3: self._sa.apply_driver_hacks(self._app, sa_url, options)<br>May 25 10:28:39 localhost python3: File “&#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask_sqlalchemy&#x2F;__init__.py”, line 914, in apply_driver_hacks<br>May 25 10:28:39 localhost python3: sa_url.database &#x3D; os.path.join(app.root_path, sa_url.database)<br>May 25 10:28:39 localhost python3: AttributeError: can’t set attribute</p>
<p>May 25 10:28:39 localhost python3: sa_url.database &#x3D; os.path.join(app.root_path, sa_url.database)<br>May 25 10:28:39 localhost python3: AttributeError: can’t set attribute</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><a href="https://www.code404.icu/661.html">AttributeError:使用flask-sqlalchemy连接到sqlite数据库时无法设置属性</a></p>
<p>[root@localhost cesi]# &#x2F;data&#x2F;supervisor&#x2F;python3.7&#x2F;bin&#x2F;pip3 install  –upgrade sqlalchemy&#x3D;&#x3D;1.3.23<br>[root@localhost cesi]# systemctl restart cesi</p>
<p>OK，已经重启了，现在再登录一下</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-47-1024x229.png"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
        <tag>cisi</tag>
      </tags>
  </entry>
  <entry>
    <title>第四篇 jenkins怎么样部署k8s项目之pipeline-podTemplate</title>
    <url>/2021/05/16/%E7%AC%AC%E5%9B%9B%E7%AF%87-jenkins%E6%80%8E%E4%B9%88%E6%A0%B7%E9%83%A8%E7%BD%B2k8s%E9%A1%B9%E7%9B%AE%E4%B9%8Bpipeline-podtemplate/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-35-1024x484.png"></p>
<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p>上两篇说了，如何在Jenkins配置PodTemplate，有点麻烦，我现在贴出我整理的一套配置，各位看官请拿走</p>
<p>&#x2F;********************************************************************************<br>** Company：<br>** auth：    老C<br>** date：    2021&#x2F;5&#x2F;14 17:08:28<br>** desc：    本配置为Jenkins对接k8s自动化部署服务配置<br>** Ver.:     V1.0.0<br>*********************************************************************************&#x2F;<br>def label &#x3D; “jenkins-slave-${UUID.randomUUID().toString()}”<br>podTemplate(<br>    cloud: ‘测试环境’,<br>    label: label,<br>    name: label,<br>    namespace: ‘devops’,<br>    serviceAccount: ‘sa-jenkins’,<br>    containers: [<br>        containerTemplate(<br>            name: ‘maven’,<br>            image: ‘maven:3.8-jdk-8’,<br>            command: ‘sleep’,<br>            args: ‘9999999’,<br>            workingDir: ‘&#x2F;home&#x2F;jenkins&#x2F;agent’,<br>            &#x2F;&#x2F; container resource limit<br>            resourceLimitCpu: ‘’,<br>            resourceLimitEphemeralStorage: ‘’,<br>            resourceLimitMemory: ‘’,<br>            resourceRequestCpu: ‘’,<br>            resourceRequestEphemeralStorage: ‘’,<br>            resourceRequestMemory: ‘’,<br>            &#x2F;&#x2F; 探针<br>            livenessProbe: containerLivenessProbe(<br>                execArgs: ‘’,<br>                failureThreshold: 0,<br>                initialDelaySeconds: 0,<br>                periodSeconds: 0,<br>                successThreshold: 0,<br>                timeoutSeconds: 0<br>            )<br>        ),<br>        containerTemplate(<br>            name: ‘jenkins-slave’,<br>            image: ‘jenkins&#x2F;jnlp-slave:latest’,<br>            command: ‘sleep’,<br>            args: ‘9999999’,<br>            workingDir: ‘&#x2F;home&#x2F;jenkins&#x2F;agent’,<br>            &#x2F;&#x2F; container resource limit<br>            resourceLimitCpu: ‘’,<br>            resourceLimitEphemeralStorage: ‘’,<br>            resourceLimitMemory: ‘’,<br>            resourceRequestCpu: ‘’,<br>            resourceRequestEphemeralStorage: ‘’,<br>            resourceRequestMemory: ‘’,<br>            &#x2F;&#x2F; 探针<br>            livenessProbe: containerLivenessProbe(<br>                execArgs: ‘’,<br>                failureThreshold: 0,<br>                initialDelaySeconds: 0,<br>                periodSeconds: 0,<br>                successThreshold: 0,<br>                timeoutSeconds: 0<br>            )<br>        ),<br>        containerTemplate(<br>            name: ‘docker’,<br>            image: ‘docker:20.10.6’,<br>            command: ‘sleep’,<br>            args: ‘9999999’,<br>            workingDir: ‘&#x2F;home&#x2F;jenkins&#x2F;agent’,<br>            &#x2F;&#x2F; container resource limit<br>            resourceLimitCpu: ‘’,<br>            resourceLimitEphemeralStorage: ‘’,<br>            resourceLimitMemory: ‘’,<br>            resourceRequestCpu: ‘’,<br>            resourceRequestEphemeralStorage: ‘’,<br>            resourceRequestMemory: ‘’,<br>            &#x2F;&#x2F; 探针<br>            livenessProbe: containerLivenessProbe(<br>                execArgs: ‘’,<br>                failureThreshold: 0,<br>                initialDelaySeconds: 0,<br>                periodSeconds: 0,<br>                successThreshold: 0,<br>                timeoutSeconds: 0<br>            )<br>        ),<br>        containerTemplate(<br>            name: ‘kubectl’,<br>            image: ‘lachlanevenson&#x2F;k8s-kubectl:latest’,<br>            command: ‘sleep’,<br>            args: ‘9999999’,<br>            workingDir: ‘&#x2F;home&#x2F;jenkins&#x2F;agent’,<br>            &#x2F;&#x2F; container resource limit<br>            resourceLimitCpu: ‘’,<br>            resourceLimitEphemeralStorage: ‘’,<br>            resourceLimitMemory: ‘’,<br>            resourceRequestCpu: ‘’,<br>            resourceRequestEphemeralStorage: ‘’,<br>            resourceRequestMemory: ‘’,<br>            &#x2F;&#x2F; 探针<br>            livenessProbe: containerLivenessProbe(<br>                execArgs: ‘’,<br>                failureThreshold: 0,<br>                initialDelaySeconds: 0,<br>                periodSeconds: 0,<br>                successThreshold: 0,<br>                timeoutSeconds: 0<br>            )<br>        )<br>    ],<br>    envVars: [<br>        envVar(key: ‘GIT_SSL_NO_VERIFY’, value: ‘1’)<br>    ],<br>    volumes: [<br>        hostPathVolume(hostPath: ‘&#x2F;data&#x2F;jenkins_home&#x2F;.m2’, mountPath: ‘&#x2F;root&#x2F;.m2’),<br>        hostPathVolume(hostPath: ‘&#x2F;var&#x2F;run&#x2F;docker.sock’, mountPath: ‘&#x2F;var&#x2F;run&#x2F;docker.sock’)<br>    ]<br>)<br>    {<br>        &#x2F;&#x2F; pipeline<br>        node(label) {<br>            stage(‘初始化’) {<br>                    script {<br>                        container(‘jenkins-slave’) {<br>                            sh ‘echo “初始化”‘<br>                            sh ‘git config –global http.sslverify false’<br>                            sh ‘git config –global https.sslverify false’<br>                            sh ‘mkdir -p configure’<br>                        }<br>                    }<br>            }<br>            stage(‘获取源码’) {<br>                    script {<br>                        git branch: ‘dev’, credentialsId: ‘a0f736bb-6bc8-43ce-93d6-xxx’, url: ‘<a href="https://xxx/xxx/xxx-CLOUD.git&#39;">https://xxx/xxx/xxx-CLOUD.git&#39;</a><br>                        dir(‘configure’) {<br>                            git credentialsId: ‘a0f736bb-6bc8-43ce-93d6-xxx’, url: ‘<a href="https://xxx/xxx/config.git&#39;">https://xxx/xxx/config.git&#39;</a><br>                        }<br>                    }<br>            }<br>            stage(‘构建maven’) {<br>                    script {<br>                        container(‘maven’) {<br>                            dir(‘xxx-cloud&#x2F;xxx-config’) {<br>                                &#x2F;&#x2F; some block<br>                                &#x2F;&#x2F; sh ‘java -version’<br>                                sh ‘mvn clean package’<br>                            }<br>                        }<br>                    }<br>            }<br>            stage(‘打包镜像’) {<br>                    script {<br>                        container(‘docker’) {<br>                            dir(‘xxx-cloud&#x2F;xxx-config&#x2F;target’) {<br>                                sh ‘cp ..&#x2F;..&#x2F;..&#x2F;configure&#x2F;config&#x2F;* .’<br>                                sh “docker build -t $registry_host’&#x2F;‘$docker_image’:’$BUILD_NUMBER –no-cache .”<br>                                sh “docker push $registry_host’&#x2F;‘$docker_image’:’$BUILD_NUMBER”<br>                                sh “docker tag $registry_host’&#x2F;‘$docker_image’:’$BUILD_NUMBER $registry_host’&#x2F;‘$docker_image’:latest’”<br>                                sh “docker push $registry_host’&#x2F;‘$docker_image’:latest’”<br>                                sh “docker rmi $registry_host’&#x2F;‘$docker_image’:’$BUILD_NUMBER”<br>                            }<br>                        }<br>                    }<br>            }<br>            stage(‘部署deploy’) {<br>                    script {<br>                        container(‘kubectl’) {<br>                            dir(‘xxx-cloud&#x2F;xxx-config&#x2F;target’) {<br>                                try {<br>                            sh ‘kubectl delete -f service.yaml’<br>                                }catch (Exception e) {<br>                            println e<br>                                }<br>                                try {<br>                            sh ‘kubectl delete -f deployment.yaml’<br>                                }catch (Exception e) {<br>                            println e<br>                                }<br>                                sh ‘kubectl apply -f deployment.yaml’<br>                                sh ‘kubectl apply -f service.yaml’<br>                            }<br>                        }<br>                    }<br>            }<br>        }<br>    }<br>parameters {<br>        string(name: ‘registry_host’, defaultValue: ‘172.25.42.xxx:5000’, description: ‘镜像仓库地址’)<br>        string(name: ‘docker_image’, defaultValue: ‘xxx&#x2F;config’, description: ‘docker镜像名’)<br>}</p>
<p>那么上面这个pipeline配置怎么用呢</p>
<p>很简单，普及一下吧！</p>
<h2 id="新建一个JOB"><a href="#新建一个JOB" class="headerlink" title="新建一个JOB"></a>新建一个JOB</h2><p>风格要选 流水线<code>pipeline</code>项目</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-32-1024x438.png"></p>
<h2 id="进入JOB的配置页面"><a href="#进入JOB的配置页面" class="headerlink" title="进入JOB的配置页面"></a>进入JOB的配置页面</h2><p>往下拉，一直到流水线配置项目，把上面配置贴到里面，完活保存！</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-33-1024x461.png"></p>
<p><img src="https://img-blog.csdnimg.cn/2021051417334991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlZW5oZW0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="见证奇迹的时刻"><a href="#见证奇迹的时刻" class="headerlink" title="见证奇迹的时刻"></a>见证奇迹的时刻</h2><p><img src="https://code404.icu/img/moveypu/2021/05/image-34-1024x301.png"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>pipeline</tag>
        <tag>k8s</tag>
        <tag>podTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解下K8S角色管理RBAC</title>
    <url>/2021/05/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%8Bk8s%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86rbac/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/04/image-53.png"></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><hr>
<p>RBAC 基于角色的访问控制– 全拼 （Role-Based Access Control）<br>​<br>Service Account为服务提供了一种方便的认证机制，可以把它理解为用户，但它不关心授权的问题。可以配合RBAC来为Service Account鉴权<br>​<br>在Kubernetes中，授权有ABAC（基于属性的访问控制）、RBAC（基于角色的访问控制）、Webhook、Node、AlwaysDeny（一直拒绝） 和 AlwaysAllow（一直允许） 这6种模式。<br>​</p>
<h3 id="在RABC-API中，通过如下的步骤进行授权"><a href="#在RABC-API中，通过如下的步骤进行授权" class="headerlink" title="在RABC API中，通过如下的步骤进行授权"></a>在RABC API中，通过如下的步骤进行授权</h3><p>1）定义角色：在定义角色时会指定此角色对于资源的访问控制的规则；<br>2）绑定角色：将主体与角色进行绑定，对用户进行访问授权。</p>
<h3 id="Role与ClusterRole"><a href="#Role与ClusterRole" class="headerlink" title="Role与ClusterRole"></a>Role与ClusterRole</h3><p>一个角色包含了一套表示一组权限的规则。 权限以纯粹的累加形式累积（没有”否定”的规则）。<br><strong>Role:</strong> 角色可以由命名空间内的Role对象定义,一个Role对象只能用于授予对某一单一命名空间中资源的访问权限<br><strong>ClusterRole:</strong> 整个Kubernetes集群范围内有效的角色则通过ClusterRole对象实现。</p>
<h4 id="介绍概念"><a href="#介绍概念" class="headerlink" title="介绍概念"></a>介绍概念</h4><p>role:<br>1、允许的操作，如get,list等​<br>2、允许操作的对象，如pod,svc等<br>​<br>rolebinding:​<br>将哪个用户绑定到哪个role或clusterrole上<br>​<br>clusterrole：(集群角色)<br>clusterrolebinding:(绑定到集群)</p>
<p>3、如果使用rolebinding绑定到clusterrole上，表示绑定的用户只能用于当前namespace的权限</p>
<p>RBAC里面的几种资源关系图，下面将用下面的资源来演示生产中经典的RBAC应用RoleBindingClusterRoleBindingServiceAccount 用户RoleClusterRole只在指定namespace中生效不受namespace限制,在整个K8s集群中生效</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><hr>
<h3 id="如何创建一个用户"><a href="#如何创建一个用户" class="headerlink" title="如何创建一个用户"></a>如何创建一个用户</h3><p>在指定命名空间下 创建 sa serviceaccount</p>
<h4 id="命令创建"><a href="#命令创建" class="headerlink" title="命令创建"></a>命令创建</h4><p>[root@k8s-master01 data]# kubectl create serviceaccount –namespace devops mysatest<br>serviceaccount&#x2F;mysatest created</p>
<h4 id="也可以用yaml配置创建"><a href="#也可以用yaml配置创建" class="headerlink" title="也可以用yaml配置创建"></a>也可以用yaml配置创建</h4><p>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: mysatest # ServiceAccount的名字<br>  namespace: devops # serviceaccount的namespace<br>  labels:<br>    app: mysatest #ServiceAccount的标签</p>
<p>把上面yaml内容存储到文件sa-mysatest.yaml内<br>前提要有 devops 命名空间<br>执行 kubectl apply -f sa-mysatest.yaml</p>
<h3 id="如何绑定系统角色"><a href="#如何绑定系统角色" class="headerlink" title="如何绑定系统角色"></a>如何绑定系统角色</h3><p>指定角色是对于资源的访问控制的规则</p>
<h4 id="命令绑定系统角色"><a href="#命令绑定系统角色" class="headerlink" title="命令绑定系统角色"></a>命令绑定系统角色</h4><p>这里用命令创建了一个绑定角色 mysatest-cluster-role，把用户mysatest绑定到了系统角色cluster-admin上</p>
<p>[root@k8s-master01 rbac]# kubectl create clusterrolebinding mysatest-cluster-role –clusterrole&#x3D;cluster-admin –serviceaccount&#x3D;devops:mysatest<br>clusterrolebinding.rbac.authorization.k8s.io&#x2F;mysatest-cluster-role created</p>
<h4 id="也可以用yaml绑定系统角色"><a href="#也可以用yaml绑定系统角色" class="headerlink" title="也可以用yaml绑定系统角色"></a>也可以用yaml绑定系统角色</h4><p>apiVersion: rbac.authorization.k8s.io&#x2F;v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: mysatest-cluster-role #ClusterRoleBinding的名字<br>subjects:</p>
<ul>
<li>kind: ServiceAccount<br>name: mysatest #serviceaccount资源对象的name<br>namespace: devops #serviceaccount的namespace<br>roleRef:<br>  kind: ClusterRole<br>  name: cluster-admin #k8s集群中最高权限的角色<br>  apiGroup: rbac.authorization.k8s.io</li>
</ul>
<p>把上面yaml内容存储到文件role-mysatest.yaml内<br>执行 kubectl apply -f role-mysatest.yaml</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><hr>
<p>[root@k8s-master01 rbac]# kubectl get sa -n devops grep mysatest<br>mysatest     1         21m<br>[root@k8s-master01 rbac]# kubectl get clusterrolebinding -o widegrep mysatest<br>mysatest-cluster-role     ClusterRole&#x2F;cluster-admin   8m24s     devops&#x2F;mysatest<br>[root@k8s-master01 rbac]# </p>
<p>可以看到，我创建的sa和clusterrolebinding<br>那么，我如何使用mysatest这个账号呢</p>
<h2 id="用新账号部署项目"><a href="#用新账号部署项目" class="headerlink" title="用新账号部署项目"></a>用新账号部署项目</h2><hr>
<p>apiVersion: apps&#x2F;v1<br>kind: Deployment<br>metadata:<br>  name: web-deployment<br>  namespace: devops<br>spec:<br>  selector:<br>    matchLabels:<br>      app: web<br>  replicas: 2 # tells deployment to run 2 pods matching the template<br>  template:<br>    metadata:<br>      labels:<br>        app: web<br>    spec:<br>      containers:<br>      - name: web-openresty<br>        image: 172.25.42.235:5000&#x2F;devops&#x2F;web:latest<br>        ports:<br>        - containerPort: 80<br>      serviceAccountName: mysatest</p>
<p>需要注意的是 serviceAccountName: mysatest<br>这个是指定用户的 必须填写，不填写的话走默认的用户<br>k8s会为每一个新namespace创建一个默认用户default用户</p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>Role-Based Access Control</tag>
        <tag>RBAC</tag>
        <tag>Service Account</tag>
        <tag>基于角色</tag>
        <tag>控制</tag>
        <tag>访问</tag>
        <tag>鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>网络 I/O 为什么会被阻塞_阻塞原理？</title>
    <url>/2021/11/28/%E7%BD%91%E7%BB%9C-i-o-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A2%AB%E9%98%BB%E5%A1%9E-%E9%98%BB%E5%A1%9E%E5%8E%9F%E7%90%86%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/11/image-15.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>我们应该都知道 socket（套接字），你可以认为我们的通信都要基于这个玩意，而常说的网络通信又分为 TCP 与 UDP 两种，下面我会以 TCP 通信为例来阐述下 socket 的通信流程。</p>
<p>不过在此之前，我先来说说什么叫 I&#x2F;O。</p>
<h3 id="I-x2F-O到底是什么"><a href="#I-x2F-O到底是什么" class="headerlink" title="I&#x2F;O到底是什么?"></a>I&#x2F;O到底是什么?</h3><hr>
<p>I&#x2F;O 其实就是 input 和 output 的缩写，即输入&#x2F;输出。</p>
<p>那输入输出啥呢？</p>
<p>比如我们用键盘来敲代码其实就是输入，那显示器显示图案就是输出，这其实就是 I&#x2F;O。</p>
<p>而我们时常关心的磁盘 I&#x2F;O 指的是硬盘和内存之间的输入输出。</p>
<p>读取本地文件的时候，要将磁盘的数据拷贝到内存中，修改本地文件的时候，需要把修改后的数据拷贝到磁盘中。</p>
<p>网络 I&#x2F;O 指的是网卡与内存之间的输入输出。</p>
<p>当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。</p>
<p>那为什么都要跟内存交互呢?</p>
<p>我们的指令最终是由 CPU 执行的，究其原因是 CPU 与内存交互的速度远高于 CPU 和这些外部设备直接交互的速度。</p>
<p>因此都是和内存交互，当然假设没有内存，让 CPU 直接和外部设备交互，那也算 I&#x2F;O。</p>
<p>总结下：I&#x2F;O 就是指内存与外部设备之间的交互（数据拷贝）。</p>
<p>好了，明确什么是 I&#x2F;O 之后，让我们来揭一揭 socket 通信内幕~</p>
<h3 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h3><hr>
<p>首先服务端需要先创建一个 socket。在 Linux 中一切都是文件，那么创建的 socket 也是文件，每个文件都有一个整型的文件描述符（fd）来指代这个文件。</p>
<p>int socket(int domain, int type, int protocol);</p>
<ul>
<li>domain：这个参数用于选择通信的协议族，比如选择 IPv4 通信，还是 IPv6 通信等等</li>
<li>type：选择套接字类型，可选字节流套接字、数据报套接字等等。</li>
<li>protocol：指定使用的协议。</li>
</ul>
<p>这个 protocol 通常可以设为 0 ，因为由前面两个参数可以推断出所要使用的协议。</p>
<p>比如<code>socket(AF_INET, SOCK_STREAM, 0);</code>，表明使用 IPv4 ，且使用字节流套接字，可以判断使用的协议为 TCP 协议。</p>
<p>这个方法的返回值为 int ，其实就是创建的 socket 的 fd。</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><hr>
<p>现在我们已经创建了一个 socket，但现在还没有地址指向这个 socket。</p>
<p>众所周知，服务器应用需要指明 IP 和端口，这样客户端才好找上门来要服务，所以此时我们需要指定一个地址和端口来与这个 socket 绑定一下。</p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>参数里的 sockfd 就是我们创建的 socket 的文件描述符，执行了 bind 参数之后我们的 socket 距离可以被访问又更近了一步。</p>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>执行了 socket、bind 之后，此时的 socket 还处于 closed 的状态，也就是不对外监听的，然后我们需要调用 listen 方法，让 socket 进入被动监听状态，这样的 socket 才能够监听到客户端的连接请求。</p>
<p>int listen(int sockfd, int backlog);</p>
<p>传入创建的 socket 的 fd，并且指明一下 backlog 的大小。</p>
<p>这个 backlog 我查阅资料的时候，看到了三种解释：</p>
<ol>
<li>socket 有一个队列，同时存放已完成的连接和半连接，backlog为这个队列的大小。</li>
<li>socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog为这个两个队列的大小之和。</li>
<li>socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog仅为已完成的连接队列大小。</li>
</ol>
<h3 id="解释下什么叫半连接"><a href="#解释下什么叫半连接" class="headerlink" title="解释下什么叫半连接"></a>解释下什么叫半连接</h3><hr>
<p>我们都知道 TCP 建立连接需要三次握手，当接收方收到请求方的建连请求后会返回 ack，此时这个连接在接收方就处于半连接状态，当接收方再收到请求方的 ack 时，这个连接就处于已完成状态：<br><img src="https://img-blog.csdnimg.cn/188a50c98c0b455fb875d5a0809ad2c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>所以上面讨论的就是这两种状态的连接的存放问题。</p>
<p>我查阅资料看到，基于 BSD 派生的系统的实现是使用的一个队列来同时存放这两种状态的连接， backlog 参数即为这个队列的大小。</p>
<p>而 Linux 则使用两个队列分别存储已完成连接和半连接，且 backlog 仅为已完成连接的队列大小</p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>现在我们已经初始化好监听套接字了，此时会有客户端连上来，然后我们需要处理这些已经完成建连的连接。</p>
<p>从上面的分析我们可以得知，三次握手完成后的连接会被加入到已完成连接队列中去。<br><img src="https://img-blog.csdnimg.cn/dabdc71112ce4a66a3d018c0fe2efa6e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这时候，我们就需要从已完成连接队列中拿到连接进行处理，这个拿取动作就由 accpet 来完成。</p>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<p>这个方法返回的 int 值就是拿到的已完成连接的 socket 的文件描述符，之后操作这个 socket 就可以进行通信了。</p>
<p>如果已完成连接队列没有连接可以取，那么调用 accept 的线程会阻塞等待。</p>
<p>至此服务端的通信流程暂告一段落，我们再看看客户端的操作。</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><hr>
<p>客户端也需要创建一个 socket，也就是调用 socket()，这里就不赘述了，我们直接开始建连操作。</p>
<p>客户端需要与服务端建立连接，在 TCP 协议下开始经典的三次握手操作，再看一下上面画的图：</p>
<p><img src="https://img-blog.csdnimg.cn/1c95dd40a17d4645a89af383e8a05605.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>客户端创建完 socket 并调用 connect 之后，连接就处于 SYN_SEND 状态，当收到服务端的 SYN+ACK 之后，连接就变为 ESTABLISHED 状态，此时就代表三次握手完毕。</p>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>调用connect需要指定远程的地址和端口进行建连，三次握手完毕之后就可以开始通信了。</p>
<p>客户端这边不需要调用 bind 操作，默认会选择源 IP 和随机端口。</p>
<p>用一幅图来小结一下建连的操作：<br><img src="https://img-blog.csdnimg.cn/2029e8a496de40db8ea2337b36641331.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>可以看到这里的两个阻塞点：</p>
<ul>
<li>connect：需要阻塞等待三次握手的完成。</li>
<li>accept：需要等待可用的已完成的连接，如果已完成连接队列为空，则被阻塞。</li>
</ul>
<h3 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h3><hr>
<p>连接建立成功之后，就能开始发送和接收消息了，我们来看一下<br><img src="https://img-blog.csdnimg.cn/8c7cf2446d33446195c0f5cbdd3ff1e8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>read 为读数据，从服务端来看就是等待客户端的请求，如果客户端不发请求，那么调用 read 会处于阻塞等待状态，没有数据可以读，这个应该很好理解。</p>
<p>write 为写数据，一般而言服务端接受客户端的请求之后，会进行一些逻辑处理，然后再把结果返回给客户端，这个写入也可能会被阻塞。</p>
<p>这里可能有人就会问 read 读不到数据阻塞等待可以理解，write 为什么还要阻塞，有数据不就直接发了吗？</p>
<p>因为我们用的是 TCP 协议，TCP 协议需要保证数据可靠地、有序地传输，并且给予端与端之间的流量控制。</p>
<p>所以说发送不是直接发出去，它有个发送缓冲区，我们需要把数据先拷贝到 TCP 的发送缓冲区，由 TCP 自行控制发送的时间和逻辑，有可能还有重传什么的。</p>
<p>如果我们发的过快，导致接收方处理不过来，那么接收方就会通过 TCP 协议告知：别发了！忙不过来了。发送缓存区是有大小限制的，由于无法发送，还不断调用 write 那么缓存区就满了，满了就不然你 write 了，所以 write 也会发生阻塞。</p>
<p>综上，read 和 write 都会发生阻塞。</p>
<h3 id="为什么网络-I-x2F-O-会被阻塞？"><a href="#为什么网络-I-x2F-O-会被阻塞？" class="headerlink" title="为什么网络 I&#x2F;O 会被阻塞？"></a>为什么网络 I&#x2F;O 会被阻塞？</h3><p>因为建连和通信涉及到的 accept、connect、read、write 这几个方法都可能会发生阻塞。</p>
<p>阻塞会占用当前执行的线程，使之不能进行其他操作，并且频繁阻塞唤醒切换上下文也会导致性能的下降。</p>
<p>由于阻塞的缘故，起初的解决的方案就是建立多个线程，但是随着互联网的发展，用户激增，连接数也随着激增，需要建立的线程数也随着一起增加，到后来就产生了 C10K 问题。</p>
<p>服务端顶不住了呀，咋办？</p>
<p>优化呗！</p>
<p>所以后来就弄了个非阻塞套接字，然后 I&#x2F;O多路复用、信号驱动I&#x2F;O、异步I&#x2F;O。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>IO</tag>
        <tag>网络</tag>
        <tag>阻塞</tag>
      </tags>
  </entry>
  <entry>
    <title>网络问题导致 SSh连接失败，Socket error Event: 32 Error: 10053.</title>
    <url>/2021/05/09/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4-ssh%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%EF%BC%8Csocket-error-event-32-error-10053/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-11.png"></p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-12.png"></p>
<p><strong>SSh连接失败，Socket error Event: 32 Error: 10053.</strong></p>
<p>SSh连接远程Centos18 服务器失败. Socket error Event: 32 Error: 10053. connection closing…socket close. connection closed by foreign host. disconnected from remote host.</p>
<p>大致情形是，服务器突然连不上，显示错误Socket error Event: 32 Error: 10053. connection closing…socket close. connection closed by foreign host. disconnected from remote host.</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-12.png"></p>
<p>去服务器上查看发现IP地址没有了</p>
<p>经过排查发现</p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>ip addr显示内容 inet 中包含 noprefixroute，看着碍眼想去掉，不知道怎么弄。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>最终找到了一台不显示这项参数的机器，打开其&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethx， 多方比对发现配置了NM_CONTROLLED&#x3D;no。<br>该参数默认为yes，竟是network manager自作主张，配置了默认路由。</p>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p>配置no之后， 查看路由表ip route show，最后一列没有metric字段，ip addr显示不再有noprefixroute</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>服务器端固定IP场景下，建议关闭，管理员控制比较稳妥。</li>
<li>桌面级应用&#x2F;DHCP场景下，建议开着，网络配置省心。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>SSh</tag>
        <tag>10053</tag>
        <tag>Socket error Event</tag>
        <tag>连接失败</tag>
      </tags>
  </entry>
  <entry>
    <title>网页出现400 Bad Request Request Header Or Cookie Too Large错误的解决方法</title>
    <url>/2021/06/17/%E7%BD%91%E9%A1%B5%E5%87%BA%E7%8E%B0400-bad-request-request-header-or-cookie-too-large%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-40.png"></p>
<p>在开发项目过程中，突然遇到400 Bad Request Request Header Or Cookie Too Large的报错，我也是第一次出现这样的错误，感觉还是挺新奇的。</p>
<h2 id="分析下出现错误的原因："><a href="#分析下出现错误的原因：" class="headerlink" title="分析下出现错误的原因："></a>分析下出现错误的原因：</h2><ol>
<li>可能是你的网络DNS配置错误。</li>
<li>由request header过大所引起，request过大，通常是由于cookie中写入了较大的值所引起的。</li>
<li>访问太频繁，浏览器的缓存量太大，产生错误。</li>
</ol>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol>
<li>清理浏览器的cookie记录，和缓存文件，重启浏览器就好了。</li>
<li>打开360安全卫士，选择系统修复，选定电脑门诊，修复即可；或者选择电脑清理，清理下系统中的垃圾文件。</li>
<li>你可以右击网上邻居－属性－找到你的本地连接－右击属性－常规选项卡里有个下拉此连接使用项目，选择INTERNETF协义（TCP&#x2F;IP）下面点击属性选自动获得，最好查一下当地的DNS填进去，如果是局域网你可以在主DNS上填写你的网关地址，如192.168.1.1或192.168.0.1</li>
<li>采用nginx服务器的话修改方法：</li>
</ol>
<p>&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf</p>
<p>在这个路径下面，修改nginx.conf</p>
<p>http<br>{</p>
<p> include  mime.types;<br> default_type  application&#x2F;octet-stream;<br> server_names_hash_bucket_size 128;<br> client_header_buffer_size 16k;  &#x2F;&#x2F;这里默认是4K，改大一点就好了</p>
<p>｝</p>
]]></content>
      <categories>
        <category>运维</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>400</tag>
        <tag>Bad Request</tag>
        <tag>Too Large</tag>
      </tags>
  </entry>
  <entry>
    <title>说下浏览器请求一个网址的过程</title>
    <url>/2021/06/10/%E8%AF%B4%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-28.png"></p>
<h3 id="说下浏览器请求一个网址的过程"><a href="#说下浏览器请求一个网址的过程" class="headerlink" title="说下浏览器请求一个网址的过程"></a>说下浏览器请求一个网址的过程</h3><ol>
<li>首先通过DNS服务器把域名解析成IP地址，通过IP和子网掩码判断是否属于同一个子网</li>
<li>构造应用层请求http报文，传输层添加TCP&#x2F;UDP头部，网络层添加IP头部，数据链路层添加以太网协议头部</li>
<li>数据经过路由器、交换机转发，最终达到目标服务器，目标服务器同样解析数据，最终拿到http报文，按照对应的程序的逻辑响应回去。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>请求过程</tag>
      </tags>
  </entry>
  <entry>
    <title>说说TCP 3次握手的过程？</title>
    <url>/2021/06/08/%E8%AF%B4%E8%AF%B4tcp-3%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-26.png"></p>
<h2 id="说说TCP-3次握手的过程？"><a href="#说说TCP-3次握手的过程？" class="headerlink" title="说说TCP 3次握手的过程？"></a>说说TCP 3次握手的过程？</h2><p>建立连接前server端需要监听端口，所以初始状态是<code>LISTEN</code>。</p>
<ol>
<li>client端建立连接，发送一个SYN同步包，发送之后状态变成<code>SYN_SENT</code></li>
<li>server端收到SYN之后，同意建立连接，返回一个ACK响应，同时也会给client发送一个SYN包，发送完成之后状态变为<code>SYN_RCVD</code></li>
<li>client端收到server的ACK之后，状态变为<code>ESTABLISHED</code>，返回ACK给server端。<br>server收到之后状态也变为<code>ESTABLISHED</code>，连接建立完成。</li>
</ol>
<h2 id="为什么要3次？2次，4次不行吗？"><a href="#为什么要3次？2次，4次不行吗？" class="headerlink" title="为什么要3次？2次，4次不行吗？"></a>为什么要3次？2次，4次不行吗？</h2><p>因为TCP是双工传输模式，不区分客户端和服务端，连接的建立是双向的过程。<br>如果只有两次，无法做到双向连接的建立，从建立连接server回复的SYN和ACK合并成一次可以看出来，他也不需要4次。<br>挥手为什么要四次？因为挥手的ACK和FIN不能同时发送，因为数据发送的截止时间不同。</p>
<h2 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h2><p>请看下一篇</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>ESTABLISHED</tag>
        <tag>3次握手</tag>
        <tag>syn</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一下你对Reactor模型的理解</title>
    <url>/2021/06/14/%E8%B0%88%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9reactor%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-37.png"></p>
<p>Reactor模型包含两个组件：</p>
<ol>
<li>Reactor：负责查询、响应IO事件，当检测到IO事件时，分发给Handlers处理。</li>
<li>Handler：与IO事件绑定，负责IO事件的处理。<br>它包含几种实现方式：</li>
</ol>
<h3 id="单线程Reactor"><a href="#单线程Reactor" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h3><p>这个模式reactor和handler在一个线程中，如果某个handler阻塞的话，会导致其他所有的handler无法执行，而且无法充分利用多核的性能。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-34-1024x275.png"></p>
<h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><p>由于decode、compute、encode的操作并非IO的操作，多线程Reactor的思路就是充分发挥多核的特性，同时把非IO的操作剥离开。<br>但是，单个Reactor承担了所有的事件监听、响应工作，如果连接过多，还是可能存在性能问题。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-35-1024x294.png"></p>
<h3 id="多Reactor多线程"><a href="#多Reactor多线程" class="headerlink" title="多Reactor多线程"></a>多Reactor多线程</h3><p>为了解决单Reactor的性能问题，就产生了多Reactor的模式。其中mainReactor建立连接，多个subReactor则负责数据读写。</p>
<p><img src="https://code404.icu/img/moveypu/2021/06/image-36-1024x252.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈你对TCP/IP四层模型，OSI七层模型的理解？</title>
    <url>/2021/06/07/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9tcp-ip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8Cosi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-25.png"></p>
<p>为了增强通用性和兼容性，计算机网络都被设计成层次机构，每一层都遵守一定的规则。<br>因此有了OSI这样一个抽象的网络通信参考模型，按照这个标准使计算机网络系统可以互相连接。</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><strong>物理层</strong>：通过网线、光缆等这种物理方式将电脑连接起来。传递的数据是比特流，0101010100。<br><strong>数据链路层</strong>：首先，把比特流封装成数据帧的格式，对0、1进行分组。电脑连接起来之后，数据都经过网卡来传输，而网卡上定义了全世界唯一的MAC地址。然后再通过广播的形式向局域网内所有电脑发送数据，再根据数据中MAC地址和自身对比判断是否是发给自己的。<br><strong>网络层</strong>：广播的形式太低效，为了区分哪些MAC地址属于同一个子网，网络层定义了IP和子网掩码，通过对IP和子网掩码进行与运算就知道是否是同一个子网，再通过路由器和交换机进行传输。IP协议属于网络层的协议。<br><strong>传输层</strong>：有了网络层的MAC+IP地址之后，为了确定数据包是从哪个进程发送过来的，就需要端口号，通过端口来建立通信，比如TCP和UDP属于这一层的协议。<br><strong>会话层</strong>：负责建立和断开连接<br><strong>表示层</strong>：为了使得数据能够被其他的计算机理解，再次将数据转换成另外一种格式，比如文字、视频、图片等。<br><strong>应用层</strong>：最高层，面对用户，提供计算机网络与最终呈现给用户的界面</p>
<h2 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h2><p><strong>TCP&#x2F;IP则是四层的结构，相当于是对OSI模型的简化。</strong><br><strong>数据链路层</strong>，也有称作网络访问层、网络接口层。他包含了OSI模型的物理层和数据链路层，把电脑连接起来。<br><strong>网络层</strong>，也叫做IP层，处理IP数据包的传输、路由，建立主机间的通信。<br><strong>传输层</strong>，就是为两台主机设备提供端到端的通信。<br><strong>应用层</strong>，包含OSI的会话层、表示层和应用层，提供了一些常用的协议规范，比如FTP、SMPT、HTTP等。</p>
<p>总结下来，就是物理层通过物理手段把电脑连接起来，数据链路层则对比特流的数据进行分组，网络层来建立主机到主机的通信，传输层建立端口到端口的通信，应用层最终负责建立连接，数据格式转换，最终呈现给用户。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>OSI</tag>
        <tag>七层模型</tag>
        <tag>四层模型</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡有哪些实现方式</title>
    <url>/2021/06/12/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/06/image-30.png"></p>
<p><strong>DNS</strong>：这是最简单的负载均衡的方式，一般用于实现地理级别的负载均衡，不同地域的用户通过DNS的解析可以返回不同的IP地址，这种方式的负载均衡简单，但是扩展性太差，控制权在域名服务商。<br><strong>HTTP重定向</strong>：通过修改Http响应头的Location达到负载均衡的目的，Http的302重定向。这种方式对性能有影响，而且增加请求耗时。<br><strong>反向代理</strong>：作用于应用层的模式，也被称作为七层负载均衡，比如常见的Nginx，性能一般可以达到万级。这种方式部署简单，成本低，而且容易扩展。<br><strong>IP</strong>：作用于网络层的和传输层的模式，也被称作四层负载均衡，通过对数据包的IP地址和端口进行修改来达到负载均衡的效果。常见的有LVS（Linux Virtual Server），通常性能可以支持10万级并发。<br>按照类型来划分的话，还可以分成<code>DNS负载均衡、硬件负载均衡、软件负载均衡</code>。<br>其中硬件负载均衡价格昂贵，性能最好，能达到百万级，软件负载均衡包括Nginx、LVS这种。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>实现方式</tag>
      </tags>
  </entry>
  <entry>
    <title>超详细的网络抓包神器 tcpdump 使用指南</title>
    <url>/2021/05/24/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E7%A5%9E%E5%99%A8-tcpdump-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/05/image-44.png"></p>
<p>tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，这个库在几乎在所有的 Linux&#x2F;Unix 中都有。熟悉 tcpdump 的使用能够帮助你分析调试网络数据，本文将通过一个个具体的示例来介绍它在不同场景下的使用方法。不管你是系统管理员，程序员，云原生工程师还是 yaml 工程师，掌握 tcpdump 的使用都能让你如虎添翼，升职加薪。</p>
<h2 id="1-基本语法和使用方法"><a href="#1-基本语法和使用方法" class="headerlink" title="1. 基本语法和使用方法"></a>1. 基本语法和使用方法</h2><p>tcpdump 的常用参数如下：</p>
<p>$ tcpdump -i eth0 -nn -s0 -v port 80复制代码</p>
<ul>
<li><strong>-i</strong> : 选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 vlan 或其他特殊接口。如果该系统上只有一个网络接口，则无需指定。</li>
<li><strong>-nn</strong> : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。</li>
<li><strong>-s0</strong> : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</li>
<li><strong>-v</strong> : 使用 -v，-vv 和 -vvv 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。</li>
<li>port 80 : 这是一个常见的端口过滤器，表示仅抓取 80 端口上的流量，通常是 HTTP。</li>
</ul>
<p>额外再介绍几个常用参数：</p>
<ul>
<li><strong>-p</strong> : 不让网络接口进入混杂模式。默认情况下使用 tcpdump 抓包时，会让网络接口进入混杂模式。一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。如果设备接入的交换机开启了混杂模式，使用 -p 选项可以有效地过滤噪声。</li>
<li><strong>-e</strong> : 显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 -e 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息。例如：</li>
</ul>
<p>$ tcpdump -n -e -c 5 not ip6</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on br-lan, link-type EN10MB (Ethernet), capture size 262144 bytes<br>18:27:53.619865 24:5e:be:0c:17:af &gt; 00:e2:69:23:d3:3b, ethertype IPv4 (0x0800), length 1162: 192.168.100.20.51410 &gt; 180.176.26.193.58695: Flags [.], seq 2045333376:2045334484, ack 3398690514, win 751, length 1108<br>18:27:53.626490 00:e2:69:23:d3:3b &gt; 24:5e:be:0c:17:af, ethertype IPv4 (0x0800), length 68: 220.173.179.66.36017 &gt; 192.168.100.20.51410: UDP, length 26<br>18:27:53.626893 24:5e:be:0c:17:af &gt; 00:e2:69:23:d3:3b, ethertype IPv4 (0x0800), length 1444: 192.168.100.20.51410 &gt; 220.173.179.66.36017: UDP, length 1402<br>18:27:53.628837 00:e2:69:23:d3:3b &gt; 24:5e:be:0c:17:af, ethertype IPv4 (0x0800), length 1324: 46.97.169.182.6881 &gt; 192.168.100.20.59145: Flags [P.], seq 3058450381:3058451651, ack 14349180, win 502, length 1270<br>18:27:53.629096 24:5e:be:0c:17:af &gt; 00:e2:69:23:d3:3b, ethertype IPv4 (0x0800), length 54: 192.168.100.20.59145 &gt; 192.168.100.1.12345: Flags [.], ack 3058451651, win 6350, length 0<br>5 packets captured复制代码</p>
<h3 id="显示-ASCII-字符串"><a href="#显示-ASCII-字符串" class="headerlink" title="显示 ASCII 字符串"></a>显示 ASCII 字符串</h3><p>-A 表示使用 ASCII 字符串打印报文的全部数据，这样可以使读取更加简单，方便使用 grep 等工具解析输出内容。-X 表示同时使用十六进制和 ASCII 字符串打印报文的全部数据。这两个参数不能一起使用。例如：</p>
<p>$ tcpdump -A -s0 port 80复制代码</p>
<h3 id="抓取特定协议的数据"><a href="#抓取特定协议的数据" class="headerlink" title="抓取特定协议的数据"></a>抓取特定协议的数据</h3><p>后面可以跟上协议名称来过滤特定协议的流量，以 UDP 为例，可以加上参数 udp 或 protocol 17，这两个命令意思相同。</p>
<p>$ tcpdump -i eth0 udp<br>$ tcpdump -i eth0 proto 17复制代码</p>
<p>同理，tcp 与 protocol 6 意思相同。</p>
<h3 id="抓取特定主机的数据"><a href="#抓取特定主机的数据" class="headerlink" title="抓取特定主机的数据"></a>抓取特定主机的数据</h3><p>使用过滤器 host 可以抓取特定目的地和源 IP 地址的流量。</p>
<p>$ tcpdump -i eth0 host 10.10.1.1复制代码</p>
<p>也可以使用 src 或 dst 只抓取源或目的地：</p>
<p>$ tcpdump -i eth0 dst 10.10.1.20复制代码</p>
<h3 id="将抓取的数据写入文件"><a href="#将抓取的数据写入文件" class="headerlink" title="将抓取的数据写入文件"></a>将抓取的数据写入文件</h3><p>使用 tcpdump 截取数据报文的时候，默认会打印到屏幕的默认输出，你会看到按照顺序和格式，很多的数据一行行快速闪过，根本来不及看清楚所有的内容。不过，tcpdump 提供了把截取的数据保存到文件的功能，以便后面使用其他图形工具（比如 wireshark，Snort）来分析。</p>
<p>-w 选项用来把数据报文输出到文件：</p>
<p>$ tcpdump -i eth0 -s0 -w test.pcap复制代码</p>
<h3 id="行缓冲模式"><a href="#行缓冲模式" class="headerlink" title="行缓冲模式"></a>行缓冲模式</h3><p>如果想实时将抓取到的数据通过管道传递给其他工具来处理，需要使用 -l 选项来开启行缓冲模式（或使用 -c 选项来开启数据包缓冲模式）。使用 -l 选项可以将输出通过立即发送给其他命令，其他命令会立即响应。</p>
<p>$ tcpdump -i eth0 -s0 -l port 80  grep ‘Server:’复制代码</p>
<h3 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h3><p>过滤的真正强大之处在于你可以随意组合它们，而连接它们的逻辑就是常用的 与&#x2F;AND&#x2F;&amp;&amp; 、 或&#x2F;OR&#x2F; 和 非&#x2F;not&#x2F;!。</p>
<p>and or &amp;&amp;<br>or or<br>not or !复制代码</p>
<h2 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2. 过滤器"></a>2. 过滤器</h2><p>关于 tcpdump 的过滤器，这里有必要单独介绍一下。</p>
<p>机器上的网络报文数量异常的多，很多时候我们只关系和具体问题有关的数据报（比如访问某个网站的数据，或者 icmp 超时的报文等等），而这些数据只占到很小的一部分。把所有的数据截取下来，从里面找到想要的信息无疑是一件很费时费力的工作。而 tcpdump 提供了灵活的语法可以精确地截取关心的数据报，简化分析的工作量。这些选择数据包的语句就是过滤器（filter）！</p>
<h3 id="Host-过滤器"><a href="#Host-过滤器" class="headerlink" title="Host 过滤器"></a>Host 过滤器</h3><p>Host 过滤器用来过滤某个主机的数据报文。例如：</p>
<p>$ tcpdump host 1.2.3.4复制代码</p>
<p>该命令会抓取所有发往主机 1.2.3.4 或者从主机 1.2.3.4 发出的流量。如果想只抓取从该主机发出的流量，可以使用下面的命令：</p>
<p>$ tcpdump src host 1.2.3.4复制代码</p>
<h3 id="Network-过滤器"><a href="#Network-过滤器" class="headerlink" title="Network 过滤器"></a>Network 过滤器</h3><p>Network 过滤器用来过滤某个网段的数据，使用的是 CIDR 模式。可以使用四元组（x.x.x.x）、三元组（x.x.x）、二元组（x.x）和一元组（x）。四元组就是指定某个主机，三元组表示子网掩码为 255.255.255.0，二元组表示子网掩码为 255.255.0.0，一元组表示子网掩码为 255.0.0.0。例如，</p>
<p>抓取所有发往网段 192.168.1.x 或从网段 192.168.1.x 发出的流量：</p>
<p>$ tcpdump net 192.168.1复制代码</p>
<p>抓取所有发往网段 10.x.x.x 或从网段 10.x.x.x 发出的流量：</p>
<p>$ tcpdump net 10复制代码</p>
<p>和 Host 过滤器一样，这里也可以指定源和目的：</p>
<p>$ tcpdump src net 10复制代码</p>
<p>也可以使用 CIDR 格式：</p>
<p>$ tcpdump src net 172.16.0.0&#x2F;12复制代码</p>
<h3 id="Proto-过滤器"><a href="#Proto-过滤器" class="headerlink" title="Proto 过滤器"></a>Proto 过滤器</h3><p>Proto 过滤器用来过滤某个协议的数据，关键字为 proto，可省略。proto 后面可以跟上协议号或协议名称，支持 icmp, igmp, igrp, pim, ah, esp, carp, vrrp, udp和 tcp。因为通常的协议名称是保留字段，所以在于 proto 指令一起使用时，必须根据 shell 类型使用一个或两个反斜杠（&#x2F;）来转义。Linux 中的 shell 需要使用两个反斜杠来转义，MacOS 只需要一个。</p>
<p>例如，抓取 icmp 协议的报文：</p>
<p>$ tcpdump -n proto \\icmp</p>
<h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><p>$ tcpdump -n icmp复制代码</p>
<h3 id="Port-过滤器"><a href="#Port-过滤器" class="headerlink" title="Port 过滤器"></a>Port 过滤器</h3><p>Port 过滤器用来过滤通过某个端口的数据报文，关键字为 port。例如：</p>
<p>$ tcpdump port 389复制代码</p>
<h2 id="3-理解-tcpdump-的输出"><a href="#3-理解-tcpdump-的输出" class="headerlink" title="3. 理解 tcpdump 的输出"></a>3. 理解 tcpdump 的输出</h2><p>截取数据只是第一步，第二步就是理解这些数据，下面就解释一下 tcpdump 命令输出各部分的意义。</p>
<p>21:27:06.995846 IP (tos 0x0, ttl 64, id 45646, offset 0, flags [DF], proto TCP (6), length 64)<br>    192.168.1.106.56166 &gt; 124.192.132.54.80: Flags [S], cksum 0xa730 (correct), seq 992042666, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 663433143 ecr 0,sackOK,eol], length 0</p>
<p>21:27:07.030487 IP (tos 0x0, ttl 51, id 0, offset 0, flags [DF], proto TCP (6), length 44)<br>    124.192.132.54.80 &gt; 192.168.1.106.56166: Flags [S.], cksum 0xedc0 (correct), seq 2147006684, ack 992042667, win 14600, options [mss 1440], length 0</p>
<p>21:27:07.030527 IP (tos 0x0, ttl 64, id 59119, offset 0, flags [DF], proto TCP (6), length 40)<br>    192.168.1.106.56166 &gt; 124.192.132.54.80: Flags [.], cksum 0x3e72 (correct), ack 2147006685, win 65535, length 0复制代码</p>
<p>最基本也是最重要的信息就是数据报的源地址&#x2F;端口和目的地址&#x2F;端口，上面的例子第一条数据报中，源地址 ip 是 192.168.1.106，源端口是 56166，目的地址是 124.192.132.54，目的端口是 80。 &gt; 符号代表数据的方向。</p>
<p>此外，上面的三条数据还是 tcp 协议的三次握手过程，第一条就是 SYN 报文，这个可以通过 Flags [S] 看出。下面是常见的 TCP 报文的 Flags:</p>
<ul>
<li>[S] : SYN（开始连接）</li>
<li>[.] : 没有 Flag</li>
<li>[P] : PSH（推送数据）</li>
<li>[F] : FIN （结束连接）</li>
<li>[R] : RST（重置连接）</li>
</ul>
<p>而第二条数据的 [S.] 表示 SYN-ACK，就是 SYN 报文的应答报文。</p>
<h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h2><p>下面给出一些具体的例子，每个例子都可以使用多种方法来获得相同的输出，你使用的方法取决于所需的输出和网络上的流量。我们在排障时，通常只想获取自己想要的内容，可以通过过滤器和 ASCII 输出并结合管道与 grep、cut、awk 等工具来实现此目的。</p>
<p>例如，在抓取 HTTP 请求和响应数据包时，可以通过删除标志 SYN&#x2F;ACK&#x2F;FIN 来过滤噪声，但还有更简单的方法，那就是通过管道传递给 grep。在达到目的的同时，我们要选择最简单最高效的方法。下面来看例子。</p>
<h3 id="提取-HTTP-用户代理"><a href="#提取-HTTP-用户代理" class="headerlink" title="提取 HTTP 用户代理"></a>提取 HTTP 用户代理</h3><p>从 HTTP 请求头中提取 HTTP 用户代理：</p>
<p>$ tcpdump -nn -A -s1500 -l  grep “User-Agent:”复制代码</p>
<p>通过 egrep 可以同时提取用户代理和主机名（或其他头文件）：</p>
<p>$ tcpdump -nn -A -s1500 -l  egrep -i ‘User-Agent:Host:’复制代码</p>
<h3 id="只抓取-HTTP-GET-和-POST-流量"><a href="#只抓取-HTTP-GET-和-POST-流量" class="headerlink" title="只抓取 HTTP GET 和 POST 流量"></a>只抓取 HTTP GET 和 POST 流量</h3><p>抓取 HTTP GET 流量：</p>
<p>$ tcpdump -s 0 -A -vv ‘tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] &#x3D; 0x47455420’复制代码</p>
<p>也可以抓取 HTTP POST 请求流量：</p>
<p>$ tcpdump -s 0 -A -vv ‘tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] &#x3D; 0x504f5354’复制代码</p>
<p>注意：该方法不能保证抓取到 HTTP POST 有效数据流量，因为一个 POST 请求会被分割为多个 TCP 数据包。</p>
<p>上述两个表达式中的十六进制将会与 GET 和 POST 请求的 ASCII 字符串匹配。例如，tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] 首先会确定我们感兴趣的字节的位置（在 TCP header 之后），然后选择我们希望匹配的 4 个字节。</p>
<h3 id="提取-HTTP-请求的-URL"><a href="#提取-HTTP-请求的-URL" class="headerlink" title="提取 HTTP 请求的 URL"></a>提取 HTTP 请求的 URL</h3><p>提取 HTTP 请求的主机名和路径：</p>
<p>$ tcpdump -s 0 -v -n -l  egrep -i “POST &#x2F;GET &#x2F;Host:”</p>
<p>tcpdump: listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>    POST &#x2F;wp-login.php HTTP&#x2F;1.1<br>    Host: dev.example.com<br>    GET &#x2F;wp-login.php HTTP&#x2F;1.1<br>    Host: dev.example.com<br>    GET &#x2F;favicon.ico HTTP&#x2F;1.1<br>    Host: dev.example.com<br>    GET &#x2F; HTTP&#x2F;1.1<br>    Host: dev.example.com复制代码</p>
<h3 id="提取-HTTP-POST-请求中的密码"><a href="#提取-HTTP-POST-请求中的密码" class="headerlink" title="提取 HTTP POST 请求中的密码"></a>提取 HTTP POST 请求中的密码</h3><p>从 HTTP POST 请求中提取密码和主机名：</p>
<p>$ tcpdump -s 0 -A -n -l  egrep -i “POST &#x2F;pwd&#x3D;passwd&#x3D;password&#x3D;Host:”</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>11:25:54.799014 IP 10.10.1.30.39224 &gt; 10.10.1.125.80: Flags [P.], seq 1458768667:1458770008, ack 2440130792, win 704, options [nop,nop,TS val 461552632 ecr 208900561], length 1341: HTTP: POST &#x2F;wp-login.php HTTP&#x2F;1.1<br>…..s..POST &#x2F;wp-login.php HTTP&#x2F;1.1<br>Host: dev.example.com<br>…..s..log&#x3D;admin&amp;pwd&#x3D;notmypassword&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;http%3A%2F%2Fdev.example.com%2Fwp-admin%2F&amp;testcookie&#x3D;1复制代码</p>
<h3 id="提取-Cookies"><a href="#提取-Cookies" class="headerlink" title="提取 Cookies"></a>提取 Cookies</h3><p>提取 Set-Cookie（服务端的 Cookie）和 Cookie（客户端的 Cookie）：</p>
<p>$ tcpdump -nn -A -s0 -l  egrep -i ‘Set-CookieHost:Cookie:’</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>Host: dev.example.com<br>Cookie: wordpress_86be02xxxxxxxxxxxxxxxxxxxc43&#x3D;admin%7C152xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxfb3e15c744fdd6; _ga&#x3D;GA1.2.21343434343421934; _gid&#x3D;GA1.2.927343434349426; wordpress_test_cookie&#x3D;WP+Cookie+check; wordpress_logged_in_86be654654645645645654645653fc43&#x3D;admin%7C15275102testtesttesttestab7a61e; wp-settings-time-1&#x3D;1527337439复制代码</p>
<h3 id="抓取-ICMP-数据包"><a href="#抓取-ICMP-数据包" class="headerlink" title="抓取 ICMP 数据包"></a>抓取 ICMP 数据包</h3><p>查看网络上的所有 ICMP 数据包：</p>
<p>$ tcpdump -n icmp</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>11:34:21.590380 IP 10.10.1.217 &gt; 10.10.1.30: ICMP echo request, id 27948, seq 1, length 64<br>11:34:21.590434 IP 10.10.1.30 &gt; 10.10.1.217: ICMP echo reply, id 27948, seq 1, length 64<br>11:34:27.680307 IP 10.10.1.159 &gt; 10.10.1.1: ICMP 10.10.1.189 udp port 59619 unreachable, length 115复制代码</p>
<h3 id="抓取非-ECHO-x2F-REPLY-类型的-ICMP-数据包"><a href="#抓取非-ECHO-x2F-REPLY-类型的-ICMP-数据包" class="headerlink" title="抓取非 ECHO&#x2F;REPLY 类型的 ICMP 数据包"></a>抓取非 ECHO&#x2F;REPLY 类型的 ICMP 数据包</h3><p>通过排除 echo 和 reply 类型的数据包使抓取到的数据包不包括标准的 ping 包：</p>
<p>$ tcpdump ‘icmp[icmptype] !&#x3D; icmp-echo and icmp[icmptype] !&#x3D; icmp-echoreply’</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>11:37:04.041037 IP 10.10.1.189 &gt; 10.10.1.20: ICMP 10.10.1.189 udp port 36078 unreachable, length 156复制代码</p>
<h3 id="抓取-SMTP-x2F-POP3-协议的邮件"><a href="#抓取-SMTP-x2F-POP3-协议的邮件" class="headerlink" title="抓取 SMTP&#x2F;POP3 协议的邮件"></a>抓取 SMTP&#x2F;POP3 协议的邮件</h3><p>可以提取电子邮件的正文和其他数据。例如，只提取电子邮件的收件人：</p>
<p>$ tcpdump -nn -l port 25  grep -i ‘MAIL FROM\RCPT TO’复制代码</p>
<h3 id="抓取-NTP-服务的查询和响应"><a href="#抓取-NTP-服务的查询和响应" class="headerlink" title="抓取 NTP 服务的查询和响应"></a>抓取 NTP 服务的查询和响应</h3><p>$ tcpdump dst port 123</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes<br>21:02:19.112502 IP test33.ntp &gt; 199.30.140.74.ntp: NTPv4, Client, length 48<br>21:02:19.113888 IP 216.239.35.0.ntp &gt; test33.ntp: NTPv4, Server, length 48<br>21:02:20.150347 IP test33.ntp &gt; 216.239.35.0.ntp: NTPv4, Client, length 48<br>21:02:20.150991 IP 216.239.35.0.ntp &gt; test33.ntp: NTPv4, Server, length 48复制代码</p>
<h3 id="抓取-SNMP-服务的查询和响应"><a href="#抓取-SNMP-服务的查询和响应" class="headerlink" title="抓取 SNMP 服务的查询和响应"></a>抓取 SNMP 服务的查询和响应</h3><p>通过 SNMP 服务，渗透测试人员可以获取大量的设备和系统信息。在这些信息中，系统信息最为关键，如操作系统版本、内核版本等。使用 SNMP 协议快速扫描程序 onesixtyone，可以看到目标系统的信息：</p>
<p>$ onesixtyone 10.10.1.10 public</p>
<p>Scanning 1 hosts, 1 communities<br>10.10.1.10 [public] Linux test33 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64复制代码</p>
<p>可以通过 tcpdump 抓取 GetRequest 和 GetResponse：</p>
<p>$ tcpdump -n -s0  port 161 and udp<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>23:39:13.725522 IP 10.10.1.159.36826 &gt; 10.10.1.20.161:  GetRequest(28)  .1.3.6.1.2.1.1.1.0<br>23:39:13.728789 IP 10.10.1.20.161 &gt; 10.10.1.159.36826:  GetResponse(109)  .1.3.6.1.2.1.1.1.0&#x3D;”Linux testmachine 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64”复制代码</p>
<h3 id="切割-pcap-文件"><a href="#切割-pcap-文件" class="headerlink" title="切割 pcap 文件"></a>切割 pcap 文件</h3><p>当抓取大量数据并写入文件时，可以自动切割为多个大小相同的文件。例如，下面的命令表示每 3600 秒创建一个新文件 capture-(hour).pcap，每个文件大小不超过 200*1000000 字节：</p>
<p>$ tcpdump  -w &#x2F;tmp&#x2F;capture-%H.pcap -G 3600 -C 200复制代码</p>
<p>这些文件的命名为 capture-{1-24}.pcap，24 小时之后，之前的文件就会被覆盖。</p>
<h3 id="抓取-IPv6-流量"><a href="#抓取-IPv6-流量" class="headerlink" title="抓取 IPv6 流量"></a>抓取 IPv6 流量</h3><p>可以通过过滤器 ip6 来抓取 IPv6 流量，同时可以指定协议如 TCP：</p>
<p>$ tcpdump -nn ip6 proto 6复制代码</p>
<p>从之前保存的文件中读取 IPv6 UDP 数据报文：</p>
<p>$ tcpdump -nr ipv6-test.pcap ip6 proto 17复制代码</p>
<h3 id="检测端口扫描"><a href="#检测端口扫描" class="headerlink" title="检测端口扫描"></a>检测端口扫描</h3><p>在下面的例子中，你会发现抓取到的报文的源和目的一直不变，且带有标志位 [S] 和 [R]，它们与一系列看似随机的目标端口进行匹配。当发送 SYN 之后，如果目标主机的端口没有打开，就会返回一个 RESET。这是 Nmap 等端口扫描工具的标准做法。</p>
<p>$ tcpdump -nn</p>
<p>21:46:19.693601 IP 10.10.1.10.60460 &gt; 10.10.1.199.5432: Flags [S], seq 116466344, win 29200, options [mss 1460,sackOK,TS val 3547090332 ecr 0,nop,wscale 7], length 0<br>21:46:19.693626 IP 10.10.1.10.35470 &gt; 10.10.1.199.513: Flags [S], seq 3400074709, win 29200, options [mss 1460,sackOK,TS val 3547090332 ecr 0,nop,wscale 7], length 0<br>21:46:19.693762 IP 10.10.1.10.44244 &gt; 10.10.1.199.389: Flags [S], seq 2214070267, win 29200, options [mss 1460,sackOK,TS val 3547090333 ecr 0,nop,wscale 7], length 0<br>21:46:19.693772 IP 10.10.1.199.389 &gt; 10.10.1.10.44244: Flags [R.], seq 0, ack 2214070268, win 0, length 0<br>21:46:19.693783 IP 10.10.1.10.35172 &gt; 10.10.1.199.1433: Flags [S], seq 2358257571, win 29200, options [mss 1460,sackOK,TS val 3547090333 ecr 0,nop,wscale 7], length 0<br>21:46:19.693826 IP 10.10.1.10.33022 &gt; 10.10.1.199.49153: Flags [S], seq 2406028551, win 29200, options [mss 1460,sackOK,TS val 3547090333 ecr 0,nop,wscale 7], length 0<br>21:46:19.695567 IP 10.10.1.10.55130 &gt; 10.10.1.199.49154: Flags [S], seq 3230403372, win 29200, options [mss 1460,sackOK,TS val 3547090334 ecr 0,nop,wscale 7], length 0<br>21:46:19.695590 IP 10.10.1.199.49154 &gt; 10.10.1.10.55130: Flags [R.], seq 0, ack 3230403373, win 0, length 0<br>21:46:19.695608 IP 10.10.1.10.33460 &gt; 10.10.1.199.49152: Flags [S], seq 3289070068, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 0<br>21:46:19.695622 IP 10.10.1.199.49152 &gt; 10.10.1.10.33460: Flags [R.], seq 0, ack 3289070069, win 0, length 0<br>21:46:19.695637 IP 10.10.1.10.34940 &gt; 10.10.1.199.1029: Flags [S], seq 140319147, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 0<br>21:46:19.695650 IP 10.10.1.199.1029 &gt; 10.10.1.10.34940: Flags [R.], seq 0, ack 140319148, win 0, length 0<br>21:46:19.695664 IP 10.10.1.10.45648 &gt; 10.10.1.199.5060: Flags [S], seq 2203629201, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 0<br>21:46:19.695775 IP 10.10.1.10.49028 &gt; 10.10.1.199.2000: Flags [S], seq 635990431, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 0<br>21:46:19.695790 IP 10.10.1.199.2000 &gt; 10.10.1.10.49028: Flags [R.], seq 0, ack 635990432, win 0, length 0复制代码</p>
<h3 id="过滤-Nmap-NSE-脚本测试结果"><a href="#过滤-Nmap-NSE-脚本测试结果" class="headerlink" title="过滤 Nmap NSE 脚本测试结果"></a>过滤 Nmap NSE 脚本测试结果</h3><p>本例中 Nmap NSE 测试脚本 http-enum.nse 用来检测 HTTP 服务的合法 URL。</p>
<p>在执行脚本测试的主机上：</p>
<p>$ nmap -p 80 –script&#x3D;http-enum.nse targetip复制代码</p>
<p>在目标主机上：</p>
<p>$ tcpdump -nn port 80  grep “GET &#x2F;“</p>
<p>GET &#x2F;w3perl&#x2F; HTTP&#x2F;1.1<br>GET &#x2F;w-agora&#x2F; HTTP&#x2F;1.1<br>GET &#x2F;way-board&#x2F; HTTP&#x2F;1.1<br>GET &#x2F;web800fo&#x2F; HTTP&#x2F;1.1<br>GET &#x2F;webaccess&#x2F; HTTP&#x2F;1.1<br>GET &#x2F;webadmin&#x2F; HTTP&#x2F;1.1<br>GET &#x2F;webAdmin&#x2F; HTTP&#x2F;1.1复制代码</p>
<h3 id="抓取-DNS-请求和响应"><a href="#抓取-DNS-请求和响应" class="headerlink" title="抓取 DNS 请求和响应"></a>抓取 DNS 请求和响应</h3><p>向 Google 公共 DNS 发起的出站 DNS 请求和 A 记录响应可以通过 tcpdump 抓取到：</p>
<p>$ tcpdump -i wlp58s0 -s0 port 53</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>14:19:06.879799 IP test.53852 &gt; google-public-dns-a.google.com.domain: 26977+ [1au] A? play.google.com. (44)<br>14:19:07.022618 IP google-public-dns-a.google.com.domain &gt; test.53852: 26977 1&#x2F;0&#x2F;1 A 216.58.203.110 (60)复制代码</p>
<h3 id="抓取-HTTP-有效数据包"><a href="#抓取-HTTP-有效数据包" class="headerlink" title="抓取 HTTP 有效数据包"></a>抓取 HTTP 有效数据包</h3><p>抓取 80 端口的 HTTP 有效数据包，排除 TCP 连接建立过程的数据包（SYN &#x2F; FIN &#x2F; ACK）：</p>
<p>$ tcpdump ‘tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) !&#x3D; 0)’复制代码</p>
<h3 id="将输出内容重定向到-Wireshark"><a href="#将输出内容重定向到-Wireshark" class="headerlink" title="将输出内容重定向到 Wireshark"></a>将输出内容重定向到 Wireshark</h3><p>通常 Wireshark（或 tshark）比 tcpdump 更容易分析应用层协议。一般的做法是在远程服务器上先使用 tcpdump 抓取数据并写入文件，然后再将文件拷贝到本地工作站上用 Wireshark 分析。</p>
<p>还有一种更高效的方法，可以通过 ssh 连接将抓取到的数据实时发送给 Wireshark 进行分析。以 MacOS 系统为例，可以通过 brew cask install wireshark 来安装，然后通过下面的命令来分析：</p>
<p>$ ssh root@remotesystem ‘tcpdump -s0 -c 1000 -nn -w - not port 22’  &#x2F;Applications&#x2F;Wireshark.app&#x2F;Contents&#x2F;MacOS&#x2F;Wireshark -k -i -复制代码</p>
<p>例如，如果想分析 DNS 协议，可以使用下面的命令：</p>
<p>$ ssh root@remotesystem ‘tcpdump -s0 -c 1000 -nn -w - port 53’  &#x2F;Applications&#x2F;Wireshark.app&#x2F;Contents&#x2F;MacOS&#x2F;Wireshark -k -i -复制代码</p>
<p>抓取到的数据：</p>
<p><img src="https://code404.icu/img/moveypu/2021/05/image-43.png"></p>
<p>-c 选项用来限制抓取数据的大小。如果不限制大小，就只能通过 ctrl-c 来停止抓取，这样一来不仅关闭了 tcpdump，也关闭了 wireshark。</p>
<h3 id="找出发包最多的-IP"><a href="#找出发包最多的-IP" class="headerlink" title="找出发包最多的 IP"></a>找出发包最多的 IP</h3><p>找出一段时间内发包最多的 IP，或者从一堆报文中找出发包最多的 IP，可以使用下面的命令：</p>
<p>$ tcpdump -nnn -t -c 200  cut -f 1,2,3,4 -d ‘.’  sort  uniq -c  sort -nr  head -n 20</p>
<p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>200 packets captured<br>261 packets received by filter<br>0 packets dropped by kernel<br>    108 IP 10.10.211.181<br>     91 IP 10.10.1.30<br>      1 IP 10.10.1.50复制代码</p>
<ul>
<li><strong>cut -f 1,2,3,4 -d ‘.’</strong> : 以 . 为分隔符，打印出每行的前四列。即 IP 地址。</li>
<li><strong>sort uniq -c</strong> : 排序并计数</li>
<li><strong>sort -nr</strong> : 按照数值大小逆向排序</li>
</ul>
<h3 id="抓取用户名和密码"><a href="#抓取用户名和密码" class="headerlink" title="抓取用户名和密码"></a>抓取用户名和密码</h3><p>本例将重点放在标准纯文本协议上，过滤出于用户名和密码相关的报文：</p>
<p>$ tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -l -A  egrep -i -B5 ‘pass&#x3D;pwd&#x3D;log&#x3D;login&#x3D;user&#x3D;username&#x3D;pw&#x3D;passw&#x3D;passwd&#x3D;password&#x3D;pass:user:username:password:login:pass user ‘复制代码</p>
<h3 id="抓取-DHCP-报文"><a href="#抓取-DHCP-报文" class="headerlink" title="抓取 DHCP 报文"></a>抓取 DHCP 报文</h3><p>最后一个例子，抓取 DHCP 服务的请求和响应报文，67 为 DHCP 端口，68 为客户机端口。</p>
<p>$ tcpdump -v -n port 67 or 68</p>
<p>tcpdump: listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>14:37:50.059662 IP (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)<br>    0.0.0.0.68 &gt; 255.255.255.255.67: BOOTP&#x2F;DHCP, Request from 00:0c:xx:xx:xx:d5, length 300, xid 0xc9779c2a, Flags [none]<br>      Client-Ethernet-Address 00:0c:xx:xx:xx:d5<br>      Vendor-rfc1048 Extensions<br>        Magic Cookie 0x63825363<br>        DHCP-Message Option 53, length 1: Request<br>        Requested-IP Option 50, length 4: 10.10.1.163<br>        Hostname Option 12, length 14: “test-ubuntu”<br>        Parameter-Request Option 55, length 16:<br>          Subnet-Mask, BR, Time-Zone, Default-Gateway<br>          Domain-Name, Domain-Name-Server, Option 119, Hostname<br>          Netbios-Name-Server, Netbios-Scope, MTU, Classless-Static-Route<br>          NTP, Classless-Static-Route-Microsoft, Static-Route, Option 252<br>14:37:50.059667 IP (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)<br>    0.0.0.0.68 &gt; 255.255.255.255.67: BOOTP&#x2F;DHCP, Request from 00:0c:xx:xx:xx:d5, length 300, xid 0xc9779c2a, Flags [none]<br>      Client-Ethernet-Address 00:0c:xx:xx:xx:d5<br>      Vendor-rfc1048 Extensions<br>        Magic Cookie 0x63825363<br>        DHCP-Message Option 53, length 1: Request<br>        Requested-IP Option 50, length 4: 10.10.1.163<br>        Hostname Option 12, length 14: “test-ubuntu”<br>        Parameter-Request Option 55, length 16:<br>          Subnet-Mask, BR, Time-Zone, Default-Gateway<br>          Domain-Name, Domain-Name-Server, Option 119, Hostname<br>          Netbios-Name-Server, Netbios-Scope, MTU, Classless-Static-Route<br>          NTP, Classless-Static-Route-Microsoft, Static-Route, Option 252<br>14:37:50.060780 IP (tos 0x0, ttl 64, id 53564, offset 0, flags [none], proto UDP (17), length 339)<br>    10.10.1.1.67 &gt; 10.10.1.163.68: BOOTP&#x2F;DHCP, Reply, length 311, xid 0xc9779c2a, Flags [none]<br>      Your-IP 10.10.1.163<br>      Server-IP 10.10.1.1<br>      Client-Ethernet-Address 00:0c:xx:xx:xx:d5<br>      Vendor-rfc1048 Extensions<br>        Magic Cookie 0x63825363<br>        DHCP-Message Option 53, length 1: ACK<br>        Server-ID Option 54, length 4: 10.10.1.1<br>        Lease-Time Option 51, length 4: 86400<br>        RN Option 58, length 4: 43200<br>        RB Option 59, length 4: 75600<br>        Subnet-Mask Option 1, length 4: 255.255.255.0<br>        BR Option 28, length 4: 10.10.1.255<br>        Domain-Name-Server Option 6, length 4: 10.10.1.1<br>        Hostname Option 12, length 14: “test-ubuntu”<br>        T252 Option 252, length 1: 10<br>        Default-Gateway Option 3, length 4: 10.10.1.1复制代码</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文主要介绍了 tcpdump 的基本语法和使用方法，并通过一些示例来展示它强大的过滤功能。将 tcpdump 与 wireshark 进行组合可以发挥更强大的功效，本文也展示了如何优雅顺滑地结合 tcpdump 和 wireshark。如果你想了解更多的细节，可以查看 tcpdump 的 man 手册。</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>通过U盘安装 centos7,Warning: dracut-initqueue timeout解决办法</title>
    <url>/2021/12/18/%E9%80%9A%E8%BF%87u%E7%9B%98%E5%AE%89%E8%A3%85-centos7warning-dracut-initqueue-timeout%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/12/image-10.png"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p>最近在IBM上安装系统时出现了这么个情况超时的情况</p>
<p>dracut-initqueue[1076]: Warning: dracut-initqueue timeout – starting timeout scripts<br>dracut-initqueue[1076]: Warning: dracut-initqueue timeout – starting timeout scripts<br>Warngin: &#x2F;dev&#x2F;root does not exist<br>Generating “&#x2F;run&#x2F;initramfs&#x2F;rdsosreport.txt”<br>Entering emergency mode. Exit the shell to continue.<br>Type “Journalctl” to view system logs.<br>You might want to save “&#x2F;run&#x2F;initramfs&#x2F;rdsosreport.txt” to a USB stick or &#x2F;boot<br>after mounting them and attach it to a bug report<br>dracut: &#x2F;<br><img src="https://img-blog.csdnimg.cn/7103f0e6830f4b4b94a592ceb8381fcb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="部署的时候有些问题出现了dracut-initqueue-timeout"><a href="#部署的时候有些问题出现了dracut-initqueue-timeout" class="headerlink" title="部署的时候有些问题出现了dracut-initqueue timeout"></a>部署的时候有些问题出现了dracut-initqueue timeout</h3><hr>
<p>dracut-initqueue timeout的问题，我在网上发现是因为centos7 找不到u盘启动的盘需要我们来设置一下</p>
<h3 id="下面是配置启动盘过程"><a href="#下面是配置启动盘过程" class="headerlink" title="下面是配置启动盘过程"></a>下面是配置启动盘过程</h3><p>dracut:&#x2F;# cd &#x2F;dev<br>dracut:&#x2F;# ls</p>
<p>这样子你就会看到所有的设备信息，找到sdbn，n为一个数字,是你u盘所在，比如我用的是sdb4</p>
<p>dracut:&#x2F;# reboot 重启之后</p>
<h3 id="重启后，在install页面按e键-gt-修改内容"><a href="#重启后，在install页面按e键-gt-修改内容" class="headerlink" title="重启后，在install页面按e键 &gt; 修改内容"></a>重启后，在install页面按e键 &gt; 修改内容</h3><p>vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd:LABEL&#x3D;CentOS\x207\x20x86_64.check quiet<br>vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd:&#x2F;dev&#x2F;sdb4 quiet</p>
<p>然后按Ctrl+x就好了。</p>
<h3 id="Ctrl-x重启，进入图形安装界面"><a href="#Ctrl-x重启，进入图形安装界面" class="headerlink" title="Ctrl+x重启，进入图形安装界面"></a>Ctrl+x重启，进入图形安装界面</h3><hr>
<p><img src="https://img-blog.csdnimg.cn/14573c1204ed44eaa35fc23fba7c9b85.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGVlbmhlbQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Centos8</category>
      </categories>
      <tags>
        <tag>dracut-initqueue timeout</tag>
        <tag>安装Centos8</tag>
      </tags>
  </entry>
  <entry>
    <title>钉钉接口报错java.net.UnknownHostException: oapi.dingtalk.com_无法访问oapi.dingtalk.com</title>
    <url>/2021/07/04/%E9%92%89%E9%92%89%E6%8E%A5%E5%8F%A3%E6%8A%A5%E9%94%99java-net-unknownhostexception-oapi-dingtalk-com-%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEoapi-dingtalk-com/</url>
    <content><![CDATA[<p><img src="https://code404.icu/img/moveypu/2021/07/image-16.png"></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><hr>
<p>配置钉钉机器人时，我发现服务器连接oapi.dingtalk.com接口连接不上去报错如下</p>
<p>java.net.UnknownHostException: oapi.dingtalk.com</p>
<h3 id="报错详细内容"><a href="#报错详细内容" class="headerlink" title="报错详细内容"></a>报错详细内容</h3><hr>
<p>ERROR: 钉钉机器人发生错误：java.net.UnknownHostException: oapi.dingtalk.com<br>at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:184)<br>at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)<br>at java.net.Socket.connect(Socket.java:607)<br>at sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:288)<br>at sun.net.NetworkClient.doConnect(NetworkClient.java:175)<br>at sun.net.<a href="http://www.http.HttpClient.openServer(HttpClient.java:463)">www.http.HttpClient.openServer(HttpClient.java:463)</a><br>at sun.net.<a href="http://www.http.HttpClient.openServer(HttpClient.java:558)">www.http.HttpClient.openServer(HttpClient.java:558)</a><br>at sun.net.<a href="http://www.protocol.https.httpsclient/">www.protocol.https.HttpsClient</a>.<init>(HttpsClient.java:264)<br>at sun.net.<a href="http://www.protocol.https.HttpsClient.New(HttpsClient.java:367)">www.protocol.https.HttpsClient.New(HttpsClient.java:367)</a><br>at sun.net.<a href="http://www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:203)">www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:203)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1205)">www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1205)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1056)">www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1056)</a><br>at sun.net.<a href="http://www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:189)">www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:189)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1340)">www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1340)</a><br>at sun.net.<a href="http://www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1315)">www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1315)</a><br>at sun.net.<a href="http://www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:264)">www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:264)</a><br>at io.jenkins.plugins.sdk.HttpRequest.request(HttpRequest.java:75)<br>at io.jenkins.plugins.sdk.DingTalkSender.call(DingTalkSender.java:119)<br>at io.jenkins.plugins.sdk.DingTalkSender.sendActionCard(DingTalkSender.java:98)<br>at io.jenkins.plugins.service.impl.DingTalkServiceImpl.send(DingTalkServiceImpl.java:60)<br>at io.jenkins.plugins.DingTalkRunListener.send(DingTalkRunListener.java:248)<br>at io.jenkins.plugins.DingTalkRunListener.onCompleted(DingTalkRunListener.java:62)<br>at io.jenkins.plugins.DingTalkRunListener.onCompleted(DingTalkRunListener.java:42)<br>at hudson.model.listeners.RunListener.fireCompleted(RunListener.java:209)<br>at hudson.model.Run.execute(Run.java:1957)<br>at hudson.model.FreeStyleBuild.run(FreeStyleBuild.java:43)<br>at hudson.model.ResourceController.execute(ResourceController.java:100)<br>at hudson.model.Executor.run(Executor.java:432)</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><hr>
<p>原因是 调用钉钉服务很慢，偶尔会报java.net.UnknownHostException: oapi.dingtalk.com<br>ping 一下 oapi.dingtalk.com<br>得到IP地址 106.11.43.160</p>
<p>[root@k8s-master01 ~]# ping oapi.dingtalk.com<br>PING cname.dingtalk.com.gds.alibabadns.com (106.11.43.160) 56(84) bytes of data.<br>64 bytes from 106.11.43.160 (106.11.43.160): icmp_seq&#x3D;1 ttl&#x3D;83 time&#x3D;7.49 ms<br>64 bytes from 106.11.43.160 (106.11.43.160): icmp_seq&#x3D;2 ttl&#x3D;83 time&#x3D;7.34 ms<br>64 bytes from 106.11.43.160 (106.11.43.160): icmp_seq&#x3D;3 ttl&#x3D;83 time&#x3D;7.32 ms<br>^C<br>— cname.dingtalk.com.gds.alibabadns.com ping statistics —<br>6 packets transmitted, 6 received, 0% packet loss, time 11ms<br>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 7.315&#x2F;7.414&#x2F;7.492&#x2F;0.115 ms</p>
<p>把 106.11.43.160 oapi.dingtalk.com 配置到hosts里面</p>
<p>vim &#x2F;etc&#x2F;hosts<br>106.11.43.160 oapi.dingtalk.com</p>
]]></content>
      <categories>
        <category>IT杂谈</category>
      </categories>
      <tags>
        <tag>Exception</tag>
        <tag>oapi.dingtalk.com</tag>
        <tag>UnknownHost</tag>
      </tags>
  </entry>
</search>
